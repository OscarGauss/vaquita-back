'use strict';

var require$$0$4 = require('path');
var require$$0$5 = require('tty');
var require$$0$6 = require('util');
var fs = require('fs');
var require$$0$7 = require('net');
var require$$0$8 = require('events');
var require$$0$9 = require('stream');
var zlib = require('zlib');
var require$$0$a = require('buffer');
var require$$1$1 = require('string_decoder');
var require$$8 = require('querystring');
var require$$4$1 = require('url');
var require$$0$b = require('http');
var require$$0$c = require('crypto');
var os = require('os');
var https = require('https');
require('http2');
var process$1 = require('process');
var require$$0$d = require('timers');
var require$$0$e = require('dns');
var require$$0$f = require('fs/promises');
var require$$2$3 = require('tls');
var require$$1$2 = require('child_process');
var require$$0$g = require('timers/promises');

function _interopNamespaceDefault(e) {
	var n = Object.create(null);
	if (e) {
		Object.keys(e).forEach(function (k) {
			if (k !== 'default') {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	}
	n.default = e;
	return Object.freeze(n);
}

var process__namespace = /*#__PURE__*/_interopNamespaceDefault(process$1);

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var express$2 = {exports: {}};

var bodyParser$1 = {exports: {}};

/*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */

var depd_1;
var hasRequiredDepd;

function requireDepd () {
	if (hasRequiredDepd) return depd_1;
	hasRequiredDepd = 1;
	/**
	 * Module dependencies.
	 */

	var relative = require$$0$4.relative;

	/**
	 * Module exports.
	 */

	depd_1 = depd;

	/**
	 * Get the path to base files on.
	 */

	var basePath = process.cwd();

	/**
	 * Determine if namespace is contained in the string.
	 */

	function containsNamespace (str, namespace) {
	  var vals = str.split(/[ ,]+/);
	  var ns = String(namespace).toLowerCase();

	  for (var i = 0; i < vals.length; i++) {
	    var val = vals[i];

	    // namespace contained
	    if (val && (val === '*' || val.toLowerCase() === ns)) {
	      return true
	    }
	  }

	  return false
	}

	/**
	 * Convert a data descriptor to accessor descriptor.
	 */

	function convertDataDescriptorToAccessor (obj, prop, message) {
	  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
	  var value = descriptor.value;

	  descriptor.get = function getter () { return value };

	  if (descriptor.writable) {
	    descriptor.set = function setter (val) { return (value = val) };
	  }

	  delete descriptor.value;
	  delete descriptor.writable;

	  Object.defineProperty(obj, prop, descriptor);

	  return descriptor
	}

	/**
	 * Create arguments string to keep arity.
	 */

	function createArgumentsString (arity) {
	  var str = '';

	  for (var i = 0; i < arity; i++) {
	    str += ', arg' + i;
	  }

	  return str.substr(2)
	}

	/**
	 * Create stack string from stack.
	 */

	function createStackString (stack) {
	  var str = this.name + ': ' + this.namespace;

	  if (this.message) {
	    str += ' deprecated ' + this.message;
	  }

	  for (var i = 0; i < stack.length; i++) {
	    str += '\n    at ' + stack[i].toString();
	  }

	  return str
	}

	/**
	 * Create deprecate for namespace in caller.
	 */

	function depd (namespace) {
	  if (!namespace) {
	    throw new TypeError('argument namespace is required')
	  }

	  var stack = getStack();
	  var site = callSiteLocation(stack[1]);
	  var file = site[0];

	  function deprecate (message) {
	    // call to self as log
	    log.call(deprecate, message);
	  }

	  deprecate._file = file;
	  deprecate._ignored = isignored(namespace);
	  deprecate._namespace = namespace;
	  deprecate._traced = istraced(namespace);
	  deprecate._warned = Object.create(null);

	  deprecate.function = wrapfunction;
	  deprecate.property = wrapproperty;

	  return deprecate
	}

	/**
	 * Determine if event emitter has listeners of a given type.
	 *
	 * The way to do this check is done three different ways in Node.js >= 0.8
	 * so this consolidates them into a minimal set using instance methods.
	 *
	 * @param {EventEmitter} emitter
	 * @param {string} type
	 * @returns {boolean}
	 * @private
	 */

	function eehaslisteners (emitter, type) {
	  var count = typeof emitter.listenerCount !== 'function'
	    ? emitter.listeners(type).length
	    : emitter.listenerCount(type);

	  return count > 0
	}

	/**
	 * Determine if namespace is ignored.
	 */

	function isignored (namespace) {
	  if (process.noDeprecation) {
	    // --no-deprecation support
	    return true
	  }

	  var str = process.env.NO_DEPRECATION || '';

	  // namespace ignored
	  return containsNamespace(str, namespace)
	}

	/**
	 * Determine if namespace is traced.
	 */

	function istraced (namespace) {
	  if (process.traceDeprecation) {
	    // --trace-deprecation support
	    return true
	  }

	  var str = process.env.TRACE_DEPRECATION || '';

	  // namespace traced
	  return containsNamespace(str, namespace)
	}

	/**
	 * Display deprecation message.
	 */

	function log (message, site) {
	  var haslisteners = eehaslisteners(process, 'deprecation');

	  // abort early if no destination
	  if (!haslisteners && this._ignored) {
	    return
	  }

	  var caller;
	  var callFile;
	  var callSite;
	  var depSite;
	  var i = 0;
	  var seen = false;
	  var stack = getStack();
	  var file = this._file;

	  if (site) {
	    // provided site
	    depSite = site;
	    callSite = callSiteLocation(stack[1]);
	    callSite.name = depSite.name;
	    file = callSite[0];
	  } else {
	    // get call site
	    i = 2;
	    depSite = callSiteLocation(stack[i]);
	    callSite = depSite;
	  }

	  // get caller of deprecated thing in relation to file
	  for (; i < stack.length; i++) {
	    caller = callSiteLocation(stack[i]);
	    callFile = caller[0];

	    if (callFile === file) {
	      seen = true;
	    } else if (callFile === this._file) {
	      file = this._file;
	    } else if (seen) {
	      break
	    }
	  }

	  var key = caller
	    ? depSite.join(':') + '__' + caller.join(':')
	    : undefined;

	  if (key !== undefined && key in this._warned) {
	    // already warned
	    return
	  }

	  this._warned[key] = true;

	  // generate automatic message from call site
	  var msg = message;
	  if (!msg) {
	    msg = callSite === depSite || !callSite.name
	      ? defaultMessage(depSite)
	      : defaultMessage(callSite);
	  }

	  // emit deprecation if listeners exist
	  if (haslisteners) {
	    var err = DeprecationError(this._namespace, msg, stack.slice(i));
	    process.emit('deprecation', err);
	    return
	  }

	  // format and write message
	  var format = process.stderr.isTTY
	    ? formatColor
	    : formatPlain;
	  var output = format.call(this, msg, caller, stack.slice(i));
	  process.stderr.write(output + '\n', 'utf8');
	}

	/**
	 * Get call site location as array.
	 */

	function callSiteLocation (callSite) {
	  var file = callSite.getFileName() || '<anonymous>';
	  var line = callSite.getLineNumber();
	  var colm = callSite.getColumnNumber();

	  if (callSite.isEval()) {
	    file = callSite.getEvalOrigin() + ', ' + file;
	  }

	  var site = [file, line, colm];

	  site.callSite = callSite;
	  site.name = callSite.getFunctionName();

	  return site
	}

	/**
	 * Generate a default message from the site.
	 */

	function defaultMessage (site) {
	  var callSite = site.callSite;
	  var funcName = site.name;

	  // make useful anonymous name
	  if (!funcName) {
	    funcName = '<anonymous@' + formatLocation(site) + '>';
	  }

	  var context = callSite.getThis();
	  var typeName = context && callSite.getTypeName();

	  // ignore useless type name
	  if (typeName === 'Object') {
	    typeName = undefined;
	  }

	  // make useful type name
	  if (typeName === 'Function') {
	    typeName = context.name || typeName;
	  }

	  return typeName && callSite.getMethodName()
	    ? typeName + '.' + funcName
	    : funcName
	}

	/**
	 * Format deprecation message without color.
	 */

	function formatPlain (msg, caller, stack) {
	  var timestamp = new Date().toUTCString();

	  var formatted = timestamp +
	    ' ' + this._namespace +
	    ' deprecated ' + msg;

	  // add stack trace
	  if (this._traced) {
	    for (var i = 0; i < stack.length; i++) {
	      formatted += '\n    at ' + stack[i].toString();
	    }

	    return formatted
	  }

	  if (caller) {
	    formatted += ' at ' + formatLocation(caller);
	  }

	  return formatted
	}

	/**
	 * Format deprecation message with color.
	 */

	function formatColor (msg, caller, stack) {
	  var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' + // bold cyan
	    ' \x1b[33;1mdeprecated\x1b[22;39m' + // bold yellow
	    ' \x1b[0m' + msg + '\x1b[39m'; // reset

	  // add stack trace
	  if (this._traced) {
	    for (var i = 0; i < stack.length; i++) {
	      formatted += '\n    \x1b[36mat ' + stack[i].toString() + '\x1b[39m'; // cyan
	    }

	    return formatted
	  }

	  if (caller) {
	    formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m'; // cyan
	  }

	  return formatted
	}

	/**
	 * Format call site location.
	 */

	function formatLocation (callSite) {
	  return relative(basePath, callSite[0]) +
	    ':' + callSite[1] +
	    ':' + callSite[2]
	}

	/**
	 * Get the stack as array of call sites.
	 */

	function getStack () {
	  var limit = Error.stackTraceLimit;
	  var obj = {};
	  var prep = Error.prepareStackTrace;

	  Error.prepareStackTrace = prepareObjectStackTrace;
	  Error.stackTraceLimit = Math.max(10, limit);

	  // capture the stack
	  Error.captureStackTrace(obj);

	  // slice this function off the top
	  var stack = obj.stack.slice(1);

	  Error.prepareStackTrace = prep;
	  Error.stackTraceLimit = limit;

	  return stack
	}

	/**
	 * Capture call site stack from v8.
	 */

	function prepareObjectStackTrace (obj, stack) {
	  return stack
	}

	/**
	 * Return a wrapped function in a deprecation message.
	 */

	function wrapfunction (fn, message) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('argument fn must be a function')
	  }

	  var args = createArgumentsString(fn.length);
	  var stack = getStack();
	  var site = callSiteLocation(stack[1]);

	  site.name = fn.name;

	  // eslint-disable-next-line no-new-func
	  var deprecatedfn = new Function('fn', 'log', 'deprecate', 'message', 'site',
	    '"use strict"\n' +
	    'return function (' + args + ') {' +
	    'log.call(deprecate, message, site)\n' +
	    'return fn.apply(this, arguments)\n' +
	    '}')(fn, log, this, message, site);

	  return deprecatedfn
	}

	/**
	 * Wrap property in a deprecation message.
	 */

	function wrapproperty (obj, prop, message) {
	  if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
	    throw new TypeError('argument obj must be object')
	  }

	  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);

	  if (!descriptor) {
	    throw new TypeError('must call property on owner object')
	  }

	  if (!descriptor.configurable) {
	    throw new TypeError('property must be configurable')
	  }

	  var deprecate = this;
	  var stack = getStack();
	  var site = callSiteLocation(stack[1]);

	  // set site name
	  site.name = prop;

	  // convert data descriptor
	  if ('value' in descriptor) {
	    descriptor = convertDataDescriptorToAccessor(obj, prop);
	  }

	  var get = descriptor.get;
	  var set = descriptor.set;

	  // wrap getter
	  if (typeof get === 'function') {
	    descriptor.get = function getter () {
	      log.call(deprecate, message, site);
	      return get.apply(this, arguments)
	    };
	  }

	  // wrap setter
	  if (typeof set === 'function') {
	    descriptor.set = function setter () {
	      log.call(deprecate, message, site);
	      return set.apply(this, arguments)
	    };
	  }

	  Object.defineProperty(obj, prop, descriptor);
	}

	/**
	 * Create DeprecationError for deprecation
	 */

	function DeprecationError (namespace, message, stack) {
	  var error = new Error();
	  var stackString;

	  Object.defineProperty(error, 'constructor', {
	    value: DeprecationError
	  });

	  Object.defineProperty(error, 'message', {
	    configurable: true,
	    enumerable: false,
	    value: message,
	    writable: true
	  });

	  Object.defineProperty(error, 'name', {
	    enumerable: false,
	    configurable: true,
	    value: 'DeprecationError',
	    writable: true
	  });

	  Object.defineProperty(error, 'namespace', {
	    configurable: true,
	    enumerable: false,
	    value: namespace,
	    writable: true
	  });

	  Object.defineProperty(error, 'stack', {
	    configurable: true,
	    enumerable: false,
	    get: function () {
	      if (stackString !== undefined) {
	        return stackString
	      }

	      // prepare stack trace
	      return (stackString = createStackString.call(this, stack))
	    },
	    set: function setter (val) {
	      stackString = val;
	    }
	  });

	  return error
	}
	return depd_1;
}

var bytes = {exports: {}};

/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */

var hasRequiredBytes;

function requireBytes () {
	if (hasRequiredBytes) return bytes.exports;
	hasRequiredBytes = 1;

	/**
	 * Module exports.
	 * @public
	 */

	bytes.exports = bytes$1;
	bytes.exports.format = format;
	bytes.exports.parse = parse;

	/**
	 * Module variables.
	 * @private
	 */

	var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;

	var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;

	var map = {
	  b:  1,
	  kb: 1 << 10,
	  mb: 1 << 20,
	  gb: 1 << 30,
	  tb: Math.pow(1024, 4),
	  pb: Math.pow(1024, 5),
	};

	var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;

	/**
	 * Convert the given value in bytes into a string or parse to string to an integer in bytes.
	 *
	 * @param {string|number} value
	 * @param {{
	 *  case: [string],
	 *  decimalPlaces: [number]
	 *  fixedDecimals: [boolean]
	 *  thousandsSeparator: [string]
	 *  unitSeparator: [string]
	 *  }} [options] bytes options.
	 *
	 * @returns {string|number|null}
	 */

	function bytes$1(value, options) {
	  if (typeof value === 'string') {
	    return parse(value);
	  }

	  if (typeof value === 'number') {
	    return format(value, options);
	  }

	  return null;
	}

	/**
	 * Format the given value in bytes into a string.
	 *
	 * If the value is negative, it is kept as such. If it is a float,
	 * it is rounded.
	 *
	 * @param {number} value
	 * @param {object} [options]
	 * @param {number} [options.decimalPlaces=2]
	 * @param {number} [options.fixedDecimals=false]
	 * @param {string} [options.thousandsSeparator=]
	 * @param {string} [options.unit=]
	 * @param {string} [options.unitSeparator=]
	 *
	 * @returns {string|null}
	 * @public
	 */

	function format(value, options) {
	  if (!Number.isFinite(value)) {
	    return null;
	  }

	  var mag = Math.abs(value);
	  var thousandsSeparator = (options && options.thousandsSeparator) || '';
	  var unitSeparator = (options && options.unitSeparator) || '';
	  var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;
	  var fixedDecimals = Boolean(options && options.fixedDecimals);
	  var unit = (options && options.unit) || '';

	  if (!unit || !map[unit.toLowerCase()]) {
	    if (mag >= map.pb) {
	      unit = 'PB';
	    } else if (mag >= map.tb) {
	      unit = 'TB';
	    } else if (mag >= map.gb) {
	      unit = 'GB';
	    } else if (mag >= map.mb) {
	      unit = 'MB';
	    } else if (mag >= map.kb) {
	      unit = 'KB';
	    } else {
	      unit = 'B';
	    }
	  }

	  var val = value / map[unit.toLowerCase()];
	  var str = val.toFixed(decimalPlaces);

	  if (!fixedDecimals) {
	    str = str.replace(formatDecimalsRegExp, '$1');
	  }

	  if (thousandsSeparator) {
	    str = str.split('.').map(function (s, i) {
	      return i === 0
	        ? s.replace(formatThousandsRegExp, thousandsSeparator)
	        : s
	    }).join('.');
	  }

	  return str + unitSeparator + unit;
	}

	/**
	 * Parse the string value into an integer in bytes.
	 *
	 * If no unit is given, it is assumed the value is in bytes.
	 *
	 * @param {number|string} val
	 *
	 * @returns {number|null}
	 * @public
	 */

	function parse(val) {
	  if (typeof val === 'number' && !isNaN(val)) {
	    return val;
	  }

	  if (typeof val !== 'string') {
	    return null;
	  }

	  // Test if the string passed is valid
	  var results = parseRegExp.exec(val);
	  var floatValue;
	  var unit = 'b';

	  if (!results) {
	    // Nothing could be extracted from the given string
	    floatValue = parseInt(val, 10);
	    unit = 'b';
	  } else {
	    // Retrieve the value and the unit
	    floatValue = parseFloat(results[1]);
	    unit = results[4].toLowerCase();
	  }

	  if (isNaN(floatValue)) {
	    return null;
	  }

	  return Math.floor(map[unit] * floatValue);
	}
	return bytes.exports;
}

var contentType = {};

/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredContentType;

function requireContentType () {
	if (hasRequiredContentType) return contentType;
	hasRequiredContentType = 1;

	/**
	 * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
	 *
	 * parameter     = token "=" ( token / quoted-string )
	 * token         = 1*tchar
	 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	 *               / DIGIT / ALPHA
	 *               ; any VCHAR, except delimiters
	 * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
	 * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
	 * obs-text      = %x80-FF
	 * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
	 */
	var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g; // eslint-disable-line no-control-regex
	var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/; // eslint-disable-line no-control-regex
	var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;

	/**
	 * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
	 *
	 * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
	 * obs-text    = %x80-FF
	 */
	var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g; // eslint-disable-line no-control-regex

	/**
	 * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
	 */
	var QUOTE_REGEXP = /([\\"])/g;

	/**
	 * RegExp to match type in RFC 7231 sec 3.1.1.1
	 *
	 * media-type = type "/" subtype
	 * type       = token
	 * subtype    = token
	 */
	var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;

	/**
	 * Module exports.
	 * @public
	 */

	contentType.format = format;
	contentType.parse = parse;

	/**
	 * Format object to media type.
	 *
	 * @param {object} obj
	 * @return {string}
	 * @public
	 */

	function format (obj) {
	  if (!obj || typeof obj !== 'object') {
	    throw new TypeError('argument obj is required')
	  }

	  var parameters = obj.parameters;
	  var type = obj.type;

	  if (!type || !TYPE_REGEXP.test(type)) {
	    throw new TypeError('invalid type')
	  }

	  var string = type;

	  // append parameters
	  if (parameters && typeof parameters === 'object') {
	    var param;
	    var params = Object.keys(parameters).sort();

	    for (var i = 0; i < params.length; i++) {
	      param = params[i];

	      if (!TOKEN_REGEXP.test(param)) {
	        throw new TypeError('invalid parameter name')
	      }

	      string += '; ' + param + '=' + qstring(parameters[param]);
	    }
	  }

	  return string
	}

	/**
	 * Parse media type to object.
	 *
	 * @param {string|object} string
	 * @return {Object}
	 * @public
	 */

	function parse (string) {
	  if (!string) {
	    throw new TypeError('argument string is required')
	  }

	  // support req/res-like objects as argument
	  var header = typeof string === 'object'
	    ? getcontenttype(string)
	    : string;

	  if (typeof header !== 'string') {
	    throw new TypeError('argument string is required to be a string')
	  }

	  var index = header.indexOf(';');
	  var type = index !== -1
	    ? header.slice(0, index).trim()
	    : header.trim();

	  if (!TYPE_REGEXP.test(type)) {
	    throw new TypeError('invalid media type')
	  }

	  var obj = new ContentType(type.toLowerCase());

	  // parse parameters
	  if (index !== -1) {
	    var key;
	    var match;
	    var value;

	    PARAM_REGEXP.lastIndex = index;

	    while ((match = PARAM_REGEXP.exec(header))) {
	      if (match.index !== index) {
	        throw new TypeError('invalid parameter format')
	      }

	      index += match[0].length;
	      key = match[1].toLowerCase();
	      value = match[2];

	      if (value.charCodeAt(0) === 0x22 /* " */) {
	        // remove quotes
	        value = value.slice(1, -1);

	        // remove escapes
	        if (value.indexOf('\\') !== -1) {
	          value = value.replace(QESC_REGEXP, '$1');
	        }
	      }

	      obj.parameters[key] = value;
	    }

	    if (index !== header.length) {
	      throw new TypeError('invalid parameter format')
	    }
	  }

	  return obj
	}

	/**
	 * Get content-type from req/res objects.
	 *
	 * @param {object}
	 * @return {Object}
	 * @private
	 */

	function getcontenttype (obj) {
	  var header;

	  if (typeof obj.getHeader === 'function') {
	    // res-like
	    header = obj.getHeader('content-type');
	  } else if (typeof obj.headers === 'object') {
	    // req-like
	    header = obj.headers && obj.headers['content-type'];
	  }

	  if (typeof header !== 'string') {
	    throw new TypeError('content-type header is missing from object')
	  }

	  return header
	}

	/**
	 * Quote a string if necessary.
	 *
	 * @param {string} val
	 * @return {string}
	 * @private
	 */

	function qstring (val) {
	  var str = String(val);

	  // no need to quote tokens
	  if (TOKEN_REGEXP.test(str)) {
	    return str
	  }

	  if (str.length > 0 && !TEXT_REGEXP.test(str)) {
	    throw new TypeError('invalid parameter value')
	  }

	  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"'
	}

	/**
	 * Class to represent a content type.
	 * @private
	 */
	function ContentType (type) {
	  this.parameters = Object.create(null);
	  this.type = type;
	}
	return contentType;
}

var httpErrors = {exports: {}};

var setprototypeof;
var hasRequiredSetprototypeof;

function requireSetprototypeof () {
	if (hasRequiredSetprototypeof) return setprototypeof;
	hasRequiredSetprototypeof = 1;
	/* eslint no-proto: 0 */
	setprototypeof = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);

	function setProtoOf (obj, proto) {
	  obj.__proto__ = proto;
	  return obj
	}

	function mixinProperties (obj, proto) {
	  for (var prop in proto) {
	    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
	      obj[prop] = proto[prop];
	    }
	  }
	  return obj
	}
	return setprototypeof;
}

var require$$0$3 = {
	"100": "Continue",
	"101": "Switching Protocols",
	"102": "Processing",
	"103": "Early Hints",
	"200": "OK",
	"201": "Created",
	"202": "Accepted",
	"203": "Non-Authoritative Information",
	"204": "No Content",
	"205": "Reset Content",
	"206": "Partial Content",
	"207": "Multi-Status",
	"208": "Already Reported",
	"226": "IM Used",
	"300": "Multiple Choices",
	"301": "Moved Permanently",
	"302": "Found",
	"303": "See Other",
	"304": "Not Modified",
	"305": "Use Proxy",
	"307": "Temporary Redirect",
	"308": "Permanent Redirect",
	"400": "Bad Request",
	"401": "Unauthorized",
	"402": "Payment Required",
	"403": "Forbidden",
	"404": "Not Found",
	"405": "Method Not Allowed",
	"406": "Not Acceptable",
	"407": "Proxy Authentication Required",
	"408": "Request Timeout",
	"409": "Conflict",
	"410": "Gone",
	"411": "Length Required",
	"412": "Precondition Failed",
	"413": "Payload Too Large",
	"414": "URI Too Long",
	"415": "Unsupported Media Type",
	"416": "Range Not Satisfiable",
	"417": "Expectation Failed",
	"418": "I'm a Teapot",
	"421": "Misdirected Request",
	"422": "Unprocessable Entity",
	"423": "Locked",
	"424": "Failed Dependency",
	"425": "Too Early",
	"426": "Upgrade Required",
	"428": "Precondition Required",
	"429": "Too Many Requests",
	"431": "Request Header Fields Too Large",
	"451": "Unavailable For Legal Reasons",
	"500": "Internal Server Error",
	"501": "Not Implemented",
	"502": "Bad Gateway",
	"503": "Service Unavailable",
	"504": "Gateway Timeout",
	"505": "HTTP Version Not Supported",
	"506": "Variant Also Negotiates",
	"507": "Insufficient Storage",
	"508": "Loop Detected",
	"509": "Bandwidth Limit Exceeded",
	"510": "Not Extended",
	"511": "Network Authentication Required"
};

/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */

var statuses;
var hasRequiredStatuses;

function requireStatuses () {
	if (hasRequiredStatuses) return statuses;
	hasRequiredStatuses = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var codes = require$$0$3;

	/**
	 * Module exports.
	 * @public
	 */

	statuses = status;

	// status code to message map
	status.message = codes;

	// status message (lower-case) to code map
	status.code = createMessageToStatusCodeMap(codes);

	// array of status codes
	status.codes = createStatusCodeList(codes);

	// status codes for redirects
	status.redirect = {
	  300: true,
	  301: true,
	  302: true,
	  303: true,
	  305: true,
	  307: true,
	  308: true
	};

	// status codes for empty bodies
	status.empty = {
	  204: true,
	  205: true,
	  304: true
	};

	// status codes for when you should retry the request
	status.retry = {
	  502: true,
	  503: true,
	  504: true
	};

	/**
	 * Create a map of message to status code.
	 * @private
	 */

	function createMessageToStatusCodeMap (codes) {
	  var map = {};

	  Object.keys(codes).forEach(function forEachCode (code) {
	    var message = codes[code];
	    var status = Number(code);

	    // populate map
	    map[message.toLowerCase()] = status;
	  });

	  return map
	}

	/**
	 * Create a list of all status codes.
	 * @private
	 */

	function createStatusCodeList (codes) {
	  return Object.keys(codes).map(function mapCode (code) {
	    return Number(code)
	  })
	}

	/**
	 * Get the status code for given message.
	 * @private
	 */

	function getStatusCode (message) {
	  var msg = message.toLowerCase();

	  if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
	    throw new Error('invalid status message: "' + message + '"')
	  }

	  return status.code[msg]
	}

	/**
	 * Get the status message for given code.
	 * @private
	 */

	function getStatusMessage (code) {
	  if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
	    throw new Error('invalid status code: ' + code)
	  }

	  return status.message[code]
	}

	/**
	 * Get the status code.
	 *
	 * Given a number, this will throw if it is not a known status
	 * code, otherwise the code will be returned. Given a string,
	 * the string will be parsed for a number and return the code
	 * if valid, otherwise will lookup the code assuming this is
	 * the status message.
	 *
	 * @param {string|number} code
	 * @returns {number}
	 * @public
	 */

	function status (code) {
	  if (typeof code === 'number') {
	    return getStatusMessage(code)
	  }

	  if (typeof code !== 'string') {
	    throw new TypeError('code must be a number or string')
	  }

	  // '403'
	  var n = parseInt(code, 10);
	  if (!isNaN(n)) {
	    return getStatusMessage(n)
	  }

	  return getStatusCode(code)
	}
	return statuses;
}

var inherits = {exports: {}};

var inherits_browser = {exports: {}};

var hasRequiredInherits_browser;

function requireInherits_browser () {
	if (hasRequiredInherits_browser) return inherits_browser.exports;
	hasRequiredInherits_browser = 1;
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    }
	  };
	} else {
	  // old school shim for old browsers
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      var TempCtor = function () {};
	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    }
	  };
	}
	return inherits_browser.exports;
}

var hasRequiredInherits;

function requireInherits () {
	if (hasRequiredInherits) return inherits.exports;
	hasRequiredInherits = 1;
	try {
	  var util = require('util');
	  /* istanbul ignore next */
	  if (typeof util.inherits !== 'function') throw '';
	  inherits.exports = util.inherits;
	} catch (e) {
	  /* istanbul ignore next */
	  inherits.exports = requireInherits_browser();
	}
	return inherits.exports;
}

/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */

var toidentifier;
var hasRequiredToidentifier;

function requireToidentifier () {
	if (hasRequiredToidentifier) return toidentifier;
	hasRequiredToidentifier = 1;

	/**
	 * Module exports.
	 * @public
	 */

	toidentifier = toIdentifier;

	/**
	 * Trasform the given string into a JavaScript identifier
	 *
	 * @param {string} str
	 * @returns {string}
	 * @public
	 */

	function toIdentifier (str) {
	  return str
	    .split(' ')
	    .map(function (token) {
	      return token.slice(0, 1).toUpperCase() + token.slice(1)
	    })
	    .join('')
	    .replace(/[^ _0-9a-z]/gi, '')
	}
	return toidentifier;
}

/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredHttpErrors;

function requireHttpErrors () {
	if (hasRequiredHttpErrors) return httpErrors.exports;
	hasRequiredHttpErrors = 1;
	(function (module) {

		/**
		 * Module dependencies.
		 * @private
		 */

		var deprecate = requireDepd()('http-errors');
		var setPrototypeOf = requireSetprototypeof();
		var statuses = requireStatuses();
		var inherits = requireInherits();
		var toIdentifier = requireToidentifier();

		/**
		 * Module exports.
		 * @public
		 */

		module.exports = createError;
		module.exports.HttpError = createHttpErrorConstructor();
		module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);

		// Populate exports for all constructors
		populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);

		/**
		 * Get the code class of a status code.
		 * @private
		 */

		function codeClass (status) {
		  return Number(String(status).charAt(0) + '00')
		}

		/**
		 * Create a new HTTP Error.
		 *
		 * @returns {Error}
		 * @public
		 */

		function createError () {
		  // so much arity going on ~_~
		  var err;
		  var msg;
		  var status = 500;
		  var props = {};
		  for (var i = 0; i < arguments.length; i++) {
		    var arg = arguments[i];
		    var type = typeof arg;
		    if (type === 'object' && arg instanceof Error) {
		      err = arg;
		      status = err.status || err.statusCode || status;
		    } else if (type === 'number' && i === 0) {
		      status = arg;
		    } else if (type === 'string') {
		      msg = arg;
		    } else if (type === 'object') {
		      props = arg;
		    } else {
		      throw new TypeError('argument #' + (i + 1) + ' unsupported type ' + type)
		    }
		  }

		  if (typeof status === 'number' && (status < 400 || status >= 600)) {
		    deprecate('non-error status code; use only 4xx or 5xx status codes');
		  }

		  if (typeof status !== 'number' ||
		    (!statuses.message[status] && (status < 400 || status >= 600))) {
		    status = 500;
		  }

		  // constructor
		  var HttpError = createError[status] || createError[codeClass(status)];

		  if (!err) {
		    // create error
		    err = HttpError
		      ? new HttpError(msg)
		      : new Error(msg || statuses.message[status]);
		    Error.captureStackTrace(err, createError);
		  }

		  if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
		    // add properties to generic error
		    err.expose = status < 500;
		    err.status = err.statusCode = status;
		  }

		  for (var key in props) {
		    if (key !== 'status' && key !== 'statusCode') {
		      err[key] = props[key];
		    }
		  }

		  return err
		}

		/**
		 * Create HTTP error abstract base class.
		 * @private
		 */

		function createHttpErrorConstructor () {
		  function HttpError () {
		    throw new TypeError('cannot construct abstract class')
		  }

		  inherits(HttpError, Error);

		  return HttpError
		}

		/**
		 * Create a constructor for a client error.
		 * @private
		 */

		function createClientErrorConstructor (HttpError, name, code) {
		  var className = toClassName(name);

		  function ClientError (message) {
		    // create the error object
		    var msg = message != null ? message : statuses.message[code];
		    var err = new Error(msg);

		    // capture a stack trace to the construction point
		    Error.captureStackTrace(err, ClientError);

		    // adjust the [[Prototype]]
		    setPrototypeOf(err, ClientError.prototype);

		    // redefine the error message
		    Object.defineProperty(err, 'message', {
		      enumerable: true,
		      configurable: true,
		      value: msg,
		      writable: true
		    });

		    // redefine the error name
		    Object.defineProperty(err, 'name', {
		      enumerable: false,
		      configurable: true,
		      value: className,
		      writable: true
		    });

		    return err
		  }

		  inherits(ClientError, HttpError);
		  nameFunc(ClientError, className);

		  ClientError.prototype.status = code;
		  ClientError.prototype.statusCode = code;
		  ClientError.prototype.expose = true;

		  return ClientError
		}

		/**
		 * Create function to test is a value is a HttpError.
		 * @private
		 */

		function createIsHttpErrorFunction (HttpError) {
		  return function isHttpError (val) {
		    if (!val || typeof val !== 'object') {
		      return false
		    }

		    if (val instanceof HttpError) {
		      return true
		    }

		    return val instanceof Error &&
		      typeof val.expose === 'boolean' &&
		      typeof val.statusCode === 'number' && val.status === val.statusCode
		  }
		}

		/**
		 * Create a constructor for a server error.
		 * @private
		 */

		function createServerErrorConstructor (HttpError, name, code) {
		  var className = toClassName(name);

		  function ServerError (message) {
		    // create the error object
		    var msg = message != null ? message : statuses.message[code];
		    var err = new Error(msg);

		    // capture a stack trace to the construction point
		    Error.captureStackTrace(err, ServerError);

		    // adjust the [[Prototype]]
		    setPrototypeOf(err, ServerError.prototype);

		    // redefine the error message
		    Object.defineProperty(err, 'message', {
		      enumerable: true,
		      configurable: true,
		      value: msg,
		      writable: true
		    });

		    // redefine the error name
		    Object.defineProperty(err, 'name', {
		      enumerable: false,
		      configurable: true,
		      value: className,
		      writable: true
		    });

		    return err
		  }

		  inherits(ServerError, HttpError);
		  nameFunc(ServerError, className);

		  ServerError.prototype.status = code;
		  ServerError.prototype.statusCode = code;
		  ServerError.prototype.expose = false;

		  return ServerError
		}

		/**
		 * Set the name of a function, if possible.
		 * @private
		 */

		function nameFunc (func, name) {
		  var desc = Object.getOwnPropertyDescriptor(func, 'name');

		  if (desc && desc.configurable) {
		    desc.value = name;
		    Object.defineProperty(func, 'name', desc);
		  }
		}

		/**
		 * Populate the exports object with constructors for every error class.
		 * @private
		 */

		function populateConstructorExports (exports, codes, HttpError) {
		  codes.forEach(function forEachCode (code) {
		    var CodeError;
		    var name = toIdentifier(statuses.message[code]);

		    switch (codeClass(code)) {
		      case 400:
		        CodeError = createClientErrorConstructor(HttpError, name, code);
		        break
		      case 500:
		        CodeError = createServerErrorConstructor(HttpError, name, code);
		        break
		    }

		    if (CodeError) {
		      // export the constructor
		      exports[code] = CodeError;
		      exports[name] = CodeError;
		    }
		  });
		}

		/**
		 * Get a class name from a name identifier.
		 * @private
		 */

		function toClassName (name) {
		  return name.substr(-5) !== 'Error'
		    ? name + 'Error'
		    : name
		} 
	} (httpErrors));
	return httpErrors.exports;
}

var src$3 = {exports: {}};

var browser$4 = {exports: {}};

var debug = {exports: {}};

/**
 * Helpers.
 */

var ms$1;
var hasRequiredMs$1;

function requireMs$1 () {
	if (hasRequiredMs$1) return ms$1;
	hasRequiredMs$1 = 1;
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	ms$1 = function(val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  return plural(ms, d, 'day') ||
	    plural(ms, h, 'hour') ||
	    plural(ms, m, 'minute') ||
	    plural(ms, s, 'second') ||
	    ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) {
	    return;
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name;
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}
	return ms$1;
}

var hasRequiredDebug;

function requireDebug () {
	if (hasRequiredDebug) return debug.exports;
	hasRequiredDebug = 1;
	(function (module, exports) {
		/**
		 * This is the common logic for both the Node.js and web browser
		 * implementations of `debug()`.
		 *
		 * Expose `debug()` as the module.
		 */

		exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
		exports.coerce = coerce;
		exports.disable = disable;
		exports.enable = enable;
		exports.enabled = enabled;
		exports.humanize = requireMs$1();

		/**
		 * The currently active debug mode names, and names to skip.
		 */

		exports.names = [];
		exports.skips = [];

		/**
		 * Map of special "%n" handling functions, for the debug "format" argument.
		 *
		 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		 */

		exports.formatters = {};

		/**
		 * Previous log timestamp.
		 */

		var prevTime;

		/**
		 * Select a color.
		 * @param {String} namespace
		 * @return {Number}
		 * @api private
		 */

		function selectColor(namespace) {
		  var hash = 0, i;

		  for (i in namespace) {
		    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
		    hash |= 0; // Convert to 32bit integer
		  }

		  return exports.colors[Math.abs(hash) % exports.colors.length];
		}

		/**
		 * Create a debugger with the given `namespace`.
		 *
		 * @param {String} namespace
		 * @return {Function}
		 * @api public
		 */

		function createDebug(namespace) {

		  function debug() {
		    // disabled?
		    if (!debug.enabled) return;

		    var self = debug;

		    // set `diff` timestamp
		    var curr = +new Date();
		    var ms = curr - (prevTime || curr);
		    self.diff = ms;
		    self.prev = prevTime;
		    self.curr = curr;
		    prevTime = curr;

		    // turn the `arguments` into a proper Array
		    var args = new Array(arguments.length);
		    for (var i = 0; i < args.length; i++) {
		      args[i] = arguments[i];
		    }

		    args[0] = exports.coerce(args[0]);

		    if ('string' !== typeof args[0]) {
		      // anything else let's inspect with %O
		      args.unshift('%O');
		    }

		    // apply any `formatters` transformations
		    var index = 0;
		    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
		      // if we encounter an escaped % then don't increase the array index
		      if (match === '%%') return match;
		      index++;
		      var formatter = exports.formatters[format];
		      if ('function' === typeof formatter) {
		        var val = args[index];
		        match = formatter.call(self, val);

		        // now we need to remove `args[index]` since it's inlined in the `format`
		        args.splice(index, 1);
		        index--;
		      }
		      return match;
		    });

		    // apply env-specific formatting (colors, etc.)
		    exports.formatArgs.call(self, args);

		    var logFn = debug.log || exports.log || console.log.bind(console);
		    logFn.apply(self, args);
		  }

		  debug.namespace = namespace;
		  debug.enabled = exports.enabled(namespace);
		  debug.useColors = exports.useColors();
		  debug.color = selectColor(namespace);

		  // env-specific initialization logic for debug instances
		  if ('function' === typeof exports.init) {
		    exports.init(debug);
		  }

		  return debug;
		}

		/**
		 * Enables a debug mode by namespaces. This can include modes
		 * separated by a colon and wildcards.
		 *
		 * @param {String} namespaces
		 * @api public
		 */

		function enable(namespaces) {
		  exports.save(namespaces);

		  exports.names = [];
		  exports.skips = [];

		  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		  var len = split.length;

		  for (var i = 0; i < len; i++) {
		    if (!split[i]) continue; // ignore empty strings
		    namespaces = split[i].replace(/\*/g, '.*?');
		    if (namespaces[0] === '-') {
		      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
		    } else {
		      exports.names.push(new RegExp('^' + namespaces + '$'));
		    }
		  }
		}

		/**
		 * Disable debug output.
		 *
		 * @api public
		 */

		function disable() {
		  exports.enable('');
		}

		/**
		 * Returns true if the given mode name is enabled, false otherwise.
		 *
		 * @param {String} name
		 * @return {Boolean}
		 * @api public
		 */

		function enabled(name) {
		  var i, len;
		  for (i = 0, len = exports.skips.length; i < len; i++) {
		    if (exports.skips[i].test(name)) {
		      return false;
		    }
		  }
		  for (i = 0, len = exports.names.length; i < len; i++) {
		    if (exports.names[i].test(name)) {
		      return true;
		    }
		  }
		  return false;
		}

		/**
		 * Coerce `val`.
		 *
		 * @param {Mixed} val
		 * @return {Mixed}
		 * @api private
		 */

		function coerce(val) {
		  if (val instanceof Error) return val.stack || val.message;
		  return val;
		} 
	} (debug, debug.exports));
	return debug.exports;
}

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browser$4.exports;
	hasRequiredBrowser = 1;
	(function (module, exports) {
		exports = module.exports = requireDebug();
		exports.log = log;
		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.storage = 'undefined' != typeof chrome
		               && 'undefined' != typeof chrome.storage
		                  ? chrome.storage.local
		                  : localstorage();

		/**
		 * Colors.
		 */

		exports.colors = [
		  'lightseagreen',
		  'forestgreen',
		  'goldenrod',
		  'dodgerblue',
		  'darkorchid',
		  'crimson'
		];

		/**
		 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
		 * and the Firebug extension (any Firefox version) are known
		 * to support "%c" CSS customizations.
		 *
		 * TODO: add a `localStorage` variable to explicitly enable/disable colors
		 */

		function useColors() {
		  // NB: In an Electron preload script, document will be defined but not fully
		  // initialized. Since we know we're in Chrome, we'll just detect this case
		  // explicitly
		  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
		    return true;
		  }

		  // is webkit? http://stackoverflow.com/a/16459606/376773
		  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
		  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		    // is firebug? http://stackoverflow.com/a/398120/376773
		    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		    // is firefox >= v31?
		    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		    // double check webkit in userAgent just in case we are in a worker
		    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
		}

		/**
		 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
		 */

		exports.formatters.j = function(v) {
		  try {
		    return JSON.stringify(v);
		  } catch (err) {
		    return '[UnexpectedJSONParseError]: ' + err.message;
		  }
		};


		/**
		 * Colorize log arguments if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
		  var useColors = this.useColors;

		  args[0] = (useColors ? '%c' : '')
		    + this.namespace
		    + (useColors ? ' %c' : ' ')
		    + args[0]
		    + (useColors ? '%c ' : ' ')
		    + '+' + exports.humanize(this.diff);

		  if (!useColors) return;

		  var c = 'color: ' + this.color;
		  args.splice(1, 0, c, 'color: inherit');

		  // the final "%c" is somewhat tricky, because there could be other
		  // arguments passed either before or after the %c, so we need to
		  // figure out the correct index to insert the CSS into
		  var index = 0;
		  var lastC = 0;
		  args[0].replace(/%[a-zA-Z%]/g, function(match) {
		    if ('%%' === match) return;
		    index++;
		    if ('%c' === match) {
		      // we only are interested in the *last* %c
		      // (the user may have provided their own)
		      lastC = index;
		    }
		  });

		  args.splice(lastC, 0, c);
		}

		/**
		 * Invokes `console.log()` when available.
		 * No-op when `console.log` is not a "function".
		 *
		 * @api public
		 */

		function log() {
		  // this hackery is required for IE8/9, where
		  // the `console.log` function doesn't have 'apply'
		  return 'object' === typeof console
		    && console.log
		    && Function.prototype.apply.call(console.log, console, arguments);
		}

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */

		function save(namespaces) {
		  try {
		    if (null == namespaces) {
		      exports.storage.removeItem('debug');
		    } else {
		      exports.storage.debug = namespaces;
		    }
		  } catch(e) {}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */

		function load() {
		  var r;
		  try {
		    r = exports.storage.debug;
		  } catch(e) {}

		  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
		  if (!r && typeof process !== 'undefined' && 'env' in process) {
		    r = process.env.DEBUG;
		  }

		  return r;
		}

		/**
		 * Enable namespaces listed in `localStorage.debug` initially.
		 */

		exports.enable(load());

		/**
		 * Localstorage attempts to return the localstorage.
		 *
		 * This is necessary because safari throws
		 * when a user disables cookies/localstorage
		 * and you attempt to access it.
		 *
		 * @return {LocalStorage}
		 * @api private
		 */

		function localstorage() {
		  try {
		    return window.localStorage;
		  } catch (e) {}
		} 
	} (browser$4, browser$4.exports));
	return browser$4.exports;
}

var node$1 = {exports: {}};

/**
 * Module dependencies.
 */

var hasRequiredNode$1;

function requireNode$1 () {
	if (hasRequiredNode$1) return node$1.exports;
	hasRequiredNode$1 = 1;
	(function (module, exports) {
		var tty = require$$0$5;
		var util = require$$0$6;

		/**
		 * This is the Node.js implementation of `debug()`.
		 *
		 * Expose `debug()` as the module.
		 */

		exports = module.exports = requireDebug();
		exports.init = init;
		exports.log = log;
		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;

		/**
		 * Colors.
		 */

		exports.colors = [6, 2, 3, 4, 5, 1];

		/**
		 * Build up the default `inspectOpts` object from the environment variables.
		 *
		 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
		 */

		exports.inspectOpts = Object.keys(process.env).filter(function (key) {
		  return /^debug_/i.test(key);
		}).reduce(function (obj, key) {
		  // camel-case
		  var prop = key
		    .substring(6)
		    .toLowerCase()
		    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

		  // coerce string value into JS value
		  var val = process.env[key];
		  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
		  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
		  else if (val === 'null') val = null;
		  else val = Number(val);

		  obj[prop] = val;
		  return obj;
		}, {});

		/**
		 * The file descriptor to write the `debug()` calls to.
		 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
		 *
		 *   $ DEBUG_FD=3 node script.js 3>debug.log
		 */

		var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

		if (1 !== fd && 2 !== fd) {
		  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
		}

		var stream = 1 === fd ? process.stdout :
		             2 === fd ? process.stderr :
		             createWritableStdioStream(fd);

		/**
		 * Is stdout a TTY? Colored output is enabled when `true`.
		 */

		function useColors() {
		  return 'colors' in exports.inspectOpts
		    ? Boolean(exports.inspectOpts.colors)
		    : tty.isatty(fd);
		}

		/**
		 * Map %o to `util.inspect()`, all on a single line.
		 */

		exports.formatters.o = function(v) {
		  this.inspectOpts.colors = this.useColors;
		  return util.inspect(v, this.inspectOpts)
		    .split('\n').map(function(str) {
		      return str.trim()
		    }).join(' ');
		};

		/**
		 * Map %o to `util.inspect()`, allowing multiple lines if needed.
		 */

		exports.formatters.O = function(v) {
		  this.inspectOpts.colors = this.useColors;
		  return util.inspect(v, this.inspectOpts);
		};

		/**
		 * Adds ANSI color escape codes if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
		  var name = this.namespace;
		  var useColors = this.useColors;

		  if (useColors) {
		    var c = this.color;
		    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

		    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
		  } else {
		    args[0] = new Date().toUTCString()
		      + ' ' + name + ' ' + args[0];
		  }
		}

		/**
		 * Invokes `util.format()` with the specified arguments and writes to `stream`.
		 */

		function log() {
		  return stream.write(util.format.apply(util, arguments) + '\n');
		}

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */

		function save(namespaces) {
		  if (null == namespaces) {
		    // If you set a process.env field to null or undefined, it gets cast to the
		    // string 'null' or 'undefined'. Just delete instead.
		    delete process.env.DEBUG;
		  } else {
		    process.env.DEBUG = namespaces;
		  }
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */

		function load() {
		  return process.env.DEBUG;
		}

		/**
		 * Copied from `node/src/node.js`.
		 *
		 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
		 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
		 */

		function createWritableStdioStream (fd) {
		  var stream;
		  var tty_wrap = process.binding('tty_wrap');

		  // Note stream._type is used for test-module-load-list.js

		  switch (tty_wrap.guessHandleType(fd)) {
		    case 'TTY':
		      stream = new tty.WriteStream(fd);
		      stream._type = 'tty';

		      // Hack to have stream not keep the event loop alive.
		      // See https://github.com/joyent/node/issues/1726
		      if (stream._handle && stream._handle.unref) {
		        stream._handle.unref();
		      }
		      break;

		    case 'FILE':
		      var fs$1 = fs;
		      stream = new fs$1.SyncWriteStream(fd, { autoClose: false });
		      stream._type = 'fs';
		      break;

		    case 'PIPE':
		    case 'TCP':
		      var net = require$$0$7;
		      stream = new net.Socket({
		        fd: fd,
		        readable: false,
		        writable: true
		      });

		      // FIXME Should probably have an option in net.Socket to create a
		      // stream from an existing fd which is writable only. But for now
		      // we'll just add this hack and set the `readable` member to false.
		      // Test: ./node test/fixtures/echo.js < /etc/passwd
		      stream.readable = false;
		      stream.read = null;
		      stream._type = 'pipe';

		      // FIXME Hack to have stream not keep the event loop alive.
		      // See https://github.com/joyent/node/issues/1726
		      if (stream._handle && stream._handle.unref) {
		        stream._handle.unref();
		      }
		      break;

		    default:
		      // Probably an error on in uv_guess_handle()
		      throw new Error('Implement me. Unknown stream file type!');
		  }

		  // For supporting legacy API we put the FD here.
		  stream.fd = fd;

		  stream._isStdio = true;

		  return stream;
		}

		/**
		 * Init logic for `debug` instances.
		 *
		 * Create a new `inspectOpts` object in case `useColors` is set
		 * differently for a particular `debug` instance.
		 */

		function init (debug) {
		  debug.inspectOpts = {};

		  var keys = Object.keys(exports.inspectOpts);
		  for (var i = 0; i < keys.length; i++) {
		    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
		  }
		}

		/**
		 * Enable namespaces listed in `process.env.DEBUG` initially.
		 */

		exports.enable(load()); 
	} (node$1, node$1.exports));
	return node$1.exports;
}

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

var hasRequiredSrc$3;

function requireSrc$3 () {
	if (hasRequiredSrc$3) return src$3.exports;
	hasRequiredSrc$3 = 1;
	if (typeof process !== 'undefined' && process.type === 'renderer') {
	  src$3.exports = requireBrowser();
	} else {
	  src$3.exports = requireNode$1();
	}
	return src$3.exports;
}

/*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

var destroy_1;
var hasRequiredDestroy;

function requireDestroy () {
	if (hasRequiredDestroy) return destroy_1;
	hasRequiredDestroy = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var EventEmitter = require$$0$8.EventEmitter;
	var ReadStream = fs.ReadStream;
	var Stream = require$$0$9;
	var Zlib = zlib;

	/**
	 * Module exports.
	 * @public
	 */

	destroy_1 = destroy;

	/**
	 * Destroy the given stream, and optionally suppress any future `error` events.
	 *
	 * @param {object} stream
	 * @param {boolean} suppress
	 * @public
	 */

	function destroy (stream, suppress) {
	  if (isFsReadStream(stream)) {
	    destroyReadStream(stream);
	  } else if (isZlibStream(stream)) {
	    destroyZlibStream(stream);
	  } else if (hasDestroy(stream)) {
	    stream.destroy();
	  }

	  if (isEventEmitter(stream) && suppress) {
	    stream.removeAllListeners('error');
	    stream.addListener('error', noop);
	  }

	  return stream
	}

	/**
	 * Destroy a ReadStream.
	 *
	 * @param {object} stream
	 * @private
	 */

	function destroyReadStream (stream) {
	  stream.destroy();

	  if (typeof stream.close === 'function') {
	    // node.js core bug work-around
	    stream.on('open', onOpenClose);
	  }
	}

	/**
	 * Close a Zlib stream.
	 *
	 * Zlib streams below Node.js 4.5.5 have a buggy implementation
	 * of .close() when zlib encountered an error.
	 *
	 * @param {object} stream
	 * @private
	 */

	function closeZlibStream (stream) {
	  if (stream._hadError === true) {
	    var prop = stream._binding === null
	      ? '_binding'
	      : '_handle';

	    stream[prop] = {
	      close: function () { this[prop] = null; }
	    };
	  }

	  stream.close();
	}

	/**
	 * Destroy a Zlib stream.
	 *
	 * Zlib streams don't have a destroy function in Node.js 6. On top of that
	 * simply calling destroy on a zlib stream in Node.js 8+ will result in a
	 * memory leak. So until that is fixed, we need to call both close AND destroy.
	 *
	 * PR to fix memory leak: https://github.com/nodejs/node/pull/23734
	 *
	 * In Node.js 6+8, it's important that destroy is called before close as the
	 * stream would otherwise emit the error 'zlib binding closed'.
	 *
	 * @param {object} stream
	 * @private
	 */

	function destroyZlibStream (stream) {
	  if (typeof stream.destroy === 'function') {
	    // node.js core bug work-around
	    // istanbul ignore if: node.js 0.8
	    if (stream._binding) {
	      // node.js < 0.10.0
	      stream.destroy();
	      if (stream._processing) {
	        stream._needDrain = true;
	        stream.once('drain', onDrainClearBinding);
	      } else {
	        stream._binding.clear();
	      }
	    } else if (stream._destroy && stream._destroy !== Stream.Transform.prototype._destroy) {
	      // node.js >= 12, ^11.1.0, ^10.15.1
	      stream.destroy();
	    } else if (stream._destroy && typeof stream.close === 'function') {
	      // node.js 7, 8
	      stream.destroyed = true;
	      stream.close();
	    } else {
	      // fallback
	      // istanbul ignore next
	      stream.destroy();
	    }
	  } else if (typeof stream.close === 'function') {
	    // node.js < 8 fallback
	    closeZlibStream(stream);
	  }
	}

	/**
	 * Determine if stream has destroy.
	 * @private
	 */

	function hasDestroy (stream) {
	  return stream instanceof Stream &&
	    typeof stream.destroy === 'function'
	}

	/**
	 * Determine if val is EventEmitter.
	 * @private
	 */

	function isEventEmitter (val) {
	  return val instanceof EventEmitter
	}

	/**
	 * Determine if stream is fs.ReadStream stream.
	 * @private
	 */

	function isFsReadStream (stream) {
	  return stream instanceof ReadStream
	}

	/**
	 * Determine if stream is Zlib stream.
	 * @private
	 */

	function isZlibStream (stream) {
	  return stream instanceof Zlib.Gzip ||
	    stream instanceof Zlib.Gunzip ||
	    stream instanceof Zlib.Deflate ||
	    stream instanceof Zlib.DeflateRaw ||
	    stream instanceof Zlib.Inflate ||
	    stream instanceof Zlib.InflateRaw ||
	    stream instanceof Zlib.Unzip
	}

	/**
	 * No-op function.
	 * @private
	 */

	function noop () {}

	/**
	 * On drain handler to clear binding.
	 * @private
	 */

	// istanbul ignore next: node.js 0.8
	function onDrainClearBinding () {
	  this._binding.clear();
	}

	/**
	 * On open handler to close stream.
	 * @private
	 */

	function onOpenClose () {
	  if (typeof this.fd === 'number') {
	    // actually close down the fd
	    this.close();
	  }
	}
	return destroy_1;
}

var lib$5 = {exports: {}};

/* eslint-disable node/no-deprecated-api */

var safer_1;
var hasRequiredSafer;

function requireSafer () {
	if (hasRequiredSafer) return safer_1;
	hasRequiredSafer = 1;

	var buffer = require$$0$a;
	var Buffer = buffer.Buffer;

	var safer = {};

	var key;

	for (key in buffer) {
	  if (!buffer.hasOwnProperty(key)) continue
	  if (key === 'SlowBuffer' || key === 'Buffer') continue
	  safer[key] = buffer[key];
	}

	var Safer = safer.Buffer = {};
	for (key in Buffer) {
	  if (!Buffer.hasOwnProperty(key)) continue
	  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
	  Safer[key] = Buffer[key];
	}

	safer.Buffer.prototype = Buffer.prototype;

	if (!Safer.from || Safer.from === Uint8Array.from) {
	  Safer.from = function (value, encodingOrOffset, length) {
	    if (typeof value === 'number') {
	      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
	    }
	    if (value && typeof value.length === 'undefined') {
	      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
	    }
	    return Buffer(value, encodingOrOffset, length)
	  };
	}

	if (!Safer.alloc) {
	  Safer.alloc = function (size, fill, encoding) {
	    if (typeof size !== 'number') {
	      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
	    }
	    if (size < 0 || size >= 2 * (1 << 30)) {
	      throw new RangeError('The value "' + size + '" is invalid for option "size"')
	    }
	    var buf = Buffer(size);
	    if (!fill || fill.length === 0) {
	      buf.fill(0);
	    } else if (typeof encoding === 'string') {
	      buf.fill(fill, encoding);
	    } else {
	      buf.fill(fill);
	    }
	    return buf
	  };
	}

	if (!safer.kStringMaxLength) {
	  try {
	    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
	  } catch (e) {
	    // we can't determine kStringMaxLength in environments where process.binding
	    // is unsupported, so let's not set it
	  }
	}

	if (!safer.constants) {
	  safer.constants = {
	    MAX_LENGTH: safer.kMaxLength
	  };
	  if (safer.kStringMaxLength) {
	    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
	  }
	}

	safer_1 = safer;
	return safer_1;
}

var bomHandling = {};

var hasRequiredBomHandling;

function requireBomHandling () {
	if (hasRequiredBomHandling) return bomHandling;
	hasRequiredBomHandling = 1;

	var BOMChar = '\uFEFF';

	bomHandling.PrependBOM = PrependBOMWrapper;
	function PrependBOMWrapper(encoder, options) {
	    this.encoder = encoder;
	    this.addBOM = true;
	}

	PrependBOMWrapper.prototype.write = function(str) {
	    if (this.addBOM) {
	        str = BOMChar + str;
	        this.addBOM = false;
	    }

	    return this.encoder.write(str);
	};

	PrependBOMWrapper.prototype.end = function() {
	    return this.encoder.end();
	};


	//------------------------------------------------------------------------------

	bomHandling.StripBOM = StripBOMWrapper;
	function StripBOMWrapper(decoder, options) {
	    this.decoder = decoder;
	    this.pass = false;
	    this.options = options || {};
	}

	StripBOMWrapper.prototype.write = function(buf) {
	    var res = this.decoder.write(buf);
	    if (this.pass || !res)
	        return res;

	    if (res[0] === BOMChar) {
	        res = res.slice(1);
	        if (typeof this.options.stripBOM === 'function')
	            this.options.stripBOM();
	    }

	    this.pass = true;
	    return res;
	};

	StripBOMWrapper.prototype.end = function() {
	    return this.decoder.end();
	};
	return bomHandling;
}

var encodings = {};

var internal;
var hasRequiredInternal;

function requireInternal () {
	if (hasRequiredInternal) return internal;
	hasRequiredInternal = 1;
	var Buffer = requireSafer().Buffer;

	// Export Node.js internal encodings.

	internal = {
	    // Encodings
	    utf8:   { type: "_internal", bomAware: true},
	    cesu8:  { type: "_internal", bomAware: true},
	    unicode11utf8: "utf8",

	    ucs2:   { type: "_internal", bomAware: true},
	    utf16le: "ucs2",

	    binary: { type: "_internal" },
	    base64: { type: "_internal" },
	    hex:    { type: "_internal" },

	    // Codec.
	    _internal: InternalCodec,
	};

	//------------------------------------------------------------------------------

	function InternalCodec(codecOptions, iconv) {
	    this.enc = codecOptions.encodingName;
	    this.bomAware = codecOptions.bomAware;

	    if (this.enc === "base64")
	        this.encoder = InternalEncoderBase64;
	    else if (this.enc === "cesu8") {
	        this.enc = "utf8"; // Use utf8 for decoding.
	        this.encoder = InternalEncoderCesu8;

	        // Add decoder for versions of Node not supporting CESU-8
	        if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== '') {
	            this.decoder = InternalDecoderCesu8;
	            this.defaultCharUnicode = iconv.defaultCharUnicode;
	        }
	    }
	}

	InternalCodec.prototype.encoder = InternalEncoder;
	InternalCodec.prototype.decoder = InternalDecoder;

	//------------------------------------------------------------------------------

	// We use node.js internal decoder. Its signature is the same as ours.
	var StringDecoder = require$$1$1.StringDecoder;

	if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
	    StringDecoder.prototype.end = function() {};


	function InternalDecoder(options, codec) {
	    StringDecoder.call(this, codec.enc);
	}

	InternalDecoder.prototype = StringDecoder.prototype;


	//------------------------------------------------------------------------------
	// Encoder is mostly trivial

	function InternalEncoder(options, codec) {
	    this.enc = codec.enc;
	}

	InternalEncoder.prototype.write = function(str) {
	    return Buffer.from(str, this.enc);
	};

	InternalEncoder.prototype.end = function() {
	};


	//------------------------------------------------------------------------------
	// Except base64 encoder, which must keep its state.

	function InternalEncoderBase64(options, codec) {
	    this.prevStr = '';
	}

	InternalEncoderBase64.prototype.write = function(str) {
	    str = this.prevStr + str;
	    var completeQuads = str.length - (str.length % 4);
	    this.prevStr = str.slice(completeQuads);
	    str = str.slice(0, completeQuads);

	    return Buffer.from(str, "base64");
	};

	InternalEncoderBase64.prototype.end = function() {
	    return Buffer.from(this.prevStr, "base64");
	};


	//------------------------------------------------------------------------------
	// CESU-8 encoder is also special.

	function InternalEncoderCesu8(options, codec) {
	}

	InternalEncoderCesu8.prototype.write = function(str) {
	    var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
	    for (var i = 0; i < str.length; i++) {
	        var charCode = str.charCodeAt(i);
	        // Naive implementation, but it works because CESU-8 is especially easy
	        // to convert from UTF-16 (which all JS strings are encoded in).
	        if (charCode < 0x80)
	            buf[bufIdx++] = charCode;
	        else if (charCode < 0x800) {
	            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
	            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
	        }
	        else { // charCode will always be < 0x10000 in javascript.
	            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
	            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
	            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
	        }
	    }
	    return buf.slice(0, bufIdx);
	};

	InternalEncoderCesu8.prototype.end = function() {
	};

	//------------------------------------------------------------------------------
	// CESU-8 decoder is not implemented in Node v4.0+

	function InternalDecoderCesu8(options, codec) {
	    this.acc = 0;
	    this.contBytes = 0;
	    this.accBytes = 0;
	    this.defaultCharUnicode = codec.defaultCharUnicode;
	}

	InternalDecoderCesu8.prototype.write = function(buf) {
	    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, 
	        res = '';
	    for (var i = 0; i < buf.length; i++) {
	        var curByte = buf[i];
	        if ((curByte & 0xC0) !== 0x80) { // Leading byte
	            if (contBytes > 0) { // Previous code is invalid
	                res += this.defaultCharUnicode;
	                contBytes = 0;
	            }

	            if (curByte < 0x80) { // Single-byte code
	                res += String.fromCharCode(curByte);
	            } else if (curByte < 0xE0) { // Two-byte code
	                acc = curByte & 0x1F;
	                contBytes = 1; accBytes = 1;
	            } else if (curByte < 0xF0) { // Three-byte code
	                acc = curByte & 0x0F;
	                contBytes = 2; accBytes = 1;
	            } else { // Four or more are not supported for CESU-8.
	                res += this.defaultCharUnicode;
	            }
	        } else { // Continuation byte
	            if (contBytes > 0) { // We're waiting for it.
	                acc = (acc << 6) | (curByte & 0x3f);
	                contBytes--; accBytes++;
	                if (contBytes === 0) {
	                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
	                    if (accBytes === 2 && acc < 0x80 && acc > 0)
	                        res += this.defaultCharUnicode;
	                    else if (accBytes === 3 && acc < 0x800)
	                        res += this.defaultCharUnicode;
	                    else
	                        // Actually add character.
	                        res += String.fromCharCode(acc);
	                }
	            } else { // Unexpected continuation byte
	                res += this.defaultCharUnicode;
	            }
	        }
	    }
	    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;
	    return res;
	};

	InternalDecoderCesu8.prototype.end = function() {
	    var res = 0;
	    if (this.contBytes > 0)
	        res += this.defaultCharUnicode;
	    return res;
	};
	return internal;
}

var utf16 = {};

var hasRequiredUtf16;

function requireUtf16 () {
	if (hasRequiredUtf16) return utf16;
	hasRequiredUtf16 = 1;
	var Buffer = requireSafer().Buffer;

	// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

	// == UTF16-BE codec. ==========================================================

	utf16.utf16be = Utf16BECodec;
	function Utf16BECodec() {
	}

	Utf16BECodec.prototype.encoder = Utf16BEEncoder;
	Utf16BECodec.prototype.decoder = Utf16BEDecoder;
	Utf16BECodec.prototype.bomAware = true;


	// -- Encoding

	function Utf16BEEncoder() {
	}

	Utf16BEEncoder.prototype.write = function(str) {
	    var buf = Buffer.from(str, 'ucs2');
	    for (var i = 0; i < buf.length; i += 2) {
	        var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;
	    }
	    return buf;
	};

	Utf16BEEncoder.prototype.end = function() {
	};


	// -- Decoding

	function Utf16BEDecoder() {
	    this.overflowByte = -1;
	}

	Utf16BEDecoder.prototype.write = function(buf) {
	    if (buf.length == 0)
	        return '';

	    var buf2 = Buffer.alloc(buf.length + 1),
	        i = 0, j = 0;

	    if (this.overflowByte !== -1) {
	        buf2[0] = buf[0];
	        buf2[1] = this.overflowByte;
	        i = 1; j = 2;
	    }

	    for (; i < buf.length-1; i += 2, j+= 2) {
	        buf2[j] = buf[i+1];
	        buf2[j+1] = buf[i];
	    }

	    this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;

	    return buf2.slice(0, j).toString('ucs2');
	};

	Utf16BEDecoder.prototype.end = function() {
	};


	// == UTF-16 codec =============================================================
	// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
	// Defaults to UTF-16LE, as it's prevalent and default in Node.
	// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
	// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

	// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

	utf16.utf16 = Utf16Codec;
	function Utf16Codec(codecOptions, iconv) {
	    this.iconv = iconv;
	}

	Utf16Codec.prototype.encoder = Utf16Encoder;
	Utf16Codec.prototype.decoder = Utf16Decoder;


	// -- Encoding (pass-through)

	function Utf16Encoder(options, codec) {
	    options = options || {};
	    if (options.addBOM === undefined)
	        options.addBOM = true;
	    this.encoder = codec.iconv.getEncoder('utf-16le', options);
	}

	Utf16Encoder.prototype.write = function(str) {
	    return this.encoder.write(str);
	};

	Utf16Encoder.prototype.end = function() {
	    return this.encoder.end();
	};


	// -- Decoding

	function Utf16Decoder(options, codec) {
	    this.decoder = null;
	    this.initialBytes = [];
	    this.initialBytesLen = 0;

	    this.options = options || {};
	    this.iconv = codec.iconv;
	}

	Utf16Decoder.prototype.write = function(buf) {
	    if (!this.decoder) {
	        // Codec is not chosen yet. Accumulate initial bytes.
	        this.initialBytes.push(buf);
	        this.initialBytesLen += buf.length;
	        
	        if (this.initialBytesLen < 16) // We need more bytes to use space heuristic (see below)
	            return '';

	        // We have enough bytes -> detect endianness.
	        var buf = Buffer.concat(this.initialBytes),
	            encoding = detectEncoding(buf, this.options.defaultEncoding);
	        this.decoder = this.iconv.getDecoder(encoding, this.options);
	        this.initialBytes.length = this.initialBytesLen = 0;
	    }

	    return this.decoder.write(buf);
	};

	Utf16Decoder.prototype.end = function() {
	    if (!this.decoder) {
	        var buf = Buffer.concat(this.initialBytes),
	            encoding = detectEncoding(buf, this.options.defaultEncoding);
	        this.decoder = this.iconv.getDecoder(encoding, this.options);

	        var res = this.decoder.write(buf),
	            trail = this.decoder.end();

	        return trail ? (res + trail) : res;
	    }
	    return this.decoder.end();
	};

	function detectEncoding(buf, defaultEncoding) {
	    var enc = defaultEncoding || 'utf-16le';

	    if (buf.length >= 2) {
	        // Check BOM.
	        if (buf[0] == 0xFE && buf[1] == 0xFF) // UTF-16BE BOM
	            enc = 'utf-16be';
	        else if (buf[0] == 0xFF && buf[1] == 0xFE) // UTF-16LE BOM
	            enc = 'utf-16le';
	        else {
	            // No BOM found. Try to deduce encoding from initial content.
	            // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
	            // So, we count ASCII as if it was LE or BE, and decide from that.
	            var asciiCharsLE = 0, asciiCharsBE = 0, // Counts of chars in both positions
	                _len = Math.min(buf.length - (buf.length % 2), 64); // Len is always even.

	            for (var i = 0; i < _len; i += 2) {
	                if (buf[i] === 0 && buf[i+1] !== 0) asciiCharsBE++;
	                if (buf[i] !== 0 && buf[i+1] === 0) asciiCharsLE++;
	            }

	            if (asciiCharsBE > asciiCharsLE)
	                enc = 'utf-16be';
	            else if (asciiCharsBE < asciiCharsLE)
	                enc = 'utf-16le';
	        }
	    }

	    return enc;
	}
	return utf16;
}

var utf7 = {};

var hasRequiredUtf7;

function requireUtf7 () {
	if (hasRequiredUtf7) return utf7;
	hasRequiredUtf7 = 1;
	var Buffer = requireSafer().Buffer;

	// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
	// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

	utf7.utf7 = Utf7Codec;
	utf7.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
	function Utf7Codec(codecOptions, iconv) {
	    this.iconv = iconv;
	}
	Utf7Codec.prototype.encoder = Utf7Encoder;
	Utf7Codec.prototype.decoder = Utf7Decoder;
	Utf7Codec.prototype.bomAware = true;


	// -- Encoding

	var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

	function Utf7Encoder(options, codec) {
	    this.iconv = codec.iconv;
	}

	Utf7Encoder.prototype.write = function(str) {
	    // Naive implementation.
	    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
	    return Buffer.from(str.replace(nonDirectChars, function(chunk) {
	        return "+" + (chunk === '+' ? '' : 
	            this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) 
	            + "-";
	    }.bind(this)));
	};

	Utf7Encoder.prototype.end = function() {
	};


	// -- Decoding

	function Utf7Decoder(options, codec) {
	    this.iconv = codec.iconv;
	    this.inBase64 = false;
	    this.base64Accum = '';
	}

	var base64Regex = /[A-Za-z0-9\/+]/;
	var base64Chars = [];
	for (var i = 0; i < 256; i++)
	    base64Chars[i] = base64Regex.test(String.fromCharCode(i));

	var plusChar = '+'.charCodeAt(0), 
	    minusChar = '-'.charCodeAt(0),
	    andChar = '&'.charCodeAt(0);

	Utf7Decoder.prototype.write = function(buf) {
	    var res = "", lastI = 0,
	        inBase64 = this.inBase64,
	        base64Accum = this.base64Accum;

	    // The decoder is more involved as we must handle chunks in stream.

	    for (var i = 0; i < buf.length; i++) {
	        if (!inBase64) { // We're in direct mode.
	            // Write direct chars until '+'
	            if (buf[i] == plusChar) {
	                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
	                lastI = i+1;
	                inBase64 = true;
	            }
	        } else { // We decode base64.
	            if (!base64Chars[buf[i]]) { // Base64 ended.
	                if (i == lastI && buf[i] == minusChar) {// "+-" -> "+"
	                    res += "+";
	                } else {
	                    var b64str = base64Accum + buf.slice(lastI, i).toString();
	                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
	                }

	                if (buf[i] != minusChar) // Minus is absorbed after base64.
	                    i--;

	                lastI = i+1;
	                inBase64 = false;
	                base64Accum = '';
	            }
	        }
	    }

	    if (!inBase64) {
	        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
	    } else {
	        var b64str = base64Accum + buf.slice(lastI).toString();

	        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
	        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
	        b64str = b64str.slice(0, canBeDecoded);

	        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
	    }

	    this.inBase64 = inBase64;
	    this.base64Accum = base64Accum;

	    return res;
	};

	Utf7Decoder.prototype.end = function() {
	    var res = "";
	    if (this.inBase64 && this.base64Accum.length > 0)
	        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

	    this.inBase64 = false;
	    this.base64Accum = '';
	    return res;
	};


	// UTF-7-IMAP codec.
	// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
	// Differences:
	//  * Base64 part is started by "&" instead of "+"
	//  * Direct characters are 0x20-0x7E, except "&" (0x26)
	//  * In Base64, "," is used instead of "/"
	//  * Base64 must not be used to represent direct characters.
	//  * No implicit shift back from Base64 (should always end with '-')
	//  * String must end in non-shifted position.
	//  * "-&" while in base64 is not allowed.


	utf7.utf7imap = Utf7IMAPCodec;
	function Utf7IMAPCodec(codecOptions, iconv) {
	    this.iconv = iconv;
	}
	Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
	Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
	Utf7IMAPCodec.prototype.bomAware = true;


	// -- Encoding

	function Utf7IMAPEncoder(options, codec) {
	    this.iconv = codec.iconv;
	    this.inBase64 = false;
	    this.base64Accum = Buffer.alloc(6);
	    this.base64AccumIdx = 0;
	}

	Utf7IMAPEncoder.prototype.write = function(str) {
	    var inBase64 = this.inBase64,
	        base64Accum = this.base64Accum,
	        base64AccumIdx = this.base64AccumIdx,
	        buf = Buffer.alloc(str.length*5 + 10), bufIdx = 0;

	    for (var i = 0; i < str.length; i++) {
	        var uChar = str.charCodeAt(i);
	        if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
	            if (inBase64) {
	                if (base64AccumIdx > 0) {
	                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
	                    base64AccumIdx = 0;
	                }

	                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
	                inBase64 = false;
	            }

	            if (!inBase64) {
	                buf[bufIdx++] = uChar; // Write direct character

	                if (uChar === andChar)  // Ampersand -> '&-'
	                    buf[bufIdx++] = minusChar;
	            }

	        } else { // Non-direct character
	            if (!inBase64) {
	                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
	                inBase64 = true;
	            }
	            if (inBase64) {
	                base64Accum[base64AccumIdx++] = uChar >> 8;
	                base64Accum[base64AccumIdx++] = uChar & 0xFF;

	                if (base64AccumIdx == base64Accum.length) {
	                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
	                    base64AccumIdx = 0;
	                }
	            }
	        }
	    }

	    this.inBase64 = inBase64;
	    this.base64AccumIdx = base64AccumIdx;

	    return buf.slice(0, bufIdx);
	};

	Utf7IMAPEncoder.prototype.end = function() {
	    var buf = Buffer.alloc(10), bufIdx = 0;
	    if (this.inBase64) {
	        if (this.base64AccumIdx > 0) {
	            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
	            this.base64AccumIdx = 0;
	        }

	        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
	        this.inBase64 = false;
	    }

	    return buf.slice(0, bufIdx);
	};


	// -- Decoding

	function Utf7IMAPDecoder(options, codec) {
	    this.iconv = codec.iconv;
	    this.inBase64 = false;
	    this.base64Accum = '';
	}

	var base64IMAPChars = base64Chars.slice();
	base64IMAPChars[','.charCodeAt(0)] = true;

	Utf7IMAPDecoder.prototype.write = function(buf) {
	    var res = "", lastI = 0,
	        inBase64 = this.inBase64,
	        base64Accum = this.base64Accum;

	    // The decoder is more involved as we must handle chunks in stream.
	    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

	    for (var i = 0; i < buf.length; i++) {
	        if (!inBase64) { // We're in direct mode.
	            // Write direct chars until '&'
	            if (buf[i] == andChar) {
	                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
	                lastI = i+1;
	                inBase64 = true;
	            }
	        } else { // We decode base64.
	            if (!base64IMAPChars[buf[i]]) { // Base64 ended.
	                if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
	                    res += "&";
	                } else {
	                    var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
	                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
	                }

	                if (buf[i] != minusChar) // Minus may be absorbed after base64.
	                    i--;

	                lastI = i+1;
	                inBase64 = false;
	                base64Accum = '';
	            }
	        }
	    }

	    if (!inBase64) {
	        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
	    } else {
	        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');

	        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
	        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
	        b64str = b64str.slice(0, canBeDecoded);

	        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
	    }

	    this.inBase64 = inBase64;
	    this.base64Accum = base64Accum;

	    return res;
	};

	Utf7IMAPDecoder.prototype.end = function() {
	    var res = "";
	    if (this.inBase64 && this.base64Accum.length > 0)
	        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

	    this.inBase64 = false;
	    this.base64Accum = '';
	    return res;
	};
	return utf7;
}

var sbcsCodec = {};

var hasRequiredSbcsCodec;

function requireSbcsCodec () {
	if (hasRequiredSbcsCodec) return sbcsCodec;
	hasRequiredSbcsCodec = 1;
	var Buffer = requireSafer().Buffer;

	// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
	// correspond to encoded bytes (if 128 - then lower half is ASCII). 

	sbcsCodec._sbcs = SBCSCodec;
	function SBCSCodec(codecOptions, iconv) {
	    if (!codecOptions)
	        throw new Error("SBCS codec is called without the data.")
	    
	    // Prepare char buffer for decoding.
	    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))
	        throw new Error("Encoding '"+codecOptions.type+"' has incorrect 'chars' (must be of len 128 or 256)");
	    
	    if (codecOptions.chars.length === 128) {
	        var asciiString = "";
	        for (var i = 0; i < 128; i++)
	            asciiString += String.fromCharCode(i);
	        codecOptions.chars = asciiString + codecOptions.chars;
	    }

	    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');
	    
	    // Encoding buffer.
	    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));

	    for (var i = 0; i < codecOptions.chars.length; i++)
	        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;

	    this.encodeBuf = encodeBuf;
	}

	SBCSCodec.prototype.encoder = SBCSEncoder;
	SBCSCodec.prototype.decoder = SBCSDecoder;


	function SBCSEncoder(options, codec) {
	    this.encodeBuf = codec.encodeBuf;
	}

	SBCSEncoder.prototype.write = function(str) {
	    var buf = Buffer.alloc(str.length);
	    for (var i = 0; i < str.length; i++)
	        buf[i] = this.encodeBuf[str.charCodeAt(i)];
	    
	    return buf;
	};

	SBCSEncoder.prototype.end = function() {
	};


	function SBCSDecoder(options, codec) {
	    this.decodeBuf = codec.decodeBuf;
	}

	SBCSDecoder.prototype.write = function(buf) {
	    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
	    var decodeBuf = this.decodeBuf;
	    var newBuf = Buffer.alloc(buf.length*2);
	    var idx1 = 0, idx2 = 0;
	    for (var i = 0; i < buf.length; i++) {
	        idx1 = buf[i]*2; idx2 = i*2;
	        newBuf[idx2] = decodeBuf[idx1];
	        newBuf[idx2+1] = decodeBuf[idx1+1];
	    }
	    return newBuf.toString('ucs2');
	};

	SBCSDecoder.prototype.end = function() {
	};
	return sbcsCodec;
}

var sbcsData;
var hasRequiredSbcsData;

function requireSbcsData () {
	if (hasRequiredSbcsData) return sbcsData;
	hasRequiredSbcsData = 1;

	// Manually added data to be used by sbcs codec in addition to generated one.

	sbcsData = {
	    // Not supported by iconv, not sure why.
	    "10029": "maccenteuro",
	    "maccenteuro": {
	        "type": "_sbcs",
	        "chars": ""
	    },

	    "808": "cp808",
	    "ibm808": "cp808",
	    "cp808": {
	        "type": "_sbcs",
	        "chars": ""
	    },

	    "mik": {
	        "type": "_sbcs",
	        "chars": ""
	    },

	    // Aliases of generated encodings.
	    "ascii8bit": "ascii",
	    "usascii": "ascii",
	    "ansix34": "ascii",
	    "ansix341968": "ascii",
	    "ansix341986": "ascii",
	    "csascii": "ascii",
	    "cp367": "ascii",
	    "ibm367": "ascii",
	    "isoir6": "ascii",
	    "iso646us": "ascii",
	    "iso646irv": "ascii",
	    "us": "ascii",

	    "latin1": "iso88591",
	    "latin2": "iso88592",
	    "latin3": "iso88593",
	    "latin4": "iso88594",
	    "latin5": "iso88599",
	    "latin6": "iso885910",
	    "latin7": "iso885913",
	    "latin8": "iso885914",
	    "latin9": "iso885915",
	    "latin10": "iso885916",

	    "csisolatin1": "iso88591",
	    "csisolatin2": "iso88592",
	    "csisolatin3": "iso88593",
	    "csisolatin4": "iso88594",
	    "csisolatincyrillic": "iso88595",
	    "csisolatinarabic": "iso88596",
	    "csisolatingreek" : "iso88597",
	    "csisolatinhebrew": "iso88598",
	    "csisolatin5": "iso88599",
	    "csisolatin6": "iso885910",

	    "l1": "iso88591",
	    "l2": "iso88592",
	    "l3": "iso88593",
	    "l4": "iso88594",
	    "l5": "iso88599",
	    "l6": "iso885910",
	    "l7": "iso885913",
	    "l8": "iso885914",
	    "l9": "iso885915",
	    "l10": "iso885916",

	    "isoir14": "iso646jp",
	    "isoir57": "iso646cn",
	    "isoir100": "iso88591",
	    "isoir101": "iso88592",
	    "isoir109": "iso88593",
	    "isoir110": "iso88594",
	    "isoir144": "iso88595",
	    "isoir127": "iso88596",
	    "isoir126": "iso88597",
	    "isoir138": "iso88598",
	    "isoir148": "iso88599",
	    "isoir157": "iso885910",
	    "isoir166": "tis620",
	    "isoir179": "iso885913",
	    "isoir199": "iso885914",
	    "isoir203": "iso885915",
	    "isoir226": "iso885916",

	    "cp819": "iso88591",
	    "ibm819": "iso88591",

	    "cyrillic": "iso88595",

	    "arabic": "iso88596",
	    "arabic8": "iso88596",
	    "ecma114": "iso88596",
	    "asmo708": "iso88596",

	    "greek" : "iso88597",
	    "greek8" : "iso88597",
	    "ecma118" : "iso88597",
	    "elot928" : "iso88597",

	    "hebrew": "iso88598",
	    "hebrew8": "iso88598",

	    "turkish": "iso88599",
	    "turkish8": "iso88599",

	    "thai": "iso885911",
	    "thai8": "iso885911",

	    "celtic": "iso885914",
	    "celtic8": "iso885914",
	    "isoceltic": "iso885914",

	    "tis6200": "tis620",
	    "tis62025291": "tis620",
	    "tis62025330": "tis620",

	    "10000": "macroman",
	    "10006": "macgreek",
	    "10007": "maccyrillic",
	    "10079": "maciceland",
	    "10081": "macturkish",

	    "cspc8codepage437": "cp437",
	    "cspc775baltic": "cp775",
	    "cspc850multilingual": "cp850",
	    "cspcp852": "cp852",
	    "cspc862latinhebrew": "cp862",
	    "cpgr": "cp869",

	    "msee": "cp1250",
	    "mscyrl": "cp1251",
	    "msansi": "cp1252",
	    "msgreek": "cp1253",
	    "msturk": "cp1254",
	    "mshebr": "cp1255",
	    "msarab": "cp1256",
	    "winbaltrim": "cp1257",

	    "cp20866": "koi8r",
	    "20866": "koi8r",
	    "ibm878": "koi8r",
	    "cskoi8r": "koi8r",

	    "cp21866": "koi8u",
	    "21866": "koi8u",
	    "ibm1168": "koi8u",

	    "strk10482002": "rk1048",

	    "tcvn5712": "tcvn",
	    "tcvn57121": "tcvn",

	    "gb198880": "iso646cn",
	    "cn": "iso646cn",

	    "csiso14jisc6220ro": "iso646jp",
	    "jisc62201969ro": "iso646jp",
	    "jp": "iso646jp",

	    "cshproman8": "hproman8",
	    "r8": "hproman8",
	    "roman8": "hproman8",
	    "xroman8": "hproman8",
	    "ibm1051": "hproman8",

	    "mac": "macintosh",
	    "csmacintosh": "macintosh",
	};
	return sbcsData;
}

var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;

function requireSbcsDataGenerated () {
	if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
	hasRequiredSbcsDataGenerated = 1;

	// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
	sbcsDataGenerated = {
	  "437": "cp437",
	  "737": "cp737",
	  "775": "cp775",
	  "850": "cp850",
	  "852": "cp852",
	  "855": "cp855",
	  "856": "cp856",
	  "857": "cp857",
	  "858": "cp858",
	  "860": "cp860",
	  "861": "cp861",
	  "862": "cp862",
	  "863": "cp863",
	  "864": "cp864",
	  "865": "cp865",
	  "866": "cp866",
	  "869": "cp869",
	  "874": "windows874",
	  "922": "cp922",
	  "1046": "cp1046",
	  "1124": "cp1124",
	  "1125": "cp1125",
	  "1129": "cp1129",
	  "1133": "cp1133",
	  "1161": "cp1161",
	  "1162": "cp1162",
	  "1163": "cp1163",
	  "1250": "windows1250",
	  "1251": "windows1251",
	  "1252": "windows1252",
	  "1253": "windows1253",
	  "1254": "windows1254",
	  "1255": "windows1255",
	  "1256": "windows1256",
	  "1257": "windows1257",
	  "1258": "windows1258",
	  "28591": "iso88591",
	  "28592": "iso88592",
	  "28593": "iso88593",
	  "28594": "iso88594",
	  "28595": "iso88595",
	  "28596": "iso88596",
	  "28597": "iso88597",
	  "28598": "iso88598",
	  "28599": "iso88599",
	  "28600": "iso885910",
	  "28601": "iso885911",
	  "28603": "iso885913",
	  "28604": "iso885914",
	  "28605": "iso885915",
	  "28606": "iso885916",
	  "windows874": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win874": "windows874",
	  "cp874": "windows874",
	  "windows1250": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1250": "windows1250",
	  "cp1250": "windows1250",
	  "windows1251": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1251": "windows1251",
	  "cp1251": "windows1251",
	  "windows1252": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1252": "windows1252",
	  "cp1252": "windows1252",
	  "windows1253": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1253": "windows1253",
	  "cp1253": "windows1253",
	  "windows1254": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1254": "windows1254",
	  "cp1254": "windows1254",
	  "windows1255": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1255": "windows1255",
	  "cp1255": "windows1255",
	  "windows1256": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1256": "windows1256",
	  "cp1256": "windows1256",
	  "windows1257": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1257": "windows1257",
	  "cp1257": "windows1257",
	  "windows1258": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1258": "windows1258",
	  "cp1258": "windows1258",
	  "iso88591": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28591": "iso88591",
	  "iso88592": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28592": "iso88592",
	  "iso88593": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28593": "iso88593",
	  "iso88594": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28594": "iso88594",
	  "iso88595": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28595": "iso88595",
	  "iso88596": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28596": "iso88596",
	  "iso88597": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28597": "iso88597",
	  "iso88598": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28598": "iso88598",
	  "iso88599": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28599": "iso88599",
	  "iso885910": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28600": "iso885910",
	  "iso885911": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28601": "iso885911",
	  "iso885913": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28603": "iso885913",
	  "iso885914": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28604": "iso885914",
	  "iso885915": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28605": "iso885915",
	  "iso885916": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28606": "iso885916",
	  "cp437": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm437": "cp437",
	  "csibm437": "cp437",
	  "cp737": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm737": "cp737",
	  "csibm737": "cp737",
	  "cp775": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm775": "cp775",
	  "csibm775": "cp775",
	  "cp850": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm850": "cp850",
	  "csibm850": "cp850",
	  "cp852": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm852": "cp852",
	  "csibm852": "cp852",
	  "cp855": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm855": "cp855",
	  "csibm855": "cp855",
	  "cp856": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm856": "cp856",
	  "csibm856": "cp856",
	  "cp857": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm857": "cp857",
	  "csibm857": "cp857",
	  "cp858": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm858": "cp858",
	  "csibm858": "cp858",
	  "cp860": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm860": "cp860",
	  "csibm860": "cp860",
	  "cp861": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm861": "cp861",
	  "csibm861": "cp861",
	  "cp862": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm862": "cp862",
	  "csibm862": "cp862",
	  "cp863": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm863": "cp863",
	  "csibm863": "cp863",
	  "cp864": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	  },
	  "ibm864": "cp864",
	  "csibm864": "cp864",
	  "cp865": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm865": "cp865",
	  "csibm865": "cp865",
	  "cp866": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm866": "cp866",
	  "csibm866": "cp866",
	  "cp869": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm869": "cp869",
	  "csibm869": "cp869",
	  "cp922": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm922": "cp922",
	  "csibm922": "cp922",
	  "cp1046": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1046": "cp1046",
	  "csibm1046": "cp1046",
	  "cp1124": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1124": "cp1124",
	  "csibm1124": "cp1124",
	  "cp1125": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1125": "cp1125",
	  "csibm1125": "cp1125",
	  "cp1129": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1129": "cp1129",
	  "csibm1129": "cp1129",
	  "cp1133": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1133": "cp1133",
	  "csibm1133": "cp1133",
	  "cp1161": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1161": "cp1161",
	  "csibm1161": "cp1161",
	  "cp1162": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1162": "cp1162",
	  "csibm1162": "cp1162",
	  "cp1163": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1163": "cp1163",
	  "csibm1163": "cp1163",
	  "maccroatian": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "maccyrillic": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macgreek": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "maciceland": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macroman": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macromania": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macthai": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macturkish": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macukraine": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8r": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8u": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8ru": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8t": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "armscii8": {
	    "type": "_sbcs",
	    "chars": ")(.,-"
	  },
	  "rk1048": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "tcvn": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	  },
	  "georgianacademy": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "georgianps": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "pt154": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "viscii": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	  },
	  "iso646cn": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
	  },
	  "iso646jp": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
	  },
	  "hproman8": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macintosh": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ascii": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "tis620": {
	    "type": "_sbcs",
	    "chars": ""
	  }
	};
	return sbcsDataGenerated;
}

var dbcsCodec = {};

var hasRequiredDbcsCodec;

function requireDbcsCodec () {
	if (hasRequiredDbcsCodec) return dbcsCodec;
	hasRequiredDbcsCodec = 1;
	var Buffer = requireSafer().Buffer;

	// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
	// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
	// To save memory and loading time, we read table files only when requested.

	dbcsCodec._dbcs = DBCSCodec;

	var UNASSIGNED = -1,
	    GB18030_CODE = -2,
	    SEQ_START  = -10,
	    NODE_START = -1000,
	    UNASSIGNED_NODE = new Array(0x100),
	    DEF_CHAR = -1;

	for (var i = 0; i < 0x100; i++)
	    UNASSIGNED_NODE[i] = UNASSIGNED;


	// Class DBCSCodec reads and initializes mapping tables.
	function DBCSCodec(codecOptions, iconv) {
	    this.encodingName = codecOptions.encodingName;
	    if (!codecOptions)
	        throw new Error("DBCS codec is called without the data.")
	    if (!codecOptions.table)
	        throw new Error("Encoding '" + this.encodingName + "' has no data.");

	    // Load tables.
	    var mappingTable = codecOptions.table();


	    // Decode tables: MBCS -> Unicode.

	    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
	    // Trie root is decodeTables[0].
	    // Values: >=  0 -> unicode character code. can be > 0xFFFF
	    //         == UNASSIGNED -> unknown/unassigned sequence.
	    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
	    //         <= NODE_START -> index of the next node in our trie to process next byte.
	    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
	    this.decodeTables = [];
	    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

	    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
	    this.decodeTableSeq = [];

	    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
	    for (var i = 0; i < mappingTable.length; i++)
	        this._addDecodeChunk(mappingTable[i]);

	    this.defaultCharUnicode = iconv.defaultCharUnicode;

	    
	    // Encode tables: Unicode -> DBCS.

	    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
	    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
	    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
	    //         == UNASSIGNED -> no conversion found. Output a default char.
	    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
	    this.encodeTable = [];
	    
	    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
	    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
	    // means end of sequence (needed when one sequence is a strict subsequence of another).
	    // Objects are kept separately from encodeTable to increase performance.
	    this.encodeTableSeq = [];

	    // Some chars can be decoded, but need not be encoded.
	    var skipEncodeChars = {};
	    if (codecOptions.encodeSkipVals)
	        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
	            var val = codecOptions.encodeSkipVals[i];
	            if (typeof val === 'number')
	                skipEncodeChars[val] = true;
	            else
	                for (var j = val.from; j <= val.to; j++)
	                    skipEncodeChars[j] = true;
	        }
	        
	    // Use decode trie to recursively fill out encode tables.
	    this._fillEncodeTable(0, 0, skipEncodeChars);

	    // Add more encoding pairs when needed.
	    if (codecOptions.encodeAdd) {
	        for (var uChar in codecOptions.encodeAdd)
	            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
	                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
	    }

	    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
	    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
	    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);


	    // Load & create GB18030 tables when needed.
	    if (typeof codecOptions.gb18030 === 'function') {
	        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

	        // Add GB18030 decode tables.
	        var thirdByteNodeIdx = this.decodeTables.length;
	        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);

	        var fourthByteNodeIdx = this.decodeTables.length;
	        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);

	        for (var i = 0x81; i <= 0xFE; i++) {
	            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
	            var secondByteNode = this.decodeTables[secondByteNodeIdx];
	            for (var j = 0x30; j <= 0x39; j++)
	                secondByteNode[j] = NODE_START - thirdByteNodeIdx;
	        }
	        for (var i = 0x81; i <= 0xFE; i++)
	            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
	        for (var i = 0x30; i <= 0x39; i++)
	            fourthByteNode[i] = GB18030_CODE;
	    }        
	}

	DBCSCodec.prototype.encoder = DBCSEncoder;
	DBCSCodec.prototype.decoder = DBCSDecoder;

	// Decoder helpers
	DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
	    var bytes = [];
	    for (; addr > 0; addr >>= 8)
	        bytes.push(addr & 0xFF);
	    if (bytes.length == 0)
	        bytes.push(0);

	    var node = this.decodeTables[0];
	    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
	        var val = node[bytes[i]];

	        if (val == UNASSIGNED) { // Create new node.
	            node[bytes[i]] = NODE_START - this.decodeTables.length;
	            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
	        }
	        else if (val <= NODE_START) { // Existing node.
	            node = this.decodeTables[NODE_START - val];
	        }
	        else
	            throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
	    }
	    return node;
	};


	DBCSCodec.prototype._addDecodeChunk = function(chunk) {
	    // First element of chunk is the hex mbcs code where we start.
	    var curAddr = parseInt(chunk[0], 16);

	    // Choose the decoding node where we'll write our chars.
	    var writeTable = this._getDecodeTrieNode(curAddr);
	    curAddr = curAddr & 0xFF;

	    // Write all other elements of the chunk to the table.
	    for (var k = 1; k < chunk.length; k++) {
	        var part = chunk[k];
	        if (typeof part === "string") { // String, write as-is.
	            for (var l = 0; l < part.length;) {
	                var code = part.charCodeAt(l++);
	                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
	                    var codeTrail = part.charCodeAt(l++);
	                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)
	                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
	                    else
	                        throw new Error("Incorrect surrogate pair in "  + this.encodingName + " at chunk " + chunk[0]);
	                }
	                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
	                    var len = 0xFFF - code + 2;
	                    var seq = [];
	                    for (var m = 0; m < len; m++)
	                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

	                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
	                    this.decodeTableSeq.push(seq);
	                }
	                else
	                    writeTable[curAddr++] = code; // Basic char
	            }
	        } 
	        else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
	            var charCode = writeTable[curAddr - 1] + 1;
	            for (var l = 0; l < part; l++)
	                writeTable[curAddr++] = charCode++;
	        }
	        else
	            throw new Error("Incorrect type '" + typeof part + "' given in "  + this.encodingName + " at chunk " + chunk[0]);
	    }
	    if (curAddr > 0xFF)
	        throw new Error("Incorrect chunk in "  + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
	};

	// Encoder helpers
	DBCSCodec.prototype._getEncodeBucket = function(uCode) {
	    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
	    if (this.encodeTable[high] === undefined)
	        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
	    return this.encodeTable[high];
	};

	DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
	    var bucket = this._getEncodeBucket(uCode);
	    var low = uCode & 0xFF;
	    if (bucket[low] <= SEQ_START)
	        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
	    else if (bucket[low] == UNASSIGNED)
	        bucket[low] = dbcsCode;
	};

	DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
	    
	    // Get the root of character tree according to first character of the sequence.
	    var uCode = seq[0];
	    var bucket = this._getEncodeBucket(uCode);
	    var low = uCode & 0xFF;

	    var node;
	    if (bucket[low] <= SEQ_START) {
	        // There's already a sequence with  - use it.
	        node = this.encodeTableSeq[SEQ_START-bucket[low]];
	    }
	    else {
	        // There was no sequence object - allocate a new one.
	        node = {};
	        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
	        bucket[low] = SEQ_START - this.encodeTableSeq.length;
	        this.encodeTableSeq.push(node);
	    }

	    // Traverse the character tree, allocating new nodes as needed.
	    for (var j = 1; j < seq.length-1; j++) {
	        var oldVal = node[uCode];
	        if (typeof oldVal === 'object')
	            node = oldVal;
	        else {
	            node = node[uCode] = {};
	            if (oldVal !== undefined)
	                node[DEF_CHAR] = oldVal;
	        }
	    }

	    // Set the leaf to given dbcsCode.
	    uCode = seq[seq.length-1];
	    node[uCode] = dbcsCode;
	};

	DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
	    var node = this.decodeTables[nodeIdx];
	    for (var i = 0; i < 0x100; i++) {
	        var uCode = node[i];
	        var mbCode = prefix + i;
	        if (skipEncodeChars[mbCode])
	            continue;

	        if (uCode >= 0)
	            this._setEncodeChar(uCode, mbCode);
	        else if (uCode <= NODE_START)
	            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
	        else if (uCode <= SEQ_START)
	            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
	    }
	};



	// == Encoder ==================================================================

	function DBCSEncoder(options, codec) {
	    // Encoder state
	    this.leadSurrogate = -1;
	    this.seqObj = undefined;
	    
	    // Static data
	    this.encodeTable = codec.encodeTable;
	    this.encodeTableSeq = codec.encodeTableSeq;
	    this.defaultCharSingleByte = codec.defCharSB;
	    this.gb18030 = codec.gb18030;
	}

	DBCSEncoder.prototype.write = function(str) {
	    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
	        leadSurrogate = this.leadSurrogate,
	        seqObj = this.seqObj, nextChar = -1,
	        i = 0, j = 0;

	    while (true) {
	        // 0. Get next character.
	        if (nextChar === -1) {
	            if (i == str.length) break;
	            var uCode = str.charCodeAt(i++);
	        }
	        else {
	            var uCode = nextChar;
	            nextChar = -1;    
	        }

	        // 1. Handle surrogates.
	        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.
	            if (uCode < 0xDC00) { // We've got lead surrogate.
	                if (leadSurrogate === -1) {
	                    leadSurrogate = uCode;
	                    continue;
	                } else {
	                    leadSurrogate = uCode;
	                    // Double lead surrogate found.
	                    uCode = UNASSIGNED;
	                }
	            } else { // We've got trail surrogate.
	                if (leadSurrogate !== -1) {
	                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
	                    leadSurrogate = -1;
	                } else {
	                    // Incomplete surrogate pair - only trail surrogate found.
	                    uCode = UNASSIGNED;
	                }
	                
	            }
	        }
	        else if (leadSurrogate !== -1) {
	            // Incomplete surrogate pair - only lead surrogate found.
	            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
	            leadSurrogate = -1;
	        }

	        // 2. Convert uCode character.
	        var dbcsCode = UNASSIGNED;
	        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
	            var resCode = seqObj[uCode];
	            if (typeof resCode === 'object') { // Sequence continues.
	                seqObj = resCode;
	                continue;

	            } else if (typeof resCode == 'number') { // Sequence finished. Write it.
	                dbcsCode = resCode;

	            } else if (resCode == undefined) { // Current character is not part of the sequence.

	                // Try default character for this sequence
	                resCode = seqObj[DEF_CHAR];
	                if (resCode !== undefined) {
	                    dbcsCode = resCode; // Found. Write it.
	                    nextChar = uCode; // Current character will be written too in the next iteration.

	                }
	            }
	            seqObj = undefined;
	        }
	        else if (uCode >= 0) {  // Regular character
	            var subtable = this.encodeTable[uCode >> 8];
	            if (subtable !== undefined)
	                dbcsCode = subtable[uCode & 0xFF];
	            
	            if (dbcsCode <= SEQ_START) { // Sequence start
	                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];
	                continue;
	            }

	            if (dbcsCode == UNASSIGNED && this.gb18030) {
	                // Use GB18030 algorithm to find character(s) to write.
	                var idx = findIdx(this.gb18030.uChars, uCode);
	                if (idx != -1) {
	                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
	                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
	                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
	                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
	                    newBuf[j++] = 0x30 + dbcsCode;
	                    continue;
	                }
	            }
	        }

	        // 3. Write dbcsCode character.
	        if (dbcsCode === UNASSIGNED)
	            dbcsCode = this.defaultCharSingleByte;
	        
	        if (dbcsCode < 0x100) {
	            newBuf[j++] = dbcsCode;
	        }
	        else if (dbcsCode < 0x10000) {
	            newBuf[j++] = dbcsCode >> 8;   // high byte
	            newBuf[j++] = dbcsCode & 0xFF; // low byte
	        }
	        else {
	            newBuf[j++] = dbcsCode >> 16;
	            newBuf[j++] = (dbcsCode >> 8) & 0xFF;
	            newBuf[j++] = dbcsCode & 0xFF;
	        }
	    }

	    this.seqObj = seqObj;
	    this.leadSurrogate = leadSurrogate;
	    return newBuf.slice(0, j);
	};

	DBCSEncoder.prototype.end = function() {
	    if (this.leadSurrogate === -1 && this.seqObj === undefined)
	        return; // All clean. Most often case.

	    var newBuf = Buffer.alloc(10), j = 0;

	    if (this.seqObj) { // We're in the sequence.
	        var dbcsCode = this.seqObj[DEF_CHAR];
	        if (dbcsCode !== undefined) { // Write beginning of the sequence.
	            if (dbcsCode < 0x100) {
	                newBuf[j++] = dbcsCode;
	            }
	            else {
	                newBuf[j++] = dbcsCode >> 8;   // high byte
	                newBuf[j++] = dbcsCode & 0xFF; // low byte
	            }
	        }
	        this.seqObj = undefined;
	    }

	    if (this.leadSurrogate !== -1) {
	        // Incomplete surrogate pair - only lead surrogate found.
	        newBuf[j++] = this.defaultCharSingleByte;
	        this.leadSurrogate = -1;
	    }
	    
	    return newBuf.slice(0, j);
	};

	// Export for testing
	DBCSEncoder.prototype.findIdx = findIdx;


	// == Decoder ==================================================================

	function DBCSDecoder(options, codec) {
	    // Decoder state
	    this.nodeIdx = 0;
	    this.prevBuf = Buffer.alloc(0);

	    // Static data
	    this.decodeTables = codec.decodeTables;
	    this.decodeTableSeq = codec.decodeTableSeq;
	    this.defaultCharUnicode = codec.defaultCharUnicode;
	    this.gb18030 = codec.gb18030;
	}

	DBCSDecoder.prototype.write = function(buf) {
	    var newBuf = Buffer.alloc(buf.length*2),
	        nodeIdx = this.nodeIdx, 
	        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,
	        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.
	        uCode;

	    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.
	        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
	    
	    for (var i = 0, j = 0; i < buf.length; i++) {
	        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];

	        // Lookup in current trie node.
	        var uCode = this.decodeTables[nodeIdx][curByte];

	        if (uCode >= 0) ;
	        else if (uCode === UNASSIGNED) { // Unknown char.
	            // TODO: Callback with seq.
	            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
	            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
	            uCode = this.defaultCharUnicode.charCodeAt(0);
	        }
	        else if (uCode === GB18030_CODE) {
	            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
	            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);
	            var idx = findIdx(this.gb18030.gbChars, ptr);
	            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
	        }
	        else if (uCode <= NODE_START) { // Go to next trie node.
	            nodeIdx = NODE_START - uCode;
	            continue;
	        }
	        else if (uCode <= SEQ_START) { // Output a sequence of chars.
	            var seq = this.decodeTableSeq[SEQ_START - uCode];
	            for (var k = 0; k < seq.length - 1; k++) {
	                uCode = seq[k];
	                newBuf[j++] = uCode & 0xFF;
	                newBuf[j++] = uCode >> 8;
	            }
	            uCode = seq[seq.length-1];
	        }
	        else
	            throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

	        // Write the character to buffer, handling higher planes using surrogate pair.
	        if (uCode > 0xFFFF) { 
	            uCode -= 0x10000;
	            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
	            newBuf[j++] = uCodeLead & 0xFF;
	            newBuf[j++] = uCodeLead >> 8;

	            uCode = 0xDC00 + uCode % 0x400;
	        }
	        newBuf[j++] = uCode & 0xFF;
	        newBuf[j++] = uCode >> 8;

	        // Reset trie node.
	        nodeIdx = 0; seqStart = i+1;
	    }

	    this.nodeIdx = nodeIdx;
	    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
	    return newBuf.slice(0, j).toString('ucs2');
	};

	DBCSDecoder.prototype.end = function() {
	    var ret = '';

	    // Try to parse all remaining chars.
	    while (this.prevBuf.length > 0) {
	        // Skip 1 character in the buffer.
	        ret += this.defaultCharUnicode;
	        var buf = this.prevBuf.slice(1);

	        // Parse remaining as usual.
	        this.prevBuf = Buffer.alloc(0);
	        this.nodeIdx = 0;
	        if (buf.length > 0)
	            ret += this.write(buf);
	    }

	    this.nodeIdx = 0;
	    return ret;
	};

	// Binary search for GB18030. Returns largest i such that table[i] <= val.
	function findIdx(table, val) {
	    if (table[0] > val)
	        return -1;

	    var l = 0, r = table.length;
	    while (l < r-1) { // always table[l] <= val < table[r]
	        var mid = l + Math.floor((r-l+1)/2);
	        if (table[mid] <= val)
	            l = mid;
	        else
	            r = mid;
	    }
	    return l;
	}
	return dbcsCodec;
}

var require$$0$2 = [
	[
		"0",
		"\u0000",
		128
	],
	[
		"a1",
		"",
		62
	],
	[
		"8140",
		"",
		9,
		""
	],
	[
		"8180",
		""
	],
	[
		"81b8",
		""
	],
	[
		"81c8",
		""
	],
	[
		"81da",
		""
	],
	[
		"81f0",
		""
	],
	[
		"81fc",
		""
	],
	[
		"824f",
		"",
		9
	],
	[
		"8260",
		"",
		25
	],
	[
		"8281",
		"",
		25
	],
	[
		"829f",
		"",
		82
	],
	[
		"8340",
		"",
		62
	],
	[
		"8380",
		"",
		22
	],
	[
		"839f",
		"",
		16,
		"",
		6
	],
	[
		"83bf",
		"",
		16,
		"",
		6
	],
	[
		"8440",
		"",
		5,
		"",
		25
	],
	[
		"8470",
		"",
		5,
		"",
		7
	],
	[
		"8480",
		"",
		17
	],
	[
		"849f",
		""
	],
	[
		"8740",
		"",
		19,
		"",
		9
	],
	[
		"875f",
		""
	],
	[
		"877e",
		""
	],
	[
		"8780",
		"",
		4,
		""
	],
	[
		"889f",
		""
	],
	[
		"8940",
		""
	],
	[
		"8980",
		""
	],
	[
		"8a40",
		""
	],
	[
		"8a80",
		""
	],
	[
		"8b40",
		""
	],
	[
		"8b80",
		""
	],
	[
		"8c40",
		""
	],
	[
		"8c80",
		""
	],
	[
		"8d40",
		""
	],
	[
		"8d80",
		""
	],
	[
		"8e40",
		""
	],
	[
		"8e80",
		""
	],
	[
		"8f40",
		""
	],
	[
		"8f80",
		""
	],
	[
		"9040",
		""
	],
	[
		"9080",
		""
	],
	[
		"9140",
		""
	],
	[
		"9180",
		""
	],
	[
		"9240",
		""
	],
	[
		"9280",
		""
	],
	[
		"9340",
		""
	],
	[
		"9380",
		""
	],
	[
		"9440",
		""
	],
	[
		"9480",
		""
	],
	[
		"9540",
		""
	],
	[
		"9580",
		""
	],
	[
		"9640",
		""
	],
	[
		"9680",
		""
	],
	[
		"9740",
		""
	],
	[
		"9780",
		""
	],
	[
		"9840",
		""
	],
	[
		"989f",
		""
	],
	[
		"9940",
		""
	],
	[
		"9980",
		""
	],
	[
		"9a40",
		""
	],
	[
		"9a80",
		""
	],
	[
		"9b40",
		""
	],
	[
		"9b80",
		""
	],
	[
		"9c40",
		""
	],
	[
		"9c80",
		""
	],
	[
		"9d40",
		""
	],
	[
		"9d80",
		""
	],
	[
		"9e40",
		""
	],
	[
		"9e80",
		""
	],
	[
		"9f40",
		""
	],
	[
		"9f80",
		""
	],
	[
		"e040",
		""
	],
	[
		"e080",
		""
	],
	[
		"e140",
		""
	],
	[
		"e180",
		""
	],
	[
		"e240",
		""
	],
	[
		"e280",
		""
	],
	[
		"e340",
		""
	],
	[
		"e380",
		""
	],
	[
		"e440",
		""
	],
	[
		"e480",
		""
	],
	[
		"e540",
		""
	],
	[
		"e580",
		""
	],
	[
		"e640",
		""
	],
	[
		"e680",
		""
	],
	[
		"e740",
		""
	],
	[
		"e780",
		""
	],
	[
		"e840",
		""
	],
	[
		"e880",
		""
	],
	[
		"e940",
		""
	],
	[
		"e980",
		""
	],
	[
		"ea40",
		""
	],
	[
		"ea80",
		""
	],
	[
		"ed40",
		""
	],
	[
		"ed80",
		""
	],
	[
		"ee40",
		""
	],
	[
		"ee80",
		""
	],
	[
		"eeef",
		"",
		9,
		""
	],
	[
		"f040",
		"",
		62
	],
	[
		"f080",
		"",
		124
	],
	[
		"f140",
		"",
		62
	],
	[
		"f180",
		"",
		124
	],
	[
		"f240",
		"",
		62
	],
	[
		"f280",
		"",
		124
	],
	[
		"f340",
		"",
		62
	],
	[
		"f380",
		"",
		124
	],
	[
		"f440",
		"",
		62
	],
	[
		"f480",
		"",
		124
	],
	[
		"f540",
		"",
		62
	],
	[
		"f580",
		"",
		124
	],
	[
		"f640",
		"",
		62
	],
	[
		"f680",
		"",
		124
	],
	[
		"f740",
		"",
		62
	],
	[
		"f780",
		"",
		124
	],
	[
		"f840",
		"",
		62
	],
	[
		"f880",
		"",
		124
	],
	[
		"f940",
		""
	],
	[
		"fa40",
		"",
		9,
		"",
		9,
		""
	],
	[
		"fa80",
		""
	],
	[
		"fb40",
		""
	],
	[
		"fb80",
		""
	],
	[
		"fc40",
		""
	]
];

var require$$1 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"8ea1",
		"",
		62
	],
	[
		"a1a1",
		"",
		9,
		""
	],
	[
		"a2a1",
		""
	],
	[
		"a2ba",
		""
	],
	[
		"a2ca",
		""
	],
	[
		"a2dc",
		""
	],
	[
		"a2f2",
		""
	],
	[
		"a2fe",
		""
	],
	[
		"a3b0",
		"",
		9
	],
	[
		"a3c1",
		"",
		25
	],
	[
		"a3e1",
		"",
		25
	],
	[
		"a4a1",
		"",
		82
	],
	[
		"a5a1",
		"",
		85
	],
	[
		"a6a1",
		"",
		16,
		"",
		6
	],
	[
		"a6c1",
		"",
		16,
		"",
		6
	],
	[
		"a7a1",
		"",
		5,
		"",
		25
	],
	[
		"a7d1",
		"",
		5,
		"",
		25
	],
	[
		"a8a1",
		""
	],
	[
		"ada1",
		"",
		19,
		"",
		9
	],
	[
		"adc0",
		""
	],
	[
		"addf",
		"",
		4,
		""
	],
	[
		"b0a1",
		""
	],
	[
		"b1a1",
		""
	],
	[
		"b2a1",
		""
	],
	[
		"b3a1",
		""
	],
	[
		"b4a1",
		""
	],
	[
		"b5a1",
		""
	],
	[
		"b6a1",
		""
	],
	[
		"b7a1",
		""
	],
	[
		"b8a1",
		""
	],
	[
		"b9a1",
		""
	],
	[
		"baa1",
		""
	],
	[
		"bba1",
		""
	],
	[
		"bca1",
		""
	],
	[
		"bda1",
		""
	],
	[
		"bea1",
		""
	],
	[
		"bfa1",
		""
	],
	[
		"c0a1",
		""
	],
	[
		"c1a1",
		""
	],
	[
		"c2a1",
		""
	],
	[
		"c3a1",
		""
	],
	[
		"c4a1",
		""
	],
	[
		"c5a1",
		""
	],
	[
		"c6a1",
		""
	],
	[
		"c7a1",
		""
	],
	[
		"c8a1",
		""
	],
	[
		"c9a1",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cda1",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d1a1",
		""
	],
	[
		"d2a1",
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"daa1",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dda1",
		""
	],
	[
		"dea1",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eba1",
		""
	],
	[
		"eca1",
		""
	],
	[
		"eda1",
		""
	],
	[
		"eea1",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f9a1",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fcf1",
		"",
		9,
		""
	],
	[
		"8fa2af",
		""
	],
	[
		"8fa2c2",
		""
	],
	[
		"8fa2eb",
		""
	],
	[
		"8fa6e1",
		""
	],
	[
		"8fa6e7",
		""
	],
	[
		"8fa6e9",
		""
	],
	[
		"8fa6ec",
		""
	],
	[
		"8fa6f1",
		""
	],
	[
		"8fa7c2",
		"",
		10,
		""
	],
	[
		"8fa7f2",
		"",
		10,
		""
	],
	[
		"8fa9a1",
		""
	],
	[
		"8fa9a4",
		""
	],
	[
		"8fa9a6",
		""
	],
	[
		"8fa9a8",
		""
	],
	[
		"8fa9ab",
		""
	],
	[
		"8fa9af",
		""
	],
	[
		"8fa9c1",
		""
	],
	[
		"8faaa1",
		""
	],
	[
		"8faaba",
		""
	],
	[
		"8faba1",
		""
	],
	[
		"8fabbd",
		""
	],
	[
		"8fabc5",
		""
	],
	[
		"8fb0a1",
		""
	],
	[
		"8fb1a1",
		""
	],
	[
		"8fb2a1",
		"",
		4,
		""
	],
	[
		"8fb3a1",
		""
	],
	[
		"8fb4a1",
		""
	],
	[
		"8fb5a1",
		""
	],
	[
		"8fb6a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"8fb7a1",
		"",
		4,
		""
	],
	[
		"8fb8a1",
		""
	],
	[
		"8fb9a1",
		""
	],
	[
		"8fbaa1",
		"",
		4,
		""
	],
	[
		"8fbba1",
		""
	],
	[
		"8fbca1",
		"",
		4,
		""
	],
	[
		"8fbda1",
		"",
		4,
		""
	],
	[
		"8fbea1",
		"",
		4,
		""
	],
	[
		"8fbfa1",
		""
	],
	[
		"8fc0a1",
		""
	],
	[
		"8fc1a1",
		""
	],
	[
		"8fc2a1",
		""
	],
	[
		"8fc3a1",
		"",
		4,
		""
	],
	[
		"8fc4a1",
		""
	],
	[
		"8fc5a1",
		""
	],
	[
		"8fc6a1",
		""
	],
	[
		"8fc7a1",
		""
	],
	[
		"8fc8a1",
		""
	],
	[
		"8fc9a1",
		"",
		4,
		"",
		4,
		""
	],
	[
		"8fcaa1",
		""
	],
	[
		"8fcba1",
		""
	],
	[
		"8fcca1",
		"",
		9,
		""
	],
	[
		"8fcda1",
		"",
		5,
		""
	],
	[
		"8fcea1",
		"",
		6,
		""
	],
	[
		"8fcfa1",
		""
	],
	[
		"8fd0a1",
		""
	],
	[
		"8fd1a1",
		""
	],
	[
		"8fd2a1",
		"",
		5
	],
	[
		"8fd3a1",
		""
	],
	[
		"8fd4a1",
		"",
		4,
		""
	],
	[
		"8fd5a1",
		""
	],
	[
		"8fd6a1",
		""
	],
	[
		"8fd7a1",
		""
	],
	[
		"8fd8a1",
		""
	],
	[
		"8fd9a1",
		"",
		4,
		"",
		6,
		""
	],
	[
		"8fdaa1",
		"",
		4,
		""
	],
	[
		"8fdba1",
		"",
		6,
		""
	],
	[
		"8fdca1",
		"",
		4,
		""
	],
	[
		"8fdda1",
		"",
		4,
		""
	],
	[
		"8fdea1",
		"",
		4,
		""
	],
	[
		"8fdfa1",
		""
	],
	[
		"8fe0a1",
		""
	],
	[
		"8fe1a1",
		"",
		4,
		""
	],
	[
		"8fe2a1",
		""
	],
	[
		"8fe3a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"8fe4a1",
		"",
		4,
		""
	],
	[
		"8fe5a1",
		"",
		4,
		""
	],
	[
		"8fe6a1",
		""
	],
	[
		"8fe7a1",
		""
	],
	[
		"8fe8a1",
		"",
		4,
		""
	],
	[
		"8fe9a1",
		"",
		4
	],
	[
		"8feaa1",
		"",
		4,
		""
	],
	[
		"8feba1",
		"",
		4,
		""
	],
	[
		"8feca1",
		""
	],
	[
		"8feda1",
		"",
		4,
		"",
		4,
		""
	]
];

var require$$2$2 = [
	[
		"0",
		"\u0000",
		127,
		""
	],
	[
		"8140",
		"",
		5,
		"",
		9,
		"",
		6,
		""
	],
	[
		"8180",
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"8240",
		"",
		4,
		"",
		8,
		"",
		4,
		"",
		11
	],
	[
		"8280",
		"",
		10,
		"",
		4,
		"",
		7,
		"",
		5,
		"",
		8,
		"",
		20,
		"",
		4,
		"",
		6,
		""
	],
	[
		"8340",
		"",
		17,
		"",
		5,
		"",
		10,
		"",
		4,
		"",
		9,
		""
	],
	[
		"8380",
		"",
		5,
		"",
		13,
		"",
		28,
		"",
		4,
		"",
		4,
		"",
		5
	],
	[
		"8440",
		"",
		5,
		"",
		5,
		""
	],
	[
		"8480",
		"",
		9,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		5,
		"",
		10,
		"",
		7,
		""
	],
	[
		"8540",
		"",
		9,
		""
	],
	[
		"8580",
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		7,
		""
	],
	[
		"8640",
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"8680",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8740",
		"",
		7,
		"",
		11,
		"",
		4,
		"",
		4
	],
	[
		"8780",
		"",
		7,
		"",
		6,
		"",
		14,
		"",
		10,
		"",
		6,
		"",
		12,
		"",
		8,
		"",
		5,
		"",
		6
	],
	[
		"8840",
		"",
		9,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8880",
		"",
		4,
		"",
		6,
		"",
		8,
		"",
		6,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		7
	],
	[
		"8940",
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		16,
		""
	],
	[
		"8980",
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		17,
		"",
		10,
		"",
		13,
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"8a40",
		"",
		4,
		"",
		12,
		""
	],
	[
		"8a80",
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		11,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		9,
		"",
		5
	],
	[
		"8b40",
		"",
		8,
		"",
		17,
		"",
		6,
		"",
		13,
		""
	],
	[
		"8b80",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		22,
		"",
		11,
		"",
		25,
		"",
		7,
		"",
		6
	],
	[
		"8c40",
		"",
		7,
		""
	],
	[
		"8c80",
		"",
		8,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		4
	],
	[
		"8d40",
		"",
		5,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		9,
		"",
		4
	],
	[
		"8d80",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		7,
		"",
		10,
		"",
		10,
		"",
		12,
		"",
		21,
		""
	],
	[
		"8e40",
		"",
		21,
		"",
		12,
		"",
		6,
		"",
		12,
		""
	],
	[
		"8e80",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		14,
		"",
		4,
		"",
		4,
		"",
		6
	],
	[
		"8f40",
		"",
		5,
		"",
		11,
		"",
		8,
		""
	],
	[
		"8f80",
		"",
		6,
		"",
		14,
		"",
		5,
		"",
		5,
		"",
		4,
		""
	],
	[
		"9040",
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9080",
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		18,
		"",
		6
	],
	[
		"9140",
		"",
		6,
		"",
		6,
		"",
		18,
		"",
		4,
		""
	],
	[
		"9180",
		"",
		6,
		"",
		8,
		"",
		9,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		16,
		"",
		13,
		"",
		8,
		"",
		5,
		"",
		4,
		""
	],
	[
		"9240",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9280",
		"",
		5,
		"",
		7,
		"",
		6,
		""
	],
	[
		"9340",
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9380",
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		7,
		"",
		9,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9440",
		"",
		24,
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		8
	],
	[
		"9480",
		"",
		4,
		"",
		4,
		"",
		14,
		"",
		7,
		"",
		7,
		""
	],
	[
		"9540",
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9580",
		"",
		4,
		"",
		4,
		"",
		8,
		"",
		4,
		"",
		4,
		"",
		25,
		"",
		7,
		"",
		5,
		""
	],
	[
		"9640",
		"",
		5,
		"",
		4,
		""
	],
	[
		"9680",
		"",
		7,
		"",
		9,
		"",
		7,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		5
	],
	[
		"9740",
		"",
		7,
		"",
		8,
		"",
		7,
		"",
		9,
		""
	],
	[
		"9780",
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		9,
		"",
		4,
		"",
		11,
		"",
		7,
		"",
		16,
		""
	],
	[
		"9840",
		"",
		4,
		"",
		5,
		"",
		9,
		""
	],
	[
		"9880",
		"",
		7,
		"",
		5,
		"",
		11,
		"",
		9,
		"",
		9,
		"",
		11,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		7,
		"",
		6,
		""
	],
	[
		"9940",
		"",
		4,
		"",
		10,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		7,
		"",
		5
	],
	[
		"9980",
		"",
		114,
		"",
		6
	],
	[
		"9a40",
		"",
		11,
		"",
		7,
		"",
		13,
		""
	],
	[
		"9a80",
		"",
		4,
		"",
		7,
		"",
		7,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		6,
		"",
		4,
		"",
		4,
		""
	],
	[
		"9b40",
		"",
		4,
		""
	],
	[
		"9b80",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9c40",
		"",
		7,
		""
	],
	[
		"9c80",
		"",
		7,
		"",
		7,
		"",
		10,
		"",
		14,
		"",
		4,
		"",
		6,
		"",
		5
	],
	[
		"9d40",
		"",
		7,
		"",
		4,
		"",
		9,
		"",
		6,
		""
	],
	[
		"9d80",
		"",
		9,
		"",
		5,
		"",
		6,
		"",
		12,
		"",
		4,
		"",
		10,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		10,
		""
	],
	[
		"9e40",
		"",
		7,
		"",
		32,
		"",
		7,
		"",
		6,
		"",
		6
	],
	[
		"9e80",
		"",
		9,
		"",
		17,
		"",
		13,
		"",
		11,
		"",
		12,
		"",
		12,
		""
	],
	[
		"9f40",
		"",
		6,
		"",
		10,
		"",
		4,
		"",
		10,
		"",
		7,
		""
	],
	[
		"9f80",
		"",
		13,
		"",
		12,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		8,
		"",
		9,
		"",
		4
	],
	[
		"a040",
		"",
		9,
		"",
		5,
		"",
		9,
		"",
		11,
		"",
		19
	],
	[
		"a080",
		"",
		9,
		"",
		6,
		"",
		4,
		"",
		11,
		"",
		11,
		"",
		6,
		""
	],
	[
		"a1a1",
		"",
		7,
		""
	],
	[
		"a2a1",
		"",
		9
	],
	[
		"a2b1",
		"",
		19,
		"",
		19,
		"",
		9
	],
	[
		"a2e5",
		"",
		9
	],
	[
		"a2f1",
		"",
		11
	],
	[
		"a3a1",
		"",
		88,
		""
	],
	[
		"a4a1",
		"",
		82
	],
	[
		"a5a1",
		"",
		85
	],
	[
		"a6a1",
		"",
		16,
		"",
		6
	],
	[
		"a6c1",
		"",
		16,
		"",
		6
	],
	[
		"a6e0",
		""
	],
	[
		"a6ee",
		""
	],
	[
		"a6f4",
		""
	],
	[
		"a7a1",
		"",
		5,
		"",
		25
	],
	[
		"a7d1",
		"",
		5,
		"",
		25
	],
	[
		"a840",
		"",
		35,
		"",
		6
	],
	[
		"a880",
		"",
		7,
		""
	],
	[
		"a8a1",
		""
	],
	[
		"a8bd",
		""
	],
	[
		"a8c0",
		""
	],
	[
		"a8c5",
		"",
		36
	],
	[
		"a940",
		"",
		8,
		""
	],
	[
		"a959",
		""
	],
	[
		"a95c",
		""
	],
	[
		"a960",
		"",
		9,
		"",
		8
	],
	[
		"a980",
		"",
		4,
		""
	],
	[
		"a996",
		""
	],
	[
		"a9a4",
		"",
		75
	],
	[
		"aa40",
		"",
		5,
		"",
		5,
		"",
		8
	],
	[
		"aa80",
		"",
		7,
		"",
		10,
		""
	],
	[
		"ab40",
		"",
		11,
		"",
		4,
		"",
		5,
		"",
		4
	],
	[
		"ab80",
		"",
		6,
		"",
		4
	],
	[
		"ac40",
		"",
		10,
		"",
		8,
		"",
		5,
		"",
		4,
		"",
		11
	],
	[
		"ac80",
		"",
		6,
		"",
		12,
		"",
		4,
		""
	],
	[
		"ad40",
		"",
		10,
		"",
		7,
		"",
		15,
		"",
		12
	],
	[
		"ad80",
		"",
		9,
		"",
		8,
		"",
		6,
		""
	],
	[
		"ae40",
		"",
		6,
		"",
		7,
		"",
		4,
		""
	],
	[
		"ae80",
		"",
		7,
		"",
		6,
		"",
		4,
		""
	],
	[
		"af40",
		"",
		4,
		""
	],
	[
		"af80",
		""
	],
	[
		"b040",
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		7,
		""
	],
	[
		"b080",
		"",
		7,
		"",
		8,
		"",
		9,
		""
	],
	[
		"b140",
		"",
		4,
		"",
		7,
		"",
		10,
		""
	],
	[
		"b180",
		"",
		4,
		"",
		7,
		"",
		7,
		""
	],
	[
		"b240",
		"",
		11,
		"",
		5,
		"",
		11,
		"",
		4
	],
	[
		"b280",
		"",
		12,
		"",
		8,
		"",
		4,
		""
	],
	[
		"b340",
		"",
		5,
		""
	],
	[
		"b380",
		"",
		11,
		"",
		7,
		"",
		6,
		""
	],
	[
		"b440",
		"",
		7,
		"",
		9
	],
	[
		"b480",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"b540",
		"",
		5,
		"",
		9,
		"",
		4,
		"",
		14,
		"",
		4,
		"",
		8,
		""
	],
	[
		"b580",
		"",
		6,
		"",
		4,
		""
	],
	[
		"b640",
		"",
		6,
		"",
		11,
		"",
		10,
		"",
		4,
		"",
		5,
		""
	],
	[
		"b680",
		"",
		6,
		"",
		4,
		""
	],
	[
		"b740",
		"",
		14,
		"",
		5,
		"",
		9,
		"",
		4,
		"",
		16
	],
	[
		"b780",
		"",
		6,
		""
	],
	[
		"b840",
		"",
		4,
		"",
		10,
		"",
		10,
		"",
		9,
		"",
		5,
		""
	],
	[
		"b880",
		"",
		4,
		""
	],
	[
		"b940",
		"",
		5,
		"",
		10,
		"",
		6,
		""
	],
	[
		"b980",
		"",
		7,
		""
	],
	[
		"ba40",
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		5,
		""
	],
	[
		"ba80",
		"",
		4,
		"",
		5,
		"",
		12,
		"",
		5,
		""
	],
	[
		"bb40",
		"",
		9,
		"",
		36,
		"",
		5,
		"",
		9
	],
	[
		"bb80",
		"",
		6,
		"",
		4,
		""
	],
	[
		"bc40",
		"",
		6,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		13,
		"",
		5
	],
	[
		"bc80",
		"",
		14,
		"",
		6,
		""
	],
	[
		"bd40",
		"",
		54,
		"",
		7
	],
	[
		"bd80",
		"",
		32,
		""
	],
	[
		"be40",
		"",
		12,
		"",
		6,
		"",
		42
	],
	[
		"be80",
		"",
		32,
		""
	],
	[
		"bf40",
		"",
		62
	],
	[
		"bf80",
		"",
		4,
		"",
		4,
		"",
		21,
		""
	],
	[
		"c040",
		"",
		35,
		"",
		23,
		""
	],
	[
		"c080",
		"",
		6,
		"",
		9,
		""
	],
	[
		"c140",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"c180",
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"c240",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c280",
		"",
		13,
		"",
		5,
		"",
		11,
		""
	],
	[
		"c340",
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"c380",
		"",
		12,
		"",
		4,
		""
	],
	[
		"c440",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"c480",
		"",
		7,
		"",
		5,
		"",
		6,
		""
	],
	[
		"c540",
		"",
		14,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"c580",
		"",
		7,
		"",
		7,
		""
	],
	[
		"c640",
		""
	],
	[
		"c680",
		"",
		4,
		"",
		9,
		""
	],
	[
		"c740",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		6,
		""
	],
	[
		"c780",
		""
	],
	[
		"c840",
		"",
		4,
		"",
		5,
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		7,
		""
	],
	[
		"c880",
		"",
		6,
		"",
		4,
		"",
		4,
		""
	],
	[
		"c940",
		"",
		4,
		"",
		7,
		"",
		12,
		""
	],
	[
		"c980",
		"",
		4,
		"",
		4,
		"",
		10,
		""
	],
	[
		"ca40",
		"",
		8,
		"",
		8,
		"",
		9,
		"",
		4,
		"",
		10
	],
	[
		"ca80",
		"",
		4,
		"",
		8,
		""
	],
	[
		"cb40",
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		4,
		""
	],
	[
		"cb80",
		"",
		5,
		"",
		6,
		"",
		14,
		""
	],
	[
		"cc40",
		"",
		4,
		"",
		10,
		"",
		15,
		"",
		13,
		""
	],
	[
		"cc80",
		"",
		11,
		"",
		4,
		"",
		7,
		""
	],
	[
		"cd40",
		"",
		6,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		""
	],
	[
		"cd80",
		""
	],
	[
		"ce40",
		"",
		6,
		"",
		5,
		"",
		7,
		""
	],
	[
		"ce80",
		"",
		4,
		"",
		6,
		"",
		4,
		""
	],
	[
		"cf40",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		9
	],
	[
		"cf80",
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"d040",
		"",
		13,
		"",
		5,
		"",
		5,
		"",
		5,
		"",
		6,
		""
	],
	[
		"d080",
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"d140",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5
	],
	[
		"d180",
		"",
		4,
		"",
		4,
		"",
		4,
		""
	],
	[
		"d240",
		"",
		8,
		"",
		24,
		"",
		5,
		"",
		19,
		""
	],
	[
		"d280",
		"",
		26,
		""
	],
	[
		"d340",
		"",
		30,
		"",
		6
	],
	[
		"d380",
		"",
		4,
		"",
		5,
		"",
		21,
		""
	],
	[
		"d440",
		"",
		31,
		"",
		8,
		"",
		21
	],
	[
		"d480",
		"",
		25,
		"",
		6,
		""
	],
	[
		"d540",
		"",
		7,
		"",
		7,
		"",
		46
	],
	[
		"d580",
		"",
		32,
		""
	],
	[
		"d640",
		"",
		34,
		"",
		27
	],
	[
		"d680",
		"",
		30,
		""
	],
	[
		"d740",
		"",
		31,
		"",
		4,
		"",
		25
	],
	[
		"d780",
		"",
		24,
		""
	],
	[
		"d840",
		"",
		8,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		6,
		""
	],
	[
		"d880",
		"",
		6,
		"",
		20,
		""
	],
	[
		"d940",
		"",
		62
	],
	[
		"d980",
		"",
		32,
		""
	],
	[
		"da40",
		"",
		14,
		"",
		8,
		"",
		4,
		"",
		9,
		""
	],
	[
		"da80",
		"",
		12,
		""
	],
	[
		"db40",
		"",
		6,
		"",
		7,
		"",
		4,
		""
	],
	[
		"db80",
		"",
		4,
		"",
		5,
		"",
		11,
		""
	],
	[
		"dc40",
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		11,
		"",
		6,
		"",
		7
	],
	[
		"dc80",
		"",
		10,
		"",
		21,
		""
	],
	[
		"dd40",
		"",
		62
	],
	[
		"dd80",
		"",
		32,
		""
	],
	[
		"de40",
		"",
		32,
		""
	],
	[
		"de80",
		"",
		4,
		""
	],
	[
		"df40",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"df80",
		"",
		4,
		""
	],
	[
		"e040",
		"",
		19,
		""
	],
	[
		"e080",
		"",
		10,
		"",
		6,
		"",
		8,
		""
	],
	[
		"e140",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		""
	],
	[
		"e180",
		"",
		10,
		"",
		9,
		"",
		8,
		""
	],
	[
		"e240",
		"",
		62
	],
	[
		"e280",
		"",
		32,
		"",
		5,
		""
	],
	[
		"e340",
		"",
		45,
		"",
		16
	],
	[
		"e380",
		"",
		7,
		"",
		24,
		""
	],
	[
		"e440",
		"",
		5,
		"",
		24,
		"",
		31
	],
	[
		"e480",
		"",
		32,
		""
	],
	[
		"e540",
		"",
		51,
		"",
		10
	],
	[
		"e580",
		"",
		31,
		""
	],
	[
		"e640",
		"",
		34,
		"",
		27
	],
	[
		"e680",
		"",
		29,
		""
	],
	[
		"e740",
		"",
		7,
		"",
		54
	],
	[
		"e780",
		"",
		32,
		"",
		6,
		"",
		4,
		""
	],
	[
		"e840",
		"",
		14,
		"",
		43,
		""
	],
	[
		"e880",
		"",
		20,
		""
	],
	[
		"e940",
		"",
		7,
		"",
		42
	],
	[
		"e980",
		"",
		32,
		""
	],
	[
		"ea40",
		"",
		27,
		"",
		6,
		""
	],
	[
		"ea80",
		"",
		4,
		"",
		12,
		""
	],
	[
		"eb40",
		"",
		9,
		"",
		7,
		"",
		9,
		"",
		6,
		""
	],
	[
		"eb80",
		"",
		4,
		""
	],
	[
		"ec40",
		"",
		8,
		"",
		4,
		"",
		18,
		"",
		7
	],
	[
		"ec80",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"ed40",
		"",
		6,
		"",
		46
	],
	[
		"ed80",
		"",
		4,
		"",
		23,
		""
	],
	[
		"ee40",
		"",
		62
	],
	[
		"ee80",
		"",
		32,
		"",
		4,
		"",
		6,
		""
	],
	[
		"ef40",
		"",
		5,
		"",
		37,
		"",
		4
	],
	[
		"ef80",
		"",
		30,
		"",
		4,
		"",
		8,
		""
	],
	[
		"f040",
		"",
		4,
		"",
		28,
		"",
		26
	],
	[
		"f080",
		"",
		9,
		"",
		12,
		"",
		4,
		"",
		6,
		""
	],
	[
		"f140",
		"",
		10,
		"",
		47
	],
	[
		"f180",
		"",
		32,
		""
	],
	[
		"f240",
		"",
		62
	],
	[
		"f280",
		"",
		32,
		""
	],
	[
		"f340",
		"",
		17,
		"",
		6,
		"",
		4,
		""
	],
	[
		"f380",
		"",
		8,
		"",
		6,
		""
	],
	[
		"f440",
		"",
		5,
		"",
		10,
		"",
		10,
		"",
		7,
		"",
		5
	],
	[
		"f480",
		"",
		32,
		""
	],
	[
		"f540",
		"",
		62
	],
	[
		"f580",
		"",
		32,
		""
	],
	[
		"f640",
		"",
		62
	],
	[
		"f680",
		"",
		32,
		"",
		5,
		"",
		5,
		"",
		4,
		"",
		7,
		""
	],
	[
		"f740",
		"",
		62
	],
	[
		"f780",
		"",
		4,
		"",
		4,
		""
	],
	[
		"f840",
		"",
		62
	],
	[
		"f880",
		"",
		32
	],
	[
		"f940",
		"",
		62
	],
	[
		"f980",
		"",
		32
	],
	[
		"fa40",
		"",
		62
	],
	[
		"fa80",
		"",
		32
	],
	[
		"fb40",
		"",
		27,
		"",
		9,
		""
	],
	[
		"fb80",
		"",
		5,
		"",
		8,
		"",
		5,
		""
	],
	[
		"fc40",
		"",
		8,
		"",
		4,
		"",
		8,
		"",
		6
	],
	[
		"fc80",
		"",
		4,
		"",
		5,
		"",
		8,
		""
	],
	[
		"fd40",
		"",
		4,
		"",
		4,
		"",
		10,
		"",
		38
	],
	[
		"fd80",
		"",
		5,
		"",
		11,
		"",
		4,
		""
	],
	[
		"fe40",
		""
	]
];

var require$$3 = [
	[
		"a140",
		"",
		62
	],
	[
		"a180",
		"",
		32
	],
	[
		"a240",
		"",
		62
	],
	[
		"a280",
		"",
		32
	],
	[
		"a2ab",
		"",
		5
	],
	[
		"a2e3",
		""
	],
	[
		"a2ef",
		""
	],
	[
		"a2fd",
		""
	],
	[
		"a340",
		"",
		62
	],
	[
		"a380",
		"",
		31,
		""
	],
	[
		"a440",
		"",
		62
	],
	[
		"a480",
		"",
		32
	],
	[
		"a4f4",
		"",
		10
	],
	[
		"a540",
		"",
		62
	],
	[
		"a580",
		"",
		32
	],
	[
		"a5f7",
		"",
		7
	],
	[
		"a640",
		"",
		62
	],
	[
		"a680",
		"",
		32
	],
	[
		"a6b9",
		"",
		7
	],
	[
		"a6d9",
		"",
		6
	],
	[
		"a6ec",
		""
	],
	[
		"a6f3",
		""
	],
	[
		"a6f6",
		"",
		8
	],
	[
		"a740",
		"",
		62
	],
	[
		"a780",
		"",
		32
	],
	[
		"a7c2",
		"",
		14
	],
	[
		"a7f2",
		"",
		12
	],
	[
		"a896",
		"",
		10
	],
	[
		"a8bc",
		""
	],
	[
		"a8bf",
		""
	],
	[
		"a8c1",
		""
	],
	[
		"a8ea",
		"",
		20
	],
	[
		"a958",
		""
	],
	[
		"a95b",
		""
	],
	[
		"a95d",
		""
	],
	[
		"a989",
		"",
		11
	],
	[
		"a997",
		"",
		12
	],
	[
		"a9f0",
		"",
		14
	],
	[
		"aaa1",
		"",
		93
	],
	[
		"aba1",
		"",
		93
	],
	[
		"aca1",
		"",
		93
	],
	[
		"ada1",
		"",
		93
	],
	[
		"aea1",
		"",
		93
	],
	[
		"afa1",
		"",
		93
	],
	[
		"d7fa",
		"",
		4
	],
	[
		"f8a1",
		"",
		93
	],
	[
		"f9a1",
		"",
		93
	],
	[
		"faa1",
		"",
		93
	],
	[
		"fba1",
		"",
		93
	],
	[
		"fca1",
		"",
		93
	],
	[
		"fda1",
		"",
		93
	],
	[
		"fe50",
		""
	],
	[
		"fe80",
		"",
		6,
		"",
		93
	]
];

var uChars = [
	128,
	165,
	169,
	178,
	184,
	216,
	226,
	235,
	238,
	244,
	248,
	251,
	253,
	258,
	276,
	284,
	300,
	325,
	329,
	334,
	364,
	463,
	465,
	467,
	469,
	471,
	473,
	475,
	477,
	506,
	594,
	610,
	712,
	716,
	730,
	930,
	938,
	962,
	970,
	1026,
	1104,
	1106,
	8209,
	8215,
	8218,
	8222,
	8231,
	8241,
	8244,
	8246,
	8252,
	8365,
	8452,
	8454,
	8458,
	8471,
	8482,
	8556,
	8570,
	8596,
	8602,
	8713,
	8720,
	8722,
	8726,
	8731,
	8737,
	8740,
	8742,
	8748,
	8751,
	8760,
	8766,
	8777,
	8781,
	8787,
	8802,
	8808,
	8816,
	8854,
	8858,
	8870,
	8896,
	8979,
	9322,
	9372,
	9548,
	9588,
	9616,
	9622,
	9634,
	9652,
	9662,
	9672,
	9676,
	9680,
	9702,
	9735,
	9738,
	9793,
	9795,
	11906,
	11909,
	11913,
	11917,
	11928,
	11944,
	11947,
	11951,
	11956,
	11960,
	11964,
	11979,
	12284,
	12292,
	12312,
	12319,
	12330,
	12351,
	12436,
	12447,
	12535,
	12543,
	12586,
	12842,
	12850,
	12964,
	13200,
	13215,
	13218,
	13253,
	13263,
	13267,
	13270,
	13384,
	13428,
	13727,
	13839,
	13851,
	14617,
	14703,
	14801,
	14816,
	14964,
	15183,
	15471,
	15585,
	16471,
	16736,
	17208,
	17325,
	17330,
	17374,
	17623,
	17997,
	18018,
	18212,
	18218,
	18301,
	18318,
	18760,
	18811,
	18814,
	18820,
	18823,
	18844,
	18848,
	18872,
	19576,
	19620,
	19738,
	19887,
	40870,
	59244,
	59336,
	59367,
	59413,
	59417,
	59423,
	59431,
	59437,
	59443,
	59452,
	59460,
	59478,
	59493,
	63789,
	63866,
	63894,
	63976,
	63986,
	64016,
	64018,
	64021,
	64025,
	64034,
	64037,
	64042,
	65074,
	65093,
	65107,
	65112,
	65127,
	65132,
	65375,
	65510,
	65536
];
var gbChars = [
	0,
	36,
	38,
	45,
	50,
	81,
	89,
	95,
	96,
	100,
	103,
	104,
	105,
	109,
	126,
	133,
	148,
	172,
	175,
	179,
	208,
	306,
	307,
	308,
	309,
	310,
	311,
	312,
	313,
	341,
	428,
	443,
	544,
	545,
	558,
	741,
	742,
	749,
	750,
	805,
	819,
	820,
	7922,
	7924,
	7925,
	7927,
	7934,
	7943,
	7944,
	7945,
	7950,
	8062,
	8148,
	8149,
	8152,
	8164,
	8174,
	8236,
	8240,
	8262,
	8264,
	8374,
	8380,
	8381,
	8384,
	8388,
	8390,
	8392,
	8393,
	8394,
	8396,
	8401,
	8406,
	8416,
	8419,
	8424,
	8437,
	8439,
	8445,
	8482,
	8485,
	8496,
	8521,
	8603,
	8936,
	8946,
	9046,
	9050,
	9063,
	9066,
	9076,
	9092,
	9100,
	9108,
	9111,
	9113,
	9131,
	9162,
	9164,
	9218,
	9219,
	11329,
	11331,
	11334,
	11336,
	11346,
	11361,
	11363,
	11366,
	11370,
	11372,
	11375,
	11389,
	11682,
	11686,
	11687,
	11692,
	11694,
	11714,
	11716,
	11723,
	11725,
	11730,
	11736,
	11982,
	11989,
	12102,
	12336,
	12348,
	12350,
	12384,
	12393,
	12395,
	12397,
	12510,
	12553,
	12851,
	12962,
	12973,
	13738,
	13823,
	13919,
	13933,
	14080,
	14298,
	14585,
	14698,
	15583,
	15847,
	16318,
	16434,
	16438,
	16481,
	16729,
	17102,
	17122,
	17315,
	17320,
	17402,
	17418,
	17859,
	17909,
	17911,
	17915,
	17916,
	17936,
	17939,
	17961,
	18664,
	18703,
	18814,
	18962,
	19043,
	33469,
	33470,
	33471,
	33484,
	33485,
	33490,
	33497,
	33501,
	33505,
	33513,
	33520,
	33536,
	33550,
	37845,
	37921,
	37948,
	38029,
	38038,
	38064,
	38065,
	38066,
	38069,
	38075,
	38076,
	38078,
	39108,
	39109,
	39113,
	39114,
	39115,
	39116,
	39265,
	39394,
	189000
];
var require$$4 = {
	uChars: uChars,
	gbChars: gbChars
};

var require$$5$1 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"8141",
		"",
		4,
		"",
		6,
		""
	],
	[
		"8161",
		"",
		9,
		"",
		5,
		""
	],
	[
		"8181",
		"",
		18,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8241",
		"",
		7,
		"",
		5
	],
	[
		"8261",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8281",
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		10,
		"",
		5,
		"",
		17,
		"",
		7,
		"",
		6,
		"",
		7,
		"",
		18
	],
	[
		"8341",
		"",
		5,
		"",
		5,
		"",
		7
	],
	[
		"8361",
		"",
		18,
		""
	],
	[
		"8381",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		46,
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"8441",
		"",
		5,
		"",
		8
	],
	[
		"8461",
		"",
		18
	],
	[
		"8481",
		"",
		7,
		"",
		6,
		"",
		5,
		"",
		10,
		"",
		5,
		"",
		18,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		26,
		""
	],
	[
		"8541",
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4
	],
	[
		"8561",
		"",
		5,
		"",
		5,
		"",
		6,
		""
	],
	[
		"8581",
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		26,
		"",
		29,
		"",
		6,
		"",
		5,
		""
	],
	[
		"8641",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8661",
		"",
		6,
		"",
		10
	],
	[
		"8681",
		"",
		22,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		22,
		"",
		4,
		""
	],
	[
		"8741",
		"",
		9,
		"",
		15
	],
	[
		"8761",
		"",
		18,
		""
	],
	[
		"8781",
		"",
		5,
		"",
		7,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		26,
		"",
		6,
		"",
		4
	],
	[
		"8841",
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		4
	],
	[
		"8861",
		"",
		4,
		""
	],
	[
		"8881",
		"",
		15,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		54,
		""
	],
	[
		"8941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8961",
		"",
		10,
		"",
		5,
		""
	],
	[
		"8981",
		"",
		21,
		"",
		18,
		"",
		18,
		"",
		6,
		"",
		6,
		"",
		7,
		"",
		15
	],
	[
		"8a41",
		"",
		10,
		"",
		6,
		""
	],
	[
		"8a61",
		"",
		4,
		"",
		18,
		""
	],
	[
		"8a81",
		"",
		4,
		"",
		19,
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		5,
		"",
		26,
		""
	],
	[
		"8b41",
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"8b61",
		"",
		6,
		"",
		8
	],
	[
		"8b81",
		"",
		52,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		18
	],
	[
		"8c41",
		"",
		15,
		"",
		4
	],
	[
		"8c61",
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"8c81",
		"",
		12,
		"",
		26,
		"",
		50,
		"",
		5,
		"",
		16
	],
	[
		"8d41",
		"",
		16,
		"",
		8
	],
	[
		"8d61",
		"",
		17,
		""
	],
	[
		"8d81",
		"",
		4,
		"",
		33,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		9,
		"",
		6,
		"",
		5,
		"",
		6,
		""
	],
	[
		"8e41",
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"8e61",
		"",
		4,
		"",
		19
	],
	[
		"8e81",
		"",
		13,
		"",
		6,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		11,
		"",
		7,
		"",
		6,
		"",
		5,
		"",
		7
	],
	[
		"8f41",
		"",
		7,
		"",
		17
	],
	[
		"8f61",
		"",
		7,
		"",
		6,
		"",
		4
	],
	[
		"8f81",
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		26,
		"",
		6,
		"",
		5
	],
	[
		"9041",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9061",
		"",
		5,
		"",
		15
	],
	[
		"9081",
		"",
		12,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		11,
		"",
		33,
		""
	],
	[
		"9141",
		"",
		6,
		"",
		5
	],
	[
		"9161",
		"",
		9,
		"",
		5
	],
	[
		"9181",
		"",
		20,
		"",
		4,
		"",
		5,
		"",
		14,
		"",
		33,
		"",
		7,
		"",
		5,
		"",
		6
	],
	[
		"9241",
		"",
		7,
		"",
		4,
		""
	],
	[
		"9261",
		"",
		7,
		"",
		7,
		"",
		4
	],
	[
		"9281",
		"",
		21,
		"",
		18,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		35,
		""
	],
	[
		"9341",
		"",
		4,
		""
	],
	[
		"9361",
		"",
		6,
		"",
		8
	],
	[
		"9381",
		"",
		37,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		22,
		""
	],
	[
		"9441",
		"",
		5,
		"",
		5,
		"",
		8
	],
	[
		"9461",
		"",
		5,
		"",
		6,
		"",
		12
	],
	[
		"9481",
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		22,
		"",
		4,
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		24
	],
	[
		"9541",
		"",
		11,
		"",
		5,
		""
	],
	[
		"9561",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9581",
		"",
		6,
		"",
		35,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		13,
		"",
		14
	],
	[
		"9641",
		"",
		23,
		""
	],
	[
		"9661",
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"9681",
		"",
		10,
		"",
		5,
		"",
		13,
		"",
		33,
		"",
		6,
		"",
		44
	],
	[
		"9741",
		"",
		16,
		"",
		8
	],
	[
		"9761",
		"",
		17,
		"",
		7
	],
	[
		"9781",
		"",
		11,
		"",
		5,
		"",
		6,
		"",
		89,
		""
	],
	[
		"9841",
		"",
		16,
		"",
		5,
		""
	],
	[
		"9861",
		"",
		6,
		"",
		15
	],
	[
		"9881",
		"",
		21,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9961",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9981",
		"",
		8,
		"",
		5,
		"",
		4,
		"",
		11,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9a41",
		"",
		16
	],
	[
		"9a61",
		"",
		6,
		"",
		6,
		""
	],
	[
		"9a81",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		33,
		"",
		5,
		"",
		6,
		""
	],
	[
		"9b41",
		"",
		6,
		"",
		8
	],
	[
		"9b61",
		"",
		17,
		"",
		7
	],
	[
		"9b81",
		"",
		25,
		"",
		4,
		"",
		5,
		"",
		50,
		"",
		22,
		""
	],
	[
		"9c41",
		"",
		4,
		"",
		5,
		"",
		5
	],
	[
		"9c61",
		"",
		8,
		"",
		6,
		"",
		9
	],
	[
		"9c81",
		"",
		8,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		26,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		12
	],
	[
		"9d41",
		"",
		13,
		"",
		8
	],
	[
		"9d61",
		"",
		25
	],
	[
		"9d81",
		"",
		8,
		"",
		5,
		"",
		9,
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9e41",
		"",
		7,
		"",
		9,
		""
	],
	[
		"9e61",
		"",
		4,
		"",
		6,
		""
	],
	[
		"9e81",
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		5,
		"",
		10,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		""
	],
	[
		"9f41",
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9f61",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9f81",
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		6,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"a041",
		"",
		5,
		"",
		6,
		""
	],
	[
		"a061",
		"",
		5,
		"",
		13
	],
	[
		"a081",
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		26,
		"",
		4,
		"",
		5,
		"",
		7,
		""
	],
	[
		"a141",
		"",
		18,
		""
	],
	[
		"a161",
		"",
		6,
		"",
		5,
		""
	],
	[
		"a181",
		"",
		14,
		"",
		5,
		"",
		4,
		"",
		9,
		""
	],
	[
		"a241",
		"",
		5,
		"",
		18
	],
	[
		"a261",
		"",
		6,
		"",
		18
	],
	[
		"a281",
		"",
		7,
		"",
		6,
		"",
		7,
		""
	],
	[
		"a341",
		"",
		6,
		"",
		10,
		""
	],
	[
		"a361",
		"",
		6,
		"",
		16
	],
	[
		"a381",
		"",
		16,
		"",
		4,
		"",
		58,
		"",
		32,
		""
	],
	[
		"a441",
		"",
		5,
		""
	],
	[
		"a461",
		"",
		5,
		"",
		12
	],
	[
		"a481",
		"",
		28,
		"",
		93
	],
	[
		"a541",
		"",
		4,
		"",
		6,
		"",
		5,
		""
	],
	[
		"a561",
		"",
		17,
		"",
		5,
		""
	],
	[
		"a581",
		"",
		16,
		"",
		14,
		"",
		9
	],
	[
		"a5b0",
		"",
		9
	],
	[
		"a5c1",
		"",
		16,
		"",
		6
	],
	[
		"a5e1",
		"",
		16,
		"",
		6
	],
	[
		"a641",
		"",
		19,
		""
	],
	[
		"a661",
		"",
		5,
		"",
		5,
		"",
		6
	],
	[
		"a681",
		"",
		6,
		"",
		18,
		"",
		7
	],
	[
		"a741",
		"",
		4,
		"",
		6,
		"",
		7
	],
	[
		"a761",
		"",
		22,
		""
	],
	[
		"a781",
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		9,
		"",
		9,
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"a841",
		"",
		10,
		"",
		14
	],
	[
		"a861",
		"",
		18,
		"",
		6
	],
	[
		"a881",
		"",
		19,
		"",
		11,
		""
	],
	[
		"a8a6",
		""
	],
	[
		"a8a8",
		""
	],
	[
		"a8b1",
		"",
		27,
		"",
		25,
		"",
		14,
		""
	],
	[
		"a941",
		"",
		14,
		"",
		10
	],
	[
		"a961",
		"",
		18
	],
	[
		"a981",
		"",
		14,
		"",
		6,
		"",
		27,
		"",
		25,
		"",
		14,
		""
	],
	[
		"aa41",
		"",
		6,
		"",
		4,
		""
	],
	[
		"aa61",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"aa81",
		"",
		29,
		"",
		82
	],
	[
		"ab41",
		"",
		6,
		"",
		5,
		""
	],
	[
		"ab61",
		"",
		6,
		"",
		5,
		"",
		5
	],
	[
		"ab81",
		"",
		8,
		"",
		6,
		"",
		12,
		"",
		85
	],
	[
		"ac41",
		"",
		5,
		"",
		6,
		""
	],
	[
		"ac61",
		"",
		11,
		"",
		4
	],
	[
		"ac81",
		"",
		28,
		"",
		5,
		"",
		25
	],
	[
		"acd1",
		"",
		5,
		"",
		25
	],
	[
		"ad41",
		"",
		6,
		"",
		5,
		"",
		7
	],
	[
		"ad61",
		"",
		6,
		"",
		10,
		""
	],
	[
		"ad81",
		"",
		5,
		"",
		18,
		""
	],
	[
		"ae41",
		"",
		5,
		"",
		16
	],
	[
		"ae61",
		"",
		5,
		"",
		6,
		"",
		4
	],
	[
		"ae81",
		"",
		6,
		"",
		5,
		""
	],
	[
		"af41",
		"",
		19
	],
	[
		"af61",
		"",
		13,
		"",
		5,
		""
	],
	[
		"af81",
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"b041",
		"",
		5,
		"",
		5,
		"",
		12
	],
	[
		"b061",
		"",
		5,
		"",
		19
	],
	[
		"b081",
		"",
		13,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"b141",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b161",
		"",
		6,
		"",
		5,
		"",
		11
	],
	[
		"b181",
		"",
		14,
		"",
		6,
		""
	],
	[
		"b241",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b261",
		"",
		18,
		"",
		5,
		""
	],
	[
		"b281",
		"",
		5,
		"",
		18,
		"",
		6,
		""
	],
	[
		"b341",
		"",
		19,
		""
	],
	[
		"b361",
		"",
		5,
		"",
		5,
		"",
		5
	],
	[
		"b381",
		"",
		5,
		"",
		5,
		"",
		19,
		"",
		4,
		""
	],
	[
		"b441",
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"b461",
		"",
		6,
		"",
		10,
		""
	],
	[
		"b481",
		"",
		6,
		"",
		18,
		"",
		4,
		"",
		4,
		""
	],
	[
		"b541",
		"",
		14,
		"",
		5
	],
	[
		"b561",
		"",
		5,
		"",
		5,
		"",
		4
	],
	[
		"b581",
		"",
		6,
		"",
		5,
		"",
		11,
		""
	],
	[
		"b641",
		"",
		7,
		"",
		17
	],
	[
		"b661",
		"",
		15,
		""
	],
	[
		"b681",
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"b741",
		"",
		13,
		"",
		6,
		""
	],
	[
		"b761",
		"",
		20,
		""
	],
	[
		"b781",
		"",
		6,
		"",
		14,
		""
	],
	[
		"b841",
		"",
		7,
		"",
		17
	],
	[
		"b861",
		"",
		8,
		"",
		13
	],
	[
		"b881",
		"",
		5,
		"",
		24,
		"",
		4,
		""
	],
	[
		"b941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b961",
		"",
		14,
		"",
		6,
		""
	],
	[
		"b981",
		"",
		22,
		"",
		4,
		"",
		4,
		""
	],
	[
		"ba41",
		"",
		5,
		"",
		6,
		""
	],
	[
		"ba61",
		"",
		5,
		"",
		4,
		"",
		5
	],
	[
		"ba81",
		"",
		6,
		"",
		9,
		""
	],
	[
		"bb41",
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"bb61",
		"",
		6,
		"",
		5,
		""
	],
	[
		"bb81",
		"",
		31,
		""
	],
	[
		"bc41",
		"",
		17,
		""
	],
	[
		"bc61",
		"",
		5,
		"",
		6,
		""
	],
	[
		"bc81",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		4,
		""
	],
	[
		"bd41",
		"",
		7,
		"",
		7,
		""
	],
	[
		"bd61",
		"",
		5,
		"",
		13
	],
	[
		"bd81",
		"",
		5,
		"",
		25,
		""
	],
	[
		"be41",
		"",
		7,
		"",
		14
	],
	[
		"be61",
		"",
		7,
		"",
		7,
		""
	],
	[
		"be81",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		8,
		"",
		6,
		""
	],
	[
		"bf41",
		"",
		10,
		"",
		14
	],
	[
		"bf61",
		"",
		18,
		""
	],
	[
		"bf81",
		"",
		5,
		"",
		7,
		"",
		6,
		"",
		5,
		""
	],
	[
		"c041",
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"c061",
		"",
		25
	],
	[
		"c081",
		"",
		6,
		"",
		5,
		"",
		7,
		""
	],
	[
		"c141",
		"",
		5,
		"",
		6,
		""
	],
	[
		"c161",
		"",
		19,
		""
	],
	[
		"c181",
		"",
		31,
		""
	],
	[
		"c241",
		"",
		4,
		"",
		5,
		""
	],
	[
		"c261",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"c281",
		"",
		5,
		"",
		7,
		"",
		9,
		""
	],
	[
		"c341",
		"",
		4
	],
	[
		"c361",
		"",
		4,
		"",
		5,
		"",
		11
	],
	[
		"c381",
		"",
		5,
		"",
		7,
		"",
		5,
		""
	],
	[
		"c441",
		"",
		7,
		"",
		7,
		""
	],
	[
		"c461",
		"",
		5,
		"",
		4
	],
	[
		"c481",
		"",
		5,
		"",
		11,
		""
	],
	[
		"c541",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c561",
		"",
		6,
		"",
		5,
		"",
		4
	],
	[
		"c581",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c641",
		"",
		6,
		"",
		5
	],
	[
		"c6a1",
		""
	],
	[
		"c7a1",
		""
	],
	[
		"c8a1",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cda1",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d1a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"d2a1",
		"",
		4,
		"",
		5,
		"",
		10,
		"",
		7,
		"",
		5,
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"daa1",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dda1",
		""
	],
	[
		"dea1",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eba1",
		""
	],
	[
		"eca1",
		""
	],
	[
		"eda1",
		""
	],
	[
		"eea1",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f5a1",
		""
	],
	[
		"f6a1",
		""
	],
	[
		"f7a1",
		""
	],
	[
		"f8a1",
		""
	],
	[
		"f9a1",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fda1",
		""
	]
];

var require$$6 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"a140",
		""
	],
	[
		"a1a1",
		"",
		4,
		""
	],
	[
		"a240",
		"",
		7,
		""
	],
	[
		"a2a1",
		"",
		9,
		"",
		9,
		"",
		8,
		"",
		25,
		"",
		21
	],
	[
		"a340",
		"",
		16,
		"",
		6,
		"",
		16,
		"",
		6,
		"",
		10
	],
	[
		"a3a1",
		"",
		25,
		""
	],
	[
		"a3e1",
		""
	],
	[
		"a440",
		""
	],
	[
		"a4a1",
		""
	],
	[
		"a540",
		""
	],
	[
		"a5a1",
		""
	],
	[
		"a640",
		""
	],
	[
		"a6a1",
		""
	],
	[
		"a740",
		""
	],
	[
		"a7a1",
		""
	],
	[
		"a840",
		""
	],
	[
		"a8a1",
		""
	],
	[
		"a940",
		""
	],
	[
		"a9a1",
		""
	],
	[
		"aa40",
		""
	],
	[
		"aaa1",
		""
	],
	[
		"ab40",
		""
	],
	[
		"aba1",
		""
	],
	[
		"ac40",
		""
	],
	[
		"aca1",
		""
	],
	[
		"ad40",
		""
	],
	[
		"ada1",
		""
	],
	[
		"ae40",
		""
	],
	[
		"aea1",
		""
	],
	[
		"af40",
		""
	],
	[
		"afa1",
		""
	],
	[
		"b040",
		""
	],
	[
		"b0a1",
		""
	],
	[
		"b140",
		""
	],
	[
		"b1a1",
		""
	],
	[
		"b240",
		""
	],
	[
		"b2a1",
		""
	],
	[
		"b340",
		""
	],
	[
		"b3a1",
		""
	],
	[
		"b440",
		""
	],
	[
		"b4a1",
		""
	],
	[
		"b540",
		""
	],
	[
		"b5a1",
		""
	],
	[
		"b640",
		""
	],
	[
		"b6a1",
		""
	],
	[
		"b740",
		""
	],
	[
		"b7a1",
		""
	],
	[
		"b840",
		""
	],
	[
		"b8a1",
		""
	],
	[
		"b940",
		""
	],
	[
		"b9a1",
		""
	],
	[
		"ba40",
		""
	],
	[
		"baa1",
		""
	],
	[
		"bb40",
		""
	],
	[
		"bba1",
		""
	],
	[
		"bc40",
		""
	],
	[
		"bca1",
		""
	],
	[
		"bd40",
		""
	],
	[
		"bda1",
		""
	],
	[
		"be40",
		""
	],
	[
		"bea1",
		""
	],
	[
		"bf40",
		""
	],
	[
		"bfa1",
		""
	],
	[
		"c040",
		""
	],
	[
		"c0a1",
		""
	],
	[
		"c140",
		""
	],
	[
		"c1a1",
		""
	],
	[
		"c240",
		""
	],
	[
		"c2a1",
		""
	],
	[
		"c340",
		""
	],
	[
		"c3a1",
		""
	],
	[
		"c440",
		""
	],
	[
		"c4a1",
		""
	],
	[
		"c540",
		""
	],
	[
		"c5a1",
		""
	],
	[
		"c640",
		""
	],
	[
		"c940",
		""
	],
	[
		"c9a1",
		""
	],
	[
		"ca40",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cb40",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cc40",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cd40",
		""
	],
	[
		"cda1",
		""
	],
	[
		"ce40",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cf40",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d040",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d140",
		""
	],
	[
		"d1a1",
		""
	],
	[
		"d240",
		""
	],
	[
		"d2a1",
		""
	],
	[
		"d340",
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d440",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d540",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d640",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d740",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d840",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d940",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"da40",
		""
	],
	[
		"daa1",
		""
	],
	[
		"db40",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dc40",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dd40",
		""
	],
	[
		"dda1",
		""
	],
	[
		"de40",
		""
	],
	[
		"dea1",
		""
	],
	[
		"df40",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e040",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e140",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e240",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e340",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e440",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e540",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e640",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e740",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e840",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e940",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"ea40",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eb40",
		""
	],
	[
		"eba1",
		""
	],
	[
		"ec40",
		""
	],
	[
		"eca1",
		""
	],
	[
		"ed40",
		""
	],
	[
		"eda1",
		""
	],
	[
		"ee40",
		""
	],
	[
		"eea1",
		""
	],
	[
		"ef40",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f040",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f140",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f240",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f340",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f440",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f540",
		""
	],
	[
		"f5a1",
		""
	],
	[
		"f640",
		""
	],
	[
		"f6a1",
		""
	],
	[
		"f740",
		""
	],
	[
		"f7a1",
		""
	],
	[
		"f840",
		""
	],
	[
		"f8a1",
		""
	],
	[
		"f940",
		""
	],
	[
		"f9a1",
		""
	]
];

var require$$7 = [
	[
		"8740",
		""
	],
	[
		"8767",
		""
	],
	[
		"87a1",
		""
	],
	[
		"8840",
		"",
		4,
		""
	],
	[
		"88a1",
		""
	],
	[
		"8940",
		""
	],
	[
		"8943",
		""
	],
	[
		"8946",
		""
	],
	[
		"894c",
		""
	],
	[
		"89a1",
		""
	],
	[
		"89ab",
		""
	],
	[
		"89b0",
		""
	],
	[
		"89b5",
		""
	],
	[
		"89c1",
		""
	],
	[
		"89c5",
		""
	],
	[
		"8a40",
		""
	],
	[
		"8a43",
		""
	],
	[
		"8a64",
		""
	],
	[
		"8a76",
		""
	],
	[
		"8aa1",
		""
	],
	[
		"8aac",
		""
	],
	[
		"8ab2",
		""
	],
	[
		"8abb",
		""
	],
	[
		"8ac9",
		""
	],
	[
		"8ace",
		""
	],
	[
		"8adf",
		""
	],
	[
		"8af6",
		""
	],
	[
		"8b40",
		""
	],
	[
		"8b55",
		""
	],
	[
		"8ba1",
		""
	],
	[
		"8bde",
		""
	],
	[
		"8c40",
		""
	],
	[
		"8ca1",
		""
	],
	[
		"8ca7",
		""
	],
	[
		"8cc9",
		""
	],
	[
		"8cce",
		""
	],
	[
		"8ce6",
		""
	],
	[
		"8d40",
		""
	],
	[
		"8d42",
		""
	],
	[
		"8da1",
		""
	],
	[
		"8e40",
		""
	],
	[
		"8ea1",
		""
	],
	[
		"8f40",
		""
	],
	[
		"8fa1",
		""
	],
	[
		"9040",
		""
	],
	[
		"90a1",
		""
	],
	[
		"9140",
		""
	],
	[
		"91a1",
		""
	],
	[
		"9240",
		""
	],
	[
		"92a1",
		""
	],
	[
		"9340",
		""
	],
	[
		"93a1",
		""
	],
	[
		"9440",
		""
	],
	[
		"94a1",
		""
	],
	[
		"9540",
		""
	],
	[
		"95a1",
		""
	],
	[
		"9640",
		""
	],
	[
		"96a1",
		""
	],
	[
		"9740",
		""
	],
	[
		"97a1",
		""
	],
	[
		"9840",
		""
	],
	[
		"98a1",
		""
	],
	[
		"9940",
		""
	],
	[
		"99a1",
		""
	],
	[
		"9a40",
		""
	],
	[
		"9aa1",
		""
	],
	[
		"9b40",
		""
	],
	[
		"9b62",
		""
	],
	[
		"9ba1",
		""
	],
	[
		"9c40",
		""
	],
	[
		"9ca1",
		""
	],
	[
		"9d40",
		""
	],
	[
		"9da1",
		""
	],
	[
		"9e40",
		""
	],
	[
		"9ea1",
		""
	],
	[
		"9ead",
		""
	],
	[
		"9ec5",
		""
	],
	[
		"9ef5",
		""
	],
	[
		"9f40",
		""
	],
	[
		"9f4f",
		""
	],
	[
		"9fa1",
		""
	],
	[
		"9fae",
		""
	],
	[
		"9fb2",
		""
	],
	[
		"9fc1",
		""
	],
	[
		"9fc9",
		""
	],
	[
		"9fdb",
		""
	],
	[
		"9fe7",
		""
	],
	[
		"9feb",
		""
	],
	[
		"9ff0",
		""
	],
	[
		"a040",
		""
	],
	[
		"a055",
		""
	],
	[
		"a058",
		""
	],
	[
		"a05b",
		""
	],
	[
		"a063",
		""
	],
	[
		"a073",
		""
	],
	[
		"a0a1",
		""
	],
	[
		"a0a6",
		""
	],
	[
		"a0ae",
		""
	],
	[
		"a0b0",
		""
	],
	[
		"a0d4",
		""
	],
	[
		"a0e2",
		""
	],
	[
		"a3c0",
		"",
		31,
		""
	],
	[
		"c6a1",
		"",
		9,
		"",
		9,
		"",
		9,
		"",
		23
	],
	[
		"c740",
		"",
		58,
		""
	],
	[
		"c7a1",
		"",
		81,
		"",
		5,
		"",
		4
	],
	[
		"c840",
		"",
		26,
		"",
		25,
		""
	],
	[
		"c8a1",
		""
	],
	[
		"c8cd",
		""
	],
	[
		"c8f5",
		""
	],
	[
		"f9fe",
		""
	],
	[
		"fa40",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fb40",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fc40",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fd40",
		""
	],
	[
		"fda1",
		""
	],
	[
		"fe40",
		""
	],
	[
		"fea1",
		""
	]
];

var dbcsData;
var hasRequiredDbcsData;

function requireDbcsData () {
	if (hasRequiredDbcsData) return dbcsData;
	hasRequiredDbcsData = 1;

	// Description of supported double byte encodings and aliases.
	// Tables are not require()-d until they are needed to speed up library load.
	// require()-s are direct to support Browserify.

	dbcsData = {
	    
	    // == Japanese/ShiftJIS ====================================================
	    // All japanese encodings are based on JIS X set of standards:
	    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
	    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
	    //              Has several variations in 1978, 1983, 1990 and 1997.
	    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
	    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
	    //              2 planes, first is superset of 0208, second - revised 0212.
	    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

	    // Byte encodings are:
	    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
	    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
	    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
	    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
	    //               0x00-0x7F       - lower part of 0201
	    //               0x8E, 0xA1-0xDF - upper part of 0201
	    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
	    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
	    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
	    //               Used as-is in ISO2022 family.
	    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
	    //                0201-1976 Roman, 0208-1978, 0208-1983.
	    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
	    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
	    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
	    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
	    //
	    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
	    //
	    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

	    'shiftjis': {
	        type: '_dbcs',
	        table: function() { return require$$0$2 },
	        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
	        encodeSkipVals: [{from: 0xED40, to: 0xF940}],
	    },
	    'csshiftjis': 'shiftjis',
	    'mskanji': 'shiftjis',
	    'sjis': 'shiftjis',
	    'windows31j': 'shiftjis',
	    'ms31j': 'shiftjis',
	    'xsjis': 'shiftjis',
	    'windows932': 'shiftjis',
	    'ms932': 'shiftjis',
	    '932': 'shiftjis',
	    'cp932': 'shiftjis',

	    'eucjp': {
	        type: '_dbcs',
	        table: function() { return require$$1 },
	        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
	    },

	    // TODO: KDDI extension to Shift_JIS
	    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
	    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.


	    // == Chinese/GBK ==========================================================
	    // http://en.wikipedia.org/wiki/GBK
	    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

	    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
	    'gb2312': 'cp936',
	    'gb231280': 'cp936',
	    'gb23121980': 'cp936',
	    'csgb2312': 'cp936',
	    'csiso58gb231280': 'cp936',
	    'euccn': 'cp936',

	    // Microsoft's CP936 is a subset and approximation of GBK.
	    'windows936': 'cp936',
	    'ms936': 'cp936',
	    '936': 'cp936',
	    'cp936': {
	        type: '_dbcs',
	        table: function() { return require$$2$2 },
	    },

	    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
	    'gbk': {
	        type: '_dbcs',
	        table: function() { return require$$2$2.concat(require$$3) },
	    },
	    'xgbk': 'gbk',
	    'isoir58': 'gbk',

	    // GB18030 is an algorithmic extension of GBK.
	    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
	    // http://icu-project.org/docs/papers/gb18030.html
	    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
	    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
	    'gb18030': {
	        type: '_dbcs',
	        table: function() { return require$$2$2.concat(require$$3) },
	        gb18030: function() { return require$$4 },
	        encodeSkipVals: [0x80],
	        encodeAdd: {'': 0xA2E3},
	    },

	    'chinese': 'gb18030',


	    // == Korean ===============================================================
	    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
	    'windows949': 'cp949',
	    'ms949': 'cp949',
	    '949': 'cp949',
	    'cp949': {
	        type: '_dbcs',
	        table: function() { return require$$5$1 },
	    },

	    'cseuckr': 'cp949',
	    'csksc56011987': 'cp949',
	    'euckr': 'cp949',
	    'isoir149': 'cp949',
	    'korean': 'cp949',
	    'ksc56011987': 'cp949',
	    'ksc56011989': 'cp949',
	    'ksc5601': 'cp949',


	    // == Big5/Taiwan/Hong Kong ================================================
	    // There are lots of tables for Big5 and cp950. Please see the following links for history:
	    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
	    // Variations, in roughly number of defined chars:
	    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
	    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
	    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
	    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
	    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
	    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
	    //    Plus, it has 4 combining sequences.
	    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
	    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
	    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
	    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
	    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
	    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
	    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
	    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
	    // 
	    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
	    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

	    'windows950': 'cp950',
	    'ms950': 'cp950',
	    '950': 'cp950',
	    'cp950': {
	        type: '_dbcs',
	        table: function() { return require$$6 },
	    },

	    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
	    'big5': 'big5hkscs',
	    'big5hkscs': {
	        type: '_dbcs',
	        table: function() { return require$$6.concat(require$$7) },
	        encodeSkipVals: [0xa2cc],
	    },

	    'cnbig5': 'big5hkscs',
	    'csbig5': 'big5hkscs',
	    'xxbig5': 'big5hkscs',
	};
	return dbcsData;
}

var hasRequiredEncodings;

function requireEncodings () {
	if (hasRequiredEncodings) return encodings;
	hasRequiredEncodings = 1;
	(function (exports) {

		// Update this array if you add/rename/remove files in this directory.
		// We support Browserify by skipping automatic module discovery and requiring modules directly.
		var modules = [
		    requireInternal(),
		    requireUtf16(),
		    requireUtf7(),
		    requireSbcsCodec(),
		    requireSbcsData(),
		    requireSbcsDataGenerated(),
		    requireDbcsCodec(),
		    requireDbcsData(),
		];

		// Put all encoding/alias/codec definitions to single object and export it. 
		for (var i = 0; i < modules.length; i++) {
		    var module = modules[i];
		    for (var enc in module)
		        if (Object.prototype.hasOwnProperty.call(module, enc))
		            exports[enc] = module[enc];
		} 
	} (encodings));
	return encodings;
}

var streams;
var hasRequiredStreams;

function requireStreams () {
	if (hasRequiredStreams) return streams;
	hasRequiredStreams = 1;

	var Buffer = require$$0$a.Buffer,
	    Transform = require$$0$9.Transform;


	// == Exports ==================================================================
	streams = function(iconv) {
	    
	    // Additional Public API.
	    iconv.encodeStream = function encodeStream(encoding, options) {
	        return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
	    };

	    iconv.decodeStream = function decodeStream(encoding, options) {
	        return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
	    };

	    iconv.supportsStreams = true;


	    // Not published yet.
	    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
	    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
	    iconv._collect = IconvLiteDecoderStream.prototype.collect;
	};


	// == Encoder stream =======================================================
	function IconvLiteEncoderStream(conv, options) {
	    this.conv = conv;
	    options = options || {};
	    options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
	    Transform.call(this, options);
	}

	IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
	    constructor: { value: IconvLiteEncoderStream }
	});

	IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
	    if (typeof chunk != 'string')
	        return done(new Error("Iconv encoding stream needs strings as its input."));
	    try {
	        var res = this.conv.write(chunk);
	        if (res && res.length) this.push(res);
	        done();
	    }
	    catch (e) {
	        done(e);
	    }
	};

	IconvLiteEncoderStream.prototype._flush = function(done) {
	    try {
	        var res = this.conv.end();
	        if (res && res.length) this.push(res);
	        done();
	    }
	    catch (e) {
	        done(e);
	    }
	};

	IconvLiteEncoderStream.prototype.collect = function(cb) {
	    var chunks = [];
	    this.on('error', cb);
	    this.on('data', function(chunk) { chunks.push(chunk); });
	    this.on('end', function() {
	        cb(null, Buffer.concat(chunks));
	    });
	    return this;
	};


	// == Decoder stream =======================================================
	function IconvLiteDecoderStream(conv, options) {
	    this.conv = conv;
	    options = options || {};
	    options.encoding = this.encoding = 'utf8'; // We output strings.
	    Transform.call(this, options);
	}

	IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
	    constructor: { value: IconvLiteDecoderStream }
	});

	IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
	    if (!Buffer.isBuffer(chunk))
	        return done(new Error("Iconv decoding stream needs buffers as its input."));
	    try {
	        var res = this.conv.write(chunk);
	        if (res && res.length) this.push(res, this.encoding);
	        done();
	    }
	    catch (e) {
	        done(e);
	    }
	};

	IconvLiteDecoderStream.prototype._flush = function(done) {
	    try {
	        var res = this.conv.end();
	        if (res && res.length) this.push(res, this.encoding);                
	        done();
	    }
	    catch (e) {
	        done(e);
	    }
	};

	IconvLiteDecoderStream.prototype.collect = function(cb) {
	    var res = '';
	    this.on('error', cb);
	    this.on('data', function(chunk) { res += chunk; });
	    this.on('end', function() {
	        cb(null, res);
	    });
	    return this;
	};
	return streams;
}

var extendNode;
var hasRequiredExtendNode;

function requireExtendNode () {
	if (hasRequiredExtendNode) return extendNode;
	hasRequiredExtendNode = 1;
	var Buffer = require$$0$a.Buffer;
	// Note: not polyfilled with safer-buffer on a purpose, as overrides Buffer

	// == Extend Node primitives to use iconv-lite =================================

	extendNode = function (iconv) {
	    var original = undefined; // Place to keep original methods.

	    // Node authors rewrote Buffer internals to make it compatible with
	    // Uint8Array and we cannot patch key functions since then.
	    // Note: this does use older Buffer API on a purpose
	    iconv.supportsNodeEncodingsExtension = !(Buffer.from || new Buffer(0) instanceof Uint8Array);

	    iconv.extendNodeEncodings = function extendNodeEncodings() {
	        if (original) return;
	        original = {};

	        if (!iconv.supportsNodeEncodingsExtension) {
	            console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
	            console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
	            return;
	        }

	        var nodeNativeEncodings = {
	            'hex': true, 'utf8': true, 'utf-8': true, 'ascii': true, 'binary': true, 
	            'base64': true, 'ucs2': true, 'ucs-2': true, 'utf16le': true, 'utf-16le': true,
	        };

	        Buffer.isNativeEncoding = function(enc) {
	            return enc && nodeNativeEncodings[enc.toLowerCase()];
	        };

	        // -- SlowBuffer -----------------------------------------------------------
	        var SlowBuffer = require$$0$a.SlowBuffer;

	        original.SlowBufferToString = SlowBuffer.prototype.toString;
	        SlowBuffer.prototype.toString = function(encoding, start, end) {
	            encoding = String(encoding || 'utf8').toLowerCase();

	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding))
	                return original.SlowBufferToString.call(this, encoding, start, end);

	            // Otherwise, use our decoding method.
	            if (typeof start == 'undefined') start = 0;
	            if (typeof end == 'undefined') end = this.length;
	            return iconv.decode(this.slice(start, end), encoding);
	        };

	        original.SlowBufferWrite = SlowBuffer.prototype.write;
	        SlowBuffer.prototype.write = function(string, offset, length, encoding) {
	            // Support both (string, offset, length, encoding)
	            // and the legacy (string, encoding, offset, length)
	            if (isFinite(offset)) {
	                if (!isFinite(length)) {
	                    encoding = length;
	                    length = undefined;
	                }
	            } else {  // legacy
	                var swap = encoding;
	                encoding = offset;
	                offset = length;
	                length = swap;
	            }

	            offset = +offset || 0;
	            var remaining = this.length - offset;
	            if (!length) {
	                length = remaining;
	            } else {
	                length = +length;
	                if (length > remaining) {
	                    length = remaining;
	                }
	            }
	            encoding = String(encoding || 'utf8').toLowerCase();

	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding))
	                return original.SlowBufferWrite.call(this, string, offset, length, encoding);

	            if (string.length > 0 && (length < 0 || offset < 0))
	                throw new RangeError('attempt to write beyond buffer bounds');

	            // Otherwise, use our encoding method.
	            var buf = iconv.encode(string, encoding);
	            if (buf.length < length) length = buf.length;
	            buf.copy(this, offset, 0, length);
	            return length;
	        };

	        // -- Buffer ---------------------------------------------------------------

	        original.BufferIsEncoding = Buffer.isEncoding;
	        Buffer.isEncoding = function(encoding) {
	            return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
	        };

	        original.BufferByteLength = Buffer.byteLength;
	        Buffer.byteLength = SlowBuffer.byteLength = function(str, encoding) {
	            encoding = String(encoding || 'utf8').toLowerCase();

	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding))
	                return original.BufferByteLength.call(this, str, encoding);

	            // Slow, I know, but we don't have a better way yet.
	            return iconv.encode(str, encoding).length;
	        };

	        original.BufferToString = Buffer.prototype.toString;
	        Buffer.prototype.toString = function(encoding, start, end) {
	            encoding = String(encoding || 'utf8').toLowerCase();

	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding))
	                return original.BufferToString.call(this, encoding, start, end);

	            // Otherwise, use our decoding method.
	            if (typeof start == 'undefined') start = 0;
	            if (typeof end == 'undefined') end = this.length;
	            return iconv.decode(this.slice(start, end), encoding);
	        };

	        original.BufferWrite = Buffer.prototype.write;
	        Buffer.prototype.write = function(string, offset, length, encoding) {
	            var _offset = offset, _length = length, _encoding = encoding;
	            // Support both (string, offset, length, encoding)
	            // and the legacy (string, encoding, offset, length)
	            if (isFinite(offset)) {
	                if (!isFinite(length)) {
	                    encoding = length;
	                    length = undefined;
	                }
	            } else {  // legacy
	                var swap = encoding;
	                encoding = offset;
	                offset = length;
	                length = swap;
	            }

	            encoding = String(encoding || 'utf8').toLowerCase();

	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding))
	                return original.BufferWrite.call(this, string, _offset, _length, _encoding);

	            offset = +offset || 0;
	            var remaining = this.length - offset;
	            if (!length) {
	                length = remaining;
	            } else {
	                length = +length;
	                if (length > remaining) {
	                    length = remaining;
	                }
	            }

	            if (string.length > 0 && (length < 0 || offset < 0))
	                throw new RangeError('attempt to write beyond buffer bounds');

	            // Otherwise, use our encoding method.
	            var buf = iconv.encode(string, encoding);
	            if (buf.length < length) length = buf.length;
	            buf.copy(this, offset, 0, length);
	            return length;

	            // TODO: Set _charsWritten.
	        };


	        // -- Readable -------------------------------------------------------------
	        if (iconv.supportsStreams) {
	            var Readable = require$$0$9.Readable;

	            original.ReadableSetEncoding = Readable.prototype.setEncoding;
	            Readable.prototype.setEncoding = function setEncoding(enc, options) {
	                // Use our own decoder, it has the same interface.
	                // We cannot use original function as it doesn't handle BOM-s.
	                this._readableState.decoder = iconv.getDecoder(enc, options);
	                this._readableState.encoding = enc;
	            };

	            Readable.prototype.collect = iconv._collect;
	        }
	    };

	    // Remove iconv-lite Node primitive extensions.
	    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
	        if (!iconv.supportsNodeEncodingsExtension)
	            return;
	        if (!original)
	            throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.")

	        delete Buffer.isNativeEncoding;

	        var SlowBuffer = require$$0$a.SlowBuffer;

	        SlowBuffer.prototype.toString = original.SlowBufferToString;
	        SlowBuffer.prototype.write = original.SlowBufferWrite;

	        Buffer.isEncoding = original.BufferIsEncoding;
	        Buffer.byteLength = original.BufferByteLength;
	        Buffer.prototype.toString = original.BufferToString;
	        Buffer.prototype.write = original.BufferWrite;

	        if (iconv.supportsStreams) {
	            var Readable = require$$0$9.Readable;

	            Readable.prototype.setEncoding = original.ReadableSetEncoding;
	            delete Readable.prototype.collect;
	        }

	        original = undefined;
	    };
	};
	return extendNode;
}

var hasRequiredLib$5;

function requireLib$5 () {
	if (hasRequiredLib$5) return lib$5.exports;
	hasRequiredLib$5 = 1;
	(function (module) {

		// Some environments don't have global Buffer (e.g. React Native).
		// Solution would be installing npm modules "buffer" and "stream" explicitly.
		var Buffer = requireSafer().Buffer;

		var bomHandling = requireBomHandling(),
		    iconv = module.exports;

		// All codecs and aliases are kept here, keyed by encoding name/alias.
		// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
		iconv.encodings = null;

		// Characters emitted in case of error.
		iconv.defaultCharUnicode = '';
		iconv.defaultCharSingleByte = '?';

		// Public API.
		iconv.encode = function encode(str, encoding, options) {
		    str = "" + (str || ""); // Ensure string.

		    var encoder = iconv.getEncoder(encoding, options);

		    var res = encoder.write(str);
		    var trail = encoder.end();
		    
		    return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;
		};

		iconv.decode = function decode(buf, encoding, options) {
		    if (typeof buf === 'string') {
		        if (!iconv.skipDecodeWarning) {
		            console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
		            iconv.skipDecodeWarning = true;
		        }

		        buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
		    }

		    var decoder = iconv.getDecoder(encoding, options);

		    var res = decoder.write(buf);
		    var trail = decoder.end();

		    return trail ? (res + trail) : res;
		};

		iconv.encodingExists = function encodingExists(enc) {
		    try {
		        iconv.getCodec(enc);
		        return true;
		    } catch (e) {
		        return false;
		    }
		};

		// Legacy aliases to convert functions
		iconv.toEncoding = iconv.encode;
		iconv.fromEncoding = iconv.decode;

		// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
		iconv._codecDataCache = {};
		iconv.getCodec = function getCodec(encoding) {
		    if (!iconv.encodings)
		        iconv.encodings = requireEncodings(); // Lazy load all encoding definitions.
		    
		    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
		    var enc = iconv._canonicalizeEncoding(encoding);

		    // Traverse iconv.encodings to find actual codec.
		    var codecOptions = {};
		    while (true) {
		        var codec = iconv._codecDataCache[enc];
		        if (codec)
		            return codec;

		        var codecDef = iconv.encodings[enc];

		        switch (typeof codecDef) {
		            case "string": // Direct alias to other encoding.
		                enc = codecDef;
		                break;

		            case "object": // Alias with options. Can be layered.
		                for (var key in codecDef)
		                    codecOptions[key] = codecDef[key];

		                if (!codecOptions.encodingName)
		                    codecOptions.encodingName = enc;
		                
		                enc = codecDef.type;
		                break;

		            case "function": // Codec itself.
		                if (!codecOptions.encodingName)
		                    codecOptions.encodingName = enc;

		                // The codec function must load all tables and return object with .encoder and .decoder methods.
		                // It'll be called only once (for each different options object).
		                codec = new codecDef(codecOptions, iconv);

		                iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
		                return codec;

		            default:
		                throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '"+enc+"')");
		        }
		    }
		};

		iconv._canonicalizeEncoding = function(encoding) {
		    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
		    return (''+encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
		};

		iconv.getEncoder = function getEncoder(encoding, options) {
		    var codec = iconv.getCodec(encoding),
		        encoder = new codec.encoder(options, codec);

		    if (codec.bomAware && options && options.addBOM)
		        encoder = new bomHandling.PrependBOM(encoder, options);

		    return encoder;
		};

		iconv.getDecoder = function getDecoder(encoding, options) {
		    var codec = iconv.getCodec(encoding),
		        decoder = new codec.decoder(options, codec);

		    if (codec.bomAware && !(options && options.stripBOM === false))
		        decoder = new bomHandling.StripBOM(decoder, options);

		    return decoder;
		};


		// Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
		var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
		if (nodeVer) {

		    // Load streaming support in Node v0.10+
		    var nodeVerArr = nodeVer.split(".").map(Number);
		    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
		        requireStreams()(iconv);
		    }

		    // Load Node primitive extensions.
		    requireExtendNode()(iconv);
		}
	} (lib$5));
	return lib$5.exports;
}

/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var unpipe_1;
var hasRequiredUnpipe;

function requireUnpipe () {
	if (hasRequiredUnpipe) return unpipe_1;
	hasRequiredUnpipe = 1;

	/**
	 * Module exports.
	 * @public
	 */

	unpipe_1 = unpipe;

	/**
	 * Determine if there are Node.js pipe-like data listeners.
	 * @private
	 */

	function hasPipeDataListeners(stream) {
	  var listeners = stream.listeners('data');

	  for (var i = 0; i < listeners.length; i++) {
	    if (listeners[i].name === 'ondata') {
	      return true
	    }
	  }

	  return false
	}

	/**
	 * Unpipe a stream from all destinations.
	 *
	 * @param {object} stream
	 * @public
	 */

	function unpipe(stream) {
	  if (!stream) {
	    throw new TypeError('argument stream is required')
	  }

	  if (typeof stream.unpipe === 'function') {
	    // new-style
	    stream.unpipe();
	    return
	  }

	  // Node.js 0.8 hack
	  if (!hasPipeDataListeners(stream)) {
	    return
	  }

	  var listener;
	  var listeners = stream.listeners('close');

	  for (var i = 0; i < listeners.length; i++) {
	    listener = listeners[i];

	    if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
	      continue
	    }

	    // invoke the listener
	    listener.call(stream);
	  }
	}
	return unpipe_1;
}

/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

var rawBody;
var hasRequiredRawBody;

function requireRawBody () {
	if (hasRequiredRawBody) return rawBody;
	hasRequiredRawBody = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var asyncHooks = tryRequireAsyncHooks();
	var bytes = requireBytes();
	var createError = requireHttpErrors();
	var iconv = requireLib$5();
	var unpipe = requireUnpipe();

	/**
	 * Module exports.
	 * @public
	 */

	rawBody = getRawBody;

	/**
	 * Module variables.
	 * @private
	 */

	var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;

	/**
	 * Get the decoder for a given encoding.
	 *
	 * @param {string} encoding
	 * @private
	 */

	function getDecoder (encoding) {
	  if (!encoding) return null

	  try {
	    return iconv.getDecoder(encoding)
	  } catch (e) {
	    // error getting decoder
	    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e

	    // the encoding was not found
	    throw createError(415, 'specified encoding unsupported', {
	      encoding: encoding,
	      type: 'encoding.unsupported'
	    })
	  }
	}

	/**
	 * Get the raw body of a stream (typically HTTP).
	 *
	 * @param {object} stream
	 * @param {object|string|function} [options]
	 * @param {function} [callback]
	 * @public
	 */

	function getRawBody (stream, options, callback) {
	  var done = callback;
	  var opts = options || {};

	  // light validation
	  if (stream === undefined) {
	    throw new TypeError('argument stream is required')
	  } else if (typeof stream !== 'object' || stream === null || typeof stream.on !== 'function') {
	    throw new TypeError('argument stream must be a stream')
	  }

	  if (options === true || typeof options === 'string') {
	    // short cut for encoding
	    opts = {
	      encoding: options
	    };
	  }

	  if (typeof options === 'function') {
	    done = options;
	    opts = {};
	  }

	  // validate callback is a function, if provided
	  if (done !== undefined && typeof done !== 'function') {
	    throw new TypeError('argument callback must be a function')
	  }

	  // require the callback without promises
	  if (!done && !commonjsGlobal.Promise) {
	    throw new TypeError('argument callback is required')
	  }

	  // get encoding
	  var encoding = opts.encoding !== true
	    ? opts.encoding
	    : 'utf-8';

	  // convert the limit to an integer
	  var limit = bytes.parse(opts.limit);

	  // convert the expected length to an integer
	  var length = opts.length != null && !isNaN(opts.length)
	    ? parseInt(opts.length, 10)
	    : null;

	  if (done) {
	    // classic callback style
	    return readStream(stream, encoding, length, limit, wrap(done))
	  }

	  return new Promise(function executor (resolve, reject) {
	    readStream(stream, encoding, length, limit, function onRead (err, buf) {
	      if (err) return reject(err)
	      resolve(buf);
	    });
	  })
	}

	/**
	 * Halt a stream.
	 *
	 * @param {Object} stream
	 * @private
	 */

	function halt (stream) {
	  // unpipe everything from the stream
	  unpipe(stream);

	  // pause stream
	  if (typeof stream.pause === 'function') {
	    stream.pause();
	  }
	}

	/**
	 * Read the data from the stream.
	 *
	 * @param {object} stream
	 * @param {string} encoding
	 * @param {number} length
	 * @param {number} limit
	 * @param {function} callback
	 * @public
	 */

	function readStream (stream, encoding, length, limit, callback) {
	  var complete = false;
	  var sync = true;

	  // check the length and limit options.
	  // note: we intentionally leave the stream paused,
	  // so users should handle the stream themselves.
	  if (limit !== null && length !== null && length > limit) {
	    return done(createError(413, 'request entity too large', {
	      expected: length,
	      length: length,
	      limit: limit,
	      type: 'entity.too.large'
	    }))
	  }

	  // streams1: assert request encoding is buffer.
	  // streams2+: assert the stream encoding is buffer.
	  //   stream._decoder: streams1
	  //   state.encoding: streams2
	  //   state.decoder: streams2, specifically < 0.10.6
	  var state = stream._readableState;
	  if (stream._decoder || (state && (state.encoding || state.decoder))) {
	    // developer error
	    return done(createError(500, 'stream encoding should not be set', {
	      type: 'stream.encoding.set'
	    }))
	  }

	  if (typeof stream.readable !== 'undefined' && !stream.readable) {
	    return done(createError(500, 'stream is not readable', {
	      type: 'stream.not.readable'
	    }))
	  }

	  var received = 0;
	  var decoder;

	  try {
	    decoder = getDecoder(encoding);
	  } catch (err) {
	    return done(err)
	  }

	  var buffer = decoder
	    ? ''
	    : [];

	  // attach listeners
	  stream.on('aborted', onAborted);
	  stream.on('close', cleanup);
	  stream.on('data', onData);
	  stream.on('end', onEnd);
	  stream.on('error', onEnd);

	  // mark sync section complete
	  sync = false;

	  function done () {
	    var args = new Array(arguments.length);

	    // copy arguments
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }

	    // mark complete
	    complete = true;

	    if (sync) {
	      process.nextTick(invokeCallback);
	    } else {
	      invokeCallback();
	    }

	    function invokeCallback () {
	      cleanup();

	      if (args[0]) {
	        // halt the stream on error
	        halt(stream);
	      }

	      callback.apply(null, args);
	    }
	  }

	  function onAborted () {
	    if (complete) return

	    done(createError(400, 'request aborted', {
	      code: 'ECONNABORTED',
	      expected: length,
	      length: length,
	      received: received,
	      type: 'request.aborted'
	    }));
	  }

	  function onData (chunk) {
	    if (complete) return

	    received += chunk.length;

	    if (limit !== null && received > limit) {
	      done(createError(413, 'request entity too large', {
	        limit: limit,
	        received: received,
	        type: 'entity.too.large'
	      }));
	    } else if (decoder) {
	      buffer += decoder.write(chunk);
	    } else {
	      buffer.push(chunk);
	    }
	  }

	  function onEnd (err) {
	    if (complete) return
	    if (err) return done(err)

	    if (length !== null && received !== length) {
	      done(createError(400, 'request size did not match content length', {
	        expected: length,
	        length: length,
	        received: received,
	        type: 'request.size.invalid'
	      }));
	    } else {
	      var string = decoder
	        ? buffer + (decoder.end() || '')
	        : Buffer.concat(buffer);
	      done(null, string);
	    }
	  }

	  function cleanup () {
	    buffer = null;

	    stream.removeListener('aborted', onAborted);
	    stream.removeListener('data', onData);
	    stream.removeListener('end', onEnd);
	    stream.removeListener('error', onEnd);
	    stream.removeListener('close', cleanup);
	  }
	}

	/**
	 * Try to require async_hooks
	 * @private
	 */

	function tryRequireAsyncHooks () {
	  try {
	    return require('async_hooks')
	  } catch (e) {
	    return {}
	  }
	}

	/**
	 * Wrap function with async resource, if possible.
	 * AsyncResource.bind static method backported.
	 * @private
	 */

	function wrap (fn) {
	  var res;

	  // create anonymous resource
	  if (asyncHooks.AsyncResource) {
	    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');
	  }

	  // incompatible node.js
	  if (!res || !res.runInAsyncScope) {
	    return fn
	  }

	  // return bound function
	  return res.runInAsyncScope.bind(res, fn, null)
	}
	return rawBody;
}

var onFinished = {exports: {}};

/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */

var eeFirst;
var hasRequiredEeFirst;

function requireEeFirst () {
	if (hasRequiredEeFirst) return eeFirst;
	hasRequiredEeFirst = 1;

	/**
	 * Module exports.
	 * @public
	 */

	eeFirst = first;

	/**
	 * Get the first event in a set of event emitters and event pairs.
	 *
	 * @param {array} stuff
	 * @param {function} done
	 * @public
	 */

	function first(stuff, done) {
	  if (!Array.isArray(stuff))
	    throw new TypeError('arg must be an array of [ee, events...] arrays')

	  var cleanups = [];

	  for (var i = 0; i < stuff.length; i++) {
	    var arr = stuff[i];

	    if (!Array.isArray(arr) || arr.length < 2)
	      throw new TypeError('each array member must be [ee, events...]')

	    var ee = arr[0];

	    for (var j = 1; j < arr.length; j++) {
	      var event = arr[j];
	      var fn = listener(event, callback);

	      // listen to the event
	      ee.on(event, fn);
	      // push this listener to the list of cleanups
	      cleanups.push({
	        ee: ee,
	        event: event,
	        fn: fn,
	      });
	    }
	  }

	  function callback() {
	    cleanup();
	    done.apply(null, arguments);
	  }

	  function cleanup() {
	    var x;
	    for (var i = 0; i < cleanups.length; i++) {
	      x = cleanups[i];
	      x.ee.removeListener(x.event, x.fn);
	    }
	  }

	  function thunk(fn) {
	    done = fn;
	  }

	  thunk.cancel = cleanup;

	  return thunk
	}

	/**
	 * Create the event listener.
	 * @private
	 */

	function listener(event, done) {
	  return function onevent(arg1) {
	    var args = new Array(arguments.length);
	    var ee = this;
	    var err = event === 'error'
	      ? arg1
	      : null;

	    // copy args to prevent arguments escaping scope
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }

	    done(err, ee, event, args);
	  }
	}
	return eeFirst;
}

/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredOnFinished;

function requireOnFinished () {
	if (hasRequiredOnFinished) return onFinished.exports;
	hasRequiredOnFinished = 1;

	/**
	 * Module exports.
	 * @public
	 */

	onFinished.exports = onFinished$1;
	onFinished.exports.isFinished = isFinished;

	/**
	 * Module dependencies.
	 * @private
	 */

	var asyncHooks = tryRequireAsyncHooks();
	var first = requireEeFirst();

	/**
	 * Variables.
	 * @private
	 */

	/* istanbul ignore next */
	var defer = typeof setImmediate === 'function'
	  ? setImmediate
	  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)); };

	/**
	 * Invoke callback when the response has finished, useful for
	 * cleaning up resources afterwards.
	 *
	 * @param {object} msg
	 * @param {function} listener
	 * @return {object}
	 * @public
	 */

	function onFinished$1 (msg, listener) {
	  if (isFinished(msg) !== false) {
	    defer(listener, null, msg);
	    return msg
	  }

	  // attach the listener to the message
	  attachListener(msg, wrap(listener));

	  return msg
	}

	/**
	 * Determine if message is already finished.
	 *
	 * @param {object} msg
	 * @return {boolean}
	 * @public
	 */

	function isFinished (msg) {
	  var socket = msg.socket;

	  if (typeof msg.finished === 'boolean') {
	    // OutgoingMessage
	    return Boolean(msg.finished || (socket && !socket.writable))
	  }

	  if (typeof msg.complete === 'boolean') {
	    // IncomingMessage
	    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))
	  }

	  // don't know
	  return undefined
	}

	/**
	 * Attach a finished listener to the message.
	 *
	 * @param {object} msg
	 * @param {function} callback
	 * @private
	 */

	function attachFinishedListener (msg, callback) {
	  var eeMsg;
	  var eeSocket;
	  var finished = false;

	  function onFinish (error) {
	    eeMsg.cancel();
	    eeSocket.cancel();

	    finished = true;
	    callback(error);
	  }

	  // finished on first message event
	  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish);

	  function onSocket (socket) {
	    // remove listener
	    msg.removeListener('socket', onSocket);

	    if (finished) return
	    if (eeMsg !== eeSocket) return

	    // finished on first socket event
	    eeSocket = first([[socket, 'error', 'close']], onFinish);
	  }

	  if (msg.socket) {
	    // socket already assigned
	    onSocket(msg.socket);
	    return
	  }

	  // wait for socket to be assigned
	  msg.on('socket', onSocket);

	  if (msg.socket === undefined) {
	    // istanbul ignore next: node.js 0.8 patch
	    patchAssignSocket(msg, onSocket);
	  }
	}

	/**
	 * Attach the listener to the message.
	 *
	 * @param {object} msg
	 * @return {function}
	 * @private
	 */

	function attachListener (msg, listener) {
	  var attached = msg.__onFinished;

	  // create a private single listener with queue
	  if (!attached || !attached.queue) {
	    attached = msg.__onFinished = createListener(msg);
	    attachFinishedListener(msg, attached);
	  }

	  attached.queue.push(listener);
	}

	/**
	 * Create listener on message.
	 *
	 * @param {object} msg
	 * @return {function}
	 * @private
	 */

	function createListener (msg) {
	  function listener (err) {
	    if (msg.__onFinished === listener) msg.__onFinished = null;
	    if (!listener.queue) return

	    var queue = listener.queue;
	    listener.queue = null;

	    for (var i = 0; i < queue.length; i++) {
	      queue[i](err, msg);
	    }
	  }

	  listener.queue = [];

	  return listener
	}

	/**
	 * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
	 *
	 * @param {ServerResponse} res
	 * @param {function} callback
	 * @private
	 */

	// istanbul ignore next: node.js 0.8 patch
	function patchAssignSocket (res, callback) {
	  var assignSocket = res.assignSocket;

	  if (typeof assignSocket !== 'function') return

	  // res.on('socket', callback) is broken in 0.8
	  res.assignSocket = function _assignSocket (socket) {
	    assignSocket.call(this, socket);
	    callback(socket);
	  };
	}

	/**
	 * Try to require async_hooks
	 * @private
	 */

	function tryRequireAsyncHooks () {
	  try {
	    return require('async_hooks')
	  } catch (e) {
	    return {}
	  }
	}

	/**
	 * Wrap function with async resource, if possible.
	 * AsyncResource.bind static method backported.
	 * @private
	 */

	function wrap (fn) {
	  var res;

	  // create anonymous resource
	  if (asyncHooks.AsyncResource) {
	    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');
	  }

	  // incompatible node.js
	  if (!res || !res.runInAsyncScope) {
	    return fn
	  }

	  // return bound function
	  return res.runInAsyncScope.bind(res, fn, null)
	}
	return onFinished.exports;
}

/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var read_1;
var hasRequiredRead;

function requireRead () {
	if (hasRequiredRead) return read_1;
	hasRequiredRead = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var createError = requireHttpErrors();
	var destroy = requireDestroy();
	var getBody = requireRawBody();
	var iconv = requireLib$5();
	var onFinished = requireOnFinished();
	var unpipe = requireUnpipe();
	var zlib$1 = zlib;

	/**
	 * Module exports.
	 */

	read_1 = read;

	/**
	 * Read a request into a buffer and parse.
	 *
	 * @param {object} req
	 * @param {object} res
	 * @param {function} next
	 * @param {function} parse
	 * @param {function} debug
	 * @param {object} options
	 * @private
	 */

	function read (req, res, next, parse, debug, options) {
	  var length;
	  var opts = options;
	  var stream;

	  // flag as parsed
	  req._body = true;

	  // read options
	  var encoding = opts.encoding !== null
	    ? opts.encoding
	    : null;
	  var verify = opts.verify;

	  try {
	    // get the content stream
	    stream = contentstream(req, debug, opts.inflate);
	    length = stream.length;
	    stream.length = undefined;
	  } catch (err) {
	    return next(err)
	  }

	  // set raw-body options
	  opts.length = length;
	  opts.encoding = verify
	    ? null
	    : encoding;

	  // assert charset is supported
	  if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {
	    return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
	      charset: encoding.toLowerCase(),
	      type: 'charset.unsupported'
	    }))
	  }

	  // read body
	  debug('read body');
	  getBody(stream, opts, function (error, body) {
	    if (error) {
	      var _error;

	      if (error.type === 'encoding.unsupported') {
	        // echo back charset
	        _error = createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
	          charset: encoding.toLowerCase(),
	          type: 'charset.unsupported'
	        });
	      } else {
	        // set status code on error
	        _error = createError(400, error);
	      }

	      // unpipe from stream and destroy
	      if (stream !== req) {
	        unpipe(req);
	        destroy(stream, true);
	      }

	      // read off entire request
	      dump(req, function onfinished () {
	        next(createError(400, _error));
	      });
	      return
	    }

	    // verify
	    if (verify) {
	      try {
	        debug('verify body');
	        verify(req, res, body, encoding);
	      } catch (err) {
	        next(createError(403, err, {
	          body: body,
	          type: err.type || 'entity.verify.failed'
	        }));
	        return
	      }
	    }

	    // parse
	    var str = body;
	    try {
	      debug('parse body');
	      str = typeof body !== 'string' && encoding !== null
	        ? iconv.decode(body, encoding)
	        : body;
	      req.body = parse(str);
	    } catch (err) {
	      next(createError(400, err, {
	        body: str,
	        type: err.type || 'entity.parse.failed'
	      }));
	      return
	    }

	    next();
	  });
	}

	/**
	 * Get the content stream of the request.
	 *
	 * @param {object} req
	 * @param {function} debug
	 * @param {boolean} [inflate=true]
	 * @return {object}
	 * @api private
	 */

	function contentstream (req, debug, inflate) {
	  var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase();
	  var length = req.headers['content-length'];
	  var stream;

	  debug('content-encoding "%s"', encoding);

	  if (inflate === false && encoding !== 'identity') {
	    throw createError(415, 'content encoding unsupported', {
	      encoding: encoding,
	      type: 'encoding.unsupported'
	    })
	  }

	  switch (encoding) {
	    case 'deflate':
	      stream = zlib$1.createInflate();
	      debug('inflate body');
	      req.pipe(stream);
	      break
	    case 'gzip':
	      stream = zlib$1.createGunzip();
	      debug('gunzip body');
	      req.pipe(stream);
	      break
	    case 'identity':
	      stream = req;
	      stream.length = length;
	      break
	    default:
	      throw createError(415, 'unsupported content encoding "' + encoding + '"', {
	        encoding: encoding,
	        type: 'encoding.unsupported'
	      })
	  }

	  return stream
	}

	/**
	 * Dump the contents of a request.
	 *
	 * @param {object} req
	 * @param {function} callback
	 * @api private
	 */

	function dump (req, callback) {
	  if (onFinished.isFinished(req)) {
	    callback(null);
	  } else {
	    onFinished(req, callback);
	    req.resume();
	  }
	}
	return read_1;
}

var typeIs = {exports: {}};

var mediaTyper = {};

/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredMediaTyper;

function requireMediaTyper () {
	if (hasRequiredMediaTyper) return mediaTyper;
	hasRequiredMediaTyper = 1;
	/**
	 * RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
	 *
	 * parameter     = token "=" ( token | quoted-string )
	 * token         = 1*<any CHAR except CTLs or separators>
	 * separators    = "(" | ")" | "<" | ">" | "@"
	 *               | "," | ";" | ":" | "\" | <">
	 *               | "/" | "[" | "]" | "?" | "="
	 *               | "{" | "}" | SP | HT
	 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	 * qdtext        = <any TEXT except <">>
	 * quoted-pair   = "\" CHAR
	 * CHAR          = <any US-ASCII character (octets 0 - 127)>
	 * TEXT          = <any OCTET except CTLs, but including LWS>
	 * LWS           = [CRLF] 1*( SP | HT )
	 * CRLF          = CR LF
	 * CR            = <US-ASCII CR, carriage return (13)>
	 * LF            = <US-ASCII LF, linefeed (10)>
	 * SP            = <US-ASCII SP, space (32)>
	 * SHT           = <US-ASCII HT, horizontal-tab (9)>
	 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	 * OCTET         = <any 8-bit sequence of data>
	 */
	var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
	var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
	var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;

	/**
	 * RegExp to match quoted-pair in RFC 2616
	 *
	 * quoted-pair = "\" CHAR
	 * CHAR        = <any US-ASCII character (octets 0 - 127)>
	 */
	var qescRegExp = /\\([\u0000-\u007f])/g;

	/**
	 * RegExp to match chars that must be quoted-pair in RFC 2616
	 */
	var quoteRegExp = /([\\"])/g;

	/**
	 * RegExp to match type in RFC 6838
	 *
	 * type-name = restricted-name
	 * subtype-name = restricted-name
	 * restricted-name = restricted-name-first *126restricted-name-chars
	 * restricted-name-first  = ALPHA / DIGIT
	 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
	 *                          "$" / "&" / "-" / "^" / "_"
	 * restricted-name-chars =/ "." ; Characters before first dot always
	 *                              ; specify a facet name
	 * restricted-name-chars =/ "+" ; Characters after last plus always
	 *                              ; specify a structured syntax suffix
	 * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
	 * DIGIT =  %x30-39             ; 0-9
	 */
	var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
	var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
	var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;

	/**
	 * Module exports.
	 */

	mediaTyper.format = format;
	mediaTyper.parse = parse;

	/**
	 * Format object to media type.
	 *
	 * @param {object} obj
	 * @return {string}
	 * @api public
	 */

	function format(obj) {
	  if (!obj || typeof obj !== 'object') {
	    throw new TypeError('argument obj is required')
	  }

	  var parameters = obj.parameters;
	  var subtype = obj.subtype;
	  var suffix = obj.suffix;
	  var type = obj.type;

	  if (!type || !typeNameRegExp.test(type)) {
	    throw new TypeError('invalid type')
	  }

	  if (!subtype || !subtypeNameRegExp.test(subtype)) {
	    throw new TypeError('invalid subtype')
	  }

	  // format as type/subtype
	  var string = type + '/' + subtype;

	  // append +suffix
	  if (suffix) {
	    if (!typeNameRegExp.test(suffix)) {
	      throw new TypeError('invalid suffix')
	    }

	    string += '+' + suffix;
	  }

	  // append parameters
	  if (parameters && typeof parameters === 'object') {
	    var param;
	    var params = Object.keys(parameters).sort();

	    for (var i = 0; i < params.length; i++) {
	      param = params[i];

	      if (!tokenRegExp.test(param)) {
	        throw new TypeError('invalid parameter name')
	      }

	      string += '; ' + param + '=' + qstring(parameters[param]);
	    }
	  }

	  return string
	}

	/**
	 * Parse media type to object.
	 *
	 * @param {string|object} string
	 * @return {Object}
	 * @api public
	 */

	function parse(string) {
	  if (!string) {
	    throw new TypeError('argument string is required')
	  }

	  // support req/res-like objects as argument
	  if (typeof string === 'object') {
	    string = getcontenttype(string);
	  }

	  if (typeof string !== 'string') {
	    throw new TypeError('argument string is required to be a string')
	  }

	  var index = string.indexOf(';');
	  var type = index !== -1
	    ? string.substr(0, index)
	    : string;

	  var key;
	  var match;
	  var obj = splitType(type);
	  var params = {};
	  var value;

	  paramRegExp.lastIndex = index;

	  while (match = paramRegExp.exec(string)) {
	    if (match.index !== index) {
	      throw new TypeError('invalid parameter format')
	    }

	    index += match[0].length;
	    key = match[1].toLowerCase();
	    value = match[2];

	    if (value[0] === '"') {
	      // remove quotes and escapes
	      value = value
	        .substr(1, value.length - 2)
	        .replace(qescRegExp, '$1');
	    }

	    params[key] = value;
	  }

	  if (index !== -1 && index !== string.length) {
	    throw new TypeError('invalid parameter format')
	  }

	  obj.parameters = params;

	  return obj
	}

	/**
	 * Get content-type from req/res objects.
	 *
	 * @param {object}
	 * @return {Object}
	 * @api private
	 */

	function getcontenttype(obj) {
	  if (typeof obj.getHeader === 'function') {
	    // res-like
	    return obj.getHeader('content-type')
	  }

	  if (typeof obj.headers === 'object') {
	    // req-like
	    return obj.headers && obj.headers['content-type']
	  }
	}

	/**
	 * Quote a string if necessary.
	 *
	 * @param {string} val
	 * @return {string}
	 * @api private
	 */

	function qstring(val) {
	  var str = String(val);

	  // no need to quote tokens
	  if (tokenRegExp.test(str)) {
	    return str
	  }

	  if (str.length > 0 && !textRegExp.test(str)) {
	    throw new TypeError('invalid parameter value')
	  }

	  return '"' + str.replace(quoteRegExp, '\\$1') + '"'
	}

	/**
	 * Simply "type/subtype+siffx" into parts.
	 *
	 * @param {string} string
	 * @return {Object}
	 * @api private
	 */

	function splitType(string) {
	  var match = typeRegExp.exec(string.toLowerCase());

	  if (!match) {
	    throw new TypeError('invalid media type')
	  }

	  var type = match[1];
	  var subtype = match[2];
	  var suffix;

	  // suffix after last +
	  var index = subtype.lastIndexOf('+');
	  if (index !== -1) {
	    suffix = subtype.substr(index + 1);
	    subtype = subtype.substr(0, index);
	  }

	  var obj = {
	    type: type,
	    subtype: subtype,
	    suffix: suffix
	  };

	  return obj
	}
	return mediaTyper;
}

var mimeTypes = {};

var require$$0$1 = {
	"application/1d-interleaved-parityfec": {
	source: "iana"
},
	"application/3gpdash-qoe-report+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/3gpp-ims+xml": {
	source: "iana",
	compressible: true
},
	"application/3gpphal+json": {
	source: "iana",
	compressible: true
},
	"application/3gpphalforms+json": {
	source: "iana",
	compressible: true
},
	"application/a2l": {
	source: "iana"
},
	"application/ace+cbor": {
	source: "iana"
},
	"application/activemessage": {
	source: "iana"
},
	"application/activity+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-directory+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcost+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcostparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointprop+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointpropparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-error+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamcontrol+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamparams+json": {
	source: "iana",
	compressible: true
},
	"application/aml": {
	source: "iana"
},
	"application/andrew-inset": {
	source: "iana",
	extensions: [
		"ez"
	]
},
	"application/applefile": {
	source: "iana"
},
	"application/applixware": {
	source: "apache",
	extensions: [
		"aw"
	]
},
	"application/at+jwt": {
	source: "iana"
},
	"application/atf": {
	source: "iana"
},
	"application/atfx": {
	source: "iana"
},
	"application/atom+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atom"
	]
},
	"application/atomcat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomcat"
	]
},
	"application/atomdeleted+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomdeleted"
	]
},
	"application/atomicmail": {
	source: "iana"
},
	"application/atomsvc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomsvc"
	]
},
	"application/atsc-dwd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dwd"
	]
},
	"application/atsc-dynamic-event-message": {
	source: "iana"
},
	"application/atsc-held+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"held"
	]
},
	"application/atsc-rdt+json": {
	source: "iana",
	compressible: true
},
	"application/atsc-rsat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsat"
	]
},
	"application/atxml": {
	source: "iana"
},
	"application/auth-policy+xml": {
	source: "iana",
	compressible: true
},
	"application/bacnet-xdd+zip": {
	source: "iana",
	compressible: false
},
	"application/batch-smtp": {
	source: "iana"
},
	"application/bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/beep+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/calendar+json": {
	source: "iana",
	compressible: true
},
	"application/calendar+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xcs"
	]
},
	"application/call-completion": {
	source: "iana"
},
	"application/cals-1840": {
	source: "iana"
},
	"application/captive+json": {
	source: "iana",
	compressible: true
},
	"application/cbor": {
	source: "iana"
},
	"application/cbor-seq": {
	source: "iana"
},
	"application/cccex": {
	source: "iana"
},
	"application/ccmp+xml": {
	source: "iana",
	compressible: true
},
	"application/ccxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ccxml"
	]
},
	"application/cdfx+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdfx"
	]
},
	"application/cdmi-capability": {
	source: "iana",
	extensions: [
		"cdmia"
	]
},
	"application/cdmi-container": {
	source: "iana",
	extensions: [
		"cdmic"
	]
},
	"application/cdmi-domain": {
	source: "iana",
	extensions: [
		"cdmid"
	]
},
	"application/cdmi-object": {
	source: "iana",
	extensions: [
		"cdmio"
	]
},
	"application/cdmi-queue": {
	source: "iana",
	extensions: [
		"cdmiq"
	]
},
	"application/cdni": {
	source: "iana"
},
	"application/cea": {
	source: "iana"
},
	"application/cea-2018+xml": {
	source: "iana",
	compressible: true
},
	"application/cellml+xml": {
	source: "iana",
	compressible: true
},
	"application/cfw": {
	source: "iana"
},
	"application/city+json": {
	source: "iana",
	compressible: true
},
	"application/clr": {
	source: "iana"
},
	"application/clue+xml": {
	source: "iana",
	compressible: true
},
	"application/clue_info+xml": {
	source: "iana",
	compressible: true
},
	"application/cms": {
	source: "iana"
},
	"application/cnrp+xml": {
	source: "iana",
	compressible: true
},
	"application/coap-group+json": {
	source: "iana",
	compressible: true
},
	"application/coap-payload": {
	source: "iana"
},
	"application/commonground": {
	source: "iana"
},
	"application/conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/cose": {
	source: "iana"
},
	"application/cose-key": {
	source: "iana"
},
	"application/cose-key-set": {
	source: "iana"
},
	"application/cpl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cpl"
	]
},
	"application/csrattrs": {
	source: "iana"
},
	"application/csta+xml": {
	source: "iana",
	compressible: true
},
	"application/cstadata+xml": {
	source: "iana",
	compressible: true
},
	"application/csvm+json": {
	source: "iana",
	compressible: true
},
	"application/cu-seeme": {
	source: "apache",
	extensions: [
		"cu"
	]
},
	"application/cwt": {
	source: "iana"
},
	"application/cybercash": {
	source: "iana"
},
	"application/dart": {
	compressible: true
},
	"application/dash+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpd"
	]
},
	"application/dash-patch+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpp"
	]
},
	"application/dashdelta": {
	source: "iana"
},
	"application/davmount+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"davmount"
	]
},
	"application/dca-rft": {
	source: "iana"
},
	"application/dcd": {
	source: "iana"
},
	"application/dec-dx": {
	source: "iana"
},
	"application/dialog-info+xml": {
	source: "iana",
	compressible: true
},
	"application/dicom": {
	source: "iana"
},
	"application/dicom+json": {
	source: "iana",
	compressible: true
},
	"application/dicom+xml": {
	source: "iana",
	compressible: true
},
	"application/dii": {
	source: "iana"
},
	"application/dit": {
	source: "iana"
},
	"application/dns": {
	source: "iana"
},
	"application/dns+json": {
	source: "iana",
	compressible: true
},
	"application/dns-message": {
	source: "iana"
},
	"application/docbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dbk"
	]
},
	"application/dots+cbor": {
	source: "iana"
},
	"application/dskpp+xml": {
	source: "iana",
	compressible: true
},
	"application/dssc+der": {
	source: "iana",
	extensions: [
		"dssc"
	]
},
	"application/dssc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdssc"
	]
},
	"application/dvcs": {
	source: "iana"
},
	"application/ecmascript": {
	source: "iana",
	compressible: true,
	extensions: [
		"es",
		"ecma"
	]
},
	"application/edi-consent": {
	source: "iana"
},
	"application/edi-x12": {
	source: "iana",
	compressible: false
},
	"application/edifact": {
	source: "iana",
	compressible: false
},
	"application/efi": {
	source: "iana"
},
	"application/elm+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/elm+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.cap+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/emergencycalldata.comment+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.control+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.deviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.ecall.msd": {
	source: "iana"
},
	"application/emergencycalldata.providerinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.serviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.subscriberinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.veds+xml": {
	source: "iana",
	compressible: true
},
	"application/emma+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emma"
	]
},
	"application/emotionml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emotionml"
	]
},
	"application/encaprtp": {
	source: "iana"
},
	"application/epp+xml": {
	source: "iana",
	compressible: true
},
	"application/epub+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"epub"
	]
},
	"application/eshop": {
	source: "iana"
},
	"application/exi": {
	source: "iana",
	extensions: [
		"exi"
	]
},
	"application/expect-ct-report+json": {
	source: "iana",
	compressible: true
},
	"application/express": {
	source: "iana",
	extensions: [
		"exp"
	]
},
	"application/fastinfoset": {
	source: "iana"
},
	"application/fastsoap": {
	source: "iana"
},
	"application/fdt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fdt"
	]
},
	"application/fhir+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fhir+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fido.trusted-apps+json": {
	compressible: true
},
	"application/fits": {
	source: "iana"
},
	"application/flexfec": {
	source: "iana"
},
	"application/font-sfnt": {
	source: "iana"
},
	"application/font-tdpfr": {
	source: "iana",
	extensions: [
		"pfr"
	]
},
	"application/font-woff": {
	source: "iana",
	compressible: false
},
	"application/framework-attributes+xml": {
	source: "iana",
	compressible: true
},
	"application/geo+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"geojson"
	]
},
	"application/geo+json-seq": {
	source: "iana"
},
	"application/geopackage+sqlite3": {
	source: "iana"
},
	"application/geoxacml+xml": {
	source: "iana",
	compressible: true
},
	"application/gltf-buffer": {
	source: "iana"
},
	"application/gml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"gml"
	]
},
	"application/gpx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"gpx"
	]
},
	"application/gxf": {
	source: "apache",
	extensions: [
		"gxf"
	]
},
	"application/gzip": {
	source: "iana",
	compressible: false,
	extensions: [
		"gz"
	]
},
	"application/h224": {
	source: "iana"
},
	"application/held+xml": {
	source: "iana",
	compressible: true
},
	"application/hjson": {
	extensions: [
		"hjson"
	]
},
	"application/http": {
	source: "iana"
},
	"application/hyperstudio": {
	source: "iana",
	extensions: [
		"stk"
	]
},
	"application/ibe-key-request+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pkg-reply+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pp-data": {
	source: "iana"
},
	"application/iges": {
	source: "iana"
},
	"application/im-iscomposing+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/index": {
	source: "iana"
},
	"application/index.cmd": {
	source: "iana"
},
	"application/index.obj": {
	source: "iana"
},
	"application/index.response": {
	source: "iana"
},
	"application/index.vnd": {
	source: "iana"
},
	"application/inkml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ink",
		"inkml"
	]
},
	"application/iotp": {
	source: "iana"
},
	"application/ipfix": {
	source: "iana",
	extensions: [
		"ipfix"
	]
},
	"application/ipp": {
	source: "iana"
},
	"application/isup": {
	source: "iana"
},
	"application/its+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"its"
	]
},
	"application/java-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"jar",
		"war",
		"ear"
	]
},
	"application/java-serialized-object": {
	source: "apache",
	compressible: false,
	extensions: [
		"ser"
	]
},
	"application/java-vm": {
	source: "apache",
	compressible: false,
	extensions: [
		"class"
	]
},
	"application/javascript": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"js",
		"mjs"
	]
},
	"application/jf2feed+json": {
	source: "iana",
	compressible: true
},
	"application/jose": {
	source: "iana"
},
	"application/jose+json": {
	source: "iana",
	compressible: true
},
	"application/jrd+json": {
	source: "iana",
	compressible: true
},
	"application/jscalendar+json": {
	source: "iana",
	compressible: true
},
	"application/json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"json",
		"map"
	]
},
	"application/json-patch+json": {
	source: "iana",
	compressible: true
},
	"application/json-seq": {
	source: "iana"
},
	"application/json5": {
	extensions: [
		"json5"
	]
},
	"application/jsonml+json": {
	source: "apache",
	compressible: true,
	extensions: [
		"jsonml"
	]
},
	"application/jwk+json": {
	source: "iana",
	compressible: true
},
	"application/jwk-set+json": {
	source: "iana",
	compressible: true
},
	"application/jwt": {
	source: "iana"
},
	"application/kpml-request+xml": {
	source: "iana",
	compressible: true
},
	"application/kpml-response+xml": {
	source: "iana",
	compressible: true
},
	"application/ld+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"jsonld"
	]
},
	"application/lgr+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lgr"
	]
},
	"application/link-format": {
	source: "iana"
},
	"application/load-control+xml": {
	source: "iana",
	compressible: true
},
	"application/lost+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lostxml"
	]
},
	"application/lostsync+xml": {
	source: "iana",
	compressible: true
},
	"application/lpf+zip": {
	source: "iana",
	compressible: false
},
	"application/lxf": {
	source: "iana"
},
	"application/mac-binhex40": {
	source: "iana",
	extensions: [
		"hqx"
	]
},
	"application/mac-compactpro": {
	source: "apache",
	extensions: [
		"cpt"
	]
},
	"application/macwriteii": {
	source: "iana"
},
	"application/mads+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mads"
	]
},
	"application/manifest+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"webmanifest"
	]
},
	"application/marc": {
	source: "iana",
	extensions: [
		"mrc"
	]
},
	"application/marcxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mrcx"
	]
},
	"application/mathematica": {
	source: "iana",
	extensions: [
		"ma",
		"nb",
		"mb"
	]
},
	"application/mathml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mathml"
	]
},
	"application/mathml-content+xml": {
	source: "iana",
	compressible: true
},
	"application/mathml-presentation+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-associated-procedure-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-deregister+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-envelope+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-protection-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-reception-report+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-schedule+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-user-service-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbox": {
	source: "iana",
	extensions: [
		"mbox"
	]
},
	"application/media-policy-dataset+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpf"
	]
},
	"application/media_control+xml": {
	source: "iana",
	compressible: true
},
	"application/mediaservercontrol+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mscml"
	]
},
	"application/merge-patch+json": {
	source: "iana",
	compressible: true
},
	"application/metalink+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"metalink"
	]
},
	"application/metalink4+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"meta4"
	]
},
	"application/mets+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mets"
	]
},
	"application/mf4": {
	source: "iana"
},
	"application/mikey": {
	source: "iana"
},
	"application/mipc": {
	source: "iana"
},
	"application/missing-blocks+cbor-seq": {
	source: "iana"
},
	"application/mmt-aei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"maei"
	]
},
	"application/mmt-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musd"
	]
},
	"application/mods+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mods"
	]
},
	"application/moss-keys": {
	source: "iana"
},
	"application/moss-signature": {
	source: "iana"
},
	"application/mosskey-data": {
	source: "iana"
},
	"application/mosskey-request": {
	source: "iana"
},
	"application/mp21": {
	source: "iana",
	extensions: [
		"m21",
		"mp21"
	]
},
	"application/mp4": {
	source: "iana",
	extensions: [
		"mp4s",
		"m4p"
	]
},
	"application/mpeg4-generic": {
	source: "iana"
},
	"application/mpeg4-iod": {
	source: "iana"
},
	"application/mpeg4-iod-xmt": {
	source: "iana"
},
	"application/mrb-consumer+xml": {
	source: "iana",
	compressible: true
},
	"application/mrb-publish+xml": {
	source: "iana",
	compressible: true
},
	"application/msc-ivr+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msc-mixer+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msword": {
	source: "iana",
	compressible: false,
	extensions: [
		"doc",
		"dot"
	]
},
	"application/mud+json": {
	source: "iana",
	compressible: true
},
	"application/multipart-core": {
	source: "iana"
},
	"application/mxf": {
	source: "iana",
	extensions: [
		"mxf"
	]
},
	"application/n-quads": {
	source: "iana",
	extensions: [
		"nq"
	]
},
	"application/n-triples": {
	source: "iana",
	extensions: [
		"nt"
	]
},
	"application/nasdata": {
	source: "iana"
},
	"application/news-checkgroups": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-groupinfo": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-transmission": {
	source: "iana"
},
	"application/nlsml+xml": {
	source: "iana",
	compressible: true
},
	"application/node": {
	source: "iana",
	extensions: [
		"cjs"
	]
},
	"application/nss": {
	source: "iana"
},
	"application/oauth-authz-req+jwt": {
	source: "iana"
},
	"application/oblivious-dns-message": {
	source: "iana"
},
	"application/ocsp-request": {
	source: "iana"
},
	"application/ocsp-response": {
	source: "iana"
},
	"application/octet-stream": {
	source: "iana",
	compressible: false,
	extensions: [
		"bin",
		"dms",
		"lrf",
		"mar",
		"so",
		"dist",
		"distz",
		"pkg",
		"bpk",
		"dump",
		"elc",
		"deploy",
		"exe",
		"dll",
		"deb",
		"dmg",
		"iso",
		"img",
		"msi",
		"msp",
		"msm",
		"buffer"
	]
},
	"application/oda": {
	source: "iana",
	extensions: [
		"oda"
	]
},
	"application/odm+xml": {
	source: "iana",
	compressible: true
},
	"application/odx": {
	source: "iana"
},
	"application/oebps-package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"opf"
	]
},
	"application/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogx"
	]
},
	"application/omdoc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"omdoc"
	]
},
	"application/onenote": {
	source: "apache",
	extensions: [
		"onetoc",
		"onetoc2",
		"onetmp",
		"onepkg"
	]
},
	"application/opc-nodeset+xml": {
	source: "iana",
	compressible: true
},
	"application/oscore": {
	source: "iana"
},
	"application/oxps": {
	source: "iana",
	extensions: [
		"oxps"
	]
},
	"application/p21": {
	source: "iana"
},
	"application/p21+zip": {
	source: "iana",
	compressible: false
},
	"application/p2p-overlay+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"relo"
	]
},
	"application/parityfec": {
	source: "iana"
},
	"application/passport": {
	source: "iana"
},
	"application/patch-ops-error+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xer"
	]
},
	"application/pdf": {
	source: "iana",
	compressible: false,
	extensions: [
		"pdf"
	]
},
	"application/pdx": {
	source: "iana"
},
	"application/pem-certificate-chain": {
	source: "iana"
},
	"application/pgp-encrypted": {
	source: "iana",
	compressible: false,
	extensions: [
		"pgp"
	]
},
	"application/pgp-keys": {
	source: "iana",
	extensions: [
		"asc"
	]
},
	"application/pgp-signature": {
	source: "iana",
	extensions: [
		"asc",
		"sig"
	]
},
	"application/pics-rules": {
	source: "apache",
	extensions: [
		"prf"
	]
},
	"application/pidf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pidf-diff+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pkcs10": {
	source: "iana",
	extensions: [
		"p10"
	]
},
	"application/pkcs12": {
	source: "iana"
},
	"application/pkcs7-mime": {
	source: "iana",
	extensions: [
		"p7m",
		"p7c"
	]
},
	"application/pkcs7-signature": {
	source: "iana",
	extensions: [
		"p7s"
	]
},
	"application/pkcs8": {
	source: "iana",
	extensions: [
		"p8"
	]
},
	"application/pkcs8-encrypted": {
	source: "iana"
},
	"application/pkix-attr-cert": {
	source: "iana",
	extensions: [
		"ac"
	]
},
	"application/pkix-cert": {
	source: "iana",
	extensions: [
		"cer"
	]
},
	"application/pkix-crl": {
	source: "iana",
	extensions: [
		"crl"
	]
},
	"application/pkix-pkipath": {
	source: "iana",
	extensions: [
		"pkipath"
	]
},
	"application/pkixcmp": {
	source: "iana",
	extensions: [
		"pki"
	]
},
	"application/pls+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pls"
	]
},
	"application/poc-settings+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/postscript": {
	source: "iana",
	compressible: true,
	extensions: [
		"ai",
		"eps",
		"ps"
	]
},
	"application/ppsp-tracker+json": {
	source: "iana",
	compressible: true
},
	"application/problem+json": {
	source: "iana",
	compressible: true
},
	"application/problem+xml": {
	source: "iana",
	compressible: true
},
	"application/provenance+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"provx"
	]
},
	"application/prs.alvestrand.titrax-sheet": {
	source: "iana"
},
	"application/prs.cww": {
	source: "iana",
	extensions: [
		"cww"
	]
},
	"application/prs.cyn": {
	source: "iana",
	charset: "7-BIT"
},
	"application/prs.hpub+zip": {
	source: "iana",
	compressible: false
},
	"application/prs.nprend": {
	source: "iana"
},
	"application/prs.plucker": {
	source: "iana"
},
	"application/prs.rdf-xml-crypt": {
	source: "iana"
},
	"application/prs.xsf+xml": {
	source: "iana",
	compressible: true
},
	"application/pskc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pskcxml"
	]
},
	"application/pvd+json": {
	source: "iana",
	compressible: true
},
	"application/qsig": {
	source: "iana"
},
	"application/raml+yaml": {
	compressible: true,
	extensions: [
		"raml"
	]
},
	"application/raptorfec": {
	source: "iana"
},
	"application/rdap+json": {
	source: "iana",
	compressible: true
},
	"application/rdf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rdf",
		"owl"
	]
},
	"application/reginfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rif"
	]
},
	"application/relax-ng-compact-syntax": {
	source: "iana",
	extensions: [
		"rnc"
	]
},
	"application/remote-printing": {
	source: "iana"
},
	"application/reputon+json": {
	source: "iana",
	compressible: true
},
	"application/resource-lists+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rl"
	]
},
	"application/resource-lists-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rld"
	]
},
	"application/rfc+xml": {
	source: "iana",
	compressible: true
},
	"application/riscos": {
	source: "iana"
},
	"application/rlmi+xml": {
	source: "iana",
	compressible: true
},
	"application/rls-services+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rs"
	]
},
	"application/route-apd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rapd"
	]
},
	"application/route-s-tsid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sls"
	]
},
	"application/route-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rusd"
	]
},
	"application/rpki-ghostbusters": {
	source: "iana",
	extensions: [
		"gbr"
	]
},
	"application/rpki-manifest": {
	source: "iana",
	extensions: [
		"mft"
	]
},
	"application/rpki-publication": {
	source: "iana"
},
	"application/rpki-roa": {
	source: "iana",
	extensions: [
		"roa"
	]
},
	"application/rpki-updown": {
	source: "iana"
},
	"application/rsd+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rsd"
	]
},
	"application/rss+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rss"
	]
},
	"application/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"application/rtploopback": {
	source: "iana"
},
	"application/rtx": {
	source: "iana"
},
	"application/samlassertion+xml": {
	source: "iana",
	compressible: true
},
	"application/samlmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/sarif+json": {
	source: "iana",
	compressible: true
},
	"application/sarif-external-properties+json": {
	source: "iana",
	compressible: true
},
	"application/sbe": {
	source: "iana"
},
	"application/sbml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sbml"
	]
},
	"application/scaip+xml": {
	source: "iana",
	compressible: true
},
	"application/scim+json": {
	source: "iana",
	compressible: true
},
	"application/scvp-cv-request": {
	source: "iana",
	extensions: [
		"scq"
	]
},
	"application/scvp-cv-response": {
	source: "iana",
	extensions: [
		"scs"
	]
},
	"application/scvp-vp-request": {
	source: "iana",
	extensions: [
		"spq"
	]
},
	"application/scvp-vp-response": {
	source: "iana",
	extensions: [
		"spp"
	]
},
	"application/sdp": {
	source: "iana",
	extensions: [
		"sdp"
	]
},
	"application/secevent+jwt": {
	source: "iana"
},
	"application/senml+cbor": {
	source: "iana"
},
	"application/senml+json": {
	source: "iana",
	compressible: true
},
	"application/senml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"senmlx"
	]
},
	"application/senml-etch+cbor": {
	source: "iana"
},
	"application/senml-etch+json": {
	source: "iana",
	compressible: true
},
	"application/senml-exi": {
	source: "iana"
},
	"application/sensml+cbor": {
	source: "iana"
},
	"application/sensml+json": {
	source: "iana",
	compressible: true
},
	"application/sensml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sensmlx"
	]
},
	"application/sensml-exi": {
	source: "iana"
},
	"application/sep+xml": {
	source: "iana",
	compressible: true
},
	"application/sep-exi": {
	source: "iana"
},
	"application/session-info": {
	source: "iana"
},
	"application/set-payment": {
	source: "iana"
},
	"application/set-payment-initiation": {
	source: "iana",
	extensions: [
		"setpay"
	]
},
	"application/set-registration": {
	source: "iana"
},
	"application/set-registration-initiation": {
	source: "iana",
	extensions: [
		"setreg"
	]
},
	"application/sgml": {
	source: "iana"
},
	"application/sgml-open-catalog": {
	source: "iana"
},
	"application/shf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"shf"
	]
},
	"application/sieve": {
	source: "iana",
	extensions: [
		"siv",
		"sieve"
	]
},
	"application/simple-filter+xml": {
	source: "iana",
	compressible: true
},
	"application/simple-message-summary": {
	source: "iana"
},
	"application/simplesymbolcontainer": {
	source: "iana"
},
	"application/sipc": {
	source: "iana"
},
	"application/slate": {
	source: "iana"
},
	"application/smil": {
	source: "iana"
},
	"application/smil+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"smi",
		"smil"
	]
},
	"application/smpte336m": {
	source: "iana"
},
	"application/soap+fastinfoset": {
	source: "iana"
},
	"application/soap+xml": {
	source: "iana",
	compressible: true
},
	"application/sparql-query": {
	source: "iana",
	extensions: [
		"rq"
	]
},
	"application/sparql-results+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"srx"
	]
},
	"application/spdx+json": {
	source: "iana",
	compressible: true
},
	"application/spirits-event+xml": {
	source: "iana",
	compressible: true
},
	"application/sql": {
	source: "iana"
},
	"application/srgs": {
	source: "iana",
	extensions: [
		"gram"
	]
},
	"application/srgs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"grxml"
	]
},
	"application/sru+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sru"
	]
},
	"application/ssdl+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ssdl"
	]
},
	"application/ssml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ssml"
	]
},
	"application/stix+json": {
	source: "iana",
	compressible: true
},
	"application/swid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"swidtag"
	]
},
	"application/tamp-apex-update": {
	source: "iana"
},
	"application/tamp-apex-update-confirm": {
	source: "iana"
},
	"application/tamp-community-update": {
	source: "iana"
},
	"application/tamp-community-update-confirm": {
	source: "iana"
},
	"application/tamp-error": {
	source: "iana"
},
	"application/tamp-sequence-adjust": {
	source: "iana"
},
	"application/tamp-sequence-adjust-confirm": {
	source: "iana"
},
	"application/tamp-status-query": {
	source: "iana"
},
	"application/tamp-status-response": {
	source: "iana"
},
	"application/tamp-update": {
	source: "iana"
},
	"application/tamp-update-confirm": {
	source: "iana"
},
	"application/tar": {
	compressible: true
},
	"application/taxii+json": {
	source: "iana",
	compressible: true
},
	"application/td+json": {
	source: "iana",
	compressible: true
},
	"application/tei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tei",
		"teicorpus"
	]
},
	"application/tetra_isi": {
	source: "iana"
},
	"application/thraud+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tfi"
	]
},
	"application/timestamp-query": {
	source: "iana"
},
	"application/timestamp-reply": {
	source: "iana"
},
	"application/timestamped-data": {
	source: "iana",
	extensions: [
		"tsd"
	]
},
	"application/tlsrpt+gzip": {
	source: "iana"
},
	"application/tlsrpt+json": {
	source: "iana",
	compressible: true
},
	"application/tnauthlist": {
	source: "iana"
},
	"application/token-introspection+jwt": {
	source: "iana"
},
	"application/toml": {
	compressible: true,
	extensions: [
		"toml"
	]
},
	"application/trickle-ice-sdpfrag": {
	source: "iana"
},
	"application/trig": {
	source: "iana",
	extensions: [
		"trig"
	]
},
	"application/ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttml"
	]
},
	"application/tve-trigger": {
	source: "iana"
},
	"application/tzif": {
	source: "iana"
},
	"application/tzif-leap": {
	source: "iana"
},
	"application/ubjson": {
	compressible: false,
	extensions: [
		"ubj"
	]
},
	"application/ulpfec": {
	source: "iana"
},
	"application/urc-grpsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/urc-ressheet+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsheet"
	]
},
	"application/urc-targetdesc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"td"
	]
},
	"application/urc-uisocketdesc+xml": {
	source: "iana",
	compressible: true
},
	"application/vcard+json": {
	source: "iana",
	compressible: true
},
	"application/vcard+xml": {
	source: "iana",
	compressible: true
},
	"application/vemmi": {
	source: "iana"
},
	"application/vividence.scriptfile": {
	source: "apache"
},
	"application/vnd.1000minds.decision-model+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"1km"
	]
},
	"application/vnd.3gpp-prose+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-prose-pc3ch+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-v2x-local-service-information": {
	source: "iana"
},
	"application/vnd.3gpp.5gnas": {
	source: "iana"
},
	"application/vnd.3gpp.access-transfer-events+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.bsf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gmop+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gtpc": {
	source: "iana"
},
	"application/vnd.3gpp.interworking-data": {
	source: "iana"
},
	"application/vnd.3gpp.lpp": {
	source: "iana"
},
	"application/vnd.3gpp.mc-signalling-ear": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-payload": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-signalling": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-floor-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-signed+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-init-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-transmission-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mid-call+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ngap": {
	source: "iana"
},
	"application/vnd.3gpp.pfcp": {
	source: "iana"
},
	"application/vnd.3gpp.pic-bw-large": {
	source: "iana",
	extensions: [
		"plb"
	]
},
	"application/vnd.3gpp.pic-bw-small": {
	source: "iana",
	extensions: [
		"psb"
	]
},
	"application/vnd.3gpp.pic-bw-var": {
	source: "iana",
	extensions: [
		"pvb"
	]
},
	"application/vnd.3gpp.s1ap": {
	source: "iana"
},
	"application/vnd.3gpp.sms": {
	source: "iana"
},
	"application/vnd.3gpp.sms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-ext+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.state-and-event-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ussd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.bcmcsinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.sms": {
	source: "iana"
},
	"application/vnd.3gpp2.tcap": {
	source: "iana",
	extensions: [
		"tcap"
	]
},
	"application/vnd.3lightssoftware.imagescal": {
	source: "iana"
},
	"application/vnd.3m.post-it-notes": {
	source: "iana",
	extensions: [
		"pwn"
	]
},
	"application/vnd.accpac.simply.aso": {
	source: "iana",
	extensions: [
		"aso"
	]
},
	"application/vnd.accpac.simply.imp": {
	source: "iana",
	extensions: [
		"imp"
	]
},
	"application/vnd.acucobol": {
	source: "iana",
	extensions: [
		"acu"
	]
},
	"application/vnd.acucorp": {
	source: "iana",
	extensions: [
		"atc",
		"acutc"
	]
},
	"application/vnd.adobe.air-application-installer-package+zip": {
	source: "apache",
	compressible: false,
	extensions: [
		"air"
	]
},
	"application/vnd.adobe.flash.movie": {
	source: "iana"
},
	"application/vnd.adobe.formscentral.fcdt": {
	source: "iana",
	extensions: [
		"fcdt"
	]
},
	"application/vnd.adobe.fxp": {
	source: "iana",
	extensions: [
		"fxp",
		"fxpl"
	]
},
	"application/vnd.adobe.partial-upload": {
	source: "iana"
},
	"application/vnd.adobe.xdp+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdp"
	]
},
	"application/vnd.adobe.xfdf": {
	source: "iana",
	extensions: [
		"xfdf"
	]
},
	"application/vnd.aether.imp": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata-pagedef": {
	source: "iana"
},
	"application/vnd.afpc.cmoca-cmresource": {
	source: "iana"
},
	"application/vnd.afpc.foca-charset": {
	source: "iana"
},
	"application/vnd.afpc.foca-codedfont": {
	source: "iana"
},
	"application/vnd.afpc.foca-codepage": {
	source: "iana"
},
	"application/vnd.afpc.modca": {
	source: "iana"
},
	"application/vnd.afpc.modca-cmtable": {
	source: "iana"
},
	"application/vnd.afpc.modca-formdef": {
	source: "iana"
},
	"application/vnd.afpc.modca-mediummap": {
	source: "iana"
},
	"application/vnd.afpc.modca-objectcontainer": {
	source: "iana"
},
	"application/vnd.afpc.modca-overlay": {
	source: "iana"
},
	"application/vnd.afpc.modca-pagesegment": {
	source: "iana"
},
	"application/vnd.age": {
	source: "iana",
	extensions: [
		"age"
	]
},
	"application/vnd.ah-barcode": {
	source: "iana"
},
	"application/vnd.ahead.space": {
	source: "iana",
	extensions: [
		"ahead"
	]
},
	"application/vnd.airzip.filesecure.azf": {
	source: "iana",
	extensions: [
		"azf"
	]
},
	"application/vnd.airzip.filesecure.azs": {
	source: "iana",
	extensions: [
		"azs"
	]
},
	"application/vnd.amadeus+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.amazon.ebook": {
	source: "apache",
	extensions: [
		"azw"
	]
},
	"application/vnd.amazon.mobi8-ebook": {
	source: "iana"
},
	"application/vnd.americandynamics.acc": {
	source: "iana",
	extensions: [
		"acc"
	]
},
	"application/vnd.amiga.ami": {
	source: "iana",
	extensions: [
		"ami"
	]
},
	"application/vnd.amundsen.maze+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.android.ota": {
	source: "iana"
},
	"application/vnd.android.package-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"apk"
	]
},
	"application/vnd.anki": {
	source: "iana"
},
	"application/vnd.anser-web-certificate-issue-initiation": {
	source: "iana",
	extensions: [
		"cii"
	]
},
	"application/vnd.anser-web-funds-transfer-initiation": {
	source: "apache",
	extensions: [
		"fti"
	]
},
	"application/vnd.antix.game-component": {
	source: "iana",
	extensions: [
		"atx"
	]
},
	"application/vnd.apache.arrow.file": {
	source: "iana"
},
	"application/vnd.apache.arrow.stream": {
	source: "iana"
},
	"application/vnd.apache.thrift.binary": {
	source: "iana"
},
	"application/vnd.apache.thrift.compact": {
	source: "iana"
},
	"application/vnd.apache.thrift.json": {
	source: "iana"
},
	"application/vnd.api+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.aplextor.warrp+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apothekende.reservation+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apple.installer+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpkg"
	]
},
	"application/vnd.apple.keynote": {
	source: "iana",
	extensions: [
		"key"
	]
},
	"application/vnd.apple.mpegurl": {
	source: "iana",
	extensions: [
		"m3u8"
	]
},
	"application/vnd.apple.numbers": {
	source: "iana",
	extensions: [
		"numbers"
	]
},
	"application/vnd.apple.pages": {
	source: "iana",
	extensions: [
		"pages"
	]
},
	"application/vnd.apple.pkpass": {
	compressible: false,
	extensions: [
		"pkpass"
	]
},
	"application/vnd.arastra.swi": {
	source: "iana"
},
	"application/vnd.aristanetworks.swi": {
	source: "iana",
	extensions: [
		"swi"
	]
},
	"application/vnd.artisan+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.artsquare": {
	source: "iana"
},
	"application/vnd.astraea-software.iota": {
	source: "iana",
	extensions: [
		"iota"
	]
},
	"application/vnd.audiograph": {
	source: "iana",
	extensions: [
		"aep"
	]
},
	"application/vnd.autopackage": {
	source: "iana"
},
	"application/vnd.avalon+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.avistar+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.balsamiq.bmml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmml"
	]
},
	"application/vnd.balsamiq.bmpr": {
	source: "iana"
},
	"application/vnd.banana-accounting": {
	source: "iana"
},
	"application/vnd.bbf.usp.error": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bekitzur-stech+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bint.med-content": {
	source: "iana"
},
	"application/vnd.biopax.rdf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.blink-idb-value-wrapper": {
	source: "iana"
},
	"application/vnd.blueice.multipass": {
	source: "iana",
	extensions: [
		"mpm"
	]
},
	"application/vnd.bluetooth.ep.oob": {
	source: "iana"
},
	"application/vnd.bluetooth.le.oob": {
	source: "iana"
},
	"application/vnd.bmi": {
	source: "iana",
	extensions: [
		"bmi"
	]
},
	"application/vnd.bpf": {
	source: "iana"
},
	"application/vnd.bpf3": {
	source: "iana"
},
	"application/vnd.businessobjects": {
	source: "iana",
	extensions: [
		"rep"
	]
},
	"application/vnd.byu.uapi+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cab-jscript": {
	source: "iana"
},
	"application/vnd.canon-cpdl": {
	source: "iana"
},
	"application/vnd.canon-lips": {
	source: "iana"
},
	"application/vnd.capasystems-pg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cendio.thinlinc.clientconf": {
	source: "iana"
},
	"application/vnd.century-systems.tcp_stream": {
	source: "iana"
},
	"application/vnd.chemdraw+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdxml"
	]
},
	"application/vnd.chess-pgn": {
	source: "iana"
},
	"application/vnd.chipnuts.karaoke-mmd": {
	source: "iana",
	extensions: [
		"mmd"
	]
},
	"application/vnd.ciedi": {
	source: "iana"
},
	"application/vnd.cinderella": {
	source: "iana",
	extensions: [
		"cdy"
	]
},
	"application/vnd.cirpack.isdn-ext": {
	source: "iana"
},
	"application/vnd.citationstyles.style+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"csl"
	]
},
	"application/vnd.claymore": {
	source: "iana",
	extensions: [
		"cla"
	]
},
	"application/vnd.cloanto.rp9": {
	source: "iana",
	extensions: [
		"rp9"
	]
},
	"application/vnd.clonk.c4group": {
	source: "iana",
	extensions: [
		"c4g",
		"c4d",
		"c4f",
		"c4p",
		"c4u"
	]
},
	"application/vnd.cluetrust.cartomobile-config": {
	source: "iana",
	extensions: [
		"c11amc"
	]
},
	"application/vnd.cluetrust.cartomobile-config-pkg": {
	source: "iana",
	extensions: [
		"c11amz"
	]
},
	"application/vnd.coffeescript": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet-template": {
	source: "iana"
},
	"application/vnd.collection+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.doc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.next+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.comicbook+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.comicbook-rar": {
	source: "iana"
},
	"application/vnd.commerce-battelle": {
	source: "iana"
},
	"application/vnd.commonspace": {
	source: "iana",
	extensions: [
		"csp"
	]
},
	"application/vnd.contact.cmsg": {
	source: "iana",
	extensions: [
		"cdbcmsg"
	]
},
	"application/vnd.coreos.ignition+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cosmocaller": {
	source: "iana",
	extensions: [
		"cmc"
	]
},
	"application/vnd.crick.clicker": {
	source: "iana",
	extensions: [
		"clkx"
	]
},
	"application/vnd.crick.clicker.keyboard": {
	source: "iana",
	extensions: [
		"clkk"
	]
},
	"application/vnd.crick.clicker.palette": {
	source: "iana",
	extensions: [
		"clkp"
	]
},
	"application/vnd.crick.clicker.template": {
	source: "iana",
	extensions: [
		"clkt"
	]
},
	"application/vnd.crick.clicker.wordbank": {
	source: "iana",
	extensions: [
		"clkw"
	]
},
	"application/vnd.criticaltools.wbs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wbs"
	]
},
	"application/vnd.cryptii.pipe+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.crypto-shade-file": {
	source: "iana"
},
	"application/vnd.cryptomator.encrypted": {
	source: "iana"
},
	"application/vnd.cryptomator.vault": {
	source: "iana"
},
	"application/vnd.ctc-posml": {
	source: "iana",
	extensions: [
		"pml"
	]
},
	"application/vnd.ctct.ws+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cups-pdf": {
	source: "iana"
},
	"application/vnd.cups-postscript": {
	source: "iana"
},
	"application/vnd.cups-ppd": {
	source: "iana",
	extensions: [
		"ppd"
	]
},
	"application/vnd.cups-raster": {
	source: "iana"
},
	"application/vnd.cups-raw": {
	source: "iana"
},
	"application/vnd.curl": {
	source: "iana"
},
	"application/vnd.curl.car": {
	source: "apache",
	extensions: [
		"car"
	]
},
	"application/vnd.curl.pcurl": {
	source: "apache",
	extensions: [
		"pcurl"
	]
},
	"application/vnd.cyan.dean.root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cybank": {
	source: "iana"
},
	"application/vnd.cyclonedx+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cyclonedx+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.d2l.coursepackage1p0+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.d3m-dataset": {
	source: "iana"
},
	"application/vnd.d3m-problem": {
	source: "iana"
},
	"application/vnd.dart": {
	source: "iana",
	compressible: true,
	extensions: [
		"dart"
	]
},
	"application/vnd.data-vision.rdz": {
	source: "iana",
	extensions: [
		"rdz"
	]
},
	"application/vnd.datapackage+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dataresource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dbf": {
	source: "iana",
	extensions: [
		"dbf"
	]
},
	"application/vnd.debian.binary-package": {
	source: "iana"
},
	"application/vnd.dece.data": {
	source: "iana",
	extensions: [
		"uvf",
		"uvvf",
		"uvd",
		"uvvd"
	]
},
	"application/vnd.dece.ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uvt",
		"uvvt"
	]
},
	"application/vnd.dece.unspecified": {
	source: "iana",
	extensions: [
		"uvx",
		"uvvx"
	]
},
	"application/vnd.dece.zip": {
	source: "iana",
	extensions: [
		"uvz",
		"uvvz"
	]
},
	"application/vnd.denovo.fcselayout-link": {
	source: "iana",
	extensions: [
		"fe_launch"
	]
},
	"application/vnd.desmume.movie": {
	source: "iana"
},
	"application/vnd.dir-bi.plate-dl-nosuffix": {
	source: "iana"
},
	"application/vnd.dm.delegation+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dna": {
	source: "iana",
	extensions: [
		"dna"
	]
},
	"application/vnd.document+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dolby.mlp": {
	source: "apache",
	extensions: [
		"mlp"
	]
},
	"application/vnd.dolby.mobile.1": {
	source: "iana"
},
	"application/vnd.dolby.mobile.2": {
	source: "iana"
},
	"application/vnd.doremir.scorecloud-binary-document": {
	source: "iana"
},
	"application/vnd.dpgraph": {
	source: "iana",
	extensions: [
		"dpg"
	]
},
	"application/vnd.dreamfactory": {
	source: "iana",
	extensions: [
		"dfac"
	]
},
	"application/vnd.drive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ds-keypoint": {
	source: "apache",
	extensions: [
		"kpxx"
	]
},
	"application/vnd.dtg.local": {
	source: "iana"
},
	"application/vnd.dtg.local.flash": {
	source: "iana"
},
	"application/vnd.dtg.local.html": {
	source: "iana"
},
	"application/vnd.dvb.ait": {
	source: "iana",
	extensions: [
		"ait"
	]
},
	"application/vnd.dvb.dvbisl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.dvbj": {
	source: "iana"
},
	"application/vnd.dvb.esgcontainer": {
	source: "iana"
},
	"application/vnd.dvb.ipdcdftnotifaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess2": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgpdd": {
	source: "iana"
},
	"application/vnd.dvb.ipdcroaming": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-base": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-enhancement": {
	source: "iana"
},
	"application/vnd.dvb.notif-aggregate-root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-container+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-generic+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-msglist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-response+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-init+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.pfr": {
	source: "iana"
},
	"application/vnd.dvb.service": {
	source: "iana",
	extensions: [
		"svc"
	]
},
	"application/vnd.dxr": {
	source: "iana"
},
	"application/vnd.dynageo": {
	source: "iana",
	extensions: [
		"geo"
	]
},
	"application/vnd.dzr": {
	source: "iana"
},
	"application/vnd.easykaraoke.cdgdownload": {
	source: "iana"
},
	"application/vnd.ecdis-update": {
	source: "iana"
},
	"application/vnd.ecip.rlp": {
	source: "iana"
},
	"application/vnd.eclipse.ditto+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ecowin.chart": {
	source: "iana",
	extensions: [
		"mag"
	]
},
	"application/vnd.ecowin.filerequest": {
	source: "iana"
},
	"application/vnd.ecowin.fileupdate": {
	source: "iana"
},
	"application/vnd.ecowin.series": {
	source: "iana"
},
	"application/vnd.ecowin.seriesrequest": {
	source: "iana"
},
	"application/vnd.ecowin.seriesupdate": {
	source: "iana"
},
	"application/vnd.efi.img": {
	source: "iana"
},
	"application/vnd.efi.iso": {
	source: "iana"
},
	"application/vnd.emclient.accessrequest+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.enliven": {
	source: "iana",
	extensions: [
		"nml"
	]
},
	"application/vnd.enphase.envoy": {
	source: "iana"
},
	"application/vnd.eprints.data+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.epson.esf": {
	source: "iana",
	extensions: [
		"esf"
	]
},
	"application/vnd.epson.msf": {
	source: "iana",
	extensions: [
		"msf"
	]
},
	"application/vnd.epson.quickanime": {
	source: "iana",
	extensions: [
		"qam"
	]
},
	"application/vnd.epson.salt": {
	source: "iana",
	extensions: [
		"slt"
	]
},
	"application/vnd.epson.ssf": {
	source: "iana",
	extensions: [
		"ssf"
	]
},
	"application/vnd.ericsson.quickcall": {
	source: "iana"
},
	"application/vnd.espass-espass+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.eszigno3+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"es3",
		"et3"
	]
},
	"application/vnd.etsi.aoc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.asic-e+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.asic-s+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.cug+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvcommand+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-bc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-cod+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-npvr+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvservice+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsync+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mcid+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mheg5": {
	source: "iana"
},
	"application/vnd.etsi.overload-control-policy-dataset+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.pstn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.sci+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.simservs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.timestamp-token": {
	source: "iana"
},
	"application/vnd.etsi.tsl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.tsl.der": {
	source: "iana"
},
	"application/vnd.eu.kasparian.car+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.eudora.data": {
	source: "iana"
},
	"application/vnd.evolv.ecig.profile": {
	source: "iana"
},
	"application/vnd.evolv.ecig.settings": {
	source: "iana"
},
	"application/vnd.evolv.ecig.theme": {
	source: "iana"
},
	"application/vnd.exstream-empower+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.exstream-package": {
	source: "iana"
},
	"application/vnd.ezpix-album": {
	source: "iana",
	extensions: [
		"ez2"
	]
},
	"application/vnd.ezpix-package": {
	source: "iana",
	extensions: [
		"ez3"
	]
},
	"application/vnd.f-secure.mobile": {
	source: "iana"
},
	"application/vnd.familysearch.gedcom+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.fastcopy-disk-image": {
	source: "iana"
},
	"application/vnd.fdf": {
	source: "iana",
	extensions: [
		"fdf"
	]
},
	"application/vnd.fdsn.mseed": {
	source: "iana",
	extensions: [
		"mseed"
	]
},
	"application/vnd.fdsn.seed": {
	source: "iana",
	extensions: [
		"seed",
		"dataless"
	]
},
	"application/vnd.ffsns": {
	source: "iana"
},
	"application/vnd.ficlab.flb+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.filmit.zfc": {
	source: "iana"
},
	"application/vnd.fints": {
	source: "iana"
},
	"application/vnd.firemonkeys.cloudcell": {
	source: "iana"
},
	"application/vnd.flographit": {
	source: "iana",
	extensions: [
		"gph"
	]
},
	"application/vnd.fluxtime.clip": {
	source: "iana",
	extensions: [
		"ftc"
	]
},
	"application/vnd.font-fontforge-sfd": {
	source: "iana"
},
	"application/vnd.framemaker": {
	source: "iana",
	extensions: [
		"fm",
		"frame",
		"maker",
		"book"
	]
},
	"application/vnd.frogans.fnc": {
	source: "iana",
	extensions: [
		"fnc"
	]
},
	"application/vnd.frogans.ltf": {
	source: "iana",
	extensions: [
		"ltf"
	]
},
	"application/vnd.fsc.weblaunch": {
	source: "iana",
	extensions: [
		"fsc"
	]
},
	"application/vnd.fujifilm.fb.docuworks": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.binder": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.jfi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.fujitsu.oasys": {
	source: "iana",
	extensions: [
		"oas"
	]
},
	"application/vnd.fujitsu.oasys2": {
	source: "iana",
	extensions: [
		"oa2"
	]
},
	"application/vnd.fujitsu.oasys3": {
	source: "iana",
	extensions: [
		"oa3"
	]
},
	"application/vnd.fujitsu.oasysgp": {
	source: "iana",
	extensions: [
		"fg5"
	]
},
	"application/vnd.fujitsu.oasysprs": {
	source: "iana",
	extensions: [
		"bh2"
	]
},
	"application/vnd.fujixerox.art-ex": {
	source: "iana"
},
	"application/vnd.fujixerox.art4": {
	source: "iana"
},
	"application/vnd.fujixerox.ddd": {
	source: "iana",
	extensions: [
		"ddd"
	]
},
	"application/vnd.fujixerox.docuworks": {
	source: "iana",
	extensions: [
		"xdw"
	]
},
	"application/vnd.fujixerox.docuworks.binder": {
	source: "iana",
	extensions: [
		"xbd"
	]
},
	"application/vnd.fujixerox.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujixerox.hbpl": {
	source: "iana"
},
	"application/vnd.fut-misnet": {
	source: "iana"
},
	"application/vnd.futoin+cbor": {
	source: "iana"
},
	"application/vnd.futoin+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.fuzzysheet": {
	source: "iana",
	extensions: [
		"fzs"
	]
},
	"application/vnd.genomatix.tuxedo": {
	source: "iana",
	extensions: [
		"txd"
	]
},
	"application/vnd.gentics.grd+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geo+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geocube+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.geogebra.file": {
	source: "iana",
	extensions: [
		"ggb"
	]
},
	"application/vnd.geogebra.slides": {
	source: "iana"
},
	"application/vnd.geogebra.tool": {
	source: "iana",
	extensions: [
		"ggt"
	]
},
	"application/vnd.geometry-explorer": {
	source: "iana",
	extensions: [
		"gex",
		"gre"
	]
},
	"application/vnd.geonext": {
	source: "iana",
	extensions: [
		"gxt"
	]
},
	"application/vnd.geoplan": {
	source: "iana",
	extensions: [
		"g2w"
	]
},
	"application/vnd.geospace": {
	source: "iana",
	extensions: [
		"g3w"
	]
},
	"application/vnd.gerber": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt-response": {
	source: "iana"
},
	"application/vnd.gmx": {
	source: "iana",
	extensions: [
		"gmx"
	]
},
	"application/vnd.google-apps.document": {
	compressible: false,
	extensions: [
		"gdoc"
	]
},
	"application/vnd.google-apps.presentation": {
	compressible: false,
	extensions: [
		"gslides"
	]
},
	"application/vnd.google-apps.spreadsheet": {
	compressible: false,
	extensions: [
		"gsheet"
	]
},
	"application/vnd.google-earth.kml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"kml"
	]
},
	"application/vnd.google-earth.kmz": {
	source: "iana",
	compressible: false,
	extensions: [
		"kmz"
	]
},
	"application/vnd.gov.sk.e-form+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.gov.sk.e-form+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.gov.sk.xmldatacontainer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.grafeq": {
	source: "iana",
	extensions: [
		"gqf",
		"gqs"
	]
},
	"application/vnd.gridmp": {
	source: "iana"
},
	"application/vnd.groove-account": {
	source: "iana",
	extensions: [
		"gac"
	]
},
	"application/vnd.groove-help": {
	source: "iana",
	extensions: [
		"ghf"
	]
},
	"application/vnd.groove-identity-message": {
	source: "iana",
	extensions: [
		"gim"
	]
},
	"application/vnd.groove-injector": {
	source: "iana",
	extensions: [
		"grv"
	]
},
	"application/vnd.groove-tool-message": {
	source: "iana",
	extensions: [
		"gtm"
	]
},
	"application/vnd.groove-tool-template": {
	source: "iana",
	extensions: [
		"tpl"
	]
},
	"application/vnd.groove-vcard": {
	source: "iana",
	extensions: [
		"vcg"
	]
},
	"application/vnd.hal+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hal+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"hal"
	]
},
	"application/vnd.handheld-entertainment+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zmm"
	]
},
	"application/vnd.hbci": {
	source: "iana",
	extensions: [
		"hbci"
	]
},
	"application/vnd.hc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hcl-bireports": {
	source: "iana"
},
	"application/vnd.hdt": {
	source: "iana"
},
	"application/vnd.heroku+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hhe.lesson-player": {
	source: "iana",
	extensions: [
		"les"
	]
},
	"application/vnd.hl7cda+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.hl7v2+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.hp-hpgl": {
	source: "iana",
	extensions: [
		"hpgl"
	]
},
	"application/vnd.hp-hpid": {
	source: "iana",
	extensions: [
		"hpid"
	]
},
	"application/vnd.hp-hps": {
	source: "iana",
	extensions: [
		"hps"
	]
},
	"application/vnd.hp-jlyt": {
	source: "iana",
	extensions: [
		"jlt"
	]
},
	"application/vnd.hp-pcl": {
	source: "iana",
	extensions: [
		"pcl"
	]
},
	"application/vnd.hp-pclxl": {
	source: "iana",
	extensions: [
		"pclxl"
	]
},
	"application/vnd.httphone": {
	source: "iana"
},
	"application/vnd.hydrostatix.sof-data": {
	source: "iana",
	extensions: [
		"sfd-hdstx"
	]
},
	"application/vnd.hyper+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyper-item+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyperdrive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hzn-3d-crossword": {
	source: "iana"
},
	"application/vnd.ibm.afplinedata": {
	source: "iana"
},
	"application/vnd.ibm.electronic-media": {
	source: "iana"
},
	"application/vnd.ibm.minipay": {
	source: "iana",
	extensions: [
		"mpy"
	]
},
	"application/vnd.ibm.modcap": {
	source: "iana",
	extensions: [
		"afp",
		"listafp",
		"list3820"
	]
},
	"application/vnd.ibm.rights-management": {
	source: "iana",
	extensions: [
		"irm"
	]
},
	"application/vnd.ibm.secure-container": {
	source: "iana",
	extensions: [
		"sc"
	]
},
	"application/vnd.iccprofile": {
	source: "iana",
	extensions: [
		"icc",
		"icm"
	]
},
	"application/vnd.ieee.1905": {
	source: "iana"
},
	"application/vnd.igloader": {
	source: "iana",
	extensions: [
		"igl"
	]
},
	"application/vnd.imagemeter.folder+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.imagemeter.image+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.immervision-ivp": {
	source: "iana",
	extensions: [
		"ivp"
	]
},
	"application/vnd.immervision-ivu": {
	source: "iana",
	extensions: [
		"ivu"
	]
},
	"application/vnd.ims.imsccv1p1": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p2": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p3": {
	source: "iana"
},
	"application/vnd.ims.lis.v2.result+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy.id+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings.simple+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.informedcontrol.rms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.informix-visionary": {
	source: "iana"
},
	"application/vnd.infotech.project": {
	source: "iana"
},
	"application/vnd.infotech.project+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.innopath.wamp.notification": {
	source: "iana"
},
	"application/vnd.insors.igm": {
	source: "iana",
	extensions: [
		"igm"
	]
},
	"application/vnd.intercon.formnet": {
	source: "iana",
	extensions: [
		"xpw",
		"xpx"
	]
},
	"application/vnd.intergeo": {
	source: "iana",
	extensions: [
		"i2g"
	]
},
	"application/vnd.intertrust.digibox": {
	source: "iana"
},
	"application/vnd.intertrust.nncp": {
	source: "iana"
},
	"application/vnd.intu.qbo": {
	source: "iana",
	extensions: [
		"qbo"
	]
},
	"application/vnd.intu.qfx": {
	source: "iana",
	extensions: [
		"qfx"
	]
},
	"application/vnd.iptc.g2.catalogitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.conceptitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.knowledgeitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.packageitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.planningitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ipunplugged.rcprofile": {
	source: "iana",
	extensions: [
		"rcprofile"
	]
},
	"application/vnd.irepository.package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"irp"
	]
},
	"application/vnd.is-xpr": {
	source: "iana",
	extensions: [
		"xpr"
	]
},
	"application/vnd.isac.fcs": {
	source: "iana",
	extensions: [
		"fcs"
	]
},
	"application/vnd.iso11783-10+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.jam": {
	source: "iana",
	extensions: [
		"jam"
	]
},
	"application/vnd.japannet-directory-service": {
	source: "iana"
},
	"application/vnd.japannet-jpnstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-payment-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-registration": {
	source: "iana"
},
	"application/vnd.japannet-registration-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-setstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-verification": {
	source: "iana"
},
	"application/vnd.japannet-verification-wakeup": {
	source: "iana"
},
	"application/vnd.jcp.javame.midlet-rms": {
	source: "iana",
	extensions: [
		"rms"
	]
},
	"application/vnd.jisp": {
	source: "iana",
	extensions: [
		"jisp"
	]
},
	"application/vnd.joost.joda-archive": {
	source: "iana",
	extensions: [
		"joda"
	]
},
	"application/vnd.jsk.isdn-ngn": {
	source: "iana"
},
	"application/vnd.kahootz": {
	source: "iana",
	extensions: [
		"ktz",
		"ktr"
	]
},
	"application/vnd.kde.karbon": {
	source: "iana",
	extensions: [
		"karbon"
	]
},
	"application/vnd.kde.kchart": {
	source: "iana",
	extensions: [
		"chrt"
	]
},
	"application/vnd.kde.kformula": {
	source: "iana",
	extensions: [
		"kfo"
	]
},
	"application/vnd.kde.kivio": {
	source: "iana",
	extensions: [
		"flw"
	]
},
	"application/vnd.kde.kontour": {
	source: "iana",
	extensions: [
		"kon"
	]
},
	"application/vnd.kde.kpresenter": {
	source: "iana",
	extensions: [
		"kpr",
		"kpt"
	]
},
	"application/vnd.kde.kspread": {
	source: "iana",
	extensions: [
		"ksp"
	]
},
	"application/vnd.kde.kword": {
	source: "iana",
	extensions: [
		"kwd",
		"kwt"
	]
},
	"application/vnd.kenameaapp": {
	source: "iana",
	extensions: [
		"htke"
	]
},
	"application/vnd.kidspiration": {
	source: "iana",
	extensions: [
		"kia"
	]
},
	"application/vnd.kinar": {
	source: "iana",
	extensions: [
		"kne",
		"knp"
	]
},
	"application/vnd.koan": {
	source: "iana",
	extensions: [
		"skp",
		"skd",
		"skt",
		"skm"
	]
},
	"application/vnd.kodak-descriptor": {
	source: "iana",
	extensions: [
		"sse"
	]
},
	"application/vnd.las": {
	source: "iana"
},
	"application/vnd.las.las+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.las.las+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lasxml"
	]
},
	"application/vnd.laszip": {
	source: "iana"
},
	"application/vnd.leap+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.liberty-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.llamagraphics.life-balance.desktop": {
	source: "iana",
	extensions: [
		"lbd"
	]
},
	"application/vnd.llamagraphics.life-balance.exchange+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lbe"
	]
},
	"application/vnd.logipipe.circuit+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.loom": {
	source: "iana"
},
	"application/vnd.lotus-1-2-3": {
	source: "iana",
	extensions: [
		"123"
	]
},
	"application/vnd.lotus-approach": {
	source: "iana",
	extensions: [
		"apr"
	]
},
	"application/vnd.lotus-freelance": {
	source: "iana",
	extensions: [
		"pre"
	]
},
	"application/vnd.lotus-notes": {
	source: "iana",
	extensions: [
		"nsf"
	]
},
	"application/vnd.lotus-organizer": {
	source: "iana",
	extensions: [
		"org"
	]
},
	"application/vnd.lotus-screencam": {
	source: "iana",
	extensions: [
		"scm"
	]
},
	"application/vnd.lotus-wordpro": {
	source: "iana",
	extensions: [
		"lwp"
	]
},
	"application/vnd.macports.portpkg": {
	source: "iana",
	extensions: [
		"portpkg"
	]
},
	"application/vnd.mapbox-vector-tile": {
	source: "iana",
	extensions: [
		"mvt"
	]
},
	"application/vnd.marlin.drm.actiontoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.conftoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.license+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.mdcf": {
	source: "iana"
},
	"application/vnd.mason+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.maxar.archive.3tz+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.maxmind.maxmind-db": {
	source: "iana"
},
	"application/vnd.mcd": {
	source: "iana",
	extensions: [
		"mcd"
	]
},
	"application/vnd.medcalcdata": {
	source: "iana",
	extensions: [
		"mc1"
	]
},
	"application/vnd.mediastation.cdkey": {
	source: "iana",
	extensions: [
		"cdkey"
	]
},
	"application/vnd.meridian-slingshot": {
	source: "iana"
},
	"application/vnd.mfer": {
	source: "iana",
	extensions: [
		"mwf"
	]
},
	"application/vnd.mfmp": {
	source: "iana",
	extensions: [
		"mfm"
	]
},
	"application/vnd.micro+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.micrografx.flo": {
	source: "iana",
	extensions: [
		"flo"
	]
},
	"application/vnd.micrografx.igx": {
	source: "iana",
	extensions: [
		"igx"
	]
},
	"application/vnd.microsoft.portable-executable": {
	source: "iana"
},
	"application/vnd.microsoft.windows.thumbnail-cache": {
	source: "iana"
},
	"application/vnd.miele+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.mif": {
	source: "iana",
	extensions: [
		"mif"
	]
},
	"application/vnd.minisoft-hp3000-save": {
	source: "iana"
},
	"application/vnd.mitsubishi.misty-guard.trustweb": {
	source: "iana"
},
	"application/vnd.mobius.daf": {
	source: "iana",
	extensions: [
		"daf"
	]
},
	"application/vnd.mobius.dis": {
	source: "iana",
	extensions: [
		"dis"
	]
},
	"application/vnd.mobius.mbk": {
	source: "iana",
	extensions: [
		"mbk"
	]
},
	"application/vnd.mobius.mqy": {
	source: "iana",
	extensions: [
		"mqy"
	]
},
	"application/vnd.mobius.msl": {
	source: "iana",
	extensions: [
		"msl"
	]
},
	"application/vnd.mobius.plc": {
	source: "iana",
	extensions: [
		"plc"
	]
},
	"application/vnd.mobius.txf": {
	source: "iana",
	extensions: [
		"txf"
	]
},
	"application/vnd.mophun.application": {
	source: "iana",
	extensions: [
		"mpn"
	]
},
	"application/vnd.mophun.certificate": {
	source: "iana",
	extensions: [
		"mpc"
	]
},
	"application/vnd.motorola.flexsuite": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.adsi": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.fis": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.gotap": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.kmr": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.ttc": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.wem": {
	source: "iana"
},
	"application/vnd.motorola.iprm": {
	source: "iana"
},
	"application/vnd.mozilla.xul+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xul"
	]
},
	"application/vnd.ms-3mfdocument": {
	source: "iana"
},
	"application/vnd.ms-artgalry": {
	source: "iana",
	extensions: [
		"cil"
	]
},
	"application/vnd.ms-asf": {
	source: "iana"
},
	"application/vnd.ms-cab-compressed": {
	source: "iana",
	extensions: [
		"cab"
	]
},
	"application/vnd.ms-color.iccprofile": {
	source: "apache"
},
	"application/vnd.ms-excel": {
	source: "iana",
	compressible: false,
	extensions: [
		"xls",
		"xlm",
		"xla",
		"xlc",
		"xlt",
		"xlw"
	]
},
	"application/vnd.ms-excel.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlam"
	]
},
	"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsb"
	]
},
	"application/vnd.ms-excel.sheet.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsm"
	]
},
	"application/vnd.ms-excel.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"xltm"
	]
},
	"application/vnd.ms-fontobject": {
	source: "iana",
	compressible: true,
	extensions: [
		"eot"
	]
},
	"application/vnd.ms-htmlhelp": {
	source: "iana",
	extensions: [
		"chm"
	]
},
	"application/vnd.ms-ims": {
	source: "iana",
	extensions: [
		"ims"
	]
},
	"application/vnd.ms-lrm": {
	source: "iana",
	extensions: [
		"lrm"
	]
},
	"application/vnd.ms-office.activex+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-officetheme": {
	source: "iana",
	extensions: [
		"thmx"
	]
},
	"application/vnd.ms-opentype": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-outlook": {
	compressible: false,
	extensions: [
		"msg"
	]
},
	"application/vnd.ms-package.obfuscated-opentype": {
	source: "apache"
},
	"application/vnd.ms-pki.seccat": {
	source: "apache",
	extensions: [
		"cat"
	]
},
	"application/vnd.ms-pki.stl": {
	source: "apache",
	extensions: [
		"stl"
	]
},
	"application/vnd.ms-playready.initiator+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-powerpoint": {
	source: "iana",
	compressible: false,
	extensions: [
		"ppt",
		"pps",
		"pot"
	]
},
	"application/vnd.ms-powerpoint.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppam"
	]
},
	"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
	source: "iana",
	extensions: [
		"pptm"
	]
},
	"application/vnd.ms-powerpoint.slide.macroenabled.12": {
	source: "iana",
	extensions: [
		"sldm"
	]
},
	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppsm"
	]
},
	"application/vnd.ms-powerpoint.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"potm"
	]
},
	"application/vnd.ms-printdevicecapabilities+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-printing.printticket+xml": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-printschematicket+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-project": {
	source: "iana",
	extensions: [
		"mpp",
		"mpt"
	]
},
	"application/vnd.ms-tnef": {
	source: "iana"
},
	"application/vnd.ms-windows.devicepairing": {
	source: "iana"
},
	"application/vnd.ms-windows.nwprinting.oob": {
	source: "iana"
},
	"application/vnd.ms-windows.printerpairing": {
	source: "iana"
},
	"application/vnd.ms-windows.wsd.oob": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-resp": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-resp": {
	source: "iana"
},
	"application/vnd.ms-word.document.macroenabled.12": {
	source: "iana",
	extensions: [
		"docm"
	]
},
	"application/vnd.ms-word.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"dotm"
	]
},
	"application/vnd.ms-works": {
	source: "iana",
	extensions: [
		"wps",
		"wks",
		"wcm",
		"wdb"
	]
},
	"application/vnd.ms-wpl": {
	source: "iana",
	extensions: [
		"wpl"
	]
},
	"application/vnd.ms-xpsdocument": {
	source: "iana",
	compressible: false,
	extensions: [
		"xps"
	]
},
	"application/vnd.msa-disk-image": {
	source: "iana"
},
	"application/vnd.mseq": {
	source: "iana",
	extensions: [
		"mseq"
	]
},
	"application/vnd.msign": {
	source: "iana"
},
	"application/vnd.multiad.creator": {
	source: "iana"
},
	"application/vnd.multiad.creator.cif": {
	source: "iana"
},
	"application/vnd.music-niff": {
	source: "iana"
},
	"application/vnd.musician": {
	source: "iana",
	extensions: [
		"mus"
	]
},
	"application/vnd.muvee.style": {
	source: "iana",
	extensions: [
		"msty"
	]
},
	"application/vnd.mynfc": {
	source: "iana",
	extensions: [
		"taglet"
	]
},
	"application/vnd.nacamar.ybrid+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ncd.control": {
	source: "iana"
},
	"application/vnd.ncd.reference": {
	source: "iana"
},
	"application/vnd.nearst.inv+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.nebumind.line": {
	source: "iana"
},
	"application/vnd.nervana": {
	source: "iana"
},
	"application/vnd.netfpx": {
	source: "iana"
},
	"application/vnd.neurolanguage.nlu": {
	source: "iana",
	extensions: [
		"nlu"
	]
},
	"application/vnd.nimn": {
	source: "iana"
},
	"application/vnd.nintendo.nitro.rom": {
	source: "iana"
},
	"application/vnd.nintendo.snes.rom": {
	source: "iana"
},
	"application/vnd.nitf": {
	source: "iana",
	extensions: [
		"ntf",
		"nitf"
	]
},
	"application/vnd.noblenet-directory": {
	source: "iana",
	extensions: [
		"nnd"
	]
},
	"application/vnd.noblenet-sealer": {
	source: "iana",
	extensions: [
		"nns"
	]
},
	"application/vnd.noblenet-web": {
	source: "iana",
	extensions: [
		"nnw"
	]
},
	"application/vnd.nokia.catalogs": {
	source: "iana"
},
	"application/vnd.nokia.conml+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.conml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.iptv.config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.isds-radio-presets": {
	source: "iana"
},
	"application/vnd.nokia.landmark+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.landmark+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.landmarkcollection+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.n-gage.ac+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ac"
	]
},
	"application/vnd.nokia.n-gage.data": {
	source: "iana",
	extensions: [
		"ngdat"
	]
},
	"application/vnd.nokia.n-gage.symbian.install": {
	source: "iana",
	extensions: [
		"n-gage"
	]
},
	"application/vnd.nokia.ncd": {
	source: "iana"
},
	"application/vnd.nokia.pcd+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.pcd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.radio-preset": {
	source: "iana",
	extensions: [
		"rpst"
	]
},
	"application/vnd.nokia.radio-presets": {
	source: "iana",
	extensions: [
		"rpss"
	]
},
	"application/vnd.novadigm.edm": {
	source: "iana",
	extensions: [
		"edm"
	]
},
	"application/vnd.novadigm.edx": {
	source: "iana",
	extensions: [
		"edx"
	]
},
	"application/vnd.novadigm.ext": {
	source: "iana",
	extensions: [
		"ext"
	]
},
	"application/vnd.ntt-local.content-share": {
	source: "iana"
},
	"application/vnd.ntt-local.file-transfer": {
	source: "iana"
},
	"application/vnd.ntt-local.ogw_remote-access": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_remote": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_tcp_stream": {
	source: "iana"
},
	"application/vnd.oasis.opendocument.chart": {
	source: "iana",
	extensions: [
		"odc"
	]
},
	"application/vnd.oasis.opendocument.chart-template": {
	source: "iana",
	extensions: [
		"otc"
	]
},
	"application/vnd.oasis.opendocument.database": {
	source: "iana",
	extensions: [
		"odb"
	]
},
	"application/vnd.oasis.opendocument.formula": {
	source: "iana",
	extensions: [
		"odf"
	]
},
	"application/vnd.oasis.opendocument.formula-template": {
	source: "iana",
	extensions: [
		"odft"
	]
},
	"application/vnd.oasis.opendocument.graphics": {
	source: "iana",
	compressible: false,
	extensions: [
		"odg"
	]
},
	"application/vnd.oasis.opendocument.graphics-template": {
	source: "iana",
	extensions: [
		"otg"
	]
},
	"application/vnd.oasis.opendocument.image": {
	source: "iana",
	extensions: [
		"odi"
	]
},
	"application/vnd.oasis.opendocument.image-template": {
	source: "iana",
	extensions: [
		"oti"
	]
},
	"application/vnd.oasis.opendocument.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"odp"
	]
},
	"application/vnd.oasis.opendocument.presentation-template": {
	source: "iana",
	extensions: [
		"otp"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"ods"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet-template": {
	source: "iana",
	extensions: [
		"ots"
	]
},
	"application/vnd.oasis.opendocument.text": {
	source: "iana",
	compressible: false,
	extensions: [
		"odt"
	]
},
	"application/vnd.oasis.opendocument.text-master": {
	source: "iana",
	extensions: [
		"odm"
	]
},
	"application/vnd.oasis.opendocument.text-template": {
	source: "iana",
	extensions: [
		"ott"
	]
},
	"application/vnd.oasis.opendocument.text-web": {
	source: "iana",
	extensions: [
		"oth"
	]
},
	"application/vnd.obn": {
	source: "iana"
},
	"application/vnd.ocf+cbor": {
	source: "iana"
},
	"application/vnd.oci.image.manifest.v1+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oftn.l10n+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessdownload+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessstreaming+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.cspg-hexbinary": {
	source: "iana"
},
	"application/vnd.oipf.dae.svg+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.dae.xhtml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.mippvcontrolmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.pae.gem": {
	source: "iana"
},
	"application/vnd.oipf.spdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.spdlist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.ueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.userprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.olpc-sugar": {
	source: "iana",
	extensions: [
		"xo"
	]
},
	"application/vnd.oma-scws-config": {
	source: "iana"
},
	"application/vnd.oma-scws-http-request": {
	source: "iana"
},
	"application/vnd.oma-scws-http-response": {
	source: "iana"
},
	"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.drm-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.imd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.ltkm": {
	source: "iana"
},
	"application/vnd.oma.bcast.notification+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.provisioningtrigger": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgboot": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgdd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sgdu": {
	source: "iana"
},
	"application/vnd.oma.bcast.simple-symbol-container": {
	source: "iana"
},
	"application/vnd.oma.bcast.smartcard-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sprov+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.stkm": {
	source: "iana"
},
	"application/vnd.oma.cab-address-book+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-feature-handler+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-pcc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-subs-invite+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-user-prefs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.dcd": {
	source: "iana"
},
	"application/vnd.oma.dcdc": {
	source: "iana"
},
	"application/vnd.oma.dd2+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dd2"
	]
},
	"application/vnd.oma.drm.risd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.group-usage-list+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+cbor": {
	source: "iana"
},
	"application/vnd.oma.lwm2m+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+tlv": {
	source: "iana"
},
	"application/vnd.oma.pal+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.detailed-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.final-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.groups+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.invocation-descriptor+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.optimized-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.push": {
	source: "iana"
},
	"application/vnd.oma.scidm.messages+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.xcap-directory+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.omads-email+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-file+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-folder+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omaloc-supl-init": {
	source: "iana"
},
	"application/vnd.onepager": {
	source: "iana"
},
	"application/vnd.onepagertamp": {
	source: "iana"
},
	"application/vnd.onepagertamx": {
	source: "iana"
},
	"application/vnd.onepagertat": {
	source: "iana"
},
	"application/vnd.onepagertatp": {
	source: "iana"
},
	"application/vnd.onepagertatx": {
	source: "iana"
},
	"application/vnd.openblox.game+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"obgx"
	]
},
	"application/vnd.openblox.game-binary": {
	source: "iana"
},
	"application/vnd.openeye.oeb": {
	source: "iana"
},
	"application/vnd.openofficeorg.extension": {
	source: "apache",
	extensions: [
		"oxt"
	]
},
	"application/vnd.openstreetmap.data+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osm"
	]
},
	"application/vnd.opentimestamps.ots": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawing+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"pptx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide": {
	source: "iana",
	extensions: [
		"sldx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
	source: "iana",
	extensions: [
		"ppsx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.template": {
	source: "iana",
	extensions: [
		"potx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"xlsx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
	source: "iana",
	extensions: [
		"xltx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.theme+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.vmldrawing": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
	source: "iana",
	compressible: false,
	extensions: [
		"docx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
	source: "iana",
	extensions: [
		"dotx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.core-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.relationships+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oracle.resource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.orange.indata": {
	source: "iana"
},
	"application/vnd.osa.netdeploy": {
	source: "iana"
},
	"application/vnd.osgeo.mapguide.package": {
	source: "iana",
	extensions: [
		"mgp"
	]
},
	"application/vnd.osgi.bundle": {
	source: "iana"
},
	"application/vnd.osgi.dp": {
	source: "iana",
	extensions: [
		"dp"
	]
},
	"application/vnd.osgi.subsystem": {
	source: "iana",
	extensions: [
		"esa"
	]
},
	"application/vnd.otps.ct-kip+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oxli.countgraph": {
	source: "iana"
},
	"application/vnd.pagerduty+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.palm": {
	source: "iana",
	extensions: [
		"pdb",
		"pqa",
		"oprc"
	]
},
	"application/vnd.panoply": {
	source: "iana"
},
	"application/vnd.paos.xml": {
	source: "iana"
},
	"application/vnd.patentdive": {
	source: "iana"
},
	"application/vnd.patientecommsdoc": {
	source: "iana"
},
	"application/vnd.pawaafile": {
	source: "iana",
	extensions: [
		"paw"
	]
},
	"application/vnd.pcos": {
	source: "iana"
},
	"application/vnd.pg.format": {
	source: "iana",
	extensions: [
		"str"
	]
},
	"application/vnd.pg.osasli": {
	source: "iana",
	extensions: [
		"ei6"
	]
},
	"application/vnd.piaccess.application-licence": {
	source: "iana"
},
	"application/vnd.picsel": {
	source: "iana",
	extensions: [
		"efif"
	]
},
	"application/vnd.pmi.widget": {
	source: "iana",
	extensions: [
		"wg"
	]
},
	"application/vnd.poc.group-advertisement+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.pocketlearn": {
	source: "iana",
	extensions: [
		"plf"
	]
},
	"application/vnd.powerbuilder6": {
	source: "iana",
	extensions: [
		"pbd"
	]
},
	"application/vnd.powerbuilder6-s": {
	source: "iana"
},
	"application/vnd.powerbuilder7": {
	source: "iana"
},
	"application/vnd.powerbuilder7-s": {
	source: "iana"
},
	"application/vnd.powerbuilder75": {
	source: "iana"
},
	"application/vnd.powerbuilder75-s": {
	source: "iana"
},
	"application/vnd.preminet": {
	source: "iana"
},
	"application/vnd.previewsystems.box": {
	source: "iana",
	extensions: [
		"box"
	]
},
	"application/vnd.proteus.magazine": {
	source: "iana",
	extensions: [
		"mgz"
	]
},
	"application/vnd.psfs": {
	source: "iana"
},
	"application/vnd.publishare-delta-tree": {
	source: "iana",
	extensions: [
		"qps"
	]
},
	"application/vnd.pvi.ptid1": {
	source: "iana",
	extensions: [
		"ptid"
	]
},
	"application/vnd.pwg-multiplexed": {
	source: "iana"
},
	"application/vnd.pwg-xhtml-print+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.qualcomm.brew-app-res": {
	source: "iana"
},
	"application/vnd.quarantainenet": {
	source: "iana"
},
	"application/vnd.quark.quarkxpress": {
	source: "iana",
	extensions: [
		"qxd",
		"qxt",
		"qwd",
		"qwt",
		"qxl",
		"qxb"
	]
},
	"application/vnd.quobject-quoxdocument": {
	source: "iana"
},
	"application/vnd.radisys.moml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-stream+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-base+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-detect+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-group+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-speech+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-transform+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.rainstor.data": {
	source: "iana"
},
	"application/vnd.rapid": {
	source: "iana"
},
	"application/vnd.rar": {
	source: "iana",
	extensions: [
		"rar"
	]
},
	"application/vnd.realvnc.bed": {
	source: "iana",
	extensions: [
		"bed"
	]
},
	"application/vnd.recordare.musicxml": {
	source: "iana",
	extensions: [
		"mxl"
	]
},
	"application/vnd.recordare.musicxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musicxml"
	]
},
	"application/vnd.renlearn.rlprint": {
	source: "iana"
},
	"application/vnd.resilient.logic": {
	source: "iana"
},
	"application/vnd.restful+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.rig.cryptonote": {
	source: "iana",
	extensions: [
		"cryptonote"
	]
},
	"application/vnd.rim.cod": {
	source: "apache",
	extensions: [
		"cod"
	]
},
	"application/vnd.rn-realmedia": {
	source: "apache",
	extensions: [
		"rm"
	]
},
	"application/vnd.rn-realmedia-vbr": {
	source: "apache",
	extensions: [
		"rmvb"
	]
},
	"application/vnd.route66.link66+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"link66"
	]
},
	"application/vnd.rs-274x": {
	source: "iana"
},
	"application/vnd.ruckus.download": {
	source: "iana"
},
	"application/vnd.s3sms": {
	source: "iana"
},
	"application/vnd.sailingtracker.track": {
	source: "iana",
	extensions: [
		"st"
	]
},
	"application/vnd.sar": {
	source: "iana"
},
	"application/vnd.sbm.cid": {
	source: "iana"
},
	"application/vnd.sbm.mid2": {
	source: "iana"
},
	"application/vnd.scribus": {
	source: "iana"
},
	"application/vnd.sealed.3df": {
	source: "iana"
},
	"application/vnd.sealed.csf": {
	source: "iana"
},
	"application/vnd.sealed.doc": {
	source: "iana"
},
	"application/vnd.sealed.eml": {
	source: "iana"
},
	"application/vnd.sealed.mht": {
	source: "iana"
},
	"application/vnd.sealed.net": {
	source: "iana"
},
	"application/vnd.sealed.ppt": {
	source: "iana"
},
	"application/vnd.sealed.tiff": {
	source: "iana"
},
	"application/vnd.sealed.xls": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.html": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.pdf": {
	source: "iana"
},
	"application/vnd.seemail": {
	source: "iana",
	extensions: [
		"see"
	]
},
	"application/vnd.seis+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.sema": {
	source: "iana",
	extensions: [
		"sema"
	]
},
	"application/vnd.semd": {
	source: "iana",
	extensions: [
		"semd"
	]
},
	"application/vnd.semf": {
	source: "iana",
	extensions: [
		"semf"
	]
},
	"application/vnd.shade-save-file": {
	source: "iana"
},
	"application/vnd.shana.informed.formdata": {
	source: "iana",
	extensions: [
		"ifm"
	]
},
	"application/vnd.shana.informed.formtemplate": {
	source: "iana",
	extensions: [
		"itp"
	]
},
	"application/vnd.shana.informed.interchange": {
	source: "iana",
	extensions: [
		"iif"
	]
},
	"application/vnd.shana.informed.package": {
	source: "iana",
	extensions: [
		"ipk"
	]
},
	"application/vnd.shootproof+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shopkick+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shp": {
	source: "iana"
},
	"application/vnd.shx": {
	source: "iana"
},
	"application/vnd.sigrok.session": {
	source: "iana"
},
	"application/vnd.simtech-mindmapper": {
	source: "iana",
	extensions: [
		"twd",
		"twds"
	]
},
	"application/vnd.siren+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.smaf": {
	source: "iana",
	extensions: [
		"mmf"
	]
},
	"application/vnd.smart.notebook": {
	source: "iana"
},
	"application/vnd.smart.teacher": {
	source: "iana",
	extensions: [
		"teacher"
	]
},
	"application/vnd.snesdev-page-table": {
	source: "iana"
},
	"application/vnd.software602.filler.form+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fo"
	]
},
	"application/vnd.software602.filler.form-xml-zip": {
	source: "iana"
},
	"application/vnd.solent.sdkm+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sdkm",
		"sdkd"
	]
},
	"application/vnd.spotfire.dxp": {
	source: "iana",
	extensions: [
		"dxp"
	]
},
	"application/vnd.spotfire.sfs": {
	source: "iana",
	extensions: [
		"sfs"
	]
},
	"application/vnd.sqlite3": {
	source: "iana"
},
	"application/vnd.sss-cod": {
	source: "iana"
},
	"application/vnd.sss-dtf": {
	source: "iana"
},
	"application/vnd.sss-ntf": {
	source: "iana"
},
	"application/vnd.stardivision.calc": {
	source: "apache",
	extensions: [
		"sdc"
	]
},
	"application/vnd.stardivision.draw": {
	source: "apache",
	extensions: [
		"sda"
	]
},
	"application/vnd.stardivision.impress": {
	source: "apache",
	extensions: [
		"sdd"
	]
},
	"application/vnd.stardivision.math": {
	source: "apache",
	extensions: [
		"smf"
	]
},
	"application/vnd.stardivision.writer": {
	source: "apache",
	extensions: [
		"sdw",
		"vor"
	]
},
	"application/vnd.stardivision.writer-global": {
	source: "apache",
	extensions: [
		"sgl"
	]
},
	"application/vnd.stepmania.package": {
	source: "iana",
	extensions: [
		"smzip"
	]
},
	"application/vnd.stepmania.stepchart": {
	source: "iana",
	extensions: [
		"sm"
	]
},
	"application/vnd.street-stream": {
	source: "iana"
},
	"application/vnd.sun.wadl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wadl"
	]
},
	"application/vnd.sun.xml.calc": {
	source: "apache",
	extensions: [
		"sxc"
	]
},
	"application/vnd.sun.xml.calc.template": {
	source: "apache",
	extensions: [
		"stc"
	]
},
	"application/vnd.sun.xml.draw": {
	source: "apache",
	extensions: [
		"sxd"
	]
},
	"application/vnd.sun.xml.draw.template": {
	source: "apache",
	extensions: [
		"std"
	]
},
	"application/vnd.sun.xml.impress": {
	source: "apache",
	extensions: [
		"sxi"
	]
},
	"application/vnd.sun.xml.impress.template": {
	source: "apache",
	extensions: [
		"sti"
	]
},
	"application/vnd.sun.xml.math": {
	source: "apache",
	extensions: [
		"sxm"
	]
},
	"application/vnd.sun.xml.writer": {
	source: "apache",
	extensions: [
		"sxw"
	]
},
	"application/vnd.sun.xml.writer.global": {
	source: "apache",
	extensions: [
		"sxg"
	]
},
	"application/vnd.sun.xml.writer.template": {
	source: "apache",
	extensions: [
		"stw"
	]
},
	"application/vnd.sus-calendar": {
	source: "iana",
	extensions: [
		"sus",
		"susp"
	]
},
	"application/vnd.svd": {
	source: "iana",
	extensions: [
		"svd"
	]
},
	"application/vnd.swiftview-ics": {
	source: "iana"
},
	"application/vnd.sycle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.syft+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.symbian.install": {
	source: "apache",
	extensions: [
		"sis",
		"sisx"
	]
},
	"application/vnd.syncml+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xsm"
	]
},
	"application/vnd.syncml.dm+wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"bdm"
	]
},
	"application/vnd.syncml.dm+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xdm"
	]
},
	"application/vnd.syncml.dm.notification": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"ddf"
	]
},
	"application/vnd.syncml.dmtnds+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmtnds+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.syncml.ds.notification": {
	source: "iana"
},
	"application/vnd.tableschema+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tao.intent-module-archive": {
	source: "iana",
	extensions: [
		"tao"
	]
},
	"application/vnd.tcpdump.pcap": {
	source: "iana",
	extensions: [
		"pcap",
		"cap",
		"dmp"
	]
},
	"application/vnd.think-cell.ppttc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tmd.mediaflex.api+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.tml": {
	source: "iana"
},
	"application/vnd.tmobile-livetv": {
	source: "iana",
	extensions: [
		"tmo"
	]
},
	"application/vnd.tri.onesource": {
	source: "iana"
},
	"application/vnd.trid.tpt": {
	source: "iana",
	extensions: [
		"tpt"
	]
},
	"application/vnd.triscape.mxs": {
	source: "iana",
	extensions: [
		"mxs"
	]
},
	"application/vnd.trueapp": {
	source: "iana",
	extensions: [
		"tra"
	]
},
	"application/vnd.truedoc": {
	source: "iana"
},
	"application/vnd.ubisoft.webplayer": {
	source: "iana"
},
	"application/vnd.ufdl": {
	source: "iana",
	extensions: [
		"ufd",
		"ufdl"
	]
},
	"application/vnd.uiq.theme": {
	source: "iana",
	extensions: [
		"utz"
	]
},
	"application/vnd.umajin": {
	source: "iana",
	extensions: [
		"umj"
	]
},
	"application/vnd.unity": {
	source: "iana",
	extensions: [
		"unityweb"
	]
},
	"application/vnd.uoml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uoml"
	]
},
	"application/vnd.uplanet.alert": {
	source: "iana"
},
	"application/vnd.uplanet.alert-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.channel": {
	source: "iana"
},
	"application/vnd.uplanet.channel-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.list": {
	source: "iana"
},
	"application/vnd.uplanet.list-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.signal": {
	source: "iana"
},
	"application/vnd.uri-map": {
	source: "iana"
},
	"application/vnd.valve.source.material": {
	source: "iana"
},
	"application/vnd.vcx": {
	source: "iana",
	extensions: [
		"vcx"
	]
},
	"application/vnd.vd-study": {
	source: "iana"
},
	"application/vnd.vectorworks": {
	source: "iana"
},
	"application/vnd.vel+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.verimatrix.vcas": {
	source: "iana"
},
	"application/vnd.veritone.aion+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.veryant.thin": {
	source: "iana"
},
	"application/vnd.ves.encrypted": {
	source: "iana"
},
	"application/vnd.vidsoft.vidconference": {
	source: "iana"
},
	"application/vnd.visio": {
	source: "iana",
	extensions: [
		"vsd",
		"vst",
		"vss",
		"vsw"
	]
},
	"application/vnd.visionary": {
	source: "iana",
	extensions: [
		"vis"
	]
},
	"application/vnd.vividence.scriptfile": {
	source: "iana"
},
	"application/vnd.vsf": {
	source: "iana",
	extensions: [
		"vsf"
	]
},
	"application/vnd.wap.sic": {
	source: "iana"
},
	"application/vnd.wap.slc": {
	source: "iana"
},
	"application/vnd.wap.wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"wbxml"
	]
},
	"application/vnd.wap.wmlc": {
	source: "iana",
	extensions: [
		"wmlc"
	]
},
	"application/vnd.wap.wmlscriptc": {
	source: "iana",
	extensions: [
		"wmlsc"
	]
},
	"application/vnd.webturbo": {
	source: "iana",
	extensions: [
		"wtb"
	]
},
	"application/vnd.wfa.dpp": {
	source: "iana"
},
	"application/vnd.wfa.p2p": {
	source: "iana"
},
	"application/vnd.wfa.wsc": {
	source: "iana"
},
	"application/vnd.windows.devicepairing": {
	source: "iana"
},
	"application/vnd.wmc": {
	source: "iana"
},
	"application/vnd.wmf.bootstrap": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica.package": {
	source: "iana"
},
	"application/vnd.wolfram.player": {
	source: "iana",
	extensions: [
		"nbp"
	]
},
	"application/vnd.wordperfect": {
	source: "iana",
	extensions: [
		"wpd"
	]
},
	"application/vnd.wqd": {
	source: "iana",
	extensions: [
		"wqd"
	]
},
	"application/vnd.wrq-hp3000-labelled": {
	source: "iana"
},
	"application/vnd.wt.stf": {
	source: "iana",
	extensions: [
		"stf"
	]
},
	"application/vnd.wv.csp+wbxml": {
	source: "iana"
},
	"application/vnd.wv.csp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.wv.ssp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xacml+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.xara": {
	source: "iana",
	extensions: [
		"xar"
	]
},
	"application/vnd.xfdl": {
	source: "iana",
	extensions: [
		"xfdl"
	]
},
	"application/vnd.xfdl.webform": {
	source: "iana"
},
	"application/vnd.xmi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xmpie.cpkg": {
	source: "iana"
},
	"application/vnd.xmpie.dpkg": {
	source: "iana"
},
	"application/vnd.xmpie.plan": {
	source: "iana"
},
	"application/vnd.xmpie.ppkg": {
	source: "iana"
},
	"application/vnd.xmpie.xlim": {
	source: "iana"
},
	"application/vnd.yamaha.hv-dic": {
	source: "iana",
	extensions: [
		"hvd"
	]
},
	"application/vnd.yamaha.hv-script": {
	source: "iana",
	extensions: [
		"hvs"
	]
},
	"application/vnd.yamaha.hv-voice": {
	source: "iana",
	extensions: [
		"hvp"
	]
},
	"application/vnd.yamaha.openscoreformat": {
	source: "iana",
	extensions: [
		"osf"
	]
},
	"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osfpvg"
	]
},
	"application/vnd.yamaha.remote-setup": {
	source: "iana"
},
	"application/vnd.yamaha.smaf-audio": {
	source: "iana",
	extensions: [
		"saf"
	]
},
	"application/vnd.yamaha.smaf-phrase": {
	source: "iana",
	extensions: [
		"spf"
	]
},
	"application/vnd.yamaha.through-ngn": {
	source: "iana"
},
	"application/vnd.yamaha.tunnel-udpencap": {
	source: "iana"
},
	"application/vnd.yaoweme": {
	source: "iana"
},
	"application/vnd.yellowriver-custom-menu": {
	source: "iana",
	extensions: [
		"cmp"
	]
},
	"application/vnd.youtube.yt": {
	source: "iana"
},
	"application/vnd.zul": {
	source: "iana",
	extensions: [
		"zir",
		"zirz"
	]
},
	"application/vnd.zzazz.deck+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zaz"
	]
},
	"application/voicexml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"vxml"
	]
},
	"application/voucher-cms+json": {
	source: "iana",
	compressible: true
},
	"application/vq-rtcpxr": {
	source: "iana"
},
	"application/wasm": {
	source: "iana",
	compressible: true,
	extensions: [
		"wasm"
	]
},
	"application/watcherinfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wif"
	]
},
	"application/webpush-options+json": {
	source: "iana",
	compressible: true
},
	"application/whoispp-query": {
	source: "iana"
},
	"application/whoispp-response": {
	source: "iana"
},
	"application/widget": {
	source: "iana",
	extensions: [
		"wgt"
	]
},
	"application/winhlp": {
	source: "apache",
	extensions: [
		"hlp"
	]
},
	"application/wita": {
	source: "iana"
},
	"application/wordperfect5.1": {
	source: "iana"
},
	"application/wsdl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wsdl"
	]
},
	"application/wspolicy+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wspolicy"
	]
},
	"application/x-7z-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"7z"
	]
},
	"application/x-abiword": {
	source: "apache",
	extensions: [
		"abw"
	]
},
	"application/x-ace-compressed": {
	source: "apache",
	extensions: [
		"ace"
	]
},
	"application/x-amf": {
	source: "apache"
},
	"application/x-apple-diskimage": {
	source: "apache",
	extensions: [
		"dmg"
	]
},
	"application/x-arj": {
	compressible: false,
	extensions: [
		"arj"
	]
},
	"application/x-authorware-bin": {
	source: "apache",
	extensions: [
		"aab",
		"x32",
		"u32",
		"vox"
	]
},
	"application/x-authorware-map": {
	source: "apache",
	extensions: [
		"aam"
	]
},
	"application/x-authorware-seg": {
	source: "apache",
	extensions: [
		"aas"
	]
},
	"application/x-bcpio": {
	source: "apache",
	extensions: [
		"bcpio"
	]
},
	"application/x-bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/x-bittorrent": {
	source: "apache",
	extensions: [
		"torrent"
	]
},
	"application/x-blorb": {
	source: "apache",
	extensions: [
		"blb",
		"blorb"
	]
},
	"application/x-bzip": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz"
	]
},
	"application/x-bzip2": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz2",
		"boz"
	]
},
	"application/x-cbr": {
	source: "apache",
	extensions: [
		"cbr",
		"cba",
		"cbt",
		"cbz",
		"cb7"
	]
},
	"application/x-cdlink": {
	source: "apache",
	extensions: [
		"vcd"
	]
},
	"application/x-cfs-compressed": {
	source: "apache",
	extensions: [
		"cfs"
	]
},
	"application/x-chat": {
	source: "apache",
	extensions: [
		"chat"
	]
},
	"application/x-chess-pgn": {
	source: "apache",
	extensions: [
		"pgn"
	]
},
	"application/x-chrome-extension": {
	extensions: [
		"crx"
	]
},
	"application/x-cocoa": {
	source: "nginx",
	extensions: [
		"cco"
	]
},
	"application/x-compress": {
	source: "apache"
},
	"application/x-conference": {
	source: "apache",
	extensions: [
		"nsc"
	]
},
	"application/x-cpio": {
	source: "apache",
	extensions: [
		"cpio"
	]
},
	"application/x-csh": {
	source: "apache",
	extensions: [
		"csh"
	]
},
	"application/x-deb": {
	compressible: false
},
	"application/x-debian-package": {
	source: "apache",
	extensions: [
		"deb",
		"udeb"
	]
},
	"application/x-dgc-compressed": {
	source: "apache",
	extensions: [
		"dgc"
	]
},
	"application/x-director": {
	source: "apache",
	extensions: [
		"dir",
		"dcr",
		"dxr",
		"cst",
		"cct",
		"cxt",
		"w3d",
		"fgd",
		"swa"
	]
},
	"application/x-doom": {
	source: "apache",
	extensions: [
		"wad"
	]
},
	"application/x-dtbncx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ncx"
	]
},
	"application/x-dtbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dtb"
	]
},
	"application/x-dtbresource+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"res"
	]
},
	"application/x-dvi": {
	source: "apache",
	compressible: false,
	extensions: [
		"dvi"
	]
},
	"application/x-envoy": {
	source: "apache",
	extensions: [
		"evy"
	]
},
	"application/x-eva": {
	source: "apache",
	extensions: [
		"eva"
	]
},
	"application/x-font-bdf": {
	source: "apache",
	extensions: [
		"bdf"
	]
},
	"application/x-font-dos": {
	source: "apache"
},
	"application/x-font-framemaker": {
	source: "apache"
},
	"application/x-font-ghostscript": {
	source: "apache",
	extensions: [
		"gsf"
	]
},
	"application/x-font-libgrx": {
	source: "apache"
},
	"application/x-font-linux-psf": {
	source: "apache",
	extensions: [
		"psf"
	]
},
	"application/x-font-pcf": {
	source: "apache",
	extensions: [
		"pcf"
	]
},
	"application/x-font-snf": {
	source: "apache",
	extensions: [
		"snf"
	]
},
	"application/x-font-speedo": {
	source: "apache"
},
	"application/x-font-sunos-news": {
	source: "apache"
},
	"application/x-font-type1": {
	source: "apache",
	extensions: [
		"pfa",
		"pfb",
		"pfm",
		"afm"
	]
},
	"application/x-font-vfont": {
	source: "apache"
},
	"application/x-freearc": {
	source: "apache",
	extensions: [
		"arc"
	]
},
	"application/x-futuresplash": {
	source: "apache",
	extensions: [
		"spl"
	]
},
	"application/x-gca-compressed": {
	source: "apache",
	extensions: [
		"gca"
	]
},
	"application/x-glulx": {
	source: "apache",
	extensions: [
		"ulx"
	]
},
	"application/x-gnumeric": {
	source: "apache",
	extensions: [
		"gnumeric"
	]
},
	"application/x-gramps-xml": {
	source: "apache",
	extensions: [
		"gramps"
	]
},
	"application/x-gtar": {
	source: "apache",
	extensions: [
		"gtar"
	]
},
	"application/x-gzip": {
	source: "apache"
},
	"application/x-hdf": {
	source: "apache",
	extensions: [
		"hdf"
	]
},
	"application/x-httpd-php": {
	compressible: true,
	extensions: [
		"php"
	]
},
	"application/x-install-instructions": {
	source: "apache",
	extensions: [
		"install"
	]
},
	"application/x-iso9660-image": {
	source: "apache",
	extensions: [
		"iso"
	]
},
	"application/x-iwork-keynote-sffkey": {
	extensions: [
		"key"
	]
},
	"application/x-iwork-numbers-sffnumbers": {
	extensions: [
		"numbers"
	]
},
	"application/x-iwork-pages-sffpages": {
	extensions: [
		"pages"
	]
},
	"application/x-java-archive-diff": {
	source: "nginx",
	extensions: [
		"jardiff"
	]
},
	"application/x-java-jnlp-file": {
	source: "apache",
	compressible: false,
	extensions: [
		"jnlp"
	]
},
	"application/x-javascript": {
	compressible: true
},
	"application/x-keepass2": {
	extensions: [
		"kdbx"
	]
},
	"application/x-latex": {
	source: "apache",
	compressible: false,
	extensions: [
		"latex"
	]
},
	"application/x-lua-bytecode": {
	extensions: [
		"luac"
	]
},
	"application/x-lzh-compressed": {
	source: "apache",
	extensions: [
		"lzh",
		"lha"
	]
},
	"application/x-makeself": {
	source: "nginx",
	extensions: [
		"run"
	]
},
	"application/x-mie": {
	source: "apache",
	extensions: [
		"mie"
	]
},
	"application/x-mobipocket-ebook": {
	source: "apache",
	extensions: [
		"prc",
		"mobi"
	]
},
	"application/x-mpegurl": {
	compressible: false
},
	"application/x-ms-application": {
	source: "apache",
	extensions: [
		"application"
	]
},
	"application/x-ms-shortcut": {
	source: "apache",
	extensions: [
		"lnk"
	]
},
	"application/x-ms-wmd": {
	source: "apache",
	extensions: [
		"wmd"
	]
},
	"application/x-ms-wmz": {
	source: "apache",
	extensions: [
		"wmz"
	]
},
	"application/x-ms-xbap": {
	source: "apache",
	extensions: [
		"xbap"
	]
},
	"application/x-msaccess": {
	source: "apache",
	extensions: [
		"mdb"
	]
},
	"application/x-msbinder": {
	source: "apache",
	extensions: [
		"obd"
	]
},
	"application/x-mscardfile": {
	source: "apache",
	extensions: [
		"crd"
	]
},
	"application/x-msclip": {
	source: "apache",
	extensions: [
		"clp"
	]
},
	"application/x-msdos-program": {
	extensions: [
		"exe"
	]
},
	"application/x-msdownload": {
	source: "apache",
	extensions: [
		"exe",
		"dll",
		"com",
		"bat",
		"msi"
	]
},
	"application/x-msmediaview": {
	source: "apache",
	extensions: [
		"mvb",
		"m13",
		"m14"
	]
},
	"application/x-msmetafile": {
	source: "apache",
	extensions: [
		"wmf",
		"wmz",
		"emf",
		"emz"
	]
},
	"application/x-msmoney": {
	source: "apache",
	extensions: [
		"mny"
	]
},
	"application/x-mspublisher": {
	source: "apache",
	extensions: [
		"pub"
	]
},
	"application/x-msschedule": {
	source: "apache",
	extensions: [
		"scd"
	]
},
	"application/x-msterminal": {
	source: "apache",
	extensions: [
		"trm"
	]
},
	"application/x-mswrite": {
	source: "apache",
	extensions: [
		"wri"
	]
},
	"application/x-netcdf": {
	source: "apache",
	extensions: [
		"nc",
		"cdf"
	]
},
	"application/x-ns-proxy-autoconfig": {
	compressible: true,
	extensions: [
		"pac"
	]
},
	"application/x-nzb": {
	source: "apache",
	extensions: [
		"nzb"
	]
},
	"application/x-perl": {
	source: "nginx",
	extensions: [
		"pl",
		"pm"
	]
},
	"application/x-pilot": {
	source: "nginx",
	extensions: [
		"prc",
		"pdb"
	]
},
	"application/x-pkcs12": {
	source: "apache",
	compressible: false,
	extensions: [
		"p12",
		"pfx"
	]
},
	"application/x-pkcs7-certificates": {
	source: "apache",
	extensions: [
		"p7b",
		"spc"
	]
},
	"application/x-pkcs7-certreqresp": {
	source: "apache",
	extensions: [
		"p7r"
	]
},
	"application/x-pki-message": {
	source: "iana"
},
	"application/x-rar-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"rar"
	]
},
	"application/x-redhat-package-manager": {
	source: "nginx",
	extensions: [
		"rpm"
	]
},
	"application/x-research-info-systems": {
	source: "apache",
	extensions: [
		"ris"
	]
},
	"application/x-sea": {
	source: "nginx",
	extensions: [
		"sea"
	]
},
	"application/x-sh": {
	source: "apache",
	compressible: true,
	extensions: [
		"sh"
	]
},
	"application/x-shar": {
	source: "apache",
	extensions: [
		"shar"
	]
},
	"application/x-shockwave-flash": {
	source: "apache",
	compressible: false,
	extensions: [
		"swf"
	]
},
	"application/x-silverlight-app": {
	source: "apache",
	extensions: [
		"xap"
	]
},
	"application/x-sql": {
	source: "apache",
	extensions: [
		"sql"
	]
},
	"application/x-stuffit": {
	source: "apache",
	compressible: false,
	extensions: [
		"sit"
	]
},
	"application/x-stuffitx": {
	source: "apache",
	extensions: [
		"sitx"
	]
},
	"application/x-subrip": {
	source: "apache",
	extensions: [
		"srt"
	]
},
	"application/x-sv4cpio": {
	source: "apache",
	extensions: [
		"sv4cpio"
	]
},
	"application/x-sv4crc": {
	source: "apache",
	extensions: [
		"sv4crc"
	]
},
	"application/x-t3vm-image": {
	source: "apache",
	extensions: [
		"t3"
	]
},
	"application/x-tads": {
	source: "apache",
	extensions: [
		"gam"
	]
},
	"application/x-tar": {
	source: "apache",
	compressible: true,
	extensions: [
		"tar"
	]
},
	"application/x-tcl": {
	source: "apache",
	extensions: [
		"tcl",
		"tk"
	]
},
	"application/x-tex": {
	source: "apache",
	extensions: [
		"tex"
	]
},
	"application/x-tex-tfm": {
	source: "apache",
	extensions: [
		"tfm"
	]
},
	"application/x-texinfo": {
	source: "apache",
	extensions: [
		"texinfo",
		"texi"
	]
},
	"application/x-tgif": {
	source: "apache",
	extensions: [
		"obj"
	]
},
	"application/x-ustar": {
	source: "apache",
	extensions: [
		"ustar"
	]
},
	"application/x-virtualbox-hdd": {
	compressible: true,
	extensions: [
		"hdd"
	]
},
	"application/x-virtualbox-ova": {
	compressible: true,
	extensions: [
		"ova"
	]
},
	"application/x-virtualbox-ovf": {
	compressible: true,
	extensions: [
		"ovf"
	]
},
	"application/x-virtualbox-vbox": {
	compressible: true,
	extensions: [
		"vbox"
	]
},
	"application/x-virtualbox-vbox-extpack": {
	compressible: false,
	extensions: [
		"vbox-extpack"
	]
},
	"application/x-virtualbox-vdi": {
	compressible: true,
	extensions: [
		"vdi"
	]
},
	"application/x-virtualbox-vhd": {
	compressible: true,
	extensions: [
		"vhd"
	]
},
	"application/x-virtualbox-vmdk": {
	compressible: true,
	extensions: [
		"vmdk"
	]
},
	"application/x-wais-source": {
	source: "apache",
	extensions: [
		"src"
	]
},
	"application/x-web-app-manifest+json": {
	compressible: true,
	extensions: [
		"webapp"
	]
},
	"application/x-www-form-urlencoded": {
	source: "iana",
	compressible: true
},
	"application/x-x509-ca-cert": {
	source: "iana",
	extensions: [
		"der",
		"crt",
		"pem"
	]
},
	"application/x-x509-ca-ra-cert": {
	source: "iana"
},
	"application/x-x509-next-ca-cert": {
	source: "iana"
},
	"application/x-xfig": {
	source: "apache",
	extensions: [
		"fig"
	]
},
	"application/x-xliff+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/x-xpinstall": {
	source: "apache",
	compressible: false,
	extensions: [
		"xpi"
	]
},
	"application/x-xz": {
	source: "apache",
	extensions: [
		"xz"
	]
},
	"application/x-zmachine": {
	source: "apache",
	extensions: [
		"z1",
		"z2",
		"z3",
		"z4",
		"z5",
		"z6",
		"z7",
		"z8"
	]
},
	"application/x400-bp": {
	source: "iana"
},
	"application/xacml+xml": {
	source: "iana",
	compressible: true
},
	"application/xaml+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xaml"
	]
},
	"application/xcap-att+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xav"
	]
},
	"application/xcap-caps+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xca"
	]
},
	"application/xcap-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdf"
	]
},
	"application/xcap-el+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xel"
	]
},
	"application/xcap-error+xml": {
	source: "iana",
	compressible: true
},
	"application/xcap-ns+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xns"
	]
},
	"application/xcon-conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/xcon-conference-info-diff+xml": {
	source: "iana",
	compressible: true
},
	"application/xenc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xenc"
	]
},
	"application/xhtml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xhtml",
		"xht"
	]
},
	"application/xhtml-voice+xml": {
	source: "apache",
	compressible: true
},
	"application/xliff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml",
		"xsl",
		"xsd",
		"rng"
	]
},
	"application/xml-dtd": {
	source: "iana",
	compressible: true,
	extensions: [
		"dtd"
	]
},
	"application/xml-external-parsed-entity": {
	source: "iana"
},
	"application/xml-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/xmpp+xml": {
	source: "iana",
	compressible: true
},
	"application/xop+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xop"
	]
},
	"application/xproc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xpl"
	]
},
	"application/xslt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xsl",
		"xslt"
	]
},
	"application/xspf+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xspf"
	]
},
	"application/xv+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mxml",
		"xhvml",
		"xvml",
		"xvm"
	]
},
	"application/yang": {
	source: "iana",
	extensions: [
		"yang"
	]
},
	"application/yang-data+json": {
	source: "iana",
	compressible: true
},
	"application/yang-data+xml": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+json": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/yin+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"yin"
	]
},
	"application/zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"zip"
	]
},
	"application/zlib": {
	source: "iana"
},
	"application/zstd": {
	source: "iana"
},
	"audio/1d-interleaved-parityfec": {
	source: "iana"
},
	"audio/32kadpcm": {
	source: "iana"
},
	"audio/3gpp": {
	source: "iana",
	compressible: false,
	extensions: [
		"3gpp"
	]
},
	"audio/3gpp2": {
	source: "iana"
},
	"audio/aac": {
	source: "iana"
},
	"audio/ac3": {
	source: "iana"
},
	"audio/adpcm": {
	source: "apache",
	extensions: [
		"adp"
	]
},
	"audio/amr": {
	source: "iana",
	extensions: [
		"amr"
	]
},
	"audio/amr-wb": {
	source: "iana"
},
	"audio/amr-wb+": {
	source: "iana"
},
	"audio/aptx": {
	source: "iana"
},
	"audio/asc": {
	source: "iana"
},
	"audio/atrac-advanced-lossless": {
	source: "iana"
},
	"audio/atrac-x": {
	source: "iana"
},
	"audio/atrac3": {
	source: "iana"
},
	"audio/basic": {
	source: "iana",
	compressible: false,
	extensions: [
		"au",
		"snd"
	]
},
	"audio/bv16": {
	source: "iana"
},
	"audio/bv32": {
	source: "iana"
},
	"audio/clearmode": {
	source: "iana"
},
	"audio/cn": {
	source: "iana"
},
	"audio/dat12": {
	source: "iana"
},
	"audio/dls": {
	source: "iana"
},
	"audio/dsr-es201108": {
	source: "iana"
},
	"audio/dsr-es202050": {
	source: "iana"
},
	"audio/dsr-es202211": {
	source: "iana"
},
	"audio/dsr-es202212": {
	source: "iana"
},
	"audio/dv": {
	source: "iana"
},
	"audio/dvi4": {
	source: "iana"
},
	"audio/eac3": {
	source: "iana"
},
	"audio/encaprtp": {
	source: "iana"
},
	"audio/evrc": {
	source: "iana"
},
	"audio/evrc-qcp": {
	source: "iana"
},
	"audio/evrc0": {
	source: "iana"
},
	"audio/evrc1": {
	source: "iana"
},
	"audio/evrcb": {
	source: "iana"
},
	"audio/evrcb0": {
	source: "iana"
},
	"audio/evrcb1": {
	source: "iana"
},
	"audio/evrcnw": {
	source: "iana"
},
	"audio/evrcnw0": {
	source: "iana"
},
	"audio/evrcnw1": {
	source: "iana"
},
	"audio/evrcwb": {
	source: "iana"
},
	"audio/evrcwb0": {
	source: "iana"
},
	"audio/evrcwb1": {
	source: "iana"
},
	"audio/evs": {
	source: "iana"
},
	"audio/flexfec": {
	source: "iana"
},
	"audio/fwdred": {
	source: "iana"
},
	"audio/g711-0": {
	source: "iana"
},
	"audio/g719": {
	source: "iana"
},
	"audio/g722": {
	source: "iana"
},
	"audio/g7221": {
	source: "iana"
},
	"audio/g723": {
	source: "iana"
},
	"audio/g726-16": {
	source: "iana"
},
	"audio/g726-24": {
	source: "iana"
},
	"audio/g726-32": {
	source: "iana"
},
	"audio/g726-40": {
	source: "iana"
},
	"audio/g728": {
	source: "iana"
},
	"audio/g729": {
	source: "iana"
},
	"audio/g7291": {
	source: "iana"
},
	"audio/g729d": {
	source: "iana"
},
	"audio/g729e": {
	source: "iana"
},
	"audio/gsm": {
	source: "iana"
},
	"audio/gsm-efr": {
	source: "iana"
},
	"audio/gsm-hr-08": {
	source: "iana"
},
	"audio/ilbc": {
	source: "iana"
},
	"audio/ip-mr_v2.5": {
	source: "iana"
},
	"audio/isac": {
	source: "apache"
},
	"audio/l16": {
	source: "iana"
},
	"audio/l20": {
	source: "iana"
},
	"audio/l24": {
	source: "iana",
	compressible: false
},
	"audio/l8": {
	source: "iana"
},
	"audio/lpc": {
	source: "iana"
},
	"audio/melp": {
	source: "iana"
},
	"audio/melp1200": {
	source: "iana"
},
	"audio/melp2400": {
	source: "iana"
},
	"audio/melp600": {
	source: "iana"
},
	"audio/mhas": {
	source: "iana"
},
	"audio/midi": {
	source: "apache",
	extensions: [
		"mid",
		"midi",
		"kar",
		"rmi"
	]
},
	"audio/mobile-xmf": {
	source: "iana",
	extensions: [
		"mxmf"
	]
},
	"audio/mp3": {
	compressible: false,
	extensions: [
		"mp3"
	]
},
	"audio/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"m4a",
		"mp4a"
	]
},
	"audio/mp4a-latm": {
	source: "iana"
},
	"audio/mpa": {
	source: "iana"
},
	"audio/mpa-robust": {
	source: "iana"
},
	"audio/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpga",
		"mp2",
		"mp2a",
		"mp3",
		"m2a",
		"m3a"
	]
},
	"audio/mpeg4-generic": {
	source: "iana"
},
	"audio/musepack": {
	source: "apache"
},
	"audio/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"oga",
		"ogg",
		"spx",
		"opus"
	]
},
	"audio/opus": {
	source: "iana"
},
	"audio/parityfec": {
	source: "iana"
},
	"audio/pcma": {
	source: "iana"
},
	"audio/pcma-wb": {
	source: "iana"
},
	"audio/pcmu": {
	source: "iana"
},
	"audio/pcmu-wb": {
	source: "iana"
},
	"audio/prs.sid": {
	source: "iana"
},
	"audio/qcelp": {
	source: "iana"
},
	"audio/raptorfec": {
	source: "iana"
},
	"audio/red": {
	source: "iana"
},
	"audio/rtp-enc-aescm128": {
	source: "iana"
},
	"audio/rtp-midi": {
	source: "iana"
},
	"audio/rtploopback": {
	source: "iana"
},
	"audio/rtx": {
	source: "iana"
},
	"audio/s3m": {
	source: "apache",
	extensions: [
		"s3m"
	]
},
	"audio/scip": {
	source: "iana"
},
	"audio/silk": {
	source: "apache",
	extensions: [
		"sil"
	]
},
	"audio/smv": {
	source: "iana"
},
	"audio/smv-qcp": {
	source: "iana"
},
	"audio/smv0": {
	source: "iana"
},
	"audio/sofa": {
	source: "iana"
},
	"audio/sp-midi": {
	source: "iana"
},
	"audio/speex": {
	source: "iana"
},
	"audio/t140c": {
	source: "iana"
},
	"audio/t38": {
	source: "iana"
},
	"audio/telephone-event": {
	source: "iana"
},
	"audio/tetra_acelp": {
	source: "iana"
},
	"audio/tetra_acelp_bb": {
	source: "iana"
},
	"audio/tone": {
	source: "iana"
},
	"audio/tsvcis": {
	source: "iana"
},
	"audio/uemclip": {
	source: "iana"
},
	"audio/ulpfec": {
	source: "iana"
},
	"audio/usac": {
	source: "iana"
},
	"audio/vdvi": {
	source: "iana"
},
	"audio/vmr-wb": {
	source: "iana"
},
	"audio/vnd.3gpp.iufp": {
	source: "iana"
},
	"audio/vnd.4sb": {
	source: "iana"
},
	"audio/vnd.audiokoz": {
	source: "iana"
},
	"audio/vnd.celp": {
	source: "iana"
},
	"audio/vnd.cisco.nse": {
	source: "iana"
},
	"audio/vnd.cmles.radio-events": {
	source: "iana"
},
	"audio/vnd.cns.anp1": {
	source: "iana"
},
	"audio/vnd.cns.inf1": {
	source: "iana"
},
	"audio/vnd.dece.audio": {
	source: "iana",
	extensions: [
		"uva",
		"uvva"
	]
},
	"audio/vnd.digital-winds": {
	source: "iana",
	extensions: [
		"eol"
	]
},
	"audio/vnd.dlna.adts": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.1": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.2": {
	source: "iana"
},
	"audio/vnd.dolby.mlp": {
	source: "iana"
},
	"audio/vnd.dolby.mps": {
	source: "iana"
},
	"audio/vnd.dolby.pl2": {
	source: "iana"
},
	"audio/vnd.dolby.pl2x": {
	source: "iana"
},
	"audio/vnd.dolby.pl2z": {
	source: "iana"
},
	"audio/vnd.dolby.pulse.1": {
	source: "iana"
},
	"audio/vnd.dra": {
	source: "iana",
	extensions: [
		"dra"
	]
},
	"audio/vnd.dts": {
	source: "iana",
	extensions: [
		"dts"
	]
},
	"audio/vnd.dts.hd": {
	source: "iana",
	extensions: [
		"dtshd"
	]
},
	"audio/vnd.dts.uhd": {
	source: "iana"
},
	"audio/vnd.dvb.file": {
	source: "iana"
},
	"audio/vnd.everad.plj": {
	source: "iana"
},
	"audio/vnd.hns.audio": {
	source: "iana"
},
	"audio/vnd.lucent.voice": {
	source: "iana",
	extensions: [
		"lvp"
	]
},
	"audio/vnd.ms-playready.media.pya": {
	source: "iana",
	extensions: [
		"pya"
	]
},
	"audio/vnd.nokia.mobile-xmf": {
	source: "iana"
},
	"audio/vnd.nortel.vbk": {
	source: "iana"
},
	"audio/vnd.nuera.ecelp4800": {
	source: "iana",
	extensions: [
		"ecelp4800"
	]
},
	"audio/vnd.nuera.ecelp7470": {
	source: "iana",
	extensions: [
		"ecelp7470"
	]
},
	"audio/vnd.nuera.ecelp9600": {
	source: "iana",
	extensions: [
		"ecelp9600"
	]
},
	"audio/vnd.octel.sbc": {
	source: "iana"
},
	"audio/vnd.presonus.multitrack": {
	source: "iana"
},
	"audio/vnd.qcelp": {
	source: "iana"
},
	"audio/vnd.rhetorex.32kadpcm": {
	source: "iana"
},
	"audio/vnd.rip": {
	source: "iana",
	extensions: [
		"rip"
	]
},
	"audio/vnd.rn-realaudio": {
	compressible: false
},
	"audio/vnd.sealedmedia.softseal.mpeg": {
	source: "iana"
},
	"audio/vnd.vmx.cvsd": {
	source: "iana"
},
	"audio/vnd.wave": {
	compressible: false
},
	"audio/vorbis": {
	source: "iana",
	compressible: false
},
	"audio/vorbis-config": {
	source: "iana"
},
	"audio/wav": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/wave": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"weba"
	]
},
	"audio/x-aac": {
	source: "apache",
	compressible: false,
	extensions: [
		"aac"
	]
},
	"audio/x-aiff": {
	source: "apache",
	extensions: [
		"aif",
		"aiff",
		"aifc"
	]
},
	"audio/x-caf": {
	source: "apache",
	compressible: false,
	extensions: [
		"caf"
	]
},
	"audio/x-flac": {
	source: "apache",
	extensions: [
		"flac"
	]
},
	"audio/x-m4a": {
	source: "nginx",
	extensions: [
		"m4a"
	]
},
	"audio/x-matroska": {
	source: "apache",
	extensions: [
		"mka"
	]
},
	"audio/x-mpegurl": {
	source: "apache",
	extensions: [
		"m3u"
	]
},
	"audio/x-ms-wax": {
	source: "apache",
	extensions: [
		"wax"
	]
},
	"audio/x-ms-wma": {
	source: "apache",
	extensions: [
		"wma"
	]
},
	"audio/x-pn-realaudio": {
	source: "apache",
	extensions: [
		"ram",
		"ra"
	]
},
	"audio/x-pn-realaudio-plugin": {
	source: "apache",
	extensions: [
		"rmp"
	]
},
	"audio/x-realaudio": {
	source: "nginx",
	extensions: [
		"ra"
	]
},
	"audio/x-tta": {
	source: "apache"
},
	"audio/x-wav": {
	source: "apache",
	extensions: [
		"wav"
	]
},
	"audio/xm": {
	source: "apache",
	extensions: [
		"xm"
	]
},
	"chemical/x-cdx": {
	source: "apache",
	extensions: [
		"cdx"
	]
},
	"chemical/x-cif": {
	source: "apache",
	extensions: [
		"cif"
	]
},
	"chemical/x-cmdf": {
	source: "apache",
	extensions: [
		"cmdf"
	]
},
	"chemical/x-cml": {
	source: "apache",
	extensions: [
		"cml"
	]
},
	"chemical/x-csml": {
	source: "apache",
	extensions: [
		"csml"
	]
},
	"chemical/x-pdb": {
	source: "apache"
},
	"chemical/x-xyz": {
	source: "apache",
	extensions: [
		"xyz"
	]
},
	"font/collection": {
	source: "iana",
	extensions: [
		"ttc"
	]
},
	"font/otf": {
	source: "iana",
	compressible: true,
	extensions: [
		"otf"
	]
},
	"font/sfnt": {
	source: "iana"
},
	"font/ttf": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttf"
	]
},
	"font/woff": {
	source: "iana",
	extensions: [
		"woff"
	]
},
	"font/woff2": {
	source: "iana",
	extensions: [
		"woff2"
	]
},
	"image/aces": {
	source: "iana",
	extensions: [
		"exr"
	]
},
	"image/apng": {
	compressible: false,
	extensions: [
		"apng"
	]
},
	"image/avci": {
	source: "iana",
	extensions: [
		"avci"
	]
},
	"image/avcs": {
	source: "iana",
	extensions: [
		"avcs"
	]
},
	"image/avif": {
	source: "iana",
	compressible: false,
	extensions: [
		"avif"
	]
},
	"image/bmp": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/cgm": {
	source: "iana",
	extensions: [
		"cgm"
	]
},
	"image/dicom-rle": {
	source: "iana",
	extensions: [
		"drle"
	]
},
	"image/emf": {
	source: "iana",
	extensions: [
		"emf"
	]
},
	"image/fits": {
	source: "iana",
	extensions: [
		"fits"
	]
},
	"image/g3fax": {
	source: "iana",
	extensions: [
		"g3"
	]
},
	"image/gif": {
	source: "iana",
	compressible: false,
	extensions: [
		"gif"
	]
},
	"image/heic": {
	source: "iana",
	extensions: [
		"heic"
	]
},
	"image/heic-sequence": {
	source: "iana",
	extensions: [
		"heics"
	]
},
	"image/heif": {
	source: "iana",
	extensions: [
		"heif"
	]
},
	"image/heif-sequence": {
	source: "iana",
	extensions: [
		"heifs"
	]
},
	"image/hej2k": {
	source: "iana",
	extensions: [
		"hej2"
	]
},
	"image/hsj2": {
	source: "iana",
	extensions: [
		"hsj2"
	]
},
	"image/ief": {
	source: "iana",
	extensions: [
		"ief"
	]
},
	"image/jls": {
	source: "iana",
	extensions: [
		"jls"
	]
},
	"image/jp2": {
	source: "iana",
	compressible: false,
	extensions: [
		"jp2",
		"jpg2"
	]
},
	"image/jpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpeg",
		"jpg",
		"jpe"
	]
},
	"image/jph": {
	source: "iana",
	extensions: [
		"jph"
	]
},
	"image/jphc": {
	source: "iana",
	extensions: [
		"jhc"
	]
},
	"image/jpm": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpm"
	]
},
	"image/jpx": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpx",
		"jpf"
	]
},
	"image/jxr": {
	source: "iana",
	extensions: [
		"jxr"
	]
},
	"image/jxra": {
	source: "iana",
	extensions: [
		"jxra"
	]
},
	"image/jxrs": {
	source: "iana",
	extensions: [
		"jxrs"
	]
},
	"image/jxs": {
	source: "iana",
	extensions: [
		"jxs"
	]
},
	"image/jxsc": {
	source: "iana",
	extensions: [
		"jxsc"
	]
},
	"image/jxsi": {
	source: "iana",
	extensions: [
		"jxsi"
	]
},
	"image/jxss": {
	source: "iana",
	extensions: [
		"jxss"
	]
},
	"image/ktx": {
	source: "iana",
	extensions: [
		"ktx"
	]
},
	"image/ktx2": {
	source: "iana",
	extensions: [
		"ktx2"
	]
},
	"image/naplps": {
	source: "iana"
},
	"image/pjpeg": {
	compressible: false
},
	"image/png": {
	source: "iana",
	compressible: false,
	extensions: [
		"png"
	]
},
	"image/prs.btif": {
	source: "iana",
	extensions: [
		"btif"
	]
},
	"image/prs.pti": {
	source: "iana",
	extensions: [
		"pti"
	]
},
	"image/pwg-raster": {
	source: "iana"
},
	"image/sgi": {
	source: "apache",
	extensions: [
		"sgi"
	]
},
	"image/svg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"svg",
		"svgz"
	]
},
	"image/t38": {
	source: "iana",
	extensions: [
		"t38"
	]
},
	"image/tiff": {
	source: "iana",
	compressible: false,
	extensions: [
		"tif",
		"tiff"
	]
},
	"image/tiff-fx": {
	source: "iana",
	extensions: [
		"tfx"
	]
},
	"image/vnd.adobe.photoshop": {
	source: "iana",
	compressible: true,
	extensions: [
		"psd"
	]
},
	"image/vnd.airzip.accelerator.azv": {
	source: "iana",
	extensions: [
		"azv"
	]
},
	"image/vnd.cns.inf2": {
	source: "iana"
},
	"image/vnd.dece.graphic": {
	source: "iana",
	extensions: [
		"uvi",
		"uvvi",
		"uvg",
		"uvvg"
	]
},
	"image/vnd.djvu": {
	source: "iana",
	extensions: [
		"djvu",
		"djv"
	]
},
	"image/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"image/vnd.dwg": {
	source: "iana",
	extensions: [
		"dwg"
	]
},
	"image/vnd.dxf": {
	source: "iana",
	extensions: [
		"dxf"
	]
},
	"image/vnd.fastbidsheet": {
	source: "iana",
	extensions: [
		"fbs"
	]
},
	"image/vnd.fpx": {
	source: "iana",
	extensions: [
		"fpx"
	]
},
	"image/vnd.fst": {
	source: "iana",
	extensions: [
		"fst"
	]
},
	"image/vnd.fujixerox.edmics-mmr": {
	source: "iana",
	extensions: [
		"mmr"
	]
},
	"image/vnd.fujixerox.edmics-rlc": {
	source: "iana",
	extensions: [
		"rlc"
	]
},
	"image/vnd.globalgraphics.pgb": {
	source: "iana"
},
	"image/vnd.microsoft.icon": {
	source: "iana",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/vnd.mix": {
	source: "iana"
},
	"image/vnd.mozilla.apng": {
	source: "iana"
},
	"image/vnd.ms-dds": {
	compressible: true,
	extensions: [
		"dds"
	]
},
	"image/vnd.ms-modi": {
	source: "iana",
	extensions: [
		"mdi"
	]
},
	"image/vnd.ms-photo": {
	source: "apache",
	extensions: [
		"wdp"
	]
},
	"image/vnd.net-fpx": {
	source: "iana",
	extensions: [
		"npx"
	]
},
	"image/vnd.pco.b16": {
	source: "iana",
	extensions: [
		"b16"
	]
},
	"image/vnd.radiance": {
	source: "iana"
},
	"image/vnd.sealed.png": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.gif": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.jpg": {
	source: "iana"
},
	"image/vnd.svf": {
	source: "iana"
},
	"image/vnd.tencent.tap": {
	source: "iana",
	extensions: [
		"tap"
	]
},
	"image/vnd.valve.source.texture": {
	source: "iana",
	extensions: [
		"vtf"
	]
},
	"image/vnd.wap.wbmp": {
	source: "iana",
	extensions: [
		"wbmp"
	]
},
	"image/vnd.xiff": {
	source: "iana",
	extensions: [
		"xif"
	]
},
	"image/vnd.zbrush.pcx": {
	source: "iana",
	extensions: [
		"pcx"
	]
},
	"image/webp": {
	source: "apache",
	extensions: [
		"webp"
	]
},
	"image/wmf": {
	source: "iana",
	extensions: [
		"wmf"
	]
},
	"image/x-3ds": {
	source: "apache",
	extensions: [
		"3ds"
	]
},
	"image/x-cmu-raster": {
	source: "apache",
	extensions: [
		"ras"
	]
},
	"image/x-cmx": {
	source: "apache",
	extensions: [
		"cmx"
	]
},
	"image/x-freehand": {
	source: "apache",
	extensions: [
		"fh",
		"fhc",
		"fh4",
		"fh5",
		"fh7"
	]
},
	"image/x-icon": {
	source: "apache",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/x-jng": {
	source: "nginx",
	extensions: [
		"jng"
	]
},
	"image/x-mrsid-image": {
	source: "apache",
	extensions: [
		"sid"
	]
},
	"image/x-ms-bmp": {
	source: "nginx",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/x-pcx": {
	source: "apache",
	extensions: [
		"pcx"
	]
},
	"image/x-pict": {
	source: "apache",
	extensions: [
		"pic",
		"pct"
	]
},
	"image/x-portable-anymap": {
	source: "apache",
	extensions: [
		"pnm"
	]
},
	"image/x-portable-bitmap": {
	source: "apache",
	extensions: [
		"pbm"
	]
},
	"image/x-portable-graymap": {
	source: "apache",
	extensions: [
		"pgm"
	]
},
	"image/x-portable-pixmap": {
	source: "apache",
	extensions: [
		"ppm"
	]
},
	"image/x-rgb": {
	source: "apache",
	extensions: [
		"rgb"
	]
},
	"image/x-tga": {
	source: "apache",
	extensions: [
		"tga"
	]
},
	"image/x-xbitmap": {
	source: "apache",
	extensions: [
		"xbm"
	]
},
	"image/x-xcf": {
	compressible: false
},
	"image/x-xpixmap": {
	source: "apache",
	extensions: [
		"xpm"
	]
},
	"image/x-xwindowdump": {
	source: "apache",
	extensions: [
		"xwd"
	]
},
	"message/cpim": {
	source: "iana"
},
	"message/delivery-status": {
	source: "iana"
},
	"message/disposition-notification": {
	source: "iana",
	extensions: [
		"disposition-notification"
	]
},
	"message/external-body": {
	source: "iana"
},
	"message/feedback-report": {
	source: "iana"
},
	"message/global": {
	source: "iana",
	extensions: [
		"u8msg"
	]
},
	"message/global-delivery-status": {
	source: "iana",
	extensions: [
		"u8dsn"
	]
},
	"message/global-disposition-notification": {
	source: "iana",
	extensions: [
		"u8mdn"
	]
},
	"message/global-headers": {
	source: "iana",
	extensions: [
		"u8hdr"
	]
},
	"message/http": {
	source: "iana",
	compressible: false
},
	"message/imdn+xml": {
	source: "iana",
	compressible: true
},
	"message/news": {
	source: "iana"
},
	"message/partial": {
	source: "iana",
	compressible: false
},
	"message/rfc822": {
	source: "iana",
	compressible: true,
	extensions: [
		"eml",
		"mime"
	]
},
	"message/s-http": {
	source: "iana"
},
	"message/sip": {
	source: "iana"
},
	"message/sipfrag": {
	source: "iana"
},
	"message/tracking-status": {
	source: "iana"
},
	"message/vnd.si.simp": {
	source: "iana"
},
	"message/vnd.wfa.wsc": {
	source: "iana",
	extensions: [
		"wsc"
	]
},
	"model/3mf": {
	source: "iana",
	extensions: [
		"3mf"
	]
},
	"model/e57": {
	source: "iana"
},
	"model/gltf+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"gltf"
	]
},
	"model/gltf-binary": {
	source: "iana",
	compressible: true,
	extensions: [
		"glb"
	]
},
	"model/iges": {
	source: "iana",
	compressible: false,
	extensions: [
		"igs",
		"iges"
	]
},
	"model/mesh": {
	source: "iana",
	compressible: false,
	extensions: [
		"msh",
		"mesh",
		"silo"
	]
},
	"model/mtl": {
	source: "iana",
	extensions: [
		"mtl"
	]
},
	"model/obj": {
	source: "iana",
	extensions: [
		"obj"
	]
},
	"model/step": {
	source: "iana"
},
	"model/step+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"stpx"
	]
},
	"model/step+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpz"
	]
},
	"model/step-xml+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpxz"
	]
},
	"model/stl": {
	source: "iana",
	extensions: [
		"stl"
	]
},
	"model/vnd.collada+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dae"
	]
},
	"model/vnd.dwf": {
	source: "iana",
	extensions: [
		"dwf"
	]
},
	"model/vnd.flatland.3dml": {
	source: "iana"
},
	"model/vnd.gdl": {
	source: "iana",
	extensions: [
		"gdl"
	]
},
	"model/vnd.gs-gdl": {
	source: "apache"
},
	"model/vnd.gs.gdl": {
	source: "iana"
},
	"model/vnd.gtw": {
	source: "iana",
	extensions: [
		"gtw"
	]
},
	"model/vnd.moml+xml": {
	source: "iana",
	compressible: true
},
	"model/vnd.mts": {
	source: "iana",
	extensions: [
		"mts"
	]
},
	"model/vnd.opengex": {
	source: "iana",
	extensions: [
		"ogex"
	]
},
	"model/vnd.parasolid.transmit.binary": {
	source: "iana",
	extensions: [
		"x_b"
	]
},
	"model/vnd.parasolid.transmit.text": {
	source: "iana",
	extensions: [
		"x_t"
	]
},
	"model/vnd.pytha.pyox": {
	source: "iana"
},
	"model/vnd.rosette.annotated-data-model": {
	source: "iana"
},
	"model/vnd.sap.vds": {
	source: "iana",
	extensions: [
		"vds"
	]
},
	"model/vnd.usdz+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"usdz"
	]
},
	"model/vnd.valve.source.compiled-map": {
	source: "iana",
	extensions: [
		"bsp"
	]
},
	"model/vnd.vtu": {
	source: "iana",
	extensions: [
		"vtu"
	]
},
	"model/vrml": {
	source: "iana",
	compressible: false,
	extensions: [
		"wrl",
		"vrml"
	]
},
	"model/x3d+binary": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3db",
		"x3dbz"
	]
},
	"model/x3d+fastinfoset": {
	source: "iana",
	extensions: [
		"x3db"
	]
},
	"model/x3d+vrml": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3dv",
		"x3dvz"
	]
},
	"model/x3d+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"x3d",
		"x3dz"
	]
},
	"model/x3d-vrml": {
	source: "iana",
	extensions: [
		"x3dv"
	]
},
	"multipart/alternative": {
	source: "iana",
	compressible: false
},
	"multipart/appledouble": {
	source: "iana"
},
	"multipart/byteranges": {
	source: "iana"
},
	"multipart/digest": {
	source: "iana"
},
	"multipart/encrypted": {
	source: "iana",
	compressible: false
},
	"multipart/form-data": {
	source: "iana",
	compressible: false
},
	"multipart/header-set": {
	source: "iana"
},
	"multipart/mixed": {
	source: "iana"
},
	"multipart/multilingual": {
	source: "iana"
},
	"multipart/parallel": {
	source: "iana"
},
	"multipart/related": {
	source: "iana",
	compressible: false
},
	"multipart/report": {
	source: "iana"
},
	"multipart/signed": {
	source: "iana",
	compressible: false
},
	"multipart/vnd.bint.med-plus": {
	source: "iana"
},
	"multipart/voice-message": {
	source: "iana"
},
	"multipart/x-mixed-replace": {
	source: "iana"
},
	"text/1d-interleaved-parityfec": {
	source: "iana"
},
	"text/cache-manifest": {
	source: "iana",
	compressible: true,
	extensions: [
		"appcache",
		"manifest"
	]
},
	"text/calendar": {
	source: "iana",
	extensions: [
		"ics",
		"ifb"
	]
},
	"text/calender": {
	compressible: true
},
	"text/cmd": {
	compressible: true
},
	"text/coffeescript": {
	extensions: [
		"coffee",
		"litcoffee"
	]
},
	"text/cql": {
	source: "iana"
},
	"text/cql-expression": {
	source: "iana"
},
	"text/cql-identifier": {
	source: "iana"
},
	"text/css": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"css"
	]
},
	"text/csv": {
	source: "iana",
	compressible: true,
	extensions: [
		"csv"
	]
},
	"text/csv-schema": {
	source: "iana"
},
	"text/directory": {
	source: "iana"
},
	"text/dns": {
	source: "iana"
},
	"text/ecmascript": {
	source: "iana"
},
	"text/encaprtp": {
	source: "iana"
},
	"text/enriched": {
	source: "iana"
},
	"text/fhirpath": {
	source: "iana"
},
	"text/flexfec": {
	source: "iana"
},
	"text/fwdred": {
	source: "iana"
},
	"text/gff3": {
	source: "iana"
},
	"text/grammar-ref-list": {
	source: "iana"
},
	"text/html": {
	source: "iana",
	compressible: true,
	extensions: [
		"html",
		"htm",
		"shtml"
	]
},
	"text/jade": {
	extensions: [
		"jade"
	]
},
	"text/javascript": {
	source: "iana",
	compressible: true
},
	"text/jcr-cnd": {
	source: "iana"
},
	"text/jsx": {
	compressible: true,
	extensions: [
		"jsx"
	]
},
	"text/less": {
	compressible: true,
	extensions: [
		"less"
	]
},
	"text/markdown": {
	source: "iana",
	compressible: true,
	extensions: [
		"markdown",
		"md"
	]
},
	"text/mathml": {
	source: "nginx",
	extensions: [
		"mml"
	]
},
	"text/mdx": {
	compressible: true,
	extensions: [
		"mdx"
	]
},
	"text/mizar": {
	source: "iana"
},
	"text/n3": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"n3"
	]
},
	"text/parameters": {
	source: "iana",
	charset: "UTF-8"
},
	"text/parityfec": {
	source: "iana"
},
	"text/plain": {
	source: "iana",
	compressible: true,
	extensions: [
		"txt",
		"text",
		"conf",
		"def",
		"list",
		"log",
		"in",
		"ini"
	]
},
	"text/provenance-notation": {
	source: "iana",
	charset: "UTF-8"
},
	"text/prs.fallenstein.rst": {
	source: "iana"
},
	"text/prs.lines.tag": {
	source: "iana",
	extensions: [
		"dsc"
	]
},
	"text/prs.prop.logic": {
	source: "iana"
},
	"text/raptorfec": {
	source: "iana"
},
	"text/red": {
	source: "iana"
},
	"text/rfc822-headers": {
	source: "iana"
},
	"text/richtext": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtx"
	]
},
	"text/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"text/rtp-enc-aescm128": {
	source: "iana"
},
	"text/rtploopback": {
	source: "iana"
},
	"text/rtx": {
	source: "iana"
},
	"text/sgml": {
	source: "iana",
	extensions: [
		"sgml",
		"sgm"
	]
},
	"text/shaclc": {
	source: "iana"
},
	"text/shex": {
	source: "iana",
	extensions: [
		"shex"
	]
},
	"text/slim": {
	extensions: [
		"slim",
		"slm"
	]
},
	"text/spdx": {
	source: "iana",
	extensions: [
		"spdx"
	]
},
	"text/strings": {
	source: "iana"
},
	"text/stylus": {
	extensions: [
		"stylus",
		"styl"
	]
},
	"text/t140": {
	source: "iana"
},
	"text/tab-separated-values": {
	source: "iana",
	compressible: true,
	extensions: [
		"tsv"
	]
},
	"text/troff": {
	source: "iana",
	extensions: [
		"t",
		"tr",
		"roff",
		"man",
		"me",
		"ms"
	]
},
	"text/turtle": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"ttl"
	]
},
	"text/ulpfec": {
	source: "iana"
},
	"text/uri-list": {
	source: "iana",
	compressible: true,
	extensions: [
		"uri",
		"uris",
		"urls"
	]
},
	"text/vcard": {
	source: "iana",
	compressible: true,
	extensions: [
		"vcard"
	]
},
	"text/vnd.a": {
	source: "iana"
},
	"text/vnd.abc": {
	source: "iana"
},
	"text/vnd.ascii-art": {
	source: "iana"
},
	"text/vnd.curl": {
	source: "iana",
	extensions: [
		"curl"
	]
},
	"text/vnd.curl.dcurl": {
	source: "apache",
	extensions: [
		"dcurl"
	]
},
	"text/vnd.curl.mcurl": {
	source: "apache",
	extensions: [
		"mcurl"
	]
},
	"text/vnd.curl.scurl": {
	source: "apache",
	extensions: [
		"scurl"
	]
},
	"text/vnd.debian.copyright": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.dmclientscript": {
	source: "iana"
},
	"text/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"text/vnd.esmertec.theme-descriptor": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.familysearch.gedcom": {
	source: "iana",
	extensions: [
		"ged"
	]
},
	"text/vnd.ficlab.flt": {
	source: "iana"
},
	"text/vnd.fly": {
	source: "iana",
	extensions: [
		"fly"
	]
},
	"text/vnd.fmi.flexstor": {
	source: "iana",
	extensions: [
		"flx"
	]
},
	"text/vnd.gml": {
	source: "iana"
},
	"text/vnd.graphviz": {
	source: "iana",
	extensions: [
		"gv"
	]
},
	"text/vnd.hans": {
	source: "iana"
},
	"text/vnd.hgl": {
	source: "iana"
},
	"text/vnd.in3d.3dml": {
	source: "iana",
	extensions: [
		"3dml"
	]
},
	"text/vnd.in3d.spot": {
	source: "iana",
	extensions: [
		"spot"
	]
},
	"text/vnd.iptc.newsml": {
	source: "iana"
},
	"text/vnd.iptc.nitf": {
	source: "iana"
},
	"text/vnd.latex-z": {
	source: "iana"
},
	"text/vnd.motorola.reflex": {
	source: "iana"
},
	"text/vnd.ms-mediapackage": {
	source: "iana"
},
	"text/vnd.net2phone.commcenter.command": {
	source: "iana"
},
	"text/vnd.radisys.msml-basic-layout": {
	source: "iana"
},
	"text/vnd.senx.warpscript": {
	source: "iana"
},
	"text/vnd.si.uricatalogue": {
	source: "iana"
},
	"text/vnd.sosi": {
	source: "iana"
},
	"text/vnd.sun.j2me.app-descriptor": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"jad"
	]
},
	"text/vnd.trolltech.linguist": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.wap.si": {
	source: "iana"
},
	"text/vnd.wap.sl": {
	source: "iana"
},
	"text/vnd.wap.wml": {
	source: "iana",
	extensions: [
		"wml"
	]
},
	"text/vnd.wap.wmlscript": {
	source: "iana",
	extensions: [
		"wmls"
	]
},
	"text/vtt": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"vtt"
	]
},
	"text/x-asm": {
	source: "apache",
	extensions: [
		"s",
		"asm"
	]
},
	"text/x-c": {
	source: "apache",
	extensions: [
		"c",
		"cc",
		"cxx",
		"cpp",
		"h",
		"hh",
		"dic"
	]
},
	"text/x-component": {
	source: "nginx",
	extensions: [
		"htc"
	]
},
	"text/x-fortran": {
	source: "apache",
	extensions: [
		"f",
		"for",
		"f77",
		"f90"
	]
},
	"text/x-gwt-rpc": {
	compressible: true
},
	"text/x-handlebars-template": {
	extensions: [
		"hbs"
	]
},
	"text/x-java-source": {
	source: "apache",
	extensions: [
		"java"
	]
},
	"text/x-jquery-tmpl": {
	compressible: true
},
	"text/x-lua": {
	extensions: [
		"lua"
	]
},
	"text/x-markdown": {
	compressible: true,
	extensions: [
		"mkd"
	]
},
	"text/x-nfo": {
	source: "apache",
	extensions: [
		"nfo"
	]
},
	"text/x-opml": {
	source: "apache",
	extensions: [
		"opml"
	]
},
	"text/x-org": {
	compressible: true,
	extensions: [
		"org"
	]
},
	"text/x-pascal": {
	source: "apache",
	extensions: [
		"p",
		"pas"
	]
},
	"text/x-processing": {
	compressible: true,
	extensions: [
		"pde"
	]
},
	"text/x-sass": {
	extensions: [
		"sass"
	]
},
	"text/x-scss": {
	extensions: [
		"scss"
	]
},
	"text/x-setext": {
	source: "apache",
	extensions: [
		"etx"
	]
},
	"text/x-sfv": {
	source: "apache",
	extensions: [
		"sfv"
	]
},
	"text/x-suse-ymp": {
	compressible: true,
	extensions: [
		"ymp"
	]
},
	"text/x-uuencode": {
	source: "apache",
	extensions: [
		"uu"
	]
},
	"text/x-vcalendar": {
	source: "apache",
	extensions: [
		"vcs"
	]
},
	"text/x-vcard": {
	source: "apache",
	extensions: [
		"vcf"
	]
},
	"text/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml"
	]
},
	"text/xml-external-parsed-entity": {
	source: "iana"
},
	"text/yaml": {
	compressible: true,
	extensions: [
		"yaml",
		"yml"
	]
},
	"video/1d-interleaved-parityfec": {
	source: "iana"
},
	"video/3gpp": {
	source: "iana",
	extensions: [
		"3gp",
		"3gpp"
	]
},
	"video/3gpp-tt": {
	source: "iana"
},
	"video/3gpp2": {
	source: "iana",
	extensions: [
		"3g2"
	]
},
	"video/av1": {
	source: "iana"
},
	"video/bmpeg": {
	source: "iana"
},
	"video/bt656": {
	source: "iana"
},
	"video/celb": {
	source: "iana"
},
	"video/dv": {
	source: "iana"
},
	"video/encaprtp": {
	source: "iana"
},
	"video/ffv1": {
	source: "iana"
},
	"video/flexfec": {
	source: "iana"
},
	"video/h261": {
	source: "iana",
	extensions: [
		"h261"
	]
},
	"video/h263": {
	source: "iana",
	extensions: [
		"h263"
	]
},
	"video/h263-1998": {
	source: "iana"
},
	"video/h263-2000": {
	source: "iana"
},
	"video/h264": {
	source: "iana",
	extensions: [
		"h264"
	]
},
	"video/h264-rcdo": {
	source: "iana"
},
	"video/h264-svc": {
	source: "iana"
},
	"video/h265": {
	source: "iana"
},
	"video/iso.segment": {
	source: "iana",
	extensions: [
		"m4s"
	]
},
	"video/jpeg": {
	source: "iana",
	extensions: [
		"jpgv"
	]
},
	"video/jpeg2000": {
	source: "iana"
},
	"video/jpm": {
	source: "apache",
	extensions: [
		"jpm",
		"jpgm"
	]
},
	"video/jxsv": {
	source: "iana"
},
	"video/mj2": {
	source: "iana",
	extensions: [
		"mj2",
		"mjp2"
	]
},
	"video/mp1s": {
	source: "iana"
},
	"video/mp2p": {
	source: "iana"
},
	"video/mp2t": {
	source: "iana",
	extensions: [
		"ts"
	]
},
	"video/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"mp4",
		"mp4v",
		"mpg4"
	]
},
	"video/mp4v-es": {
	source: "iana"
},
	"video/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpeg",
		"mpg",
		"mpe",
		"m1v",
		"m2v"
	]
},
	"video/mpeg4-generic": {
	source: "iana"
},
	"video/mpv": {
	source: "iana"
},
	"video/nv": {
	source: "iana"
},
	"video/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogv"
	]
},
	"video/parityfec": {
	source: "iana"
},
	"video/pointer": {
	source: "iana"
},
	"video/quicktime": {
	source: "iana",
	compressible: false,
	extensions: [
		"qt",
		"mov"
	]
},
	"video/raptorfec": {
	source: "iana"
},
	"video/raw": {
	source: "iana"
},
	"video/rtp-enc-aescm128": {
	source: "iana"
},
	"video/rtploopback": {
	source: "iana"
},
	"video/rtx": {
	source: "iana"
},
	"video/scip": {
	source: "iana"
},
	"video/smpte291": {
	source: "iana"
},
	"video/smpte292m": {
	source: "iana"
},
	"video/ulpfec": {
	source: "iana"
},
	"video/vc1": {
	source: "iana"
},
	"video/vc2": {
	source: "iana"
},
	"video/vnd.cctv": {
	source: "iana"
},
	"video/vnd.dece.hd": {
	source: "iana",
	extensions: [
		"uvh",
		"uvvh"
	]
},
	"video/vnd.dece.mobile": {
	source: "iana",
	extensions: [
		"uvm",
		"uvvm"
	]
},
	"video/vnd.dece.mp4": {
	source: "iana"
},
	"video/vnd.dece.pd": {
	source: "iana",
	extensions: [
		"uvp",
		"uvvp"
	]
},
	"video/vnd.dece.sd": {
	source: "iana",
	extensions: [
		"uvs",
		"uvvs"
	]
},
	"video/vnd.dece.video": {
	source: "iana",
	extensions: [
		"uvv",
		"uvvv"
	]
},
	"video/vnd.directv.mpeg": {
	source: "iana"
},
	"video/vnd.directv.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dlna.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dvb.file": {
	source: "iana",
	extensions: [
		"dvb"
	]
},
	"video/vnd.fvt": {
	source: "iana",
	extensions: [
		"fvt"
	]
},
	"video/vnd.hns.video": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsavc": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsmpeg2": {
	source: "iana"
},
	"video/vnd.motorola.video": {
	source: "iana"
},
	"video/vnd.motorola.videop": {
	source: "iana"
},
	"video/vnd.mpegurl": {
	source: "iana",
	extensions: [
		"mxu",
		"m4u"
	]
},
	"video/vnd.ms-playready.media.pyv": {
	source: "iana",
	extensions: [
		"pyv"
	]
},
	"video/vnd.nokia.interleaved-multimedia": {
	source: "iana"
},
	"video/vnd.nokia.mp4vr": {
	source: "iana"
},
	"video/vnd.nokia.videovoip": {
	source: "iana"
},
	"video/vnd.objectvideo": {
	source: "iana"
},
	"video/vnd.radgamettools.bink": {
	source: "iana"
},
	"video/vnd.radgamettools.smacker": {
	source: "iana"
},
	"video/vnd.sealed.mpeg1": {
	source: "iana"
},
	"video/vnd.sealed.mpeg4": {
	source: "iana"
},
	"video/vnd.sealed.swf": {
	source: "iana"
},
	"video/vnd.sealedmedia.softseal.mov": {
	source: "iana"
},
	"video/vnd.uvvu.mp4": {
	source: "iana",
	extensions: [
		"uvu",
		"uvvu"
	]
},
	"video/vnd.vivo": {
	source: "iana",
	extensions: [
		"viv"
	]
},
	"video/vnd.youtube.yt": {
	source: "iana"
},
	"video/vp8": {
	source: "iana"
},
	"video/vp9": {
	source: "iana"
},
	"video/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"webm"
	]
},
	"video/x-f4v": {
	source: "apache",
	extensions: [
		"f4v"
	]
},
	"video/x-fli": {
	source: "apache",
	extensions: [
		"fli"
	]
},
	"video/x-flv": {
	source: "apache",
	compressible: false,
	extensions: [
		"flv"
	]
},
	"video/x-m4v": {
	source: "apache",
	extensions: [
		"m4v"
	]
},
	"video/x-matroska": {
	source: "apache",
	compressible: false,
	extensions: [
		"mkv",
		"mk3d",
		"mks"
	]
},
	"video/x-mng": {
	source: "apache",
	extensions: [
		"mng"
	]
},
	"video/x-ms-asf": {
	source: "apache",
	extensions: [
		"asf",
		"asx"
	]
},
	"video/x-ms-vob": {
	source: "apache",
	extensions: [
		"vob"
	]
},
	"video/x-ms-wm": {
	source: "apache",
	extensions: [
		"wm"
	]
},
	"video/x-ms-wmv": {
	source: "apache",
	compressible: false,
	extensions: [
		"wmv"
	]
},
	"video/x-ms-wmx": {
	source: "apache",
	extensions: [
		"wmx"
	]
},
	"video/x-ms-wvx": {
	source: "apache",
	extensions: [
		"wvx"
	]
},
	"video/x-msvideo": {
	source: "apache",
	extensions: [
		"avi"
	]
},
	"video/x-sgi-movie": {
	source: "apache",
	extensions: [
		"movie"
	]
},
	"video/x-smv": {
	source: "apache",
	extensions: [
		"smv"
	]
},
	"x-conference/x-cooltalk": {
	source: "apache",
	extensions: [
		"ice"
	]
},
	"x-shader/x-fragment": {
	compressible: true
},
	"x-shader/x-vertex": {
	compressible: true
}
};

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

var mimeDb;
var hasRequiredMimeDb;

function requireMimeDb () {
	if (hasRequiredMimeDb) return mimeDb;
	hasRequiredMimeDb = 1;
	/**
	 * Module exports.
	 */

	mimeDb = require$$0$1;
	return mimeDb;
}

/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredMimeTypes;

function requireMimeTypes () {
	if (hasRequiredMimeTypes) return mimeTypes;
	hasRequiredMimeTypes = 1;
	(function (exports) {

		/**
		 * Module dependencies.
		 * @private
		 */

		var db = requireMimeDb();
		var extname = require$$0$4.extname;

		/**
		 * Module variables.
		 * @private
		 */

		var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
		var TEXT_TYPE_REGEXP = /^text\//i;

		/**
		 * Module exports.
		 * @public
		 */

		exports.charset = charset;
		exports.charsets = { lookup: charset };
		exports.contentType = contentType;
		exports.extension = extension;
		exports.extensions = Object.create(null);
		exports.lookup = lookup;
		exports.types = Object.create(null);

		// Populate the extensions/types maps
		populateMaps(exports.extensions, exports.types);

		/**
		 * Get the default charset for a MIME type.
		 *
		 * @param {string} type
		 * @return {boolean|string}
		 */

		function charset (type) {
		  if (!type || typeof type !== 'string') {
		    return false
		  }

		  // TODO: use media-typer
		  var match = EXTRACT_TYPE_REGEXP.exec(type);
		  var mime = match && db[match[1].toLowerCase()];

		  if (mime && mime.charset) {
		    return mime.charset
		  }

		  // default text/* to utf-8
		  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
		    return 'UTF-8'
		  }

		  return false
		}

		/**
		 * Create a full Content-Type header given a MIME type or extension.
		 *
		 * @param {string} str
		 * @return {boolean|string}
		 */

		function contentType (str) {
		  // TODO: should this even be in this module?
		  if (!str || typeof str !== 'string') {
		    return false
		  }

		  var mime = str.indexOf('/') === -1
		    ? exports.lookup(str)
		    : str;

		  if (!mime) {
		    return false
		  }

		  // TODO: use content-type or other module
		  if (mime.indexOf('charset') === -1) {
		    var charset = exports.charset(mime);
		    if (charset) mime += '; charset=' + charset.toLowerCase();
		  }

		  return mime
		}

		/**
		 * Get the default extension for a MIME type.
		 *
		 * @param {string} type
		 * @return {boolean|string}
		 */

		function extension (type) {
		  if (!type || typeof type !== 'string') {
		    return false
		  }

		  // TODO: use media-typer
		  var match = EXTRACT_TYPE_REGEXP.exec(type);

		  // get extensions
		  var exts = match && exports.extensions[match[1].toLowerCase()];

		  if (!exts || !exts.length) {
		    return false
		  }

		  return exts[0]
		}

		/**
		 * Lookup the MIME type for a file path/extension.
		 *
		 * @param {string} path
		 * @return {boolean|string}
		 */

		function lookup (path) {
		  if (!path || typeof path !== 'string') {
		    return false
		  }

		  // get the extension ("ext" or ".ext" or full path)
		  var extension = extname('x.' + path)
		    .toLowerCase()
		    .substr(1);

		  if (!extension) {
		    return false
		  }

		  return exports.types[extension] || false
		}

		/**
		 * Populate the extensions and types maps.
		 * @private
		 */

		function populateMaps (extensions, types) {
		  // source preference (least -> most)
		  var preference = ['nginx', 'apache', undefined, 'iana'];

		  Object.keys(db).forEach(function forEachMimeType (type) {
		    var mime = db[type];
		    var exts = mime.extensions;

		    if (!exts || !exts.length) {
		      return
		    }

		    // mime -> extensions
		    extensions[type] = exts;

		    // extension -> mime
		    for (var i = 0; i < exts.length; i++) {
		      var extension = exts[i];

		      if (types[extension]) {
		        var from = preference.indexOf(db[types[extension]].source);
		        var to = preference.indexOf(mime.source);

		        if (types[extension] !== 'application/octet-stream' &&
		          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
		          // skip the remapping
		          continue
		        }
		      }

		      // set the extension -> mime
		      types[extension] = type;
		    }
		  });
		} 
	} (mimeTypes));
	return mimeTypes;
}

/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredTypeIs;

function requireTypeIs () {
	if (hasRequiredTypeIs) return typeIs.exports;
	hasRequiredTypeIs = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var typer = requireMediaTyper();
	var mime = requireMimeTypes();

	/**
	 * Module exports.
	 * @public
	 */

	typeIs.exports = typeofrequest;
	typeIs.exports.is = typeis;
	typeIs.exports.hasBody = hasbody;
	typeIs.exports.normalize = normalize;
	typeIs.exports.match = mimeMatch;

	/**
	 * Compare a `value` content-type with `types`.
	 * Each `type` can be an extension like `html`,
	 * a special shortcut like `multipart` or `urlencoded`,
	 * or a mime type.
	 *
	 * If no types match, `false` is returned.
	 * Otherwise, the first `type` that matches is returned.
	 *
	 * @param {String} value
	 * @param {Array} types
	 * @public
	 */

	function typeis (value, types_) {
	  var i;
	  var types = types_;

	  // remove parameters and normalize
	  var val = tryNormalizeType(value);

	  // no type or invalid
	  if (!val) {
	    return false
	  }

	  // support flattened arguments
	  if (types && !Array.isArray(types)) {
	    types = new Array(arguments.length - 1);
	    for (i = 0; i < types.length; i++) {
	      types[i] = arguments[i + 1];
	    }
	  }

	  // no types, return the content type
	  if (!types || !types.length) {
	    return val
	  }

	  var type;
	  for (i = 0; i < types.length; i++) {
	    if (mimeMatch(normalize(type = types[i]), val)) {
	      return type[0] === '+' || type.indexOf('*') !== -1
	        ? val
	        : type
	    }
	  }

	  // no matches
	  return false
	}

	/**
	 * Check if a request has a request body.
	 * A request with a body __must__ either have `transfer-encoding`
	 * or `content-length` headers set.
	 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
	 *
	 * @param {Object} request
	 * @return {Boolean}
	 * @public
	 */

	function hasbody (req) {
	  return req.headers['transfer-encoding'] !== undefined ||
	    !isNaN(req.headers['content-length'])
	}

	/**
	 * Check if the incoming request contains the "Content-Type"
	 * header field, and it contains any of the give mime `type`s.
	 * If there is no request body, `null` is returned.
	 * If there is no content type, `false` is returned.
	 * Otherwise, it returns the first `type` that matches.
	 *
	 * Examples:
	 *
	 *     // With Content-Type: text/html; charset=utf-8
	 *     this.is('html'); // => 'html'
	 *     this.is('text/html'); // => 'text/html'
	 *     this.is('text/*', 'application/json'); // => 'text/html'
	 *
	 *     // When Content-Type is application/json
	 *     this.is('json', 'urlencoded'); // => 'json'
	 *     this.is('application/json'); // => 'application/json'
	 *     this.is('html', 'application/*'); // => 'application/json'
	 *
	 *     this.is('html'); // => false
	 *
	 * @param {String|Array} types...
	 * @return {String|false|null}
	 * @public
	 */

	function typeofrequest (req, types_) {
	  var types = types_;

	  // no body
	  if (!hasbody(req)) {
	    return null
	  }

	  // support flattened arguments
	  if (arguments.length > 2) {
	    types = new Array(arguments.length - 1);
	    for (var i = 0; i < types.length; i++) {
	      types[i] = arguments[i + 1];
	    }
	  }

	  // request content type
	  var value = req.headers['content-type'];

	  return typeis(value, types)
	}

	/**
	 * Normalize a mime type.
	 * If it's a shorthand, expand it to a valid mime type.
	 *
	 * In general, you probably want:
	 *
	 *   var type = is(req, ['urlencoded', 'json', 'multipart']);
	 *
	 * Then use the appropriate body parsers.
	 * These three are the most common request body types
	 * and are thus ensured to work.
	 *
	 * @param {String} type
	 * @private
	 */

	function normalize (type) {
	  if (typeof type !== 'string') {
	    // invalid type
	    return false
	  }

	  switch (type) {
	    case 'urlencoded':
	      return 'application/x-www-form-urlencoded'
	    case 'multipart':
	      return 'multipart/*'
	  }

	  if (type[0] === '+') {
	    // "+json" -> "*/*+json" expando
	    return '*/*' + type
	  }

	  return type.indexOf('/') === -1
	    ? mime.lookup(type)
	    : type
	}

	/**
	 * Check if `expected` mime type
	 * matches `actual` mime type with
	 * wildcard and +suffix support.
	 *
	 * @param {String} expected
	 * @param {String} actual
	 * @return {Boolean}
	 * @private
	 */

	function mimeMatch (expected, actual) {
	  // invalid type
	  if (expected === false) {
	    return false
	  }

	  // split types
	  var actualParts = actual.split('/');
	  var expectedParts = expected.split('/');

	  // invalid format
	  if (actualParts.length !== 2 || expectedParts.length !== 2) {
	    return false
	  }

	  // validate type
	  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
	    return false
	  }

	  // validate suffix wildcard
	  if (expectedParts[1].substr(0, 2) === '*+') {
	    return expectedParts[1].length <= actualParts[1].length + 1 &&
	      expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length)
	  }

	  // validate subtype
	  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
	    return false
	  }

	  return true
	}

	/**
	 * Normalize a type and remove parameters.
	 *
	 * @param {string} value
	 * @return {string}
	 * @private
	 */

	function normalizeType (value) {
	  // parse the type
	  var type = typer.parse(value);

	  // remove the parameters
	  type.parameters = undefined;

	  // reformat it
	  return typer.format(type)
	}

	/**
	 * Try to normalize a type and remove parameters.
	 *
	 * @param {string} value
	 * @return {string}
	 * @private
	 */

	function tryNormalizeType (value) {
	  if (!value) {
	    return null
	  }

	  try {
	    return normalizeType(value)
	  } catch (err) {
	    return null
	  }
	}
	return typeIs.exports;
}

/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var json_1;
var hasRequiredJson;

function requireJson () {
	if (hasRequiredJson) return json_1;
	hasRequiredJson = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var bytes = requireBytes();
	var contentType = requireContentType();
	var createError = requireHttpErrors();
	var debug = requireSrc$3()('body-parser:json');
	var read = requireRead();
	var typeis = requireTypeIs();

	/**
	 * Module exports.
	 */

	json_1 = json;

	/**
	 * RegExp to match the first non-space in a string.
	 *
	 * Allowed whitespace is defined in RFC 7159:
	 *
	 *    ws = *(
	 *            %x20 /              ; Space
	 *            %x09 /              ; Horizontal tab
	 *            %x0A /              ; Line feed or New line
	 *            %x0D )              ; Carriage return
	 */

	var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/; // eslint-disable-line no-control-regex

	var JSON_SYNTAX_CHAR = '#';
	var JSON_SYNTAX_REGEXP = /#+/g;

	/**
	 * Create a middleware to parse JSON bodies.
	 *
	 * @param {object} [options]
	 * @return {function}
	 * @public
	 */

	function json (options) {
	  var opts = options || {};

	  var limit = typeof opts.limit !== 'number'
	    ? bytes.parse(opts.limit || '100kb')
	    : opts.limit;
	  var inflate = opts.inflate !== false;
	  var reviver = opts.reviver;
	  var strict = opts.strict !== false;
	  var type = opts.type || 'application/json';
	  var verify = opts.verify || false;

	  if (verify !== false && typeof verify !== 'function') {
	    throw new TypeError('option verify must be function')
	  }

	  // create the appropriate type checking function
	  var shouldParse = typeof type !== 'function'
	    ? typeChecker(type)
	    : type;

	  function parse (body) {
	    if (body.length === 0) {
	      // special-case empty json body, as it's a common client-side mistake
	      // TODO: maybe make this configurable or part of "strict" option
	      return {}
	    }

	    if (strict) {
	      var first = firstchar(body);

	      if (first !== '{' && first !== '[') {
	        debug('strict violation');
	        throw createStrictSyntaxError(body, first)
	      }
	    }

	    try {
	      debug('parse json');
	      return JSON.parse(body, reviver)
	    } catch (e) {
	      throw normalizeJsonSyntaxError(e, {
	        message: e.message,
	        stack: e.stack
	      })
	    }
	  }

	  return function jsonParser (req, res, next) {
	    if (req._body) {
	      debug('body already parsed');
	      next();
	      return
	    }

	    req.body = req.body || {};

	    // skip requests without bodies
	    if (!typeis.hasBody(req)) {
	      debug('skip empty body');
	      next();
	      return
	    }

	    debug('content-type %j', req.headers['content-type']);

	    // determine if request should be parsed
	    if (!shouldParse(req)) {
	      debug('skip parsing');
	      next();
	      return
	    }

	    // assert charset per RFC 7159 sec 8.1
	    var charset = getCharset(req) || 'utf-8';
	    if (charset.slice(0, 4) !== 'utf-') {
	      debug('invalid charset');
	      next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
	        charset: charset,
	        type: 'charset.unsupported'
	      }));
	      return
	    }

	    // read
	    read(req, res, next, parse, debug, {
	      encoding: charset,
	      inflate: inflate,
	      limit: limit,
	      verify: verify
	    });
	  }
	}

	/**
	 * Create strict violation syntax error matching native error.
	 *
	 * @param {string} str
	 * @param {string} char
	 * @return {Error}
	 * @private
	 */

	function createStrictSyntaxError (str, char) {
	  var index = str.indexOf(char);
	  var partial = '';

	  if (index !== -1) {
	    partial = str.substring(0, index) + JSON_SYNTAX_CHAR;

	    for (var i = index + 1; i < str.length; i++) {
	      partial += JSON_SYNTAX_CHAR;
	    }
	  }

	  try {
	    JSON.parse(partial); /* istanbul ignore next */ throw new SyntaxError('strict violation')
	  } catch (e) {
	    return normalizeJsonSyntaxError(e, {
	      message: e.message.replace(JSON_SYNTAX_REGEXP, function (placeholder) {
	        return str.substring(index, index + placeholder.length)
	      }),
	      stack: e.stack
	    })
	  }
	}

	/**
	 * Get the first non-whitespace character in a string.
	 *
	 * @param {string} str
	 * @return {function}
	 * @private
	 */

	function firstchar (str) {
	  var match = FIRST_CHAR_REGEXP.exec(str);

	  return match
	    ? match[1]
	    : undefined
	}

	/**
	 * Get the charset of a request.
	 *
	 * @param {object} req
	 * @api private
	 */

	function getCharset (req) {
	  try {
	    return (contentType.parse(req).parameters.charset || '').toLowerCase()
	  } catch (e) {
	    return undefined
	  }
	}

	/**
	 * Normalize a SyntaxError for JSON.parse.
	 *
	 * @param {SyntaxError} error
	 * @param {object} obj
	 * @return {SyntaxError}
	 */

	function normalizeJsonSyntaxError (error, obj) {
	  var keys = Object.getOwnPropertyNames(error);

	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (key !== 'stack' && key !== 'message') {
	      delete error[key];
	    }
	  }

	  // replace stack before message for Node.js 0.10 and below
	  error.stack = obj.stack.replace(error.message, obj.message);
	  error.message = obj.message;

	  return error
	}

	/**
	 * Get the simple type checker.
	 *
	 * @param {string} type
	 * @return {function}
	 */

	function typeChecker (type) {
	  return function checkType (req) {
	    return Boolean(typeis(req, type))
	  }
	}
	return json_1;
}

/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var raw_1;
var hasRequiredRaw;

function requireRaw () {
	if (hasRequiredRaw) return raw_1;
	hasRequiredRaw = 1;

	/**
	 * Module dependencies.
	 */

	var bytes = requireBytes();
	var debug = requireSrc$3()('body-parser:raw');
	var read = requireRead();
	var typeis = requireTypeIs();

	/**
	 * Module exports.
	 */

	raw_1 = raw;

	/**
	 * Create a middleware to parse raw bodies.
	 *
	 * @param {object} [options]
	 * @return {function}
	 * @api public
	 */

	function raw (options) {
	  var opts = options || {};

	  var inflate = opts.inflate !== false;
	  var limit = typeof opts.limit !== 'number'
	    ? bytes.parse(opts.limit || '100kb')
	    : opts.limit;
	  var type = opts.type || 'application/octet-stream';
	  var verify = opts.verify || false;

	  if (verify !== false && typeof verify !== 'function') {
	    throw new TypeError('option verify must be function')
	  }

	  // create the appropriate type checking function
	  var shouldParse = typeof type !== 'function'
	    ? typeChecker(type)
	    : type;

	  function parse (buf) {
	    return buf
	  }

	  return function rawParser (req, res, next) {
	    if (req._body) {
	      debug('body already parsed');
	      next();
	      return
	    }

	    req.body = req.body || {};

	    // skip requests without bodies
	    if (!typeis.hasBody(req)) {
	      debug('skip empty body');
	      next();
	      return
	    }

	    debug('content-type %j', req.headers['content-type']);

	    // determine if request should be parsed
	    if (!shouldParse(req)) {
	      debug('skip parsing');
	      next();
	      return
	    }

	    // read
	    read(req, res, next, parse, debug, {
	      encoding: null,
	      inflate: inflate,
	      limit: limit,
	      verify: verify
	    });
	  }
	}

	/**
	 * Get the simple type checker.
	 *
	 * @param {string} type
	 * @return {function}
	 */

	function typeChecker (type) {
	  return function checkType (req) {
	    return Boolean(typeis(req, type))
	  }
	}
	return raw_1;
}

/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var text_1;
var hasRequiredText;

function requireText () {
	if (hasRequiredText) return text_1;
	hasRequiredText = 1;

	/**
	 * Module dependencies.
	 */

	var bytes = requireBytes();
	var contentType = requireContentType();
	var debug = requireSrc$3()('body-parser:text');
	var read = requireRead();
	var typeis = requireTypeIs();

	/**
	 * Module exports.
	 */

	text_1 = text;

	/**
	 * Create a middleware to parse text bodies.
	 *
	 * @param {object} [options]
	 * @return {function}
	 * @api public
	 */

	function text (options) {
	  var opts = options || {};

	  var defaultCharset = opts.defaultCharset || 'utf-8';
	  var inflate = opts.inflate !== false;
	  var limit = typeof opts.limit !== 'number'
	    ? bytes.parse(opts.limit || '100kb')
	    : opts.limit;
	  var type = opts.type || 'text/plain';
	  var verify = opts.verify || false;

	  if (verify !== false && typeof verify !== 'function') {
	    throw new TypeError('option verify must be function')
	  }

	  // create the appropriate type checking function
	  var shouldParse = typeof type !== 'function'
	    ? typeChecker(type)
	    : type;

	  function parse (buf) {
	    return buf
	  }

	  return function textParser (req, res, next) {
	    if (req._body) {
	      debug('body already parsed');
	      next();
	      return
	    }

	    req.body = req.body || {};

	    // skip requests without bodies
	    if (!typeis.hasBody(req)) {
	      debug('skip empty body');
	      next();
	      return
	    }

	    debug('content-type %j', req.headers['content-type']);

	    // determine if request should be parsed
	    if (!shouldParse(req)) {
	      debug('skip parsing');
	      next();
	      return
	    }

	    // get charset
	    var charset = getCharset(req) || defaultCharset;

	    // read
	    read(req, res, next, parse, debug, {
	      encoding: charset,
	      inflate: inflate,
	      limit: limit,
	      verify: verify
	    });
	  }
	}

	/**
	 * Get the charset of a request.
	 *
	 * @param {object} req
	 * @api private
	 */

	function getCharset (req) {
	  try {
	    return (contentType.parse(req).parameters.charset || '').toLowerCase()
	  } catch (e) {
	    return undefined
	  }
	}

	/**
	 * Get the simple type checker.
	 *
	 * @param {string} type
	 * @return {function}
	 */

	function typeChecker (type) {
	  return function checkType (req) {
	    return Boolean(typeis(req, type))
	  }
	}
	return text_1;
}

var esErrors;
var hasRequiredEsErrors;

function requireEsErrors () {
	if (hasRequiredEsErrors) return esErrors;
	hasRequiredEsErrors = 1;

	/** @type {import('.')} */
	esErrors = Error;
	return esErrors;
}

var _eval;
var hasRequired_eval;

function require_eval () {
	if (hasRequired_eval) return _eval;
	hasRequired_eval = 1;

	/** @type {import('./eval')} */
	_eval = EvalError;
	return _eval;
}

var range;
var hasRequiredRange;

function requireRange () {
	if (hasRequiredRange) return range;
	hasRequiredRange = 1;

	/** @type {import('./range')} */
	range = RangeError;
	return range;
}

var ref;
var hasRequiredRef;

function requireRef () {
	if (hasRequiredRef) return ref;
	hasRequiredRef = 1;

	/** @type {import('./ref')} */
	ref = ReferenceError;
	return ref;
}

var syntax;
var hasRequiredSyntax;

function requireSyntax () {
	if (hasRequiredSyntax) return syntax;
	hasRequiredSyntax = 1;

	/** @type {import('./syntax')} */
	syntax = SyntaxError;
	return syntax;
}

var type;
var hasRequiredType;

function requireType () {
	if (hasRequiredType) return type;
	hasRequiredType = 1;

	/** @type {import('./type')} */
	type = TypeError;
	return type;
}

var uri;
var hasRequiredUri;

function requireUri () {
	if (hasRequiredUri) return uri;
	hasRequiredUri = 1;

	/** @type {import('./uri')} */
	uri = URIError;
	return uri;
}

var shams;
var hasRequiredShams;

function requireShams () {
	if (hasRequiredShams) return shams;
	hasRequiredShams = 1;

	/* eslint complexity: [2, 18], max-statements: [2, 33] */
	shams = function hasSymbols() {
		if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
		if (typeof Symbol.iterator === 'symbol') { return true; }

		var obj = {};
		var sym = Symbol('test');
		var symObj = Object(sym);
		if (typeof sym === 'string') { return false; }

		if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
		if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

		// temp disabled per https://github.com/ljharb/object.assign/issues/17
		// if (sym instanceof Symbol) { return false; }
		// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
		// if (!(symObj instanceof Symbol)) { return false; }

		// if (typeof Symbol.prototype.toString !== 'function') { return false; }
		// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

		var symVal = 42;
		obj[sym] = symVal;
		for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
		if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

		if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) { return false; }

		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

		if (typeof Object.getOwnPropertyDescriptor === 'function') {
			var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
			if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
		}

		return true;
	};
	return shams;
}

var hasSymbols;
var hasRequiredHasSymbols;

function requireHasSymbols () {
	if (hasRequiredHasSymbols) return hasSymbols;
	hasRequiredHasSymbols = 1;

	var origSymbol = typeof Symbol !== 'undefined' && Symbol;
	var hasSymbolSham = requireShams();

	hasSymbols = function hasNativeSymbols() {
		if (typeof origSymbol !== 'function') { return false; }
		if (typeof Symbol !== 'function') { return false; }
		if (typeof origSymbol('foo') !== 'symbol') { return false; }
		if (typeof Symbol('bar') !== 'symbol') { return false; }

		return hasSymbolSham();
	};
	return hasSymbols;
}

var hasProto;
var hasRequiredHasProto;

function requireHasProto () {
	if (hasRequiredHasProto) return hasProto;
	hasRequiredHasProto = 1;

	var test = {
		__proto__: null,
		foo: {}
	};

	var $Object = Object;

	/** @type {import('.')} */
	hasProto = function hasProto() {
		// @ts-expect-error: TS errors on an inherited property for some reason
		return { __proto__: test }.foo === test.foo
			&& !(test instanceof $Object);
	};
	return hasProto;
}

var implementation;
var hasRequiredImplementation;

function requireImplementation () {
	if (hasRequiredImplementation) return implementation;
	hasRequiredImplementation = 1;

	/* eslint no-invalid-this: 1 */

	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
	var toStr = Object.prototype.toString;
	var max = Math.max;
	var funcType = '[object Function]';

	var concatty = function concatty(a, b) {
	    var arr = [];

	    for (var i = 0; i < a.length; i += 1) {
	        arr[i] = a[i];
	    }
	    for (var j = 0; j < b.length; j += 1) {
	        arr[j + a.length] = b[j];
	    }

	    return arr;
	};

	var slicy = function slicy(arrLike, offset) {
	    var arr = [];
	    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
	        arr[j] = arrLike[i];
	    }
	    return arr;
	};

	var joiny = function (arr, joiner) {
	    var str = '';
	    for (var i = 0; i < arr.length; i += 1) {
	        str += arr[i];
	        if (i + 1 < arr.length) {
	            str += joiner;
	        }
	    }
	    return str;
	};

	implementation = function bind(that) {
	    var target = this;
	    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
	        throw new TypeError(ERROR_MESSAGE + target);
	    }
	    var args = slicy(arguments, 1);

	    var bound;
	    var binder = function () {
	        if (this instanceof bound) {
	            var result = target.apply(
	                this,
	                concatty(args, arguments)
	            );
	            if (Object(result) === result) {
	                return result;
	            }
	            return this;
	        }
	        return target.apply(
	            that,
	            concatty(args, arguments)
	        );

	    };

	    var boundLength = max(0, target.length - args.length);
	    var boundArgs = [];
	    for (var i = 0; i < boundLength; i++) {
	        boundArgs[i] = '$' + i;
	    }

	    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

	    if (target.prototype) {
	        var Empty = function Empty() {};
	        Empty.prototype = target.prototype;
	        bound.prototype = new Empty();
	        Empty.prototype = null;
	    }

	    return bound;
	};
	return implementation;
}

var functionBind;
var hasRequiredFunctionBind;

function requireFunctionBind () {
	if (hasRequiredFunctionBind) return functionBind;
	hasRequiredFunctionBind = 1;

	var implementation = requireImplementation();

	functionBind = Function.prototype.bind || implementation;
	return functionBind;
}

var hasown;
var hasRequiredHasown;

function requireHasown () {
	if (hasRequiredHasown) return hasown;
	hasRequiredHasown = 1;

	var call = Function.prototype.call;
	var $hasOwn = Object.prototype.hasOwnProperty;
	var bind = requireFunctionBind();

	/** @type {import('.')} */
	hasown = bind.call(call, $hasOwn);
	return hasown;
}

var getIntrinsic;
var hasRequiredGetIntrinsic;

function requireGetIntrinsic () {
	if (hasRequiredGetIntrinsic) return getIntrinsic;
	hasRequiredGetIntrinsic = 1;

	var undefined$1;

	var $Error = /*@__PURE__*/ requireEsErrors();
	var $EvalError = /*@__PURE__*/ require_eval();
	var $RangeError = /*@__PURE__*/ requireRange();
	var $ReferenceError = /*@__PURE__*/ requireRef();
	var $SyntaxError = /*@__PURE__*/ requireSyntax();
	var $TypeError = /*@__PURE__*/ requireType();
	var $URIError = /*@__PURE__*/ requireUri();

	var $Function = Function;

	// eslint-disable-next-line consistent-return
	var getEvalledConstructor = function (expressionSyntax) {
		try {
			return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
		} catch (e) {}
	};

	var $gOPD = Object.getOwnPropertyDescriptor;
	if ($gOPD) {
		try {
			$gOPD({}, '');
		} catch (e) {
			$gOPD = null; // this is IE 8, which has a broken gOPD
		}
	}

	var throwTypeError = function () {
		throw new $TypeError();
	};
	var ThrowTypeError = $gOPD
		? (function () {
			try {
				// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
				arguments.callee; // IE 8 does not throw here
				return throwTypeError;
			} catch (calleeThrows) {
				try {
					// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
					return $gOPD(arguments, 'callee').get;
				} catch (gOPDthrows) {
					return throwTypeError;
				}
			}
		}())
		: throwTypeError;

	var hasSymbols = requireHasSymbols()();
	var hasProto = /*@__PURE__*/ requireHasProto()();

	var getProto = Object.getPrototypeOf || (
		hasProto
			? function (x) { return x.__proto__; } // eslint-disable-line no-proto
			: null
	);

	var needsEval = {};

	var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined$1 : getProto(Uint8Array);

	var INTRINSICS = {
		__proto__: null,
		'%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
		'%Array%': Array,
		'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
		'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
		'%AsyncFromSyncIteratorPrototype%': undefined$1,
		'%AsyncFunction%': needsEval,
		'%AsyncGenerator%': needsEval,
		'%AsyncGeneratorFunction%': needsEval,
		'%AsyncIteratorPrototype%': needsEval,
		'%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
		'%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
		'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined$1 : BigInt64Array,
		'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined$1 : BigUint64Array,
		'%Boolean%': Boolean,
		'%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
		'%Date%': Date,
		'%decodeURI%': decodeURI,
		'%decodeURIComponent%': decodeURIComponent,
		'%encodeURI%': encodeURI,
		'%encodeURIComponent%': encodeURIComponent,
		'%Error%': $Error,
		'%eval%': eval, // eslint-disable-line no-eval
		'%EvalError%': $EvalError,
		'%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
		'%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
		'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
		'%Function%': $Function,
		'%GeneratorFunction%': needsEval,
		'%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
		'%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
		'%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
		'%isFinite%': isFinite,
		'%isNaN%': isNaN,
		'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
		'%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
		'%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
		'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
		'%Math%': Math,
		'%Number%': Number,
		'%Object%': Object,
		'%parseFloat%': parseFloat,
		'%parseInt%': parseInt,
		'%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
		'%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
		'%RangeError%': $RangeError,
		'%ReferenceError%': $ReferenceError,
		'%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
		'%RegExp%': RegExp,
		'%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
		'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
		'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
		'%String%': String,
		'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined$1,
		'%Symbol%': hasSymbols ? Symbol : undefined$1,
		'%SyntaxError%': $SyntaxError,
		'%ThrowTypeError%': ThrowTypeError,
		'%TypedArray%': TypedArray,
		'%TypeError%': $TypeError,
		'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
		'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
		'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
		'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
		'%URIError%': $URIError,
		'%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
		'%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
		'%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet
	};

	if (getProto) {
		try {
			null.error; // eslint-disable-line no-unused-expressions
		} catch (e) {
			// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
			var errorProto = getProto(getProto(e));
			INTRINSICS['%Error.prototype%'] = errorProto;
		}
	}

	var doEval = function doEval(name) {
		var value;
		if (name === '%AsyncFunction%') {
			value = getEvalledConstructor('async function () {}');
		} else if (name === '%GeneratorFunction%') {
			value = getEvalledConstructor('function* () {}');
		} else if (name === '%AsyncGeneratorFunction%') {
			value = getEvalledConstructor('async function* () {}');
		} else if (name === '%AsyncGenerator%') {
			var fn = doEval('%AsyncGeneratorFunction%');
			if (fn) {
				value = fn.prototype;
			}
		} else if (name === '%AsyncIteratorPrototype%') {
			var gen = doEval('%AsyncGenerator%');
			if (gen && getProto) {
				value = getProto(gen.prototype);
			}
		}

		INTRINSICS[name] = value;

		return value;
	};

	var LEGACY_ALIASES = {
		__proto__: null,
		'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
		'%ArrayPrototype%': ['Array', 'prototype'],
		'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
		'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
		'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
		'%ArrayProto_values%': ['Array', 'prototype', 'values'],
		'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
		'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
		'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
		'%BooleanPrototype%': ['Boolean', 'prototype'],
		'%DataViewPrototype%': ['DataView', 'prototype'],
		'%DatePrototype%': ['Date', 'prototype'],
		'%ErrorPrototype%': ['Error', 'prototype'],
		'%EvalErrorPrototype%': ['EvalError', 'prototype'],
		'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
		'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
		'%FunctionPrototype%': ['Function', 'prototype'],
		'%Generator%': ['GeneratorFunction', 'prototype'],
		'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
		'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
		'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
		'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
		'%JSONParse%': ['JSON', 'parse'],
		'%JSONStringify%': ['JSON', 'stringify'],
		'%MapPrototype%': ['Map', 'prototype'],
		'%NumberPrototype%': ['Number', 'prototype'],
		'%ObjectPrototype%': ['Object', 'prototype'],
		'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
		'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
		'%PromisePrototype%': ['Promise', 'prototype'],
		'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
		'%Promise_all%': ['Promise', 'all'],
		'%Promise_reject%': ['Promise', 'reject'],
		'%Promise_resolve%': ['Promise', 'resolve'],
		'%RangeErrorPrototype%': ['RangeError', 'prototype'],
		'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
		'%RegExpPrototype%': ['RegExp', 'prototype'],
		'%SetPrototype%': ['Set', 'prototype'],
		'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
		'%StringPrototype%': ['String', 'prototype'],
		'%SymbolPrototype%': ['Symbol', 'prototype'],
		'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
		'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
		'%TypeErrorPrototype%': ['TypeError', 'prototype'],
		'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
		'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
		'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
		'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
		'%URIErrorPrototype%': ['URIError', 'prototype'],
		'%WeakMapPrototype%': ['WeakMap', 'prototype'],
		'%WeakSetPrototype%': ['WeakSet', 'prototype']
	};

	var bind = requireFunctionBind();
	var hasOwn = /*@__PURE__*/ requireHasown();
	var $concat = bind.call(Function.call, Array.prototype.concat);
	var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
	var $replace = bind.call(Function.call, String.prototype.replace);
	var $strSlice = bind.call(Function.call, String.prototype.slice);
	var $exec = bind.call(Function.call, RegExp.prototype.exec);

	/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
	var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
	var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
	var stringToPath = function stringToPath(string) {
		var first = $strSlice(string, 0, 1);
		var last = $strSlice(string, -1);
		if (first === '%' && last !== '%') {
			throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
		} else if (last === '%' && first !== '%') {
			throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
		}
		var result = [];
		$replace(string, rePropName, function (match, number, quote, subString) {
			result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
		});
		return result;
	};
	/* end adaptation */

	var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
		var intrinsicName = name;
		var alias;
		if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
			alias = LEGACY_ALIASES[intrinsicName];
			intrinsicName = '%' + alias[0] + '%';
		}

		if (hasOwn(INTRINSICS, intrinsicName)) {
			var value = INTRINSICS[intrinsicName];
			if (value === needsEval) {
				value = doEval(intrinsicName);
			}
			if (typeof value === 'undefined' && !allowMissing) {
				throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
			}

			return {
				alias: alias,
				name: intrinsicName,
				value: value
			};
		}

		throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
	};

	getIntrinsic = function GetIntrinsic(name, allowMissing) {
		if (typeof name !== 'string' || name.length === 0) {
			throw new $TypeError('intrinsic name must be a non-empty string');
		}
		if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
			throw new $TypeError('"allowMissing" argument must be a boolean');
		}

		if ($exec(/^%?[^%]*%?$/, name) === null) {
			throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
		}
		var parts = stringToPath(name);
		var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

		var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
		var intrinsicRealName = intrinsic.name;
		var value = intrinsic.value;
		var skipFurtherCaching = false;

		var alias = intrinsic.alias;
		if (alias) {
			intrinsicBaseName = alias[0];
			$spliceApply(parts, $concat([0, 1], alias));
		}

		for (var i = 1, isOwn = true; i < parts.length; i += 1) {
			var part = parts[i];
			var first = $strSlice(part, 0, 1);
			var last = $strSlice(part, -1);
			if (
				(
					(first === '"' || first === "'" || first === '`')
					|| (last === '"' || last === "'" || last === '`')
				)
				&& first !== last
			) {
				throw new $SyntaxError('property names with quotes must have matching quotes');
			}
			if (part === 'constructor' || !isOwn) {
				skipFurtherCaching = true;
			}

			intrinsicBaseName += '.' + part;
			intrinsicRealName = '%' + intrinsicBaseName + '%';

			if (hasOwn(INTRINSICS, intrinsicRealName)) {
				value = INTRINSICS[intrinsicRealName];
			} else if (value != null) {
				if (!(part in value)) {
					if (!allowMissing) {
						throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
					}
					return void undefined$1;
				}
				if ($gOPD && (i + 1) >= parts.length) {
					var desc = $gOPD(value, part);
					isOwn = !!desc;

					// By convention, when a data property is converted to an accessor
					// property to emulate a data property that does not suffer from
					// the override mistake, that accessor's getter is marked with
					// an `originalValue` property. Here, when we detect this, we
					// uphold the illusion by pretending to see that original data
					// property, i.e., returning the value rather than the getter
					// itself.
					if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
						value = desc.get;
					} else {
						value = value[part];
					}
				} else {
					isOwn = hasOwn(value, part);
					value = value[part];
				}

				if (isOwn && !skipFurtherCaching) {
					INTRINSICS[intrinsicRealName] = value;
				}
			}
		}
		return value;
	};
	return getIntrinsic;
}

var callBind = {exports: {}};

var esDefineProperty;
var hasRequiredEsDefineProperty;

function requireEsDefineProperty () {
	if (hasRequiredEsDefineProperty) return esDefineProperty;
	hasRequiredEsDefineProperty = 1;

	var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();

	/** @type {import('.')} */
	var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
	if ($defineProperty) {
		try {
			$defineProperty({}, 'a', { value: 1 });
		} catch (e) {
			// IE 8 has a broken defineProperty
			$defineProperty = false;
		}
	}

	esDefineProperty = $defineProperty;
	return esDefineProperty;
}

var gopd$1;
var hasRequiredGopd$1;

function requireGopd$1 () {
	if (hasRequiredGopd$1) return gopd$1;
	hasRequiredGopd$1 = 1;

	var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();

	var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

	if ($gOPD) {
		try {
			$gOPD([], 'length');
		} catch (e) {
			// IE 8 has a broken gOPD
			$gOPD = null;
		}
	}

	gopd$1 = $gOPD;
	return gopd$1;
}

var defineDataProperty;
var hasRequiredDefineDataProperty;

function requireDefineDataProperty () {
	if (hasRequiredDefineDataProperty) return defineDataProperty;
	hasRequiredDefineDataProperty = 1;

	var $defineProperty = /*@__PURE__*/ requireEsDefineProperty();

	var $SyntaxError = /*@__PURE__*/ requireSyntax();
	var $TypeError = /*@__PURE__*/ requireType();

	var gopd = /*@__PURE__*/ requireGopd$1();

	/** @type {import('.')} */
	defineDataProperty = function defineDataProperty(
		obj,
		property,
		value
	) {
		if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
			throw new $TypeError('`obj` must be an object or a function`');
		}
		if (typeof property !== 'string' && typeof property !== 'symbol') {
			throw new $TypeError('`property` must be a string or a symbol`');
		}
		if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
			throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
		}
		if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
			throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
		}
		if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
			throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
		}
		if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
			throw new $TypeError('`loose`, if provided, must be a boolean');
		}

		var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
		var nonWritable = arguments.length > 4 ? arguments[4] : null;
		var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
		var loose = arguments.length > 6 ? arguments[6] : false;

		/* @type {false | TypedPropertyDescriptor<unknown>} */
		var desc = !!gopd && gopd(obj, property);

		if ($defineProperty) {
			$defineProperty(obj, property, {
				configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
				enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
				value: value,
				writable: nonWritable === null && desc ? desc.writable : !nonWritable
			});
		} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
			// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
			obj[property] = value; // eslint-disable-line no-param-reassign
		} else {
			throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
		}
	};
	return defineDataProperty;
}

var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;

function requireHasPropertyDescriptors () {
	if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
	hasRequiredHasPropertyDescriptors = 1;

	var $defineProperty = /*@__PURE__*/ requireEsDefineProperty();

	var hasPropertyDescriptors = function hasPropertyDescriptors() {
		return !!$defineProperty;
	};

	hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
		// node v0.6 has a bug where array lengths can be Set but not Defined
		if (!$defineProperty) {
			return null;
		}
		try {
			return $defineProperty([], 'length', { value: 1 }).length !== 1;
		} catch (e) {
			// In Firefox 4-22, defining length on an array throws an exception.
			return true;
		}
	};

	hasPropertyDescriptors_1 = hasPropertyDescriptors;
	return hasPropertyDescriptors_1;
}

var gopd;
var hasRequiredGopd;

function requireGopd () {
	if (hasRequiredGopd) return gopd;
	hasRequiredGopd = 1;

	var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();

	var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

	if ($gOPD) {
		try {
			$gOPD([], 'length');
		} catch (e) {
			// IE 8 has a broken gOPD
			$gOPD = null;
		}
	}

	gopd = $gOPD;
	return gopd;
}

var setFunctionLength;
var hasRequiredSetFunctionLength;

function requireSetFunctionLength () {
	if (hasRequiredSetFunctionLength) return setFunctionLength;
	hasRequiredSetFunctionLength = 1;

	var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();
	var define = /*@__PURE__*/ requireDefineDataProperty();
	var hasDescriptors = /*@__PURE__*/ requireHasPropertyDescriptors()();
	var gOPD = /*@__PURE__*/ requireGopd();

	var $TypeError = /*@__PURE__*/ requireType();
	var $floor = GetIntrinsic('%Math.floor%');

	/** @type {import('.')} */
	setFunctionLength = function setFunctionLength(fn, length) {
		if (typeof fn !== 'function') {
			throw new $TypeError('`fn` is not a function');
		}
		if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
			throw new $TypeError('`length` must be a positive 32-bit integer');
		}

		var loose = arguments.length > 2 && !!arguments[2];

		var functionLengthIsConfigurable = true;
		var functionLengthIsWritable = true;
		if ('length' in fn && gOPD) {
			var desc = gOPD(fn, 'length');
			if (desc && !desc.configurable) {
				functionLengthIsConfigurable = false;
			}
			if (desc && !desc.writable) {
				functionLengthIsWritable = false;
			}
		}

		if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
			if (hasDescriptors) {
				define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
			} else {
				define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
			}
		}
		return fn;
	};
	return setFunctionLength;
}

var hasRequiredCallBind;

function requireCallBind () {
	if (hasRequiredCallBind) return callBind.exports;
	hasRequiredCallBind = 1;
	(function (module) {

		var bind = requireFunctionBind();
		var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();
		var setFunctionLength = /*@__PURE__*/ requireSetFunctionLength();

		var $TypeError = /*@__PURE__*/ requireType();
		var $apply = GetIntrinsic('%Function.prototype.apply%');
		var $call = GetIntrinsic('%Function.prototype.call%');
		var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

		var $defineProperty = /*@__PURE__*/ requireEsDefineProperty();
		var $max = GetIntrinsic('%Math.max%');

		module.exports = function callBind(originalFunction) {
			if (typeof originalFunction !== 'function') {
				throw new $TypeError('a function is required');
			}
			var func = $reflectApply(bind, $call, arguments);
			return setFunctionLength(
				func,
				1 + $max(0, originalFunction.length - (arguments.length - 1)),
				true
			);
		};

		var applyBind = function applyBind() {
			return $reflectApply(bind, $apply, arguments);
		};

		if ($defineProperty) {
			$defineProperty(module.exports, 'apply', { value: applyBind });
		} else {
			module.exports.apply = applyBind;
		} 
	} (callBind));
	return callBind.exports;
}

var callBound;
var hasRequiredCallBound;

function requireCallBound () {
	if (hasRequiredCallBound) return callBound;
	hasRequiredCallBound = 1;

	var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();

	var callBind = requireCallBind();

	var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

	callBound = function callBoundIntrinsic(name, allowMissing) {
		var intrinsic = GetIntrinsic(name, !!allowMissing);
		if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
			return callBind(intrinsic);
		}
		return intrinsic;
	};
	return callBound;
}

var util_inspect;
var hasRequiredUtil_inspect;

function requireUtil_inspect () {
	if (hasRequiredUtil_inspect) return util_inspect;
	hasRequiredUtil_inspect = 1;
	util_inspect = require$$0$6.inspect;
	return util_inspect;
}

var objectInspect;
var hasRequiredObjectInspect;

function requireObjectInspect () {
	if (hasRequiredObjectInspect) return objectInspect;
	hasRequiredObjectInspect = 1;
	var hasMap = typeof Map === 'function' && Map.prototype;
	var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
	var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
	var mapForEach = hasMap && Map.prototype.forEach;
	var hasSet = typeof Set === 'function' && Set.prototype;
	var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
	var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
	var setForEach = hasSet && Set.prototype.forEach;
	var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
	var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
	var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
	var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
	var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
	var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
	var booleanValueOf = Boolean.prototype.valueOf;
	var objectToString = Object.prototype.toString;
	var functionToString = Function.prototype.toString;
	var $match = String.prototype.match;
	var $slice = String.prototype.slice;
	var $replace = String.prototype.replace;
	var $toUpperCase = String.prototype.toUpperCase;
	var $toLowerCase = String.prototype.toLowerCase;
	var $test = RegExp.prototype.test;
	var $concat = Array.prototype.concat;
	var $join = Array.prototype.join;
	var $arrSlice = Array.prototype.slice;
	var $floor = Math.floor;
	var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
	var gOPS = Object.getOwnPropertySymbols;
	var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
	var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
	// ie, `has-tostringtag/shams
	var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
	    ? Symbol.toStringTag
	    : null;
	var isEnumerable = Object.prototype.propertyIsEnumerable;

	var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
	    [].__proto__ === Array.prototype // eslint-disable-line no-proto
	        ? function (O) {
	            return O.__proto__; // eslint-disable-line no-proto
	        }
	        : null
	);

	function addNumericSeparator(num, str) {
	    if (
	        num === Infinity
	        || num === -Infinity
	        || num !== num
	        || (num && num > -1000 && num < 1000)
	        || $test.call(/e/, str)
	    ) {
	        return str;
	    }
	    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
	    if (typeof num === 'number') {
	        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
	        if (int !== num) {
	            var intStr = String(int);
	            var dec = $slice.call(str, intStr.length + 1);
	            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
	        }
	    }
	    return $replace.call(str, sepRegex, '$&_');
	}

	var utilInspect = /*@__PURE__*/ requireUtil_inspect();
	var inspectCustom = utilInspect.custom;
	var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

	objectInspect = function inspect_(obj, options, depth, seen) {
	    var opts = options || {};

	    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
	        throw new TypeError('option "quoteStyle" must be "single" or "double"');
	    }
	    if (
	        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
	            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
	            : opts.maxStringLength !== null
	        )
	    ) {
	        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
	    }
	    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
	    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
	        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
	    }

	    if (
	        has(opts, 'indent')
	        && opts.indent !== null
	        && opts.indent !== '\t'
	        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
	    ) {
	        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
	    }
	    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
	        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
	    }
	    var numericSeparator = opts.numericSeparator;

	    if (typeof obj === 'undefined') {
	        return 'undefined';
	    }
	    if (obj === null) {
	        return 'null';
	    }
	    if (typeof obj === 'boolean') {
	        return obj ? 'true' : 'false';
	    }

	    if (typeof obj === 'string') {
	        return inspectString(obj, opts);
	    }
	    if (typeof obj === 'number') {
	        if (obj === 0) {
	            return Infinity / obj > 0 ? '0' : '-0';
	        }
	        var str = String(obj);
	        return numericSeparator ? addNumericSeparator(obj, str) : str;
	    }
	    if (typeof obj === 'bigint') {
	        var bigIntStr = String(obj) + 'n';
	        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
	    }

	    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
	    if (typeof depth === 'undefined') { depth = 0; }
	    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
	        return isArray(obj) ? '[Array]' : '[Object]';
	    }

	    var indent = getIndent(opts, depth);

	    if (typeof seen === 'undefined') {
	        seen = [];
	    } else if (indexOf(seen, obj) >= 0) {
	        return '[Circular]';
	    }

	    function inspect(value, from, noIndent) {
	        if (from) {
	            seen = $arrSlice.call(seen);
	            seen.push(from);
	        }
	        if (noIndent) {
	            var newOpts = {
	                depth: opts.depth
	            };
	            if (has(opts, 'quoteStyle')) {
	                newOpts.quoteStyle = opts.quoteStyle;
	            }
	            return inspect_(value, newOpts, depth + 1, seen);
	        }
	        return inspect_(value, opts, depth + 1, seen);
	    }

	    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
	        var name = nameOf(obj);
	        var keys = arrObjKeys(obj, inspect);
	        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
	    }
	    if (isSymbol(obj)) {
	        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
	        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
	    }
	    if (isElement(obj)) {
	        var s = '<' + $toLowerCase.call(String(obj.nodeName));
	        var attrs = obj.attributes || [];
	        for (var i = 0; i < attrs.length; i++) {
	            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
	        }
	        s += '>';
	        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
	        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
	        return s;
	    }
	    if (isArray(obj)) {
	        if (obj.length === 0) { return '[]'; }
	        var xs = arrObjKeys(obj, inspect);
	        if (indent && !singleLineValues(xs)) {
	            return '[' + indentedJoin(xs, indent) + ']';
	        }
	        return '[ ' + $join.call(xs, ', ') + ' ]';
	    }
	    if (isError(obj)) {
	        var parts = arrObjKeys(obj, inspect);
	        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
	            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
	        }
	        if (parts.length === 0) { return '[' + String(obj) + ']'; }
	        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
	    }
	    if (typeof obj === 'object' && customInspect) {
	        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
	            return utilInspect(obj, { depth: maxDepth - depth });
	        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
	            return obj.inspect();
	        }
	    }
	    if (isMap(obj)) {
	        var mapParts = [];
	        if (mapForEach) {
	            mapForEach.call(obj, function (value, key) {
	                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
	            });
	        }
	        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
	    }
	    if (isSet(obj)) {
	        var setParts = [];
	        if (setForEach) {
	            setForEach.call(obj, function (value) {
	                setParts.push(inspect(value, obj));
	            });
	        }
	        return collectionOf('Set', setSize.call(obj), setParts, indent);
	    }
	    if (isWeakMap(obj)) {
	        return weakCollectionOf('WeakMap');
	    }
	    if (isWeakSet(obj)) {
	        return weakCollectionOf('WeakSet');
	    }
	    if (isWeakRef(obj)) {
	        return weakCollectionOf('WeakRef');
	    }
	    if (isNumber(obj)) {
	        return markBoxed(inspect(Number(obj)));
	    }
	    if (isBigInt(obj)) {
	        return markBoxed(inspect(bigIntValueOf.call(obj)));
	    }
	    if (isBoolean(obj)) {
	        return markBoxed(booleanValueOf.call(obj));
	    }
	    if (isString(obj)) {
	        return markBoxed(inspect(String(obj)));
	    }
	    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
	    /* eslint-env browser */
	    if (typeof window !== 'undefined' && obj === window) {
	        return '{ [object Window] }';
	    }
	    if (
	        (typeof globalThis !== 'undefined' && obj === globalThis)
	        || (typeof commonjsGlobal !== 'undefined' && obj === commonjsGlobal)
	    ) {
	        return '{ [object globalThis] }';
	    }
	    if (!isDate(obj) && !isRegExp(obj)) {
	        var ys = arrObjKeys(obj, inspect);
	        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
	        var protoTag = obj instanceof Object ? '' : 'null prototype';
	        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
	        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
	        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
	        if (ys.length === 0) { return tag + '{}'; }
	        if (indent) {
	            return tag + '{' + indentedJoin(ys, indent) + '}';
	        }
	        return tag + '{ ' + $join.call(ys, ', ') + ' }';
	    }
	    return String(obj);
	};

	function wrapQuotes(s, defaultStyle, opts) {
	    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
	    return quoteChar + s + quoteChar;
	}

	function quote(s) {
	    return $replace.call(String(s), /"/g, '&quot;');
	}

	function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

	// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
	function isSymbol(obj) {
	    if (hasShammedSymbols) {
	        return obj && typeof obj === 'object' && obj instanceof Symbol;
	    }
	    if (typeof obj === 'symbol') {
	        return true;
	    }
	    if (!obj || typeof obj !== 'object' || !symToString) {
	        return false;
	    }
	    try {
	        symToString.call(obj);
	        return true;
	    } catch (e) {}
	    return false;
	}

	function isBigInt(obj) {
	    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
	        return false;
	    }
	    try {
	        bigIntValueOf.call(obj);
	        return true;
	    } catch (e) {}
	    return false;
	}

	var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
	function has(obj, key) {
	    return hasOwn.call(obj, key);
	}

	function toStr(obj) {
	    return objectToString.call(obj);
	}

	function nameOf(f) {
	    if (f.name) { return f.name; }
	    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
	    if (m) { return m[1]; }
	    return null;
	}

	function indexOf(xs, x) {
	    if (xs.indexOf) { return xs.indexOf(x); }
	    for (var i = 0, l = xs.length; i < l; i++) {
	        if (xs[i] === x) { return i; }
	    }
	    return -1;
	}

	function isMap(x) {
	    if (!mapSize || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        mapSize.call(x);
	        try {
	            setSize.call(x);
	        } catch (s) {
	            return true;
	        }
	        return x instanceof Map; // core-js workaround, pre-v2.5.0
	    } catch (e) {}
	    return false;
	}

	function isWeakMap(x) {
	    if (!weakMapHas || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        weakMapHas.call(x, weakMapHas);
	        try {
	            weakSetHas.call(x, weakSetHas);
	        } catch (s) {
	            return true;
	        }
	        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
	    } catch (e) {}
	    return false;
	}

	function isWeakRef(x) {
	    if (!weakRefDeref || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        weakRefDeref.call(x);
	        return true;
	    } catch (e) {}
	    return false;
	}

	function isSet(x) {
	    if (!setSize || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        setSize.call(x);
	        try {
	            mapSize.call(x);
	        } catch (m) {
	            return true;
	        }
	        return x instanceof Set; // core-js workaround, pre-v2.5.0
	    } catch (e) {}
	    return false;
	}

	function isWeakSet(x) {
	    if (!weakSetHas || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        weakSetHas.call(x, weakSetHas);
	        try {
	            weakMapHas.call(x, weakMapHas);
	        } catch (s) {
	            return true;
	        }
	        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
	    } catch (e) {}
	    return false;
	}

	function isElement(x) {
	    if (!x || typeof x !== 'object') { return false; }
	    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
	        return true;
	    }
	    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
	}

	function inspectString(str, opts) {
	    if (str.length > opts.maxStringLength) {
	        var remaining = str.length - opts.maxStringLength;
	        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
	        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
	    }
	    // eslint-disable-next-line no-control-regex
	    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
	    return wrapQuotes(s, 'single', opts);
	}

	function lowbyte(c) {
	    var n = c.charCodeAt(0);
	    var x = {
	        8: 'b',
	        9: 't',
	        10: 'n',
	        12: 'f',
	        13: 'r'
	    }[n];
	    if (x) { return '\\' + x; }
	    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
	}

	function markBoxed(str) {
	    return 'Object(' + str + ')';
	}

	function weakCollectionOf(type) {
	    return type + ' { ? }';
	}

	function collectionOf(type, size, entries, indent) {
	    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
	    return type + ' (' + size + ') {' + joinedEntries + '}';
	}

	function singleLineValues(xs) {
	    for (var i = 0; i < xs.length; i++) {
	        if (indexOf(xs[i], '\n') >= 0) {
	            return false;
	        }
	    }
	    return true;
	}

	function getIndent(opts, depth) {
	    var baseIndent;
	    if (opts.indent === '\t') {
	        baseIndent = '\t';
	    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
	        baseIndent = $join.call(Array(opts.indent + 1), ' ');
	    } else {
	        return null;
	    }
	    return {
	        base: baseIndent,
	        prev: $join.call(Array(depth + 1), baseIndent)
	    };
	}

	function indentedJoin(xs, indent) {
	    if (xs.length === 0) { return ''; }
	    var lineJoiner = '\n' + indent.prev + indent.base;
	    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
	}

	function arrObjKeys(obj, inspect) {
	    var isArr = isArray(obj);
	    var xs = [];
	    if (isArr) {
	        xs.length = obj.length;
	        for (var i = 0; i < obj.length; i++) {
	            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
	        }
	    }
	    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
	    var symMap;
	    if (hasShammedSymbols) {
	        symMap = {};
	        for (var k = 0; k < syms.length; k++) {
	            symMap['$' + syms[k]] = syms[k];
	        }
	    }

	    for (var key in obj) { // eslint-disable-line no-restricted-syntax
	        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
	        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
	        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
	            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
	            continue; // eslint-disable-line no-restricted-syntax, no-continue
	        } else if ($test.call(/[^\w$]/, key)) {
	            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
	        } else {
	            xs.push(key + ': ' + inspect(obj[key], obj));
	        }
	    }
	    if (typeof gOPS === 'function') {
	        for (var j = 0; j < syms.length; j++) {
	            if (isEnumerable.call(obj, syms[j])) {
	                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
	            }
	        }
	    }
	    return xs;
	}
	return objectInspect;
}

var sideChannel;
var hasRequiredSideChannel;

function requireSideChannel () {
	if (hasRequiredSideChannel) return sideChannel;
	hasRequiredSideChannel = 1;

	var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();
	var callBound = requireCallBound();
	var inspect = /*@__PURE__*/ requireObjectInspect();

	var $TypeError = /*@__PURE__*/ requireType();
	var $WeakMap = GetIntrinsic('%WeakMap%', true);
	var $Map = GetIntrinsic('%Map%', true);

	var $weakMapGet = callBound('WeakMap.prototype.get', true);
	var $weakMapSet = callBound('WeakMap.prototype.set', true);
	var $weakMapHas = callBound('WeakMap.prototype.has', true);
	var $mapGet = callBound('Map.prototype.get', true);
	var $mapSet = callBound('Map.prototype.set', true);
	var $mapHas = callBound('Map.prototype.has', true);

	/*
	* This function traverses the list returning the node corresponding to the given key.
	*
	* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list. By doing so, all the recently used nodes can be accessed relatively quickly.
	*/
	/** @type {import('.').listGetNode} */
	var listGetNode = function (list, key) { // eslint-disable-line consistent-return
		/** @type {typeof list | NonNullable<(typeof list)['next']>} */
		var prev = list;
		/** @type {(typeof list)['next']} */
		var curr;
		for (; (curr = prev.next) !== null; prev = curr) {
			if (curr.key === key) {
				prev.next = curr.next;
				// eslint-disable-next-line no-extra-parens
				curr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);
				list.next = curr; // eslint-disable-line no-param-reassign
				return curr;
			}
		}
	};

	/** @type {import('.').listGet} */
	var listGet = function (objects, key) {
		var node = listGetNode(objects, key);
		return node && node.value;
	};
	/** @type {import('.').listSet} */
	var listSet = function (objects, key, value) {
		var node = listGetNode(objects, key);
		if (node) {
			node.value = value;
		} else {
			// Prepend the new node to the beginning of the list
			objects.next = /** @type {import('.').ListNode<typeof value>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens
				key: key,
				next: objects.next,
				value: value
			});
		}
	};
	/** @type {import('.').listHas} */
	var listHas = function (objects, key) {
		return !!listGetNode(objects, key);
	};

	/** @type {import('.')} */
	sideChannel = function getSideChannel() {
		/** @type {WeakMap<object, unknown>} */ var $wm;
		/** @type {Map<object, unknown>} */ var $m;
		/** @type {import('.').RootNode<unknown>} */ var $o;

		/** @type {import('.').Channel} */
		var channel = {
			assert: function (key) {
				if (!channel.has(key)) {
					throw new $TypeError('Side channel does not contain ' + inspect(key));
				}
			},
			get: function (key) { // eslint-disable-line consistent-return
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapGet($wm, key);
					}
				} else if ($Map) {
					if ($m) {
						return $mapGet($m, key);
					}
				} else {
					if ($o) { // eslint-disable-line no-lonely-if
						return listGet($o, key);
					}
				}
			},
			has: function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapHas($wm, key);
					}
				} else if ($Map) {
					if ($m) {
						return $mapHas($m, key);
					}
				} else {
					if ($o) { // eslint-disable-line no-lonely-if
						return listHas($o, key);
					}
				}
				return false;
			},
			set: function (key, value) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if (!$wm) {
						$wm = new $WeakMap();
					}
					$weakMapSet($wm, key, value);
				} else if ($Map) {
					if (!$m) {
						$m = new $Map();
					}
					$mapSet($m, key, value);
				} else {
					if (!$o) {
						// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
						$o = { key: {}, next: null };
					}
					listSet($o, key, value);
				}
			}
		};
		return channel;
	};
	return sideChannel;
}

var formats;
var hasRequiredFormats;

function requireFormats () {
	if (hasRequiredFormats) return formats;
	hasRequiredFormats = 1;

	var replace = String.prototype.replace;
	var percentTwenties = /%20/g;

	var Format = {
	    RFC1738: 'RFC1738',
	    RFC3986: 'RFC3986'
	};

	formats = {
	    'default': Format.RFC3986,
	    formatters: {
	        RFC1738: function (value) {
	            return replace.call(value, percentTwenties, '+');
	        },
	        RFC3986: function (value) {
	            return String(value);
	        }
	    },
	    RFC1738: Format.RFC1738,
	    RFC3986: Format.RFC3986
	};
	return formats;
}

var utils$3;
var hasRequiredUtils$3;

function requireUtils$3 () {
	if (hasRequiredUtils$3) return utils$3;
	hasRequiredUtils$3 = 1;

	var formats = /*@__PURE__*/ requireFormats();

	var has = Object.prototype.hasOwnProperty;
	var isArray = Array.isArray;

	var hexTable = (function () {
	    var array = [];
	    for (var i = 0; i < 256; ++i) {
	        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
	    }

	    return array;
	}());

	var compactQueue = function compactQueue(queue) {
	    while (queue.length > 1) {
	        var item = queue.pop();
	        var obj = item.obj[item.prop];

	        if (isArray(obj)) {
	            var compacted = [];

	            for (var j = 0; j < obj.length; ++j) {
	                if (typeof obj[j] !== 'undefined') {
	                    compacted.push(obj[j]);
	                }
	            }

	            item.obj[item.prop] = compacted;
	        }
	    }
	};

	var arrayToObject = function arrayToObject(source, options) {
	    var obj = options && options.plainObjects ? Object.create(null) : {};
	    for (var i = 0; i < source.length; ++i) {
	        if (typeof source[i] !== 'undefined') {
	            obj[i] = source[i];
	        }
	    }

	    return obj;
	};

	var merge = function merge(target, source, options) {
	    /* eslint no-param-reassign: 0 */
	    if (!source) {
	        return target;
	    }

	    if (typeof source !== 'object') {
	        if (isArray(target)) {
	            target.push(source);
	        } else if (target && typeof target === 'object') {
	            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
	                target[source] = true;
	            }
	        } else {
	            return [target, source];
	        }

	        return target;
	    }

	    if (!target || typeof target !== 'object') {
	        return [target].concat(source);
	    }

	    var mergeTarget = target;
	    if (isArray(target) && !isArray(source)) {
	        mergeTarget = arrayToObject(target, options);
	    }

	    if (isArray(target) && isArray(source)) {
	        source.forEach(function (item, i) {
	            if (has.call(target, i)) {
	                var targetItem = target[i];
	                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
	                    target[i] = merge(targetItem, item, options);
	                } else {
	                    target.push(item);
	                }
	            } else {
	                target[i] = item;
	            }
	        });
	        return target;
	    }

	    return Object.keys(source).reduce(function (acc, key) {
	        var value = source[key];

	        if (has.call(acc, key)) {
	            acc[key] = merge(acc[key], value, options);
	        } else {
	            acc[key] = value;
	        }
	        return acc;
	    }, mergeTarget);
	};

	var assign = function assignSingleSource(target, source) {
	    return Object.keys(source).reduce(function (acc, key) {
	        acc[key] = source[key];
	        return acc;
	    }, target);
	};

	var decode = function (str, decoder, charset) {
	    var strWithoutPlus = str.replace(/\+/g, ' ');
	    if (charset === 'iso-8859-1') {
	        // unescape never throws, no try...catch needed:
	        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
	    }
	    // utf-8
	    try {
	        return decodeURIComponent(strWithoutPlus);
	    } catch (e) {
	        return strWithoutPlus;
	    }
	};

	var limit = 1024;

	/* eslint operator-linebreak: [2, "before"] */

	var encode = function encode(str, defaultEncoder, charset, kind, format) {
	    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
	    // It has been adapted here for stricter adherence to RFC 3986
	    if (str.length === 0) {
	        return str;
	    }

	    var string = str;
	    if (typeof str === 'symbol') {
	        string = Symbol.prototype.toString.call(str);
	    } else if (typeof str !== 'string') {
	        string = String(str);
	    }

	    if (charset === 'iso-8859-1') {
	        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
	            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
	        });
	    }

	    var out = '';
	    for (var j = 0; j < string.length; j += limit) {
	        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
	        var arr = [];

	        for (var i = 0; i < segment.length; ++i) {
	            var c = segment.charCodeAt(i);
	            if (
	                c === 0x2D // -
	                || c === 0x2E // .
	                || c === 0x5F // _
	                || c === 0x7E // ~
	                || (c >= 0x30 && c <= 0x39) // 0-9
	                || (c >= 0x41 && c <= 0x5A) // a-z
	                || (c >= 0x61 && c <= 0x7A) // A-Z
	                || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
	            ) {
	                arr[arr.length] = segment.charAt(i);
	                continue;
	            }

	            if (c < 0x80) {
	                arr[arr.length] = hexTable[c];
	                continue;
	            }

	            if (c < 0x800) {
	                arr[arr.length] = hexTable[0xC0 | (c >> 6)]
	                    + hexTable[0x80 | (c & 0x3F)];
	                continue;
	            }

	            if (c < 0xD800 || c >= 0xE000) {
	                arr[arr.length] = hexTable[0xE0 | (c >> 12)]
	                    + hexTable[0x80 | ((c >> 6) & 0x3F)]
	                    + hexTable[0x80 | (c & 0x3F)];
	                continue;
	            }

	            i += 1;
	            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));

	            arr[arr.length] = hexTable[0xF0 | (c >> 18)]
	                + hexTable[0x80 | ((c >> 12) & 0x3F)]
	                + hexTable[0x80 | ((c >> 6) & 0x3F)]
	                + hexTable[0x80 | (c & 0x3F)];
	        }

	        out += arr.join('');
	    }

	    return out;
	};

	var compact = function compact(value) {
	    var queue = [{ obj: { o: value }, prop: 'o' }];
	    var refs = [];

	    for (var i = 0; i < queue.length; ++i) {
	        var item = queue[i];
	        var obj = item.obj[item.prop];

	        var keys = Object.keys(obj);
	        for (var j = 0; j < keys.length; ++j) {
	            var key = keys[j];
	            var val = obj[key];
	            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
	                queue.push({ obj: obj, prop: key });
	                refs.push(val);
	            }
	        }
	    }

	    compactQueue(queue);

	    return value;
	};

	var isRegExp = function isRegExp(obj) {
	    return Object.prototype.toString.call(obj) === '[object RegExp]';
	};

	var isBuffer = function isBuffer(obj) {
	    if (!obj || typeof obj !== 'object') {
	        return false;
	    }

	    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};

	var combine = function combine(a, b) {
	    return [].concat(a, b);
	};

	var maybeMap = function maybeMap(val, fn) {
	    if (isArray(val)) {
	        var mapped = [];
	        for (var i = 0; i < val.length; i += 1) {
	            mapped.push(fn(val[i]));
	        }
	        return mapped;
	    }
	    return fn(val);
	};

	utils$3 = {
	    arrayToObject: arrayToObject,
	    assign: assign,
	    combine: combine,
	    compact: compact,
	    decode: decode,
	    encode: encode,
	    isBuffer: isBuffer,
	    isRegExp: isRegExp,
	    maybeMap: maybeMap,
	    merge: merge
	};
	return utils$3;
}

var stringify_1;
var hasRequiredStringify;

function requireStringify () {
	if (hasRequiredStringify) return stringify_1;
	hasRequiredStringify = 1;

	var getSideChannel = requireSideChannel();
	var utils = /*@__PURE__*/ requireUtils$3();
	var formats = /*@__PURE__*/ requireFormats();
	var has = Object.prototype.hasOwnProperty;

	var arrayPrefixGenerators = {
	    brackets: function brackets(prefix) {
	        return prefix + '[]';
	    },
	    comma: 'comma',
	    indices: function indices(prefix, key) {
	        return prefix + '[' + key + ']';
	    },
	    repeat: function repeat(prefix) {
	        return prefix;
	    }
	};

	var isArray = Array.isArray;
	var push = Array.prototype.push;
	var pushToArray = function (arr, valueOrArray) {
	    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
	};

	var toISO = Date.prototype.toISOString;

	var defaultFormat = formats['default'];
	var defaults = {
	    addQueryPrefix: false,
	    allowDots: false,
	    allowEmptyArrays: false,
	    arrayFormat: 'indices',
	    charset: 'utf-8',
	    charsetSentinel: false,
	    delimiter: '&',
	    encode: true,
	    encodeDotInKeys: false,
	    encoder: utils.encode,
	    encodeValuesOnly: false,
	    format: defaultFormat,
	    formatter: formats.formatters[defaultFormat],
	    // deprecated
	    indices: false,
	    serializeDate: function serializeDate(date) {
	        return toISO.call(date);
	    },
	    skipNulls: false,
	    strictNullHandling: false
	};

	var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
	    return typeof v === 'string'
	        || typeof v === 'number'
	        || typeof v === 'boolean'
	        || typeof v === 'symbol'
	        || typeof v === 'bigint';
	};

	var sentinel = {};

	var stringify = function stringify(
	    object,
	    prefix,
	    generateArrayPrefix,
	    commaRoundTrip,
	    allowEmptyArrays,
	    strictNullHandling,
	    skipNulls,
	    encodeDotInKeys,
	    encoder,
	    filter,
	    sort,
	    allowDots,
	    serializeDate,
	    format,
	    formatter,
	    encodeValuesOnly,
	    charset,
	    sideChannel
	) {
	    var obj = object;

	    var tmpSc = sideChannel;
	    var step = 0;
	    var findFlag = false;
	    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
	        // Where object last appeared in the ref tree
	        var pos = tmpSc.get(object);
	        step += 1;
	        if (typeof pos !== 'undefined') {
	            if (pos === step) {
	                throw new RangeError('Cyclic object value');
	            } else {
	                findFlag = true; // Break while
	            }
	        }
	        if (typeof tmpSc.get(sentinel) === 'undefined') {
	            step = 0;
	        }
	    }

	    if (typeof filter === 'function') {
	        obj = filter(prefix, obj);
	    } else if (obj instanceof Date) {
	        obj = serializeDate(obj);
	    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
	        obj = utils.maybeMap(obj, function (value) {
	            if (value instanceof Date) {
	                return serializeDate(value);
	            }
	            return value;
	        });
	    }

	    if (obj === null) {
	        if (strictNullHandling) {
	            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
	        }

	        obj = '';
	    }

	    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
	        if (encoder) {
	            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
	            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
	        }
	        return [formatter(prefix) + '=' + formatter(String(obj))];
	    }

	    var values = [];

	    if (typeof obj === 'undefined') {
	        return values;
	    }

	    var objKeys;
	    if (generateArrayPrefix === 'comma' && isArray(obj)) {
	        // we need to join elements in
	        if (encodeValuesOnly && encoder) {
	            obj = utils.maybeMap(obj, encoder);
	        }
	        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
	    } else if (isArray(filter)) {
	        objKeys = filter;
	    } else {
	        var keys = Object.keys(obj);
	        objKeys = sort ? keys.sort(sort) : keys;
	    }

	    var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, '%2E') : prefix;

	    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;

	    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
	        return adjustedPrefix + '[]';
	    }

	    for (var j = 0; j < objKeys.length; ++j) {
	        var key = objKeys[j];
	        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

	        if (skipNulls && value === null) {
	            continue;
	        }

	        var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, '%2E') : key;
	        var keyPrefix = isArray(obj)
	            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix
	            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');

	        sideChannel.set(object, step);
	        var valueSideChannel = getSideChannel();
	        valueSideChannel.set(sentinel, sideChannel);
	        pushToArray(values, stringify(
	            value,
	            keyPrefix,
	            generateArrayPrefix,
	            commaRoundTrip,
	            allowEmptyArrays,
	            strictNullHandling,
	            skipNulls,
	            encodeDotInKeys,
	            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
	            filter,
	            sort,
	            allowDots,
	            serializeDate,
	            format,
	            formatter,
	            encodeValuesOnly,
	            charset,
	            valueSideChannel
	        ));
	    }

	    return values;
	};

	var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
	    if (!opts) {
	        return defaults;
	    }

	    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
	        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
	    }

	    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
	        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
	    }

	    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
	        throw new TypeError('Encoder has to be a function.');
	    }

	    var charset = opts.charset || defaults.charset;
	    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
	        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
	    }

	    var format = formats['default'];
	    if (typeof opts.format !== 'undefined') {
	        if (!has.call(formats.formatters, opts.format)) {
	            throw new TypeError('Unknown format option provided.');
	        }
	        format = opts.format;
	    }
	    var formatter = formats.formatters[format];

	    var filter = defaults.filter;
	    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
	        filter = opts.filter;
	    }

	    var arrayFormat;
	    if (opts.arrayFormat in arrayPrefixGenerators) {
	        arrayFormat = opts.arrayFormat;
	    } else if ('indices' in opts) {
	        arrayFormat = opts.indices ? 'indices' : 'repeat';
	    } else {
	        arrayFormat = defaults.arrayFormat;
	    }

	    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
	        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
	    }

	    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

	    return {
	        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
	        allowDots: allowDots,
	        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
	        arrayFormat: arrayFormat,
	        charset: charset,
	        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
	        commaRoundTrip: opts.commaRoundTrip,
	        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
	        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
	        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
	        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
	        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
	        filter: filter,
	        format: format,
	        formatter: formatter,
	        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
	        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
	        sort: typeof opts.sort === 'function' ? opts.sort : null,
	        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
	    };
	};

	stringify_1 = function (object, opts) {
	    var obj = object;
	    var options = normalizeStringifyOptions(opts);

	    var objKeys;
	    var filter;

	    if (typeof options.filter === 'function') {
	        filter = options.filter;
	        obj = filter('', obj);
	    } else if (isArray(options.filter)) {
	        filter = options.filter;
	        objKeys = filter;
	    }

	    var keys = [];

	    if (typeof obj !== 'object' || obj === null) {
	        return '';
	    }

	    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
	    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;

	    if (!objKeys) {
	        objKeys = Object.keys(obj);
	    }

	    if (options.sort) {
	        objKeys.sort(options.sort);
	    }

	    var sideChannel = getSideChannel();
	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];

	        if (options.skipNulls && obj[key] === null) {
	            continue;
	        }
	        pushToArray(keys, stringify(
	            obj[key],
	            key,
	            generateArrayPrefix,
	            commaRoundTrip,
	            options.allowEmptyArrays,
	            options.strictNullHandling,
	            options.skipNulls,
	            options.encodeDotInKeys,
	            options.encode ? options.encoder : null,
	            options.filter,
	            options.sort,
	            options.allowDots,
	            options.serializeDate,
	            options.format,
	            options.formatter,
	            options.encodeValuesOnly,
	            options.charset,
	            sideChannel
	        ));
	    }

	    var joined = keys.join(options.delimiter);
	    var prefix = options.addQueryPrefix === true ? '?' : '';

	    if (options.charsetSentinel) {
	        if (options.charset === 'iso-8859-1') {
	            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
	            prefix += 'utf8=%26%2310003%3B&';
	        } else {
	            // encodeURIComponent('')
	            prefix += 'utf8=%E2%9C%93&';
	        }
	    }

	    return joined.length > 0 ? prefix + joined : '';
	};
	return stringify_1;
}

var parse;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse;
	hasRequiredParse = 1;

	var utils = /*@__PURE__*/ requireUtils$3();

	var has = Object.prototype.hasOwnProperty;
	var isArray = Array.isArray;

	var defaults = {
	    allowDots: false,
	    allowEmptyArrays: false,
	    allowPrototypes: false,
	    allowSparse: false,
	    arrayLimit: 20,
	    charset: 'utf-8',
	    charsetSentinel: false,
	    comma: false,
	    decodeDotInKeys: false,
	    decoder: utils.decode,
	    delimiter: '&',
	    depth: 5,
	    duplicates: 'combine',
	    ignoreQueryPrefix: false,
	    interpretNumericEntities: false,
	    parameterLimit: 1000,
	    parseArrays: true,
	    plainObjects: false,
	    strictDepth: false,
	    strictNullHandling: false
	};

	var interpretNumericEntities = function (str) {
	    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
	        return String.fromCharCode(parseInt(numberStr, 10));
	    });
	};

	var parseArrayValue = function (val, options) {
	    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
	        return val.split(',');
	    }

	    return val;
	};

	// This is what browsers will submit when the  character occurs in an
	// application/x-www-form-urlencoded body and the encoding of the page containing
	// the form is iso-8859-1, or when the submitted form has an accept-charset
	// attribute of iso-8859-1. Presumably also with other charsets that do not contain
	// the  character, such as us-ascii.
	var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

	// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
	var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')

	var parseValues = function parseQueryStringValues(str, options) {
	    var obj = { __proto__: null };

	    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
	    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
	    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
	    var parts = cleanStr.split(options.delimiter, limit);
	    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
	    var i;

	    var charset = options.charset;
	    if (options.charsetSentinel) {
	        for (i = 0; i < parts.length; ++i) {
	            if (parts[i].indexOf('utf8=') === 0) {
	                if (parts[i] === charsetSentinel) {
	                    charset = 'utf-8';
	                } else if (parts[i] === isoSentinel) {
	                    charset = 'iso-8859-1';
	                }
	                skipIndex = i;
	                i = parts.length; // The eslint settings do not allow break;
	            }
	        }
	    }

	    for (i = 0; i < parts.length; ++i) {
	        if (i === skipIndex) {
	            continue;
	        }
	        var part = parts[i];

	        var bracketEqualsPos = part.indexOf(']=');
	        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

	        var key, val;
	        if (pos === -1) {
	            key = options.decoder(part, defaults.decoder, charset, 'key');
	            val = options.strictNullHandling ? null : '';
	        } else {
	            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
	            val = utils.maybeMap(
	                parseArrayValue(part.slice(pos + 1), options),
	                function (encodedVal) {
	                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
	                }
	            );
	        }

	        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
	            val = interpretNumericEntities(val);
	        }

	        if (part.indexOf('[]=') > -1) {
	            val = isArray(val) ? [val] : val;
	        }

	        var existing = has.call(obj, key);
	        if (existing && options.duplicates === 'combine') {
	            obj[key] = utils.combine(obj[key], val);
	        } else if (!existing || options.duplicates === 'last') {
	            obj[key] = val;
	        }
	    }

	    return obj;
	};

	var parseObject = function (chain, val, options, valuesParsed) {
	    var leaf = valuesParsed ? val : parseArrayValue(val, options);

	    for (var i = chain.length - 1; i >= 0; --i) {
	        var obj;
	        var root = chain[i];

	        if (root === '[]' && options.parseArrays) {
	            obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))
	                ? []
	                : [].concat(leaf);
	        } else {
	            obj = options.plainObjects ? Object.create(null) : {};
	            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
	            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
	            var index = parseInt(decodedRoot, 10);
	            if (!options.parseArrays && decodedRoot === '') {
	                obj = { 0: leaf };
	            } else if (
	                !isNaN(index)
	                && root !== decodedRoot
	                && String(index) === decodedRoot
	                && index >= 0
	                && (options.parseArrays && index <= options.arrayLimit)
	            ) {
	                obj = [];
	                obj[index] = leaf;
	            } else if (decodedRoot !== '__proto__') {
	                obj[decodedRoot] = leaf;
	            }
	        }

	        leaf = obj;
	    }

	    return leaf;
	};

	var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
	    if (!givenKey) {
	        return;
	    }

	    // Transform dot notation to bracket notation
	    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

	    // The regex chunks

	    var brackets = /(\[[^[\]]*])/;
	    var child = /(\[[^[\]]*])/g;

	    // Get the parent

	    var segment = options.depth > 0 && brackets.exec(key);
	    var parent = segment ? key.slice(0, segment.index) : key;

	    // Stash the parent if it exists

	    var keys = [];
	    if (parent) {
	        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
	        if (!options.plainObjects && has.call(Object.prototype, parent)) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }

	        keys.push(parent);
	    }

	    // Loop through children appending to the array until we hit depth

	    var i = 0;
	    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
	        i += 1;
	        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }
	        keys.push(segment[1]);
	    }

	    // If there's a remainder, check strictDepth option for throw, else just add whatever is left

	    if (segment) {
	        if (options.strictDepth === true) {
	            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
	        }
	        keys.push('[' + key.slice(segment.index) + ']');
	    }

	    return parseObject(keys, val, options, valuesParsed);
	};

	var normalizeParseOptions = function normalizeParseOptions(opts) {
	    if (!opts) {
	        return defaults;
	    }

	    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
	        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
	    }

	    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
	        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
	    }

	    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
	        throw new TypeError('Decoder has to be a function.');
	    }

	    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
	        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
	    }
	    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

	    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;

	    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
	        throw new TypeError('The duplicates option must be either combine, first, or last');
	    }

	    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

	    return {
	        allowDots: allowDots,
	        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
	        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
	        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
	        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
	        charset: charset,
	        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
	        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
	        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
	        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
	        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
	        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
	        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
	        duplicates: duplicates,
	        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
	        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
	        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
	        parseArrays: opts.parseArrays !== false,
	        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
	        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
	        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
	    };
	};

	parse = function (str, opts) {
	    var options = normalizeParseOptions(opts);

	    if (str === '' || str === null || typeof str === 'undefined') {
	        return options.plainObjects ? Object.create(null) : {};
	    }

	    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
	    var obj = options.plainObjects ? Object.create(null) : {};

	    // Iterate over the keys and setup the new object

	    var keys = Object.keys(tempObj);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
	        obj = utils.merge(obj, newObj, options);
	    }

	    if (options.allowSparse === true) {
	        return obj;
	    }

	    return utils.compact(obj);
	};
	return parse;
}

var lib$4;
var hasRequiredLib$4;

function requireLib$4 () {
	if (hasRequiredLib$4) return lib$4;
	hasRequiredLib$4 = 1;

	var stringify = /*@__PURE__*/ requireStringify();
	var parse = /*@__PURE__*/ requireParse();
	var formats = /*@__PURE__*/ requireFormats();

	lib$4 = {
	    formats: formats,
	    parse: parse,
	    stringify: stringify
	};
	return lib$4;
}

/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var urlencoded_1;
var hasRequiredUrlencoded$1;

function requireUrlencoded$1 () {
	if (hasRequiredUrlencoded$1) return urlencoded_1;
	hasRequiredUrlencoded$1 = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var bytes = requireBytes();
	var contentType = requireContentType();
	var createError = requireHttpErrors();
	var debug = requireSrc$3()('body-parser:urlencoded');
	var deprecate = requireDepd()('body-parser');
	var read = requireRead();
	var typeis = requireTypeIs();

	/**
	 * Module exports.
	 */

	urlencoded_1 = urlencoded;

	/**
	 * Cache of parser modules.
	 */

	var parsers = Object.create(null);

	/**
	 * Create a middleware to parse urlencoded bodies.
	 *
	 * @param {object} [options]
	 * @return {function}
	 * @public
	 */

	function urlencoded (options) {
	  var opts = options || {};

	  // notice because option default will flip in next major
	  if (opts.extended === undefined) {
	    deprecate('undefined extended: provide extended option');
	  }

	  var extended = opts.extended !== false;
	  var inflate = opts.inflate !== false;
	  var limit = typeof opts.limit !== 'number'
	    ? bytes.parse(opts.limit || '100kb')
	    : opts.limit;
	  var type = opts.type || 'application/x-www-form-urlencoded';
	  var verify = opts.verify || false;
	  var depth = typeof opts.depth !== 'number'
	    ? Number(opts.depth || 32)
	    : opts.depth;

	  if (verify !== false && typeof verify !== 'function') {
	    throw new TypeError('option verify must be function')
	  }

	  // create the appropriate query parser
	  var queryparse = extended
	    ? extendedparser(opts)
	    : simpleparser(opts);

	  // create the appropriate type checking function
	  var shouldParse = typeof type !== 'function'
	    ? typeChecker(type)
	    : type;

	  function parse (body) {
	    return body.length
	      ? queryparse(body)
	      : {}
	  }

	  return function urlencodedParser (req, res, next) {
	    if (req._body) {
	      debug('body already parsed');
	      next();
	      return
	    }

	    req.body = req.body || {};

	    // skip requests without bodies
	    if (!typeis.hasBody(req)) {
	      debug('skip empty body');
	      next();
	      return
	    }

	    debug('content-type %j', req.headers['content-type']);

	    // determine if request should be parsed
	    if (!shouldParse(req)) {
	      debug('skip parsing');
	      next();
	      return
	    }

	    // assert charset
	    var charset = getCharset(req) || 'utf-8';
	    if (charset !== 'utf-8') {
	      debug('invalid charset');
	      next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
	        charset: charset,
	        type: 'charset.unsupported'
	      }));
	      return
	    }

	    // read
	    read(req, res, next, parse, debug, {
	      debug: debug,
	      encoding: charset,
	      inflate: inflate,
	      limit: limit,
	      verify: verify,
	      depth: depth
	    });
	  }
	}

	/**
	 * Get the extended query parser.
	 *
	 * @param {object} options
	 */

	function extendedparser (options) {
	  var parameterLimit = options.parameterLimit !== undefined
	    ? options.parameterLimit
	    : 1000;

	  var depth = typeof options.depth !== 'number'
	    ? Number(options.depth || 32)
	    : options.depth;
	  var parse = parser('qs');

	  if (isNaN(parameterLimit) || parameterLimit < 1) {
	    throw new TypeError('option parameterLimit must be a positive number')
	  }

	  if (isNaN(depth) || depth < 0) {
	    throw new TypeError('option depth must be a zero or a positive number')
	  }

	  if (isFinite(parameterLimit)) {
	    parameterLimit = parameterLimit | 0;
	  }

	  return function queryparse (body) {
	    var paramCount = parameterCount(body, parameterLimit);

	    if (paramCount === undefined) {
	      debug('too many parameters');
	      throw createError(413, 'too many parameters', {
	        type: 'parameters.too.many'
	      })
	    }

	    var arrayLimit = Math.max(100, paramCount);

	    debug('parse extended urlencoding');
	    try {
	      return parse(body, {
	        allowPrototypes: true,
	        arrayLimit: arrayLimit,
	        depth: depth,
	        strictDepth: true,
	        parameterLimit: parameterLimit
	      })
	    } catch (err) {
	      if (err instanceof RangeError) {
	        throw createError(400, 'The input exceeded the depth', {
	          type: 'querystring.parse.rangeError'
	        })
	      } else {
	        throw err
	      }
	    }
	  }
	}

	/**
	 * Get the charset of a request.
	 *
	 * @param {object} req
	 * @api private
	 */

	function getCharset (req) {
	  try {
	    return (contentType.parse(req).parameters.charset || '').toLowerCase()
	  } catch (e) {
	    return undefined
	  }
	}

	/**
	 * Count the number of parameters, stopping once limit reached
	 *
	 * @param {string} body
	 * @param {number} limit
	 * @api private
	 */

	function parameterCount (body, limit) {
	  var count = 0;
	  var index = 0;

	  while ((index = body.indexOf('&', index)) !== -1) {
	    count++;
	    index++;

	    if (count === limit) {
	      return undefined
	    }
	  }

	  return count
	}

	/**
	 * Get parser for module name dynamically.
	 *
	 * @param {string} name
	 * @return {function}
	 * @api private
	 */

	function parser (name) {
	  var mod = parsers[name];

	  if (mod !== undefined) {
	    return mod.parse
	  }

	  // this uses a switch for static require analysis
	  switch (name) {
	    case 'qs':
	      mod = /*@__PURE__*/ requireLib$4();
	      break
	    case 'querystring':
	      mod = require$$8;
	      break
	  }

	  // store to prevent invoking require()
	  parsers[name] = mod;

	  return mod.parse
	}

	/**
	 * Get the simple query parser.
	 *
	 * @param {object} options
	 */

	function simpleparser (options) {
	  var parameterLimit = options.parameterLimit !== undefined
	    ? options.parameterLimit
	    : 1000;
	  var parse = parser('querystring');

	  if (isNaN(parameterLimit) || parameterLimit < 1) {
	    throw new TypeError('option parameterLimit must be a positive number')
	  }

	  if (isFinite(parameterLimit)) {
	    parameterLimit = parameterLimit | 0;
	  }

	  return function queryparse (body) {
	    var paramCount = parameterCount(body, parameterLimit);

	    if (paramCount === undefined) {
	      debug('too many parameters');
	      throw createError(413, 'too many parameters', {
	        type: 'parameters.too.many'
	      })
	    }

	    debug('parse urlencoding');
	    return parse(body, undefined, undefined, { maxKeys: parameterLimit })
	  }
	}

	/**
	 * Get the simple type checker.
	 *
	 * @param {string} type
	 * @return {function}
	 */

	function typeChecker (type) {
	  return function checkType (req) {
	    return Boolean(typeis(req, type))
	  }
	}
	return urlencoded_1;
}

/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredBodyParser;

function requireBodyParser () {
	if (hasRequiredBodyParser) return bodyParser$1.exports;
	hasRequiredBodyParser = 1;
	(function (module, exports) {

		/**
		 * Module dependencies.
		 * @private
		 */

		var deprecate = requireDepd()('body-parser');

		/**
		 * Cache of loaded parsers.
		 * @private
		 */

		var parsers = Object.create(null);

		/**
		 * @typedef Parsers
		 * @type {function}
		 * @property {function} json
		 * @property {function} raw
		 * @property {function} text
		 * @property {function} urlencoded
		 */

		/**
		 * Module exports.
		 * @type {Parsers}
		 */

		exports = module.exports = deprecate.function(bodyParser,
		  'bodyParser: use individual json/urlencoded middlewares');

		/**
		 * JSON parser.
		 * @public
		 */

		Object.defineProperty(exports, 'json', {
		  configurable: true,
		  enumerable: true,
		  get: createParserGetter('json')
		});

		/**
		 * Raw parser.
		 * @public
		 */

		Object.defineProperty(exports, 'raw', {
		  configurable: true,
		  enumerable: true,
		  get: createParserGetter('raw')
		});

		/**
		 * Text parser.
		 * @public
		 */

		Object.defineProperty(exports, 'text', {
		  configurable: true,
		  enumerable: true,
		  get: createParserGetter('text')
		});

		/**
		 * URL-encoded parser.
		 * @public
		 */

		Object.defineProperty(exports, 'urlencoded', {
		  configurable: true,
		  enumerable: true,
		  get: createParserGetter('urlencoded')
		});

		/**
		 * Create a middleware to parse json and urlencoded bodies.
		 *
		 * @param {object} [options]
		 * @return {function}
		 * @deprecated
		 * @public
		 */

		function bodyParser (options) {
		  // use default type for parsers
		  var opts = Object.create(options || null, {
		    type: {
		      configurable: true,
		      enumerable: true,
		      value: undefined,
		      writable: true
		    }
		  });

		  var _urlencoded = exports.urlencoded(opts);
		  var _json = exports.json(opts);

		  return function bodyParser (req, res, next) {
		    _json(req, res, function (err) {
		      if (err) return next(err)
		      _urlencoded(req, res, next);
		    });
		  }
		}

		/**
		 * Create a getter for loading a parser.
		 * @private
		 */

		function createParserGetter (name) {
		  return function get () {
		    return loadParser(name)
		  }
		}

		/**
		 * Load a parser module.
		 * @private
		 */

		function loadParser (parserName) {
		  var parser = parsers[parserName];

		  if (parser !== undefined) {
		    return parser
		  }

		  // this uses a switch for static require analysis
		  switch (parserName) {
		    case 'json':
		      parser = requireJson();
		      break
		    case 'raw':
		      parser = requireRaw();
		      break
		    case 'text':
		      parser = requireText();
		      break
		    case 'urlencoded':
		      parser = requireUrlencoded$1();
		      break
		  }

		  // store to prevent invoking require()
		  return (parsers[parserName] = parser)
		} 
	} (bodyParser$1, bodyParser$1.exports));
	return bodyParser$1.exports;
}

/*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var mergeDescriptors;
var hasRequiredMergeDescriptors;

function requireMergeDescriptors () {
	if (hasRequiredMergeDescriptors) return mergeDescriptors;
	hasRequiredMergeDescriptors = 1;

	/**
	 * Module exports.
	 * @public
	 */

	mergeDescriptors = merge;

	/**
	 * Module variables.
	 * @private
	 */

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	/**
	 * Merge the property descriptors of `src` into `dest`
	 *
	 * @param {object} dest Object to add descriptors to
	 * @param {object} src Object to clone descriptors from
	 * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
	 * @returns {object} Reference to dest
	 * @public
	 */

	function merge (dest, src, redefine) {
	  if (!dest) {
	    throw new TypeError('argument dest is required')
	  }

	  if (!src) {
	    throw new TypeError('argument src is required')
	  }

	  if (redefine === undefined) {
	    // Default to true
	    redefine = true;
	  }

	  Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName (name) {
	    if (!redefine && hasOwnProperty.call(dest, name)) {
	      // Skip descriptor
	      return
	    }

	    // Copy descriptor
	    var descriptor = Object.getOwnPropertyDescriptor(src, name);
	    Object.defineProperty(dest, name, descriptor);
	  });

	  return dest
	}
	return mergeDescriptors;
}

var application = {exports: {}};

/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */

var encodeurl$1;
var hasRequiredEncodeurl$1;

function requireEncodeurl$1 () {
	if (hasRequiredEncodeurl$1) return encodeurl$1;
	hasRequiredEncodeurl$1 = 1;

	/**
	 * Module exports.
	 * @public
	 */

	encodeurl$1 = encodeUrl;

	/**
	 * RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
	 * and including invalid escape sequences.
	 * @private
	 */

	var ENCODE_CHARS_REGEXP = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;

	/**
	 * RegExp to match unmatched surrogate pair.
	 * @private
	 */

	var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;

	/**
	 * String to replace unmatched surrogate pair with.
	 * @private
	 */

	var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2';

	/**
	 * Encode a URL to a percent-encoded form, excluding already-encoded sequences.
	 *
	 * This function will take an already-encoded URL and encode all the non-URL
	 * code points. This function will not encode the "%" character unless it is
	 * not part of a valid sequence (`%20` will be left as-is, but `%foo` will
	 * be encoded as `%25foo`).
	 *
	 * This encode is meant to be "safe" and does not throw errors. It will try as
	 * hard as it can to properly encode the given URL, including replacing any raw,
	 * unpaired surrogate pairs with the Unicode replacement character prior to
	 * encoding.
	 *
	 * @param {string} url
	 * @return {string}
	 * @public
	 */

	function encodeUrl (url) {
	  return String(url)
	    .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
	    .replace(ENCODE_CHARS_REGEXP, encodeURI)
	}
	return encodeurl$1;
}

/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */

var escapeHtml_1;
var hasRequiredEscapeHtml;

function requireEscapeHtml () {
	if (hasRequiredEscapeHtml) return escapeHtml_1;
	hasRequiredEscapeHtml = 1;

	/**
	 * Module variables.
	 * @private
	 */

	var matchHtmlRegExp = /["'&<>]/;

	/**
	 * Module exports.
	 * @public
	 */

	escapeHtml_1 = escapeHtml;

	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */

	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);

	  if (!match) {
	    return str;
	  }

	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;

	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34: // "
	        escape = '&quot;';
	        break;
	      case 38: // &
	        escape = '&amp;';
	        break;
	      case 39: // '
	        escape = '&#39;';
	        break;
	      case 60: // <
	        escape = '&lt;';
	        break;
	      case 62: // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }

	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }

	    lastIndex = index + 1;
	    html += escape;
	  }

	  return lastIndex !== index
	    ? html + str.substring(lastIndex, index)
	    : html;
	}
	return escapeHtml_1;
}

var parseurl = {exports: {}};

/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredParseurl;

function requireParseurl () {
	if (hasRequiredParseurl) return parseurl.exports;
	hasRequiredParseurl = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var url = require$$4$1;
	var parse = url.parse;
	var Url = url.Url;

	/**
	 * Module exports.
	 * @public
	 */

	parseurl.exports = parseurl$1;
	parseurl.exports.original = originalurl;

	/**
	 * Parse the `req` url with memoization.
	 *
	 * @param {ServerRequest} req
	 * @return {Object}
	 * @public
	 */

	function parseurl$1 (req) {
	  var url = req.url;

	  if (url === undefined) {
	    // URL is undefined
	    return undefined
	  }

	  var parsed = req._parsedUrl;

	  if (fresh(url, parsed)) {
	    // Return cached URL parse
	    return parsed
	  }

	  // Parse the URL
	  parsed = fastparse(url);
	  parsed._raw = url;

	  return (req._parsedUrl = parsed)
	}
	/**
	 * Parse the `req` original url with fallback and memoization.
	 *
	 * @param {ServerRequest} req
	 * @return {Object}
	 * @public
	 */

	function originalurl (req) {
	  var url = req.originalUrl;

	  if (typeof url !== 'string') {
	    // Fallback
	    return parseurl$1(req)
	  }

	  var parsed = req._parsedOriginalUrl;

	  if (fresh(url, parsed)) {
	    // Return cached URL parse
	    return parsed
	  }

	  // Parse the URL
	  parsed = fastparse(url);
	  parsed._raw = url;

	  return (req._parsedOriginalUrl = parsed)
	}
	/**
	 * Parse the `str` url with fast-path short-cut.
	 *
	 * @param {string} str
	 * @return {Object}
	 * @private
	 */

	function fastparse (str) {
	  if (typeof str !== 'string' || str.charCodeAt(0) !== 0x2f /* / */) {
	    return parse(str)
	  }

	  var pathname = str;
	  var query = null;
	  var search = null;

	  // This takes the regexp from https://github.com/joyent/node/pull/7878
	  // Which is /^(\/[^?#\s]*)(\?[^#\s]*)?$/
	  // And unrolls it into a for loop
	  for (var i = 1; i < str.length; i++) {
	    switch (str.charCodeAt(i)) {
	      case 0x3f: /* ?  */
	        if (search === null) {
	          pathname = str.substring(0, i);
	          query = str.substring(i + 1);
	          search = str.substring(i);
	        }
	        break
	      case 0x09: /* \t */
	      case 0x0a: /* \n */
	      case 0x0c: /* \f */
	      case 0x0d: /* \r */
	      case 0x20: /*    */
	      case 0x23: /* #  */
	      case 0xa0:
	      case 0xfeff:
	        return parse(str)
	    }
	  }

	  var url = Url !== undefined
	    ? new Url()
	    : {};

	  url.path = str;
	  url.href = str;
	  url.pathname = pathname;

	  if (search !== null) {
	    url.query = query;
	    url.search = search;
	  }

	  return url
	}

	/**
	 * Determine if parsed is still fresh for url.
	 *
	 * @param {string} url
	 * @param {object} parsedUrl
	 * @return {boolean}
	 * @private
	 */

	function fresh (url, parsedUrl) {
	  return typeof parsedUrl === 'object' &&
	    parsedUrl !== null &&
	    (Url === undefined || parsedUrl instanceof Url) &&
	    parsedUrl._raw === url
	}
	return parseurl.exports;
}

/*!
 * finalhandler
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

var finalhandler_1;
var hasRequiredFinalhandler;

function requireFinalhandler () {
	if (hasRequiredFinalhandler) return finalhandler_1;
	hasRequiredFinalhandler = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var debug = requireSrc$3()('finalhandler');
	var encodeUrl = requireEncodeurl$1();
	var escapeHtml = requireEscapeHtml();
	var onFinished = requireOnFinished();
	var parseUrl = requireParseurl();
	var statuses = requireStatuses();
	var unpipe = requireUnpipe();

	/**
	 * Module variables.
	 * @private
	 */

	var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
	var NEWLINE_REGEXP = /\n/g;

	/* istanbul ignore next */
	var defer = typeof setImmediate === 'function'
	  ? setImmediate
	  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)); };
	var isFinished = onFinished.isFinished;

	/**
	 * Create a minimal HTML document.
	 *
	 * @param {string} message
	 * @private
	 */

	function createHtmlDocument (message) {
	  var body = escapeHtml(message)
	    .replace(NEWLINE_REGEXP, '<br>')
	    .replace(DOUBLE_SPACE_REGEXP, ' &nbsp;');

	  return '<!DOCTYPE html>\n' +
	    '<html lang="en">\n' +
	    '<head>\n' +
	    '<meta charset="utf-8">\n' +
	    '<title>Error</title>\n' +
	    '</head>\n' +
	    '<body>\n' +
	    '<pre>' + body + '</pre>\n' +
	    '</body>\n' +
	    '</html>\n'
	}

	/**
	 * Module exports.
	 * @public
	 */

	finalhandler_1 = finalhandler;

	/**
	 * Create a function to handle the final response.
	 *
	 * @param {Request} req
	 * @param {Response} res
	 * @param {Object} [options]
	 * @return {Function}
	 * @public
	 */

	function finalhandler (req, res, options) {
	  var opts = options || {};

	  // get environment
	  var env = opts.env || process.env.NODE_ENV || 'development';

	  // get error callback
	  var onerror = opts.onerror;

	  return function (err) {
	    var headers;
	    var msg;
	    var status;

	    // ignore 404 on in-flight response
	    if (!err && headersSent(res)) {
	      debug('cannot 404 after headers sent');
	      return
	    }

	    // unhandled error
	    if (err) {
	      // respect status code from error
	      status = getErrorStatusCode(err);

	      if (status === undefined) {
	        // fallback to status code on response
	        status = getResponseStatusCode(res);
	      } else {
	        // respect headers from error
	        headers = getErrorHeaders(err);
	      }

	      // get error message
	      msg = getErrorMessage(err, status, env);
	    } else {
	      // not found
	      status = 404;
	      msg = 'Cannot ' + req.method + ' ' + encodeUrl(getResourceName(req));
	    }

	    debug('default %s', status);

	    // schedule onerror callback
	    if (err && onerror) {
	      defer(onerror, err, req, res);
	    }

	    // cannot actually respond
	    if (headersSent(res)) {
	      debug('cannot %d after headers sent', status);
	      if (req.socket) {
	        req.socket.destroy();
	      }
	      return
	    }

	    // send response
	    send(req, res, status, headers, msg);
	  }
	}

	/**
	 * Get headers from Error object.
	 *
	 * @param {Error} err
	 * @return {object}
	 * @private
	 */

	function getErrorHeaders (err) {
	  if (!err.headers || typeof err.headers !== 'object') {
	    return undefined
	  }

	  var headers = Object.create(null);
	  var keys = Object.keys(err.headers);

	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    headers[key] = err.headers[key];
	  }

	  return headers
	}

	/**
	 * Get message from Error object, fallback to status message.
	 *
	 * @param {Error} err
	 * @param {number} status
	 * @param {string} env
	 * @return {string}
	 * @private
	 */

	function getErrorMessage (err, status, env) {
	  var msg;

	  if (env !== 'production') {
	    // use err.stack, which typically includes err.message
	    msg = err.stack;

	    // fallback to err.toString() when possible
	    if (!msg && typeof err.toString === 'function') {
	      msg = err.toString();
	    }
	  }

	  return msg || statuses.message[status]
	}

	/**
	 * Get status code from Error object.
	 *
	 * @param {Error} err
	 * @return {number}
	 * @private
	 */

	function getErrorStatusCode (err) {
	  // check err.status
	  if (typeof err.status === 'number' && err.status >= 400 && err.status < 600) {
	    return err.status
	  }

	  // check err.statusCode
	  if (typeof err.statusCode === 'number' && err.statusCode >= 400 && err.statusCode < 600) {
	    return err.statusCode
	  }

	  return undefined
	}

	/**
	 * Get resource name for the request.
	 *
	 * This is typically just the original pathname of the request
	 * but will fallback to "resource" is that cannot be determined.
	 *
	 * @param {IncomingMessage} req
	 * @return {string}
	 * @private
	 */

	function getResourceName (req) {
	  try {
	    return parseUrl.original(req).pathname
	  } catch (e) {
	    return 'resource'
	  }
	}

	/**
	 * Get status code from response.
	 *
	 * @param {OutgoingMessage} res
	 * @return {number}
	 * @private
	 */

	function getResponseStatusCode (res) {
	  var status = res.statusCode;

	  // default status code to 500 if outside valid range
	  if (typeof status !== 'number' || status < 400 || status > 599) {
	    status = 500;
	  }

	  return status
	}

	/**
	 * Determine if the response headers have been sent.
	 *
	 * @param {object} res
	 * @returns {boolean}
	 * @private
	 */

	function headersSent (res) {
	  return typeof res.headersSent !== 'boolean'
	    ? Boolean(res._header)
	    : res.headersSent
	}

	/**
	 * Send response.
	 *
	 * @param {IncomingMessage} req
	 * @param {OutgoingMessage} res
	 * @param {number} status
	 * @param {object} headers
	 * @param {string} message
	 * @private
	 */

	function send (req, res, status, headers, message) {
	  function write () {
	    // response body
	    var body = createHtmlDocument(message);

	    // response status
	    res.statusCode = status;

	    if (req.httpVersionMajor < 2) {
	      res.statusMessage = statuses.message[status];
	    }

	    // remove any content headers
	    res.removeHeader('Content-Encoding');
	    res.removeHeader('Content-Language');
	    res.removeHeader('Content-Range');

	    // response headers
	    setHeaders(res, headers);

	    // security headers
	    res.setHeader('Content-Security-Policy', "default-src 'none'");
	    res.setHeader('X-Content-Type-Options', 'nosniff');

	    // standard headers
	    res.setHeader('Content-Type', 'text/html; charset=utf-8');
	    res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'));

	    if (req.method === 'HEAD') {
	      res.end();
	      return
	    }

	    res.end(body, 'utf8');
	  }

	  if (isFinished(req)) {
	    write();
	    return
	  }

	  // unpipe everything from the request
	  unpipe(req);

	  // flush the request
	  onFinished(req, write);
	  req.resume();
	}

	/**
	 * Set response headers from an object.
	 *
	 * @param {OutgoingMessage} res
	 * @param {object} headers
	 * @private
	 */

	function setHeaders (res, headers) {
	  if (!headers) {
	    return
	  }

	  var keys = Object.keys(headers);
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    res.setHeader(key, headers[key]);
	  }
	}
	return finalhandler_1;
}

var router$2 = {exports: {}};

var arrayFlatten_1;
var hasRequiredArrayFlatten;

function requireArrayFlatten () {
	if (hasRequiredArrayFlatten) return arrayFlatten_1;
	hasRequiredArrayFlatten = 1;

	/**
	 * Expose `arrayFlatten`.
	 */
	arrayFlatten_1 = arrayFlatten;

	/**
	 * Recursive flatten function with depth.
	 *
	 * @param  {Array}  array
	 * @param  {Array}  result
	 * @param  {Number} depth
	 * @return {Array}
	 */
	function flattenWithDepth (array, result, depth) {
	  for (var i = 0; i < array.length; i++) {
	    var value = array[i];

	    if (depth > 0 && Array.isArray(value)) {
	      flattenWithDepth(value, result, depth - 1);
	    } else {
	      result.push(value);
	    }
	  }

	  return result
	}

	/**
	 * Recursive flatten function. Omitting depth is slightly faster.
	 *
	 * @param  {Array} array
	 * @param  {Array} result
	 * @return {Array}
	 */
	function flattenForever (array, result) {
	  for (var i = 0; i < array.length; i++) {
	    var value = array[i];

	    if (Array.isArray(value)) {
	      flattenForever(value, result);
	    } else {
	      result.push(value);
	    }
	  }

	  return result
	}

	/**
	 * Flatten an array, with the ability to define a depth.
	 *
	 * @param  {Array}  array
	 * @param  {Number} depth
	 * @return {Array}
	 */
	function arrayFlatten (array, depth) {
	  if (depth == null) {
	    return flattenForever(array, [])
	  }

	  return flattenWithDepth(array, [], depth)
	}
	return arrayFlatten_1;
}

/**
 * Expose `pathToRegexp`.
 */

var pathToRegexp_1;
var hasRequiredPathToRegexp;

function requirePathToRegexp () {
	if (hasRequiredPathToRegexp) return pathToRegexp_1;
	hasRequiredPathToRegexp = 1;
	pathToRegexp_1 = pathToRegexp;

	/**
	 * Match matching groups in a regular expression.
	 */
	var MATCHING_GROUP_REGEXP = /\\.|\((?:\?<(.*?)>)?(?!\?)/g;

	/**
	 * Normalize the given path string,
	 * returning a regular expression.
	 *
	 * An empty array should be passed,
	 * which will contain the placeholder
	 * key names. For example "/user/:id" will
	 * then contain ["id"].
	 *
	 * @param  {String|RegExp|Array} path
	 * @param  {Array} keys
	 * @param  {Object} options
	 * @return {RegExp}
	 * @api private
	 */

	function pathToRegexp(path, keys, options) {
	  options = options || {};
	  keys = keys || [];
	  var strict = options.strict;
	  var end = options.end !== false;
	  var flags = options.sensitive ? '' : 'i';
	  var lookahead = options.lookahead !== false;
	  var extraOffset = 0;
	  var keysOffset = keys.length;
	  var i = 0;
	  var name = 0;
	  var pos = 0;
	  var backtrack = '';
	  var m;

	  if (path instanceof RegExp) {
	    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
	      if (m[0][0] === '\\') continue;

	      keys.push({
	        name: m[1] || name++,
	        optional: false,
	        offset: m.index
	      });
	    }

	    return path;
	  }

	  if (Array.isArray(path)) {
	    // Map array parts into regexps and return their source. We also pass
	    // the same keys and options instance into every generation to get
	    // consistent matching groups before we join the sources together.
	    path = path.map(function (value) {
	      return pathToRegexp(value, keys, options).source;
	    });

	    return new RegExp(path.join('|'), flags);
	  }

	  path = path.replace(
	    /\\.|(\/)?(\.)?:(\w+)(\(.*?\))?(\*)?(\?)?|[.*]|\/\(/g,
	    function (match, slash, format, key, capture, star, optional, offset) {
	      pos = offset + match.length;

	      if (match[0] === '\\') {
	        backtrack += match;
	        return match;
	      }

	      if (match === '.') {
	        backtrack += '\\.';
	        extraOffset += 1;
	        return '\\.';
	      }

	      backtrack = slash || format ? '' : path.slice(pos, offset);

	      if (match === '*') {
	        extraOffset += 3;
	        return '(.*)';
	      }

	      if (match === '/(') {
	        backtrack += '/';
	        extraOffset += 2;
	        return '/(?:';
	      }

	      slash = slash || '';
	      format = format ? '\\.' : '';
	      optional = optional || '';
	      capture = capture ?
	        capture.replace(/\\.|\*/, function (m) { return m === '*' ? '(.*)' : m; }) :
	        (backtrack ? '((?:(?!/|' + backtrack + ').)+?)' : '([^/' + format + ']+?)');

	      keys.push({
	        name: key,
	        optional: !!optional,
	        offset: offset + extraOffset
	      });

	      var result = '(?:'
	        + format + slash + capture
	        + (star ? '((?:[/' + format + '].+?)?)' : '')
	        + ')'
	        + optional;

	      extraOffset += result.length - match.length;

	      return result;
	    });

	  // This is a workaround for handling unnamed matching groups.
	  while (m = MATCHING_GROUP_REGEXP.exec(path)) {
	    if (m[0][0] === '\\') continue;

	    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
	      keys.splice(keysOffset + i, 0, {
	        name: name++, // Unnamed matching groups must be consistently linear.
	        optional: false,
	        offset: m.index
	      });
	    }

	    i++;
	  }

	  path += strict ? '' : path[path.length - 1] === '/' ? '?' : '/?';

	  // If the path is non-ending, match until the end or a slash.
	  if (end) {
	    path += '$';
	  } else if (path[path.length - 1] !== '/') {
	    path += lookahead ? '(?=/|$)' : '(?:/|$)';
	  }

	  return new RegExp('^' + path, flags);
	}	return pathToRegexp_1;
}

/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var layer;
var hasRequiredLayer;

function requireLayer () {
	if (hasRequiredLayer) return layer;
	hasRequiredLayer = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var pathRegexp = requirePathToRegexp();
	var debug = requireSrc$3()('express:router:layer');

	/**
	 * Module variables.
	 * @private
	 */

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	/**
	 * Module exports.
	 * @public
	 */

	layer = Layer;

	function Layer(path, options, fn) {
	  if (!(this instanceof Layer)) {
	    return new Layer(path, options, fn);
	  }

	  debug('new %o', path);
	  var opts = options || {};

	  this.handle = fn;
	  this.name = fn.name || '<anonymous>';
	  this.params = undefined;
	  this.path = undefined;
	  this.regexp = pathRegexp(path, this.keys = [], opts);

	  // set fast path flags
	  this.regexp.fast_star = path === '*';
	  this.regexp.fast_slash = path === '/' && opts.end === false;
	}

	/**
	 * Handle the error for the layer.
	 *
	 * @param {Error} error
	 * @param {Request} req
	 * @param {Response} res
	 * @param {function} next
	 * @api private
	 */

	Layer.prototype.handle_error = function handle_error(error, req, res, next) {
	  var fn = this.handle;

	  if (fn.length !== 4) {
	    // not a standard error handler
	    return next(error);
	  }

	  try {
	    fn(error, req, res, next);
	  } catch (err) {
	    next(err);
	  }
	};

	/**
	 * Handle the request for the layer.
	 *
	 * @param {Request} req
	 * @param {Response} res
	 * @param {function} next
	 * @api private
	 */

	Layer.prototype.handle_request = function handle(req, res, next) {
	  var fn = this.handle;

	  if (fn.length > 3) {
	    // not a standard request handler
	    return next();
	  }

	  try {
	    fn(req, res, next);
	  } catch (err) {
	    next(err);
	  }
	};

	/**
	 * Check if this route matches `path`, if so
	 * populate `.params`.
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api private
	 */

	Layer.prototype.match = function match(path) {
	  var match;

	  if (path != null) {
	    // fast path non-ending match for / (any path matches)
	    if (this.regexp.fast_slash) {
	      this.params = {};
	      this.path = '';
	      return true
	    }

	    // fast path for * (everything matched in a param)
	    if (this.regexp.fast_star) {
	      this.params = {'0': decode_param(path)};
	      this.path = path;
	      return true
	    }

	    // match the path
	    match = this.regexp.exec(path);
	  }

	  if (!match) {
	    this.params = undefined;
	    this.path = undefined;
	    return false;
	  }

	  // store values
	  this.params = {};
	  this.path = match[0];

	  var keys = this.keys;
	  var params = this.params;

	  for (var i = 1; i < match.length; i++) {
	    var key = keys[i - 1];
	    var prop = key.name;
	    var val = decode_param(match[i]);

	    if (val !== undefined || !(hasOwnProperty.call(params, prop))) {
	      params[prop] = val;
	    }
	  }

	  return true;
	};

	/**
	 * Decode param value.
	 *
	 * @param {string} val
	 * @return {string}
	 * @private
	 */

	function decode_param(val) {
	  if (typeof val !== 'string' || val.length === 0) {
	    return val;
	  }

	  try {
	    return decodeURIComponent(val);
	  } catch (err) {
	    if (err instanceof URIError) {
	      err.message = 'Failed to decode param \'' + val + '\'';
	      err.status = err.statusCode = 400;
	    }

	    throw err;
	  }
	}
	return layer;
}

/*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */

var methods;
var hasRequiredMethods;

function requireMethods () {
	if (hasRequiredMethods) return methods;
	hasRequiredMethods = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var http = require$$0$b;

	/**
	 * Module exports.
	 * @public
	 */

	methods = getCurrentNodeMethods() || getBasicNodeMethods();

	/**
	 * Get the current Node.js methods.
	 * @private
	 */

	function getCurrentNodeMethods() {
	  return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
	    return method.toLowerCase();
	  });
	}

	/**
	 * Get the "basic" Node.js methods, a snapshot from Node.js 0.10.
	 * @private
	 */

	function getBasicNodeMethods() {
	  return [
	    'get',
	    'post',
	    'put',
	    'head',
	    'delete',
	    'options',
	    'trace',
	    'copy',
	    'lock',
	    'mkcol',
	    'move',
	    'purge',
	    'propfind',
	    'proppatch',
	    'unlock',
	    'report',
	    'mkactivity',
	    'checkout',
	    'merge',
	    'm-search',
	    'notify',
	    'subscribe',
	    'unsubscribe',
	    'patch',
	    'search',
	    'connect'
	  ];
	}
	return methods;
}

/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var route;
var hasRequiredRoute;

function requireRoute () {
	if (hasRequiredRoute) return route;
	hasRequiredRoute = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var debug = requireSrc$3()('express:router:route');
	var flatten = requireArrayFlatten();
	var Layer = requireLayer();
	var methods = requireMethods();

	/**
	 * Module variables.
	 * @private
	 */

	var slice = Array.prototype.slice;
	var toString = Object.prototype.toString;

	/**
	 * Module exports.
	 * @public
	 */

	route = Route;

	/**
	 * Initialize `Route` with the given `path`,
	 *
	 * @param {String} path
	 * @public
	 */

	function Route(path) {
	  this.path = path;
	  this.stack = [];

	  debug('new %o', path);

	  // route handlers for various http methods
	  this.methods = {};
	}

	/**
	 * Determine if the route handles a given method.
	 * @private
	 */

	Route.prototype._handles_method = function _handles_method(method) {
	  if (this.methods._all) {
	    return true;
	  }

	  // normalize name
	  var name = typeof method === 'string'
	    ? method.toLowerCase()
	    : method;

	  if (name === 'head' && !this.methods['head']) {
	    name = 'get';
	  }

	  return Boolean(this.methods[name]);
	};

	/**
	 * @return {Array} supported HTTP methods
	 * @private
	 */

	Route.prototype._options = function _options() {
	  var methods = Object.keys(this.methods);

	  // append automatic head
	  if (this.methods.get && !this.methods.head) {
	    methods.push('head');
	  }

	  for (var i = 0; i < methods.length; i++) {
	    // make upper case
	    methods[i] = methods[i].toUpperCase();
	  }

	  return methods;
	};

	/**
	 * dispatch req, res into this route
	 * @private
	 */

	Route.prototype.dispatch = function dispatch(req, res, done) {
	  var idx = 0;
	  var stack = this.stack;
	  var sync = 0;

	  if (stack.length === 0) {
	    return done();
	  }
	  var method = typeof req.method === 'string'
	    ? req.method.toLowerCase()
	    : req.method;

	  if (method === 'head' && !this.methods['head']) {
	    method = 'get';
	  }

	  req.route = this;

	  next();

	  function next(err) {
	    // signal to exit route
	    if (err && err === 'route') {
	      return done();
	    }

	    // signal to exit router
	    if (err && err === 'router') {
	      return done(err)
	    }

	    // max sync stack
	    if (++sync > 100) {
	      return setImmediate(next, err)
	    }

	    var layer = stack[idx++];

	    // end of layers
	    if (!layer) {
	      return done(err)
	    }

	    if (layer.method && layer.method !== method) {
	      next(err);
	    } else if (err) {
	      layer.handle_error(err, req, res, next);
	    } else {
	      layer.handle_request(req, res, next);
	    }

	    sync = 0;
	  }
	};

	/**
	 * Add a handler for all HTTP verbs to this route.
	 *
	 * Behaves just like middleware and can respond or call `next`
	 * to continue processing.
	 *
	 * You can use multiple `.all` call to add multiple handlers.
	 *
	 *   function check_something(req, res, next){
	 *     next();
	 *   };
	 *
	 *   function validate_user(req, res, next){
	 *     next();
	 *   };
	 *
	 *   route
	 *   .all(validate_user)
	 *   .all(check_something)
	 *   .get(function(req, res, next){
	 *     res.send('hello world');
	 *   });
	 *
	 * @param {function} handler
	 * @return {Route} for chaining
	 * @api public
	 */

	Route.prototype.all = function all() {
	  var handles = flatten(slice.call(arguments));

	  for (var i = 0; i < handles.length; i++) {
	    var handle = handles[i];

	    if (typeof handle !== 'function') {
	      var type = toString.call(handle);
	      var msg = 'Route.all() requires a callback function but got a ' + type;
	      throw new TypeError(msg);
	    }

	    var layer = Layer('/', {}, handle);
	    layer.method = undefined;

	    this.methods._all = true;
	    this.stack.push(layer);
	  }

	  return this;
	};

	methods.forEach(function(method){
	  Route.prototype[method] = function(){
	    var handles = flatten(slice.call(arguments));

	    for (var i = 0; i < handles.length; i++) {
	      var handle = handles[i];

	      if (typeof handle !== 'function') {
	        var type = toString.call(handle);
	        var msg = 'Route.' + method + '() requires a callback function but got a ' + type;
	        throw new Error(msg);
	      }

	      debug('%s %o', method, this.path);

	      var layer = Layer('/', {}, handle);
	      layer.method = method;

	      this.methods[method] = true;
	      this.stack.push(layer);
	    }

	    return this;
	  };
	});
	return route;
}

var utilsMerge = {exports: {}};

/**
 * Merge object b with object a.
 *
 *     var a = { foo: 'bar' }
 *       , b = { bar: 'baz' };
 *
 *     merge(a, b);
 *     // => { foo: 'bar', bar: 'baz' }
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object}
 * @api public
 */

var hasRequiredUtilsMerge;

function requireUtilsMerge () {
	if (hasRequiredUtilsMerge) return utilsMerge.exports;
	hasRequiredUtilsMerge = 1;
	(function (module, exports) {
		module.exports = function(a, b){
		  if (a && b) {
		    for (var key in b) {
		      a[key] = b[key];
		    }
		  }
		  return a;
		}; 
	} (utilsMerge));
	return utilsMerge.exports;
}

/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredRouter;

function requireRouter () {
	if (hasRequiredRouter) return router$2.exports;
	hasRequiredRouter = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var Route = requireRoute();
	var Layer = requireLayer();
	var methods = requireMethods();
	var mixin = requireUtilsMerge();
	var debug = requireSrc$3()('express:router');
	var deprecate = requireDepd()('express');
	var flatten = requireArrayFlatten();
	var parseUrl = requireParseurl();
	var setPrototypeOf = requireSetprototypeof();

	/**
	 * Module variables.
	 * @private
	 */

	var objectRegExp = /^\[object (\S+)\]$/;
	var slice = Array.prototype.slice;
	var toString = Object.prototype.toString;

	/**
	 * Initialize a new `Router` with the given `options`.
	 *
	 * @param {Object} [options]
	 * @return {Router} which is a callable function
	 * @public
	 */

	var proto = router$2.exports = function(options) {
	  var opts = options || {};

	  function router(req, res, next) {
	    router.handle(req, res, next);
	  }

	  // mixin Router class functions
	  setPrototypeOf(router, proto);

	  router.params = {};
	  router._params = [];
	  router.caseSensitive = opts.caseSensitive;
	  router.mergeParams = opts.mergeParams;
	  router.strict = opts.strict;
	  router.stack = [];

	  return router;
	};

	/**
	 * Map the given param placeholder `name`(s) to the given callback.
	 *
	 * Parameter mapping is used to provide pre-conditions to routes
	 * which use normalized placeholders. For example a _:user_id_ parameter
	 * could automatically load a user's information from the database without
	 * any additional code,
	 *
	 * The callback uses the same signature as middleware, the only difference
	 * being that the value of the placeholder is passed, in this case the _id_
	 * of the user. Once the `next()` function is invoked, just like middleware
	 * it will continue on to execute the route, or subsequent parameter functions.
	 *
	 * Just like in middleware, you must either respond to the request or call next
	 * to avoid stalling the request.
	 *
	 *  app.param('user_id', function(req, res, next, id){
	 *    User.find(id, function(err, user){
	 *      if (err) {
	 *        return next(err);
	 *      } else if (!user) {
	 *        return next(new Error('failed to load user'));
	 *      }
	 *      req.user = user;
	 *      next();
	 *    });
	 *  });
	 *
	 * @param {String} name
	 * @param {Function} fn
	 * @return {app} for chaining
	 * @public
	 */

	proto.param = function param(name, fn) {
	  // param logic
	  if (typeof name === 'function') {
	    deprecate('router.param(fn): Refactor to use path params');
	    this._params.push(name);
	    return;
	  }

	  // apply param functions
	  var params = this._params;
	  var len = params.length;
	  var ret;

	  if (name[0] === ':') {
	    deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.slice(1)) + ', fn) instead');
	    name = name.slice(1);
	  }

	  for (var i = 0; i < len; ++i) {
	    if (ret = params[i](name, fn)) {
	      fn = ret;
	    }
	  }

	  // ensure we end up with a
	  // middleware function
	  if ('function' !== typeof fn) {
	    throw new Error('invalid param() call for ' + name + ', got ' + fn);
	  }

	  (this.params[name] = this.params[name] || []).push(fn);
	  return this;
	};

	/**
	 * Dispatch a req, res into the router.
	 * @private
	 */

	proto.handle = function handle(req, res, out) {
	  var self = this;

	  debug('dispatching %s %s', req.method, req.url);

	  var idx = 0;
	  var protohost = getProtohost(req.url) || '';
	  var removed = '';
	  var slashAdded = false;
	  var sync = 0;
	  var paramcalled = {};

	  // store options for OPTIONS request
	  // only used if OPTIONS request
	  var options = [];

	  // middleware and routes
	  var stack = self.stack;

	  // manage inter-router variables
	  var parentParams = req.params;
	  var parentUrl = req.baseUrl || '';
	  var done = restore(out, req, 'baseUrl', 'next', 'params');

	  // setup next layer
	  req.next = next;

	  // for options requests, respond with a default if nothing else responds
	  if (req.method === 'OPTIONS') {
	    done = wrap(done, function(old, err) {
	      if (err || options.length === 0) return old(err);
	      sendOptionsResponse(res, options, old);
	    });
	  }

	  // setup basic req values
	  req.baseUrl = parentUrl;
	  req.originalUrl = req.originalUrl || req.url;

	  next();

	  function next(err) {
	    var layerError = err === 'route'
	      ? null
	      : err;

	    // remove added slash
	    if (slashAdded) {
	      req.url = req.url.slice(1);
	      slashAdded = false;
	    }

	    // restore altered req.url
	    if (removed.length !== 0) {
	      req.baseUrl = parentUrl;
	      req.url = protohost + removed + req.url.slice(protohost.length);
	      removed = '';
	    }

	    // signal to exit router
	    if (layerError === 'router') {
	      setImmediate(done, null);
	      return
	    }

	    // no more matching layers
	    if (idx >= stack.length) {
	      setImmediate(done, layerError);
	      return;
	    }

	    // max sync stack
	    if (++sync > 100) {
	      return setImmediate(next, err)
	    }

	    // get pathname of request
	    var path = getPathname(req);

	    if (path == null) {
	      return done(layerError);
	    }

	    // find next matching layer
	    var layer;
	    var match;
	    var route;

	    while (match !== true && idx < stack.length) {
	      layer = stack[idx++];
	      match = matchLayer(layer, path);
	      route = layer.route;

	      if (typeof match !== 'boolean') {
	        // hold on to layerError
	        layerError = layerError || match;
	      }

	      if (match !== true) {
	        continue;
	      }

	      if (!route) {
	        // process non-route handlers normally
	        continue;
	      }

	      if (layerError) {
	        // routes do not match with a pending error
	        match = false;
	        continue;
	      }

	      var method = req.method;
	      var has_method = route._handles_method(method);

	      // build up automatic options response
	      if (!has_method && method === 'OPTIONS') {
	        appendMethods(options, route._options());
	      }

	      // don't even bother matching route
	      if (!has_method && method !== 'HEAD') {
	        match = false;
	      }
	    }

	    // no match
	    if (match !== true) {
	      return done(layerError);
	    }

	    // store route for dispatch on change
	    if (route) {
	      req.route = route;
	    }

	    // Capture one-time layer values
	    req.params = self.mergeParams
	      ? mergeParams(layer.params, parentParams)
	      : layer.params;
	    var layerPath = layer.path;

	    // this should be done for the layer
	    self.process_params(layer, paramcalled, req, res, function (err) {
	      if (err) {
	        next(layerError || err);
	      } else if (route) {
	        layer.handle_request(req, res, next);
	      } else {
	        trim_prefix(layer, layerError, layerPath, path);
	      }

	      sync = 0;
	    });
	  }

	  function trim_prefix(layer, layerError, layerPath, path) {
	    if (layerPath.length !== 0) {
	      // Validate path is a prefix match
	      if (layerPath !== path.slice(0, layerPath.length)) {
	        next(layerError);
	        return
	      }

	      // Validate path breaks on a path separator
	      var c = path[layerPath.length];
	      if (c && c !== '/' && c !== '.') return next(layerError)

	      // Trim off the part of the url that matches the route
	      // middleware (.use stuff) needs to have the path stripped
	      debug('trim prefix (%s) from url %s', layerPath, req.url);
	      removed = layerPath;
	      req.url = protohost + req.url.slice(protohost.length + removed.length);

	      // Ensure leading slash
	      if (!protohost && req.url[0] !== '/') {
	        req.url = '/' + req.url;
	        slashAdded = true;
	      }

	      // Setup base URL (no trailing slash)
	      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'
	        ? removed.substring(0, removed.length - 1)
	        : removed);
	    }

	    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);

	    if (layerError) {
	      layer.handle_error(layerError, req, res, next);
	    } else {
	      layer.handle_request(req, res, next);
	    }
	  }
	};

	/**
	 * Process any parameters for the layer.
	 * @private
	 */

	proto.process_params = function process_params(layer, called, req, res, done) {
	  var params = this.params;

	  // captured parameters from the layer, keys and values
	  var keys = layer.keys;

	  // fast track
	  if (!keys || keys.length === 0) {
	    return done();
	  }

	  var i = 0;
	  var name;
	  var paramIndex = 0;
	  var key;
	  var paramVal;
	  var paramCallbacks;
	  var paramCalled;

	  // process params in order
	  // param callbacks can be async
	  function param(err) {
	    if (err) {
	      return done(err);
	    }

	    if (i >= keys.length ) {
	      return done();
	    }

	    paramIndex = 0;
	    key = keys[i++];
	    name = key.name;
	    paramVal = req.params[name];
	    paramCallbacks = params[name];
	    paramCalled = called[name];

	    if (paramVal === undefined || !paramCallbacks) {
	      return param();
	    }

	    // param previously called with same value or error occurred
	    if (paramCalled && (paramCalled.match === paramVal
	      || (paramCalled.error && paramCalled.error !== 'route'))) {
	      // restore value
	      req.params[name] = paramCalled.value;

	      // next param
	      return param(paramCalled.error);
	    }

	    called[name] = paramCalled = {
	      error: null,
	      match: paramVal,
	      value: paramVal
	    };

	    paramCallback();
	  }

	  // single param callbacks
	  function paramCallback(err) {
	    var fn = paramCallbacks[paramIndex++];

	    // store updated value
	    paramCalled.value = req.params[key.name];

	    if (err) {
	      // store error
	      paramCalled.error = err;
	      param(err);
	      return;
	    }

	    if (!fn) return param();

	    try {
	      fn(req, res, paramCallback, paramVal, key.name);
	    } catch (e) {
	      paramCallback(e);
	    }
	  }

	  param();
	};

	/**
	 * Use the given middleware function, with optional path, defaulting to "/".
	 *
	 * Use (like `.all`) will run for any http METHOD, but it will not add
	 * handlers for those methods so OPTIONS requests will not consider `.use`
	 * functions even if they could respond.
	 *
	 * The other difference is that _route_ path is stripped and not visible
	 * to the handler function. The main effect of this feature is that mounted
	 * handlers can operate without any code changes regardless of the "prefix"
	 * pathname.
	 *
	 * @public
	 */

	proto.use = function use(fn) {
	  var offset = 0;
	  var path = '/';

	  // default path to '/'
	  // disambiguate router.use([fn])
	  if (typeof fn !== 'function') {
	    var arg = fn;

	    while (Array.isArray(arg) && arg.length !== 0) {
	      arg = arg[0];
	    }

	    // first arg is the path
	    if (typeof arg !== 'function') {
	      offset = 1;
	      path = fn;
	    }
	  }

	  var callbacks = flatten(slice.call(arguments, offset));

	  if (callbacks.length === 0) {
	    throw new TypeError('Router.use() requires a middleware function')
	  }

	  for (var i = 0; i < callbacks.length; i++) {
	    var fn = callbacks[i];

	    if (typeof fn !== 'function') {
	      throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn))
	    }

	    // add the middleware
	    debug('use %o %s', path, fn.name || '<anonymous>');

	    var layer = new Layer(path, {
	      sensitive: this.caseSensitive,
	      strict: false,
	      end: false
	    }, fn);

	    layer.route = undefined;

	    this.stack.push(layer);
	  }

	  return this;
	};

	/**
	 * Create a new Route for the given path.
	 *
	 * Each route contains a separate middleware stack and VERB handlers.
	 *
	 * See the Route api documentation for details on adding handlers
	 * and middleware to routes.
	 *
	 * @param {String} path
	 * @return {Route}
	 * @public
	 */

	proto.route = function route(path) {
	  var route = new Route(path);

	  var layer = new Layer(path, {
	    sensitive: this.caseSensitive,
	    strict: this.strict,
	    end: true
	  }, route.dispatch.bind(route));

	  layer.route = route;

	  this.stack.push(layer);
	  return route;
	};

	// create Router#VERB functions
	methods.concat('all').forEach(function(method){
	  proto[method] = function(path){
	    var route = this.route(path);
	    route[method].apply(route, slice.call(arguments, 1));
	    return this;
	  };
	});

	// append methods to a list of methods
	function appendMethods(list, addition) {
	  for (var i = 0; i < addition.length; i++) {
	    var method = addition[i];
	    if (list.indexOf(method) === -1) {
	      list.push(method);
	    }
	  }
	}

	// get pathname of request
	function getPathname(req) {
	  try {
	    return parseUrl(req).pathname;
	  } catch (err) {
	    return undefined;
	  }
	}

	// Get get protocol + host for a URL
	function getProtohost(url) {
	  if (typeof url !== 'string' || url.length === 0 || url[0] === '/') {
	    return undefined
	  }

	  var searchIndex = url.indexOf('?');
	  var pathLength = searchIndex !== -1
	    ? searchIndex
	    : url.length;
	  var fqdnIndex = url.slice(0, pathLength).indexOf('://');

	  return fqdnIndex !== -1
	    ? url.substring(0, url.indexOf('/', 3 + fqdnIndex))
	    : undefined
	}

	// get type for error message
	function gettype(obj) {
	  var type = typeof obj;

	  if (type !== 'object') {
	    return type;
	  }

	  // inspect [[Class]] for objects
	  return toString.call(obj)
	    .replace(objectRegExp, '$1');
	}

	/**
	 * Match path to a layer.
	 *
	 * @param {Layer} layer
	 * @param {string} path
	 * @private
	 */

	function matchLayer(layer, path) {
	  try {
	    return layer.match(path);
	  } catch (err) {
	    return err;
	  }
	}

	// merge params with parent params
	function mergeParams(params, parent) {
	  if (typeof parent !== 'object' || !parent) {
	    return params;
	  }

	  // make copy of parent for base
	  var obj = mixin({}, parent);

	  // simple non-numeric merging
	  if (!(0 in params) || !(0 in parent)) {
	    return mixin(obj, params);
	  }

	  var i = 0;
	  var o = 0;

	  // determine numeric gaps
	  while (i in params) {
	    i++;
	  }

	  while (o in parent) {
	    o++;
	  }

	  // offset numeric indices in params before merge
	  for (i--; i >= 0; i--) {
	    params[i + o] = params[i];

	    // create holes for the merge when necessary
	    if (i < o) {
	      delete params[i];
	    }
	  }

	  return mixin(obj, params);
	}

	// restore obj props after function
	function restore(fn, obj) {
	  var props = new Array(arguments.length - 2);
	  var vals = new Array(arguments.length - 2);

	  for (var i = 0; i < props.length; i++) {
	    props[i] = arguments[i + 2];
	    vals[i] = obj[props[i]];
	  }

	  return function () {
	    // restore vals
	    for (var i = 0; i < props.length; i++) {
	      obj[props[i]] = vals[i];
	    }

	    return fn.apply(this, arguments);
	  };
	}

	// send an OPTIONS response
	function sendOptionsResponse(res, options, next) {
	  try {
	    var body = options.join(',');
	    res.set('Allow', body);
	    res.send(body);
	  } catch (err) {
	    next(err);
	  }
	}

	// wrap a function
	function wrap(old, fn) {
	  return function proxy() {
	    var args = new Array(arguments.length + 1);

	    args[0] = old;
	    for (var i = 0, len = arguments.length; i < len; i++) {
	      args[i + 1] = arguments[i];
	    }

	    fn.apply(this, args);
	  };
	}
	return router$2.exports;
}

var init = {};

/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredInit;

function requireInit () {
	if (hasRequiredInit) return init;
	hasRequiredInit = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var setPrototypeOf = requireSetprototypeof();

	/**
	 * Initialization middleware, exposing the
	 * request and response to each other, as well
	 * as defaulting the X-Powered-By header field.
	 *
	 * @param {Function} app
	 * @return {Function}
	 * @api private
	 */

	init.init = function(app){
	  return function expressInit(req, res, next){
	    if (app.enabled('x-powered-by')) res.setHeader('X-Powered-By', 'Express');
	    req.res = res;
	    res.req = req;
	    req.next = next;

	    setPrototypeOf(req, app.request);
	    setPrototypeOf(res, app.response);

	    res.locals = res.locals || Object.create(null);

	    next();
	  };
	};
	return init;
}

/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var query;
var hasRequiredQuery;

function requireQuery () {
	if (hasRequiredQuery) return query;
	hasRequiredQuery = 1;

	/**
	 * Module dependencies.
	 */

	var merge = requireUtilsMerge();
	var parseUrl = requireParseurl();
	var qs = /*@__PURE__*/ requireLib$4();

	/**
	 * @param {Object} options
	 * @return {Function}
	 * @api public
	 */

	query = function query(options) {
	  var opts = merge({}, options);
	  var queryparse = qs.parse;

	  if (typeof options === 'function') {
	    queryparse = options;
	    opts = undefined;
	  }

	  if (opts !== undefined && opts.allowPrototypes === undefined) {
	    // back-compat for qs module
	    opts.allowPrototypes = true;
	  }

	  return function query(req, res, next){
	    if (!req.query) {
	      var val = parseUrl(req).query;
	      req.query = queryparse(val, opts);
	    }

	    next();
	  };
	};
	return query;
}

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var view;
var hasRequiredView;

function requireView () {
	if (hasRequiredView) return view;
	hasRequiredView = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var debug = requireSrc$3()('express:view');
	var path = require$$0$4;
	var fs$1 = fs;

	/**
	 * Module variables.
	 * @private
	 */

	var dirname = path.dirname;
	var basename = path.basename;
	var extname = path.extname;
	var join = path.join;
	var resolve = path.resolve;

	/**
	 * Module exports.
	 * @public
	 */

	view = View;

	/**
	 * Initialize a new `View` with the given `name`.
	 *
	 * Options:
	 *
	 *   - `defaultEngine` the default template engine name
	 *   - `engines` template engine require() cache
	 *   - `root` root path for view lookup
	 *
	 * @param {string} name
	 * @param {object} options
	 * @public
	 */

	function View(name, options) {
	  var opts = options || {};

	  this.defaultEngine = opts.defaultEngine;
	  this.ext = extname(name);
	  this.name = name;
	  this.root = opts.root;

	  if (!this.ext && !this.defaultEngine) {
	    throw new Error('No default engine was specified and no extension was provided.');
	  }

	  var fileName = name;

	  if (!this.ext) {
	    // get extension from default engine name
	    this.ext = this.defaultEngine[0] !== '.'
	      ? '.' + this.defaultEngine
	      : this.defaultEngine;

	    fileName += this.ext;
	  }

	  if (!opts.engines[this.ext]) {
	    // load engine
	    var mod = this.ext.slice(1);
	    debug('require "%s"', mod);

	    // default engine export
	    var fn = commonjsRequire(mod).__express;

	    if (typeof fn !== 'function') {
	      throw new Error('Module "' + mod + '" does not provide a view engine.')
	    }

	    opts.engines[this.ext] = fn;
	  }

	  // store loaded engine
	  this.engine = opts.engines[this.ext];

	  // lookup path
	  this.path = this.lookup(fileName);
	}

	/**
	 * Lookup view by the given `name`
	 *
	 * @param {string} name
	 * @private
	 */

	View.prototype.lookup = function lookup(name) {
	  var path;
	  var roots = [].concat(this.root);

	  debug('lookup "%s"', name);

	  for (var i = 0; i < roots.length && !path; i++) {
	    var root = roots[i];

	    // resolve the path
	    var loc = resolve(root, name);
	    var dir = dirname(loc);
	    var file = basename(loc);

	    // resolve the file
	    path = this.resolve(dir, file);
	  }

	  return path;
	};

	/**
	 * Render with the given options.
	 *
	 * @param {object} options
	 * @param {function} callback
	 * @private
	 */

	View.prototype.render = function render(options, callback) {
	  debug('render "%s"', this.path);
	  this.engine(this.path, options, callback);
	};

	/**
	 * Resolve the file within the given directory.
	 *
	 * @param {string} dir
	 * @param {string} file
	 * @private
	 */

	View.prototype.resolve = function resolve(dir, file) {
	  var ext = this.ext;

	  // <path>.<ext>
	  var path = join(dir, file);
	  var stat = tryStat(path);

	  if (stat && stat.isFile()) {
	    return path;
	  }

	  // <path>/index.<ext>
	  path = join(dir, basename(file, ext), 'index' + ext);
	  stat = tryStat(path);

	  if (stat && stat.isFile()) {
	    return path;
	  }
	};

	/**
	 * Return a stat, maybe.
	 *
	 * @param {string} path
	 * @return {fs.Stats}
	 * @private
	 */

	function tryStat(path) {
	  debug('stat "%s"', path);

	  try {
	    return fs$1.statSync(path);
	  } catch (e) {
	    return undefined;
	  }
	}
	return view;
}

var utils$2 = {};

var safeBuffer$1 = {exports: {}};

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredSafeBuffer$1;

function requireSafeBuffer$1 () {
	if (hasRequiredSafeBuffer$1) return safeBuffer$1.exports;
	hasRequiredSafeBuffer$1 = 1;
	(function (module, exports) {
		/* eslint-disable node/no-deprecated-api */
		var buffer = require$$0$a;
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports);
		  exports.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		SafeBuffer.prototype = Object.create(Buffer.prototype);

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		}; 
	} (safeBuffer$1, safeBuffer$1.exports));
	return safeBuffer$1.exports;
}

var contentDisposition = {exports: {}};

var safeBuffer = {exports: {}};

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredSafeBuffer;

function requireSafeBuffer () {
	if (hasRequiredSafeBuffer) return safeBuffer.exports;
	hasRequiredSafeBuffer = 1;
	(function (module, exports) {
		/* eslint-disable node/no-deprecated-api */
		var buffer = require$$0$a;
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports);
		  exports.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		SafeBuffer.prototype = Object.create(Buffer.prototype);

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		}; 
	} (safeBuffer, safeBuffer.exports));
	return safeBuffer.exports;
}

/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredContentDisposition;

function requireContentDisposition () {
	if (hasRequiredContentDisposition) return contentDisposition.exports;
	hasRequiredContentDisposition = 1;

	/**
	 * Module exports.
	 * @public
	 */

	contentDisposition.exports = contentDisposition$1;
	contentDisposition.exports.parse = parse;

	/**
	 * Module dependencies.
	 * @private
	 */

	var basename = require$$0$4.basename;
	var Buffer = requireSafeBuffer().Buffer;

	/**
	 * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
	 * @private
	 */

	var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g; // eslint-disable-line no-control-regex

	/**
	 * RegExp to match percent encoding escape.
	 * @private
	 */

	var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
	var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;

	/**
	 * RegExp to match non-latin1 characters.
	 * @private
	 */

	var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;

	/**
	 * RegExp to match quoted-pair in RFC 2616
	 *
	 * quoted-pair = "\" CHAR
	 * CHAR        = <any US-ASCII character (octets 0 - 127)>
	 * @private
	 */

	var QESC_REGEXP = /\\([\u0000-\u007f])/g; // eslint-disable-line no-control-regex

	/**
	 * RegExp to match chars that must be quoted-pair in RFC 2616
	 * @private
	 */

	var QUOTE_REGEXP = /([\\"])/g;

	/**
	 * RegExp for various RFC 2616 grammar
	 *
	 * parameter     = token "=" ( token | quoted-string )
	 * token         = 1*<any CHAR except CTLs or separators>
	 * separators    = "(" | ")" | "<" | ">" | "@"
	 *               | "," | ";" | ":" | "\" | <">
	 *               | "/" | "[" | "]" | "?" | "="
	 *               | "{" | "}" | SP | HT
	 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	 * qdtext        = <any TEXT except <">>
	 * quoted-pair   = "\" CHAR
	 * CHAR          = <any US-ASCII character (octets 0 - 127)>
	 * TEXT          = <any OCTET except CTLs, but including LWS>
	 * LWS           = [CRLF] 1*( SP | HT )
	 * CRLF          = CR LF
	 * CR            = <US-ASCII CR, carriage return (13)>
	 * LF            = <US-ASCII LF, linefeed (10)>
	 * SP            = <US-ASCII SP, space (32)>
	 * HT            = <US-ASCII HT, horizontal-tab (9)>
	 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	 * OCTET         = <any 8-bit sequence of data>
	 * @private
	 */

	var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g; // eslint-disable-line no-control-regex
	var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
	var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;

	/**
	 * RegExp for various RFC 5987 grammar
	 *
	 * ext-value     = charset  "'" [ language ] "'" value-chars
	 * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
	 * mime-charset  = 1*mime-charsetc
	 * mime-charsetc = ALPHA / DIGIT
	 *               / "!" / "#" / "$" / "%" / "&"
	 *               / "+" / "-" / "^" / "_" / "`"
	 *               / "{" / "}" / "~"
	 * language      = ( 2*3ALPHA [ extlang ] )
	 *               / 4ALPHA
	 *               / 5*8ALPHA
	 * extlang       = *3( "-" 3ALPHA )
	 * value-chars   = *( pct-encoded / attr-char )
	 * pct-encoded   = "%" HEXDIG HEXDIG
	 * attr-char     = ALPHA / DIGIT
	 *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
	 *               / "^" / "_" / "`" / "|" / "~"
	 * @private
	 */

	var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;

	/**
	 * RegExp for various RFC 6266 grammar
	 *
	 * disposition-type = "inline" | "attachment" | disp-ext-type
	 * disp-ext-type    = token
	 * disposition-parm = filename-parm | disp-ext-parm
	 * filename-parm    = "filename" "=" value
	 *                  | "filename*" "=" ext-value
	 * disp-ext-parm    = token "=" value
	 *                  | ext-token "=" ext-value
	 * ext-token        = <the characters in token, followed by "*">
	 * @private
	 */

	var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/; // eslint-disable-line no-control-regex

	/**
	 * Create an attachment Content-Disposition header.
	 *
	 * @param {string} [filename]
	 * @param {object} [options]
	 * @param {string} [options.type=attachment]
	 * @param {string|boolean} [options.fallback=true]
	 * @return {string}
	 * @public
	 */

	function contentDisposition$1 (filename, options) {
	  var opts = options || {};

	  // get type
	  var type = opts.type || 'attachment';

	  // get parameters
	  var params = createparams(filename, opts.fallback);

	  // format into string
	  return format(new ContentDisposition(type, params))
	}

	/**
	 * Create parameters object from filename and fallback.
	 *
	 * @param {string} [filename]
	 * @param {string|boolean} [fallback=true]
	 * @return {object}
	 * @private
	 */

	function createparams (filename, fallback) {
	  if (filename === undefined) {
	    return
	  }

	  var params = {};

	  if (typeof filename !== 'string') {
	    throw new TypeError('filename must be a string')
	  }

	  // fallback defaults to true
	  if (fallback === undefined) {
	    fallback = true;
	  }

	  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
	    throw new TypeError('fallback must be a string or boolean')
	  }

	  if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {
	    throw new TypeError('fallback must be ISO-8859-1 string')
	  }

	  // restrict to file base name
	  var name = basename(filename);

	  // determine if name is suitable for quoted string
	  var isQuotedString = TEXT_REGEXP.test(name);

	  // generate fallback name
	  var fallbackName = typeof fallback !== 'string'
	    ? fallback && getlatin1(name)
	    : basename(fallback);
	  var hasFallback = typeof fallbackName === 'string' && fallbackName !== name;

	  // set extended filename parameter
	  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
	    params['filename*'] = name;
	  }

	  // set filename parameter
	  if (isQuotedString || hasFallback) {
	    params.filename = hasFallback
	      ? fallbackName
	      : name;
	  }

	  return params
	}

	/**
	 * Format object to Content-Disposition header.
	 *
	 * @param {object} obj
	 * @param {string} obj.type
	 * @param {object} [obj.parameters]
	 * @return {string}
	 * @private
	 */

	function format (obj) {
	  var parameters = obj.parameters;
	  var type = obj.type;

	  if (!type || typeof type !== 'string' || !TOKEN_REGEXP.test(type)) {
	    throw new TypeError('invalid type')
	  }

	  // start with normalized type
	  var string = String(type).toLowerCase();

	  // append parameters
	  if (parameters && typeof parameters === 'object') {
	    var param;
	    var params = Object.keys(parameters).sort();

	    for (var i = 0; i < params.length; i++) {
	      param = params[i];

	      var val = param.substr(-1) === '*'
	        ? ustring(parameters[param])
	        : qstring(parameters[param]);

	      string += '; ' + param + '=' + val;
	    }
	  }

	  return string
	}

	/**
	 * Decode a RFC 5987 field value (gracefully).
	 *
	 * @param {string} str
	 * @return {string}
	 * @private
	 */

	function decodefield (str) {
	  var match = EXT_VALUE_REGEXP.exec(str);

	  if (!match) {
	    throw new TypeError('invalid extended field value')
	  }

	  var charset = match[1].toLowerCase();
	  var encoded = match[2];
	  var value;

	  // to binary string
	  var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);

	  switch (charset) {
	    case 'iso-8859-1':
	      value = getlatin1(binary);
	      break
	    case 'utf-8':
	      value = Buffer.from(binary, 'binary').toString('utf8');
	      break
	    default:
	      throw new TypeError('unsupported charset in extended field')
	  }

	  return value
	}

	/**
	 * Get ISO-8859-1 version of string.
	 *
	 * @param {string} val
	 * @return {string}
	 * @private
	 */

	function getlatin1 (val) {
	  // simple Unicode -> ISO-8859-1 transformation
	  return String(val).replace(NON_LATIN1_REGEXP, '?')
	}

	/**
	 * Parse Content-Disposition header string.
	 *
	 * @param {string} string
	 * @return {object}
	 * @public
	 */

	function parse (string) {
	  if (!string || typeof string !== 'string') {
	    throw new TypeError('argument string is required')
	  }

	  var match = DISPOSITION_TYPE_REGEXP.exec(string);

	  if (!match) {
	    throw new TypeError('invalid type format')
	  }

	  // normalize type
	  var index = match[0].length;
	  var type = match[1].toLowerCase();

	  var key;
	  var names = [];
	  var params = {};
	  var value;

	  // calculate index to start at
	  index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ';'
	    ? index - 1
	    : index;

	  // match parameters
	  while ((match = PARAM_REGEXP.exec(string))) {
	    if (match.index !== index) {
	      throw new TypeError('invalid parameter format')
	    }

	    index += match[0].length;
	    key = match[1].toLowerCase();
	    value = match[2];

	    if (names.indexOf(key) !== -1) {
	      throw new TypeError('invalid duplicate parameter')
	    }

	    names.push(key);

	    if (key.indexOf('*') + 1 === key.length) {
	      // decode extended value
	      key = key.slice(0, -1);
	      value = decodefield(value);

	      // overwrite existing value
	      params[key] = value;
	      continue
	    }

	    if (typeof params[key] === 'string') {
	      continue
	    }

	    if (value[0] === '"') {
	      // remove quotes and escapes
	      value = value
	        .substr(1, value.length - 2)
	        .replace(QESC_REGEXP, '$1');
	    }

	    params[key] = value;
	  }

	  if (index !== -1 && index !== string.length) {
	    throw new TypeError('invalid parameter format')
	  }

	  return new ContentDisposition(type, params)
	}

	/**
	 * Percent decode a single character.
	 *
	 * @param {string} str
	 * @param {string} hex
	 * @return {string}
	 * @private
	 */

	function pdecode (str, hex) {
	  return String.fromCharCode(parseInt(hex, 16))
	}

	/**
	 * Percent encode a single character.
	 *
	 * @param {string} char
	 * @return {string}
	 * @private
	 */

	function pencode (char) {
	  return '%' + String(char)
	    .charCodeAt(0)
	    .toString(16)
	    .toUpperCase()
	}

	/**
	 * Quote a string for HTTP.
	 *
	 * @param {string} val
	 * @return {string}
	 * @private
	 */

	function qstring (val) {
	  var str = String(val);

	  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"'
	}

	/**
	 * Encode a Unicode string for HTTP (RFC 5987).
	 *
	 * @param {string} val
	 * @return {string}
	 * @private
	 */

	function ustring (val) {
	  var str = String(val);

	  // percent encode as UTF-8
	  var encoded = encodeURIComponent(str)
	    .replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);

	  return 'UTF-8\'\'' + encoded
	}

	/**
	 * Class for parsed Content-Disposition header for v8 optimization
	 *
	 * @public
	 * @param {string} type
	 * @param {object} parameters
	 * @constructor
	 */

	function ContentDisposition (type, parameters) {
	  this.type = type;
	  this.parameters = parameters;
	}
	return contentDisposition.exports;
}

var send = {exports: {}};

/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */

var encodeurl;
var hasRequiredEncodeurl;

function requireEncodeurl () {
	if (hasRequiredEncodeurl) return encodeurl;
	hasRequiredEncodeurl = 1;

	/**
	 * Module exports.
	 * @public
	 */

	encodeurl = encodeUrl;

	/**
	 * RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
	 * and including invalid escape sequences.
	 * @private
	 */

	var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;

	/**
	 * RegExp to match unmatched surrogate pair.
	 * @private
	 */

	var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;

	/**
	 * String to replace unmatched surrogate pair with.
	 * @private
	 */

	var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2';

	/**
	 * Encode a URL to a percent-encoded form, excluding already-encoded sequences.
	 *
	 * This function will take an already-encoded URL and encode all the non-URL
	 * code points. This function will not encode the "%" character unless it is
	 * not part of a valid sequence (`%20` will be left as-is, but `%foo` will
	 * be encoded as `%25foo`).
	 *
	 * This encode is meant to be "safe" and does not throw errors. It will try as
	 * hard as it can to properly encode the given URL, including replacing any raw,
	 * unpaired surrogate pairs with the Unicode replacement character prior to
	 * encoding.
	 *
	 * @param {string} url
	 * @return {string}
	 * @public
	 */

	function encodeUrl (url) {
	  return String(url)
	    .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
	    .replace(ENCODE_CHARS_REGEXP, encodeURI)
	}
	return encodeurl;
}

/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */

var etag_1;
var hasRequiredEtag;

function requireEtag () {
	if (hasRequiredEtag) return etag_1;
	hasRequiredEtag = 1;

	/**
	 * Module exports.
	 * @public
	 */

	etag_1 = etag;

	/**
	 * Module dependencies.
	 * @private
	 */

	var crypto = require$$0$c;
	var Stats = fs.Stats;

	/**
	 * Module variables.
	 * @private
	 */

	var toString = Object.prototype.toString;

	/**
	 * Generate an entity tag.
	 *
	 * @param {Buffer|string} entity
	 * @return {string}
	 * @private
	 */

	function entitytag (entity) {
	  if (entity.length === 0) {
	    // fast-path empty
	    return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"'
	  }

	  // compute hash of entity
	  var hash = crypto
	    .createHash('sha1')
	    .update(entity, 'utf8')
	    .digest('base64')
	    .substring(0, 27);

	  // compute length of entity
	  var len = typeof entity === 'string'
	    ? Buffer.byteLength(entity, 'utf8')
	    : entity.length;

	  return '"' + len.toString(16) + '-' + hash + '"'
	}

	/**
	 * Create a simple ETag.
	 *
	 * @param {string|Buffer|Stats} entity
	 * @param {object} [options]
	 * @param {boolean} [options.weak]
	 * @return {String}
	 * @public
	 */

	function etag (entity, options) {
	  if (entity == null) {
	    throw new TypeError('argument entity is required')
	  }

	  // support fs.Stats object
	  var isStats = isstats(entity);
	  var weak = options && typeof options.weak === 'boolean'
	    ? options.weak
	    : isStats;

	  // validate argument
	  if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {
	    throw new TypeError('argument entity must be string, Buffer, or fs.Stats')
	  }

	  // generate entity tag
	  var tag = isStats
	    ? stattag(entity)
	    : entitytag(entity);

	  return weak
	    ? 'W/' + tag
	    : tag
	}

	/**
	 * Determine if object is a Stats object.
	 *
	 * @param {object} obj
	 * @return {boolean}
	 * @api private
	 */

	function isstats (obj) {
	  // genuine fs.Stats
	  if (typeof Stats === 'function' && obj instanceof Stats) {
	    return true
	  }

	  // quack quack
	  return obj && typeof obj === 'object' &&
	    'ctime' in obj && toString.call(obj.ctime) === '[object Date]' &&
	    'mtime' in obj && toString.call(obj.mtime) === '[object Date]' &&
	    'ino' in obj && typeof obj.ino === 'number' &&
	    'size' in obj && typeof obj.size === 'number'
	}

	/**
	 * Generate a tag for a stat.
	 *
	 * @param {object} stat
	 * @return {string}
	 * @private
	 */

	function stattag (stat) {
	  var mtime = stat.mtime.getTime().toString(16);
	  var size = stat.size.toString(16);

	  return '"' + size + '-' + mtime + '"'
	}
	return etag_1;
}

/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

var fresh_1;
var hasRequiredFresh;

function requireFresh () {
	if (hasRequiredFresh) return fresh_1;
	hasRequiredFresh = 1;

	/**
	 * RegExp to check for no-cache token in Cache-Control.
	 * @private
	 */

	var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;

	/**
	 * Module exports.
	 * @public
	 */

	fresh_1 = fresh;

	/**
	 * Check freshness of the response using request and response headers.
	 *
	 * @param {Object} reqHeaders
	 * @param {Object} resHeaders
	 * @return {Boolean}
	 * @public
	 */

	function fresh (reqHeaders, resHeaders) {
	  // fields
	  var modifiedSince = reqHeaders['if-modified-since'];
	  var noneMatch = reqHeaders['if-none-match'];

	  // unconditional request
	  if (!modifiedSince && !noneMatch) {
	    return false
	  }

	  // Always return stale when Cache-Control: no-cache
	  // to support end-to-end reload requests
	  // https://tools.ietf.org/html/rfc2616#section-14.9.4
	  var cacheControl = reqHeaders['cache-control'];
	  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
	    return false
	  }

	  // if-none-match
	  if (noneMatch && noneMatch !== '*') {
	    var etag = resHeaders['etag'];

	    if (!etag) {
	      return false
	    }

	    var etagStale = true;
	    var matches = parseTokenList(noneMatch);
	    for (var i = 0; i < matches.length; i++) {
	      var match = matches[i];
	      if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {
	        etagStale = false;
	        break
	      }
	    }

	    if (etagStale) {
	      return false
	    }
	  }

	  // if-modified-since
	  if (modifiedSince) {
	    var lastModified = resHeaders['last-modified'];
	    var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));

	    if (modifiedStale) {
	      return false
	    }
	  }

	  return true
	}

	/**
	 * Parse an HTTP Date into a number.
	 *
	 * @param {string} date
	 * @private
	 */

	function parseHttpDate (date) {
	  var timestamp = date && Date.parse(date);

	  // istanbul ignore next: guard against date.js Date.parse patching
	  return typeof timestamp === 'number'
	    ? timestamp
	    : NaN
	}

	/**
	 * Parse a HTTP token list.
	 *
	 * @param {string} str
	 * @private
	 */

	function parseTokenList (str) {
	  var end = 0;
	  var list = [];
	  var start = 0;

	  // gather tokens
	  for (var i = 0, len = str.length; i < len; i++) {
	    switch (str.charCodeAt(i)) {
	      case 0x20: /*   */
	        if (start === end) {
	          start = end = i + 1;
	        }
	        break
	      case 0x2c: /* , */
	        list.push(str.substring(start, end));
	        start = end = i + 1;
	        break
	      default:
	        end = i + 1;
	        break
	    }
	  }

	  // final token
	  list.push(str.substring(start, end));

	  return list
	}
	return fresh_1;
}

var require$$2$1 = {
	"application/andrew-inset": [
	"ez"
],
	"application/applixware": [
	"aw"
],
	"application/atom+xml": [
	"atom"
],
	"application/atomcat+xml": [
	"atomcat"
],
	"application/atomsvc+xml": [
	"atomsvc"
],
	"application/bdoc": [
	"bdoc"
],
	"application/ccxml+xml": [
	"ccxml"
],
	"application/cdmi-capability": [
	"cdmia"
],
	"application/cdmi-container": [
	"cdmic"
],
	"application/cdmi-domain": [
	"cdmid"
],
	"application/cdmi-object": [
	"cdmio"
],
	"application/cdmi-queue": [
	"cdmiq"
],
	"application/cu-seeme": [
	"cu"
],
	"application/dash+xml": [
	"mpd"
],
	"application/davmount+xml": [
	"davmount"
],
	"application/docbook+xml": [
	"dbk"
],
	"application/dssc+der": [
	"dssc"
],
	"application/dssc+xml": [
	"xdssc"
],
	"application/ecmascript": [
	"ecma"
],
	"application/emma+xml": [
	"emma"
],
	"application/epub+zip": [
	"epub"
],
	"application/exi": [
	"exi"
],
	"application/font-tdpfr": [
	"pfr"
],
	"application/font-woff": [
],
	"application/font-woff2": [
],
	"application/geo+json": [
	"geojson"
],
	"application/gml+xml": [
	"gml"
],
	"application/gpx+xml": [
	"gpx"
],
	"application/gxf": [
	"gxf"
],
	"application/gzip": [
	"gz"
],
	"application/hyperstudio": [
	"stk"
],
	"application/inkml+xml": [
	"ink",
	"inkml"
],
	"application/ipfix": [
	"ipfix"
],
	"application/java-archive": [
	"jar",
	"war",
	"ear"
],
	"application/java-serialized-object": [
	"ser"
],
	"application/java-vm": [
	"class"
],
	"application/javascript": [
	"js",
	"mjs"
],
	"application/json": [
	"json",
	"map"
],
	"application/json5": [
	"json5"
],
	"application/jsonml+json": [
	"jsonml"
],
	"application/ld+json": [
	"jsonld"
],
	"application/lost+xml": [
	"lostxml"
],
	"application/mac-binhex40": [
	"hqx"
],
	"application/mac-compactpro": [
	"cpt"
],
	"application/mads+xml": [
	"mads"
],
	"application/manifest+json": [
	"webmanifest"
],
	"application/marc": [
	"mrc"
],
	"application/marcxml+xml": [
	"mrcx"
],
	"application/mathematica": [
	"ma",
	"nb",
	"mb"
],
	"application/mathml+xml": [
	"mathml"
],
	"application/mbox": [
	"mbox"
],
	"application/mediaservercontrol+xml": [
	"mscml"
],
	"application/metalink+xml": [
	"metalink"
],
	"application/metalink4+xml": [
	"meta4"
],
	"application/mets+xml": [
	"mets"
],
	"application/mods+xml": [
	"mods"
],
	"application/mp21": [
	"m21",
	"mp21"
],
	"application/mp4": [
	"mp4s",
	"m4p"
],
	"application/msword": [
	"doc",
	"dot"
],
	"application/mxf": [
	"mxf"
],
	"application/octet-stream": [
	"bin",
	"dms",
	"lrf",
	"mar",
	"so",
	"dist",
	"distz",
	"pkg",
	"bpk",
	"dump",
	"elc",
	"deploy",
	"exe",
	"dll",
	"deb",
	"dmg",
	"iso",
	"img",
	"msi",
	"msp",
	"msm",
	"buffer"
],
	"application/oda": [
	"oda"
],
	"application/oebps-package+xml": [
	"opf"
],
	"application/ogg": [
	"ogx"
],
	"application/omdoc+xml": [
	"omdoc"
],
	"application/onenote": [
	"onetoc",
	"onetoc2",
	"onetmp",
	"onepkg"
],
	"application/oxps": [
	"oxps"
],
	"application/patch-ops-error+xml": [
	"xer"
],
	"application/pdf": [
	"pdf"
],
	"application/pgp-encrypted": [
	"pgp"
],
	"application/pgp-signature": [
	"asc",
	"sig"
],
	"application/pics-rules": [
	"prf"
],
	"application/pkcs10": [
	"p10"
],
	"application/pkcs7-mime": [
	"p7m",
	"p7c"
],
	"application/pkcs7-signature": [
	"p7s"
],
	"application/pkcs8": [
	"p8"
],
	"application/pkix-attr-cert": [
	"ac"
],
	"application/pkix-cert": [
	"cer"
],
	"application/pkix-crl": [
	"crl"
],
	"application/pkix-pkipath": [
	"pkipath"
],
	"application/pkixcmp": [
	"pki"
],
	"application/pls+xml": [
	"pls"
],
	"application/postscript": [
	"ai",
	"eps",
	"ps"
],
	"application/prs.cww": [
	"cww"
],
	"application/pskc+xml": [
	"pskcxml"
],
	"application/raml+yaml": [
	"raml"
],
	"application/rdf+xml": [
	"rdf"
],
	"application/reginfo+xml": [
	"rif"
],
	"application/relax-ng-compact-syntax": [
	"rnc"
],
	"application/resource-lists+xml": [
	"rl"
],
	"application/resource-lists-diff+xml": [
	"rld"
],
	"application/rls-services+xml": [
	"rs"
],
	"application/rpki-ghostbusters": [
	"gbr"
],
	"application/rpki-manifest": [
	"mft"
],
	"application/rpki-roa": [
	"roa"
],
	"application/rsd+xml": [
	"rsd"
],
	"application/rss+xml": [
	"rss"
],
	"application/rtf": [
	"rtf"
],
	"application/sbml+xml": [
	"sbml"
],
	"application/scvp-cv-request": [
	"scq"
],
	"application/scvp-cv-response": [
	"scs"
],
	"application/scvp-vp-request": [
	"spq"
],
	"application/scvp-vp-response": [
	"spp"
],
	"application/sdp": [
	"sdp"
],
	"application/set-payment-initiation": [
	"setpay"
],
	"application/set-registration-initiation": [
	"setreg"
],
	"application/shf+xml": [
	"shf"
],
	"application/smil+xml": [
	"smi",
	"smil"
],
	"application/sparql-query": [
	"rq"
],
	"application/sparql-results+xml": [
	"srx"
],
	"application/srgs": [
	"gram"
],
	"application/srgs+xml": [
	"grxml"
],
	"application/sru+xml": [
	"sru"
],
	"application/ssdl+xml": [
	"ssdl"
],
	"application/ssml+xml": [
	"ssml"
],
	"application/tei+xml": [
	"tei",
	"teicorpus"
],
	"application/thraud+xml": [
	"tfi"
],
	"application/timestamped-data": [
	"tsd"
],
	"application/vnd.3gpp.pic-bw-large": [
	"plb"
],
	"application/vnd.3gpp.pic-bw-small": [
	"psb"
],
	"application/vnd.3gpp.pic-bw-var": [
	"pvb"
],
	"application/vnd.3gpp2.tcap": [
	"tcap"
],
	"application/vnd.3m.post-it-notes": [
	"pwn"
],
	"application/vnd.accpac.simply.aso": [
	"aso"
],
	"application/vnd.accpac.simply.imp": [
	"imp"
],
	"application/vnd.acucobol": [
	"acu"
],
	"application/vnd.acucorp": [
	"atc",
	"acutc"
],
	"application/vnd.adobe.air-application-installer-package+zip": [
	"air"
],
	"application/vnd.adobe.formscentral.fcdt": [
	"fcdt"
],
	"application/vnd.adobe.fxp": [
	"fxp",
	"fxpl"
],
	"application/vnd.adobe.xdp+xml": [
	"xdp"
],
	"application/vnd.adobe.xfdf": [
	"xfdf"
],
	"application/vnd.ahead.space": [
	"ahead"
],
	"application/vnd.airzip.filesecure.azf": [
	"azf"
],
	"application/vnd.airzip.filesecure.azs": [
	"azs"
],
	"application/vnd.amazon.ebook": [
	"azw"
],
	"application/vnd.americandynamics.acc": [
	"acc"
],
	"application/vnd.amiga.ami": [
	"ami"
],
	"application/vnd.android.package-archive": [
	"apk"
],
	"application/vnd.anser-web-certificate-issue-initiation": [
	"cii"
],
	"application/vnd.anser-web-funds-transfer-initiation": [
	"fti"
],
	"application/vnd.antix.game-component": [
	"atx"
],
	"application/vnd.apple.installer+xml": [
	"mpkg"
],
	"application/vnd.apple.mpegurl": [
	"m3u8"
],
	"application/vnd.apple.pkpass": [
	"pkpass"
],
	"application/vnd.aristanetworks.swi": [
	"swi"
],
	"application/vnd.astraea-software.iota": [
	"iota"
],
	"application/vnd.audiograph": [
	"aep"
],
	"application/vnd.blueice.multipass": [
	"mpm"
],
	"application/vnd.bmi": [
	"bmi"
],
	"application/vnd.businessobjects": [
	"rep"
],
	"application/vnd.chemdraw+xml": [
	"cdxml"
],
	"application/vnd.chipnuts.karaoke-mmd": [
	"mmd"
],
	"application/vnd.cinderella": [
	"cdy"
],
	"application/vnd.claymore": [
	"cla"
],
	"application/vnd.cloanto.rp9": [
	"rp9"
],
	"application/vnd.clonk.c4group": [
	"c4g",
	"c4d",
	"c4f",
	"c4p",
	"c4u"
],
	"application/vnd.cluetrust.cartomobile-config": [
	"c11amc"
],
	"application/vnd.cluetrust.cartomobile-config-pkg": [
	"c11amz"
],
	"application/vnd.commonspace": [
	"csp"
],
	"application/vnd.contact.cmsg": [
	"cdbcmsg"
],
	"application/vnd.cosmocaller": [
	"cmc"
],
	"application/vnd.crick.clicker": [
	"clkx"
],
	"application/vnd.crick.clicker.keyboard": [
	"clkk"
],
	"application/vnd.crick.clicker.palette": [
	"clkp"
],
	"application/vnd.crick.clicker.template": [
	"clkt"
],
	"application/vnd.crick.clicker.wordbank": [
	"clkw"
],
	"application/vnd.criticaltools.wbs+xml": [
	"wbs"
],
	"application/vnd.ctc-posml": [
	"pml"
],
	"application/vnd.cups-ppd": [
	"ppd"
],
	"application/vnd.curl.car": [
	"car"
],
	"application/vnd.curl.pcurl": [
	"pcurl"
],
	"application/vnd.dart": [
	"dart"
],
	"application/vnd.data-vision.rdz": [
	"rdz"
],
	"application/vnd.dece.data": [
	"uvf",
	"uvvf",
	"uvd",
	"uvvd"
],
	"application/vnd.dece.ttml+xml": [
	"uvt",
	"uvvt"
],
	"application/vnd.dece.unspecified": [
	"uvx",
	"uvvx"
],
	"application/vnd.dece.zip": [
	"uvz",
	"uvvz"
],
	"application/vnd.denovo.fcselayout-link": [
	"fe_launch"
],
	"application/vnd.dna": [
	"dna"
],
	"application/vnd.dolby.mlp": [
	"mlp"
],
	"application/vnd.dpgraph": [
	"dpg"
],
	"application/vnd.dreamfactory": [
	"dfac"
],
	"application/vnd.ds-keypoint": [
	"kpxx"
],
	"application/vnd.dvb.ait": [
	"ait"
],
	"application/vnd.dvb.service": [
	"svc"
],
	"application/vnd.dynageo": [
	"geo"
],
	"application/vnd.ecowin.chart": [
	"mag"
],
	"application/vnd.enliven": [
	"nml"
],
	"application/vnd.epson.esf": [
	"esf"
],
	"application/vnd.epson.msf": [
	"msf"
],
	"application/vnd.epson.quickanime": [
	"qam"
],
	"application/vnd.epson.salt": [
	"slt"
],
	"application/vnd.epson.ssf": [
	"ssf"
],
	"application/vnd.eszigno3+xml": [
	"es3",
	"et3"
],
	"application/vnd.ezpix-album": [
	"ez2"
],
	"application/vnd.ezpix-package": [
	"ez3"
],
	"application/vnd.fdf": [
	"fdf"
],
	"application/vnd.fdsn.mseed": [
	"mseed"
],
	"application/vnd.fdsn.seed": [
	"seed",
	"dataless"
],
	"application/vnd.flographit": [
	"gph"
],
	"application/vnd.fluxtime.clip": [
	"ftc"
],
	"application/vnd.framemaker": [
	"fm",
	"frame",
	"maker",
	"book"
],
	"application/vnd.frogans.fnc": [
	"fnc"
],
	"application/vnd.frogans.ltf": [
	"ltf"
],
	"application/vnd.fsc.weblaunch": [
	"fsc"
],
	"application/vnd.fujitsu.oasys": [
	"oas"
],
	"application/vnd.fujitsu.oasys2": [
	"oa2"
],
	"application/vnd.fujitsu.oasys3": [
	"oa3"
],
	"application/vnd.fujitsu.oasysgp": [
	"fg5"
],
	"application/vnd.fujitsu.oasysprs": [
	"bh2"
],
	"application/vnd.fujixerox.ddd": [
	"ddd"
],
	"application/vnd.fujixerox.docuworks": [
	"xdw"
],
	"application/vnd.fujixerox.docuworks.binder": [
	"xbd"
],
	"application/vnd.fuzzysheet": [
	"fzs"
],
	"application/vnd.genomatix.tuxedo": [
	"txd"
],
	"application/vnd.geogebra.file": [
	"ggb"
],
	"application/vnd.geogebra.tool": [
	"ggt"
],
	"application/vnd.geometry-explorer": [
	"gex",
	"gre"
],
	"application/vnd.geonext": [
	"gxt"
],
	"application/vnd.geoplan": [
	"g2w"
],
	"application/vnd.geospace": [
	"g3w"
],
	"application/vnd.gmx": [
	"gmx"
],
	"application/vnd.google-apps.document": [
	"gdoc"
],
	"application/vnd.google-apps.presentation": [
	"gslides"
],
	"application/vnd.google-apps.spreadsheet": [
	"gsheet"
],
	"application/vnd.google-earth.kml+xml": [
	"kml"
],
	"application/vnd.google-earth.kmz": [
	"kmz"
],
	"application/vnd.grafeq": [
	"gqf",
	"gqs"
],
	"application/vnd.groove-account": [
	"gac"
],
	"application/vnd.groove-help": [
	"ghf"
],
	"application/vnd.groove-identity-message": [
	"gim"
],
	"application/vnd.groove-injector": [
	"grv"
],
	"application/vnd.groove-tool-message": [
	"gtm"
],
	"application/vnd.groove-tool-template": [
	"tpl"
],
	"application/vnd.groove-vcard": [
	"vcg"
],
	"application/vnd.hal+xml": [
	"hal"
],
	"application/vnd.handheld-entertainment+xml": [
	"zmm"
],
	"application/vnd.hbci": [
	"hbci"
],
	"application/vnd.hhe.lesson-player": [
	"les"
],
	"application/vnd.hp-hpgl": [
	"hpgl"
],
	"application/vnd.hp-hpid": [
	"hpid"
],
	"application/vnd.hp-hps": [
	"hps"
],
	"application/vnd.hp-jlyt": [
	"jlt"
],
	"application/vnd.hp-pcl": [
	"pcl"
],
	"application/vnd.hp-pclxl": [
	"pclxl"
],
	"application/vnd.hydrostatix.sof-data": [
	"sfd-hdstx"
],
	"application/vnd.ibm.minipay": [
	"mpy"
],
	"application/vnd.ibm.modcap": [
	"afp",
	"listafp",
	"list3820"
],
	"application/vnd.ibm.rights-management": [
	"irm"
],
	"application/vnd.ibm.secure-container": [
	"sc"
],
	"application/vnd.iccprofile": [
	"icc",
	"icm"
],
	"application/vnd.igloader": [
	"igl"
],
	"application/vnd.immervision-ivp": [
	"ivp"
],
	"application/vnd.immervision-ivu": [
	"ivu"
],
	"application/vnd.insors.igm": [
	"igm"
],
	"application/vnd.intercon.formnet": [
	"xpw",
	"xpx"
],
	"application/vnd.intergeo": [
	"i2g"
],
	"application/vnd.intu.qbo": [
	"qbo"
],
	"application/vnd.intu.qfx": [
	"qfx"
],
	"application/vnd.ipunplugged.rcprofile": [
	"rcprofile"
],
	"application/vnd.irepository.package+xml": [
	"irp"
],
	"application/vnd.is-xpr": [
	"xpr"
],
	"application/vnd.isac.fcs": [
	"fcs"
],
	"application/vnd.jam": [
	"jam"
],
	"application/vnd.jcp.javame.midlet-rms": [
	"rms"
],
	"application/vnd.jisp": [
	"jisp"
],
	"application/vnd.joost.joda-archive": [
	"joda"
],
	"application/vnd.kahootz": [
	"ktz",
	"ktr"
],
	"application/vnd.kde.karbon": [
	"karbon"
],
	"application/vnd.kde.kchart": [
	"chrt"
],
	"application/vnd.kde.kformula": [
	"kfo"
],
	"application/vnd.kde.kivio": [
	"flw"
],
	"application/vnd.kde.kontour": [
	"kon"
],
	"application/vnd.kde.kpresenter": [
	"kpr",
	"kpt"
],
	"application/vnd.kde.kspread": [
	"ksp"
],
	"application/vnd.kde.kword": [
	"kwd",
	"kwt"
],
	"application/vnd.kenameaapp": [
	"htke"
],
	"application/vnd.kidspiration": [
	"kia"
],
	"application/vnd.kinar": [
	"kne",
	"knp"
],
	"application/vnd.koan": [
	"skp",
	"skd",
	"skt",
	"skm"
],
	"application/vnd.kodak-descriptor": [
	"sse"
],
	"application/vnd.las.las+xml": [
	"lasxml"
],
	"application/vnd.llamagraphics.life-balance.desktop": [
	"lbd"
],
	"application/vnd.llamagraphics.life-balance.exchange+xml": [
	"lbe"
],
	"application/vnd.lotus-1-2-3": [
	"123"
],
	"application/vnd.lotus-approach": [
	"apr"
],
	"application/vnd.lotus-freelance": [
	"pre"
],
	"application/vnd.lotus-notes": [
	"nsf"
],
	"application/vnd.lotus-organizer": [
	"org"
],
	"application/vnd.lotus-screencam": [
	"scm"
],
	"application/vnd.lotus-wordpro": [
	"lwp"
],
	"application/vnd.macports.portpkg": [
	"portpkg"
],
	"application/vnd.mcd": [
	"mcd"
],
	"application/vnd.medcalcdata": [
	"mc1"
],
	"application/vnd.mediastation.cdkey": [
	"cdkey"
],
	"application/vnd.mfer": [
	"mwf"
],
	"application/vnd.mfmp": [
	"mfm"
],
	"application/vnd.micrografx.flo": [
	"flo"
],
	"application/vnd.micrografx.igx": [
	"igx"
],
	"application/vnd.mif": [
	"mif"
],
	"application/vnd.mobius.daf": [
	"daf"
],
	"application/vnd.mobius.dis": [
	"dis"
],
	"application/vnd.mobius.mbk": [
	"mbk"
],
	"application/vnd.mobius.mqy": [
	"mqy"
],
	"application/vnd.mobius.msl": [
	"msl"
],
	"application/vnd.mobius.plc": [
	"plc"
],
	"application/vnd.mobius.txf": [
	"txf"
],
	"application/vnd.mophun.application": [
	"mpn"
],
	"application/vnd.mophun.certificate": [
	"mpc"
],
	"application/vnd.mozilla.xul+xml": [
	"xul"
],
	"application/vnd.ms-artgalry": [
	"cil"
],
	"application/vnd.ms-cab-compressed": [
	"cab"
],
	"application/vnd.ms-excel": [
	"xls",
	"xlm",
	"xla",
	"xlc",
	"xlt",
	"xlw"
],
	"application/vnd.ms-excel.addin.macroenabled.12": [
	"xlam"
],
	"application/vnd.ms-excel.sheet.binary.macroenabled.12": [
	"xlsb"
],
	"application/vnd.ms-excel.sheet.macroenabled.12": [
	"xlsm"
],
	"application/vnd.ms-excel.template.macroenabled.12": [
	"xltm"
],
	"application/vnd.ms-fontobject": [
	"eot"
],
	"application/vnd.ms-htmlhelp": [
	"chm"
],
	"application/vnd.ms-ims": [
	"ims"
],
	"application/vnd.ms-lrm": [
	"lrm"
],
	"application/vnd.ms-officetheme": [
	"thmx"
],
	"application/vnd.ms-outlook": [
	"msg"
],
	"application/vnd.ms-pki.seccat": [
	"cat"
],
	"application/vnd.ms-pki.stl": [
	"stl"
],
	"application/vnd.ms-powerpoint": [
	"ppt",
	"pps",
	"pot"
],
	"application/vnd.ms-powerpoint.addin.macroenabled.12": [
	"ppam"
],
	"application/vnd.ms-powerpoint.presentation.macroenabled.12": [
	"pptm"
],
	"application/vnd.ms-powerpoint.slide.macroenabled.12": [
	"sldm"
],
	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": [
	"ppsm"
],
	"application/vnd.ms-powerpoint.template.macroenabled.12": [
	"potm"
],
	"application/vnd.ms-project": [
	"mpp",
	"mpt"
],
	"application/vnd.ms-word.document.macroenabled.12": [
	"docm"
],
	"application/vnd.ms-word.template.macroenabled.12": [
	"dotm"
],
	"application/vnd.ms-works": [
	"wps",
	"wks",
	"wcm",
	"wdb"
],
	"application/vnd.ms-wpl": [
	"wpl"
],
	"application/vnd.ms-xpsdocument": [
	"xps"
],
	"application/vnd.mseq": [
	"mseq"
],
	"application/vnd.musician": [
	"mus"
],
	"application/vnd.muvee.style": [
	"msty"
],
	"application/vnd.mynfc": [
	"taglet"
],
	"application/vnd.neurolanguage.nlu": [
	"nlu"
],
	"application/vnd.nitf": [
	"ntf",
	"nitf"
],
	"application/vnd.noblenet-directory": [
	"nnd"
],
	"application/vnd.noblenet-sealer": [
	"nns"
],
	"application/vnd.noblenet-web": [
	"nnw"
],
	"application/vnd.nokia.n-gage.data": [
	"ngdat"
],
	"application/vnd.nokia.n-gage.symbian.install": [
	"n-gage"
],
	"application/vnd.nokia.radio-preset": [
	"rpst"
],
	"application/vnd.nokia.radio-presets": [
	"rpss"
],
	"application/vnd.novadigm.edm": [
	"edm"
],
	"application/vnd.novadigm.edx": [
	"edx"
],
	"application/vnd.novadigm.ext": [
	"ext"
],
	"application/vnd.oasis.opendocument.chart": [
	"odc"
],
	"application/vnd.oasis.opendocument.chart-template": [
	"otc"
],
	"application/vnd.oasis.opendocument.database": [
	"odb"
],
	"application/vnd.oasis.opendocument.formula": [
	"odf"
],
	"application/vnd.oasis.opendocument.formula-template": [
	"odft"
],
	"application/vnd.oasis.opendocument.graphics": [
	"odg"
],
	"application/vnd.oasis.opendocument.graphics-template": [
	"otg"
],
	"application/vnd.oasis.opendocument.image": [
	"odi"
],
	"application/vnd.oasis.opendocument.image-template": [
	"oti"
],
	"application/vnd.oasis.opendocument.presentation": [
	"odp"
],
	"application/vnd.oasis.opendocument.presentation-template": [
	"otp"
],
	"application/vnd.oasis.opendocument.spreadsheet": [
	"ods"
],
	"application/vnd.oasis.opendocument.spreadsheet-template": [
	"ots"
],
	"application/vnd.oasis.opendocument.text": [
	"odt"
],
	"application/vnd.oasis.opendocument.text-master": [
	"odm"
],
	"application/vnd.oasis.opendocument.text-template": [
	"ott"
],
	"application/vnd.oasis.opendocument.text-web": [
	"oth"
],
	"application/vnd.olpc-sugar": [
	"xo"
],
	"application/vnd.oma.dd2+xml": [
	"dd2"
],
	"application/vnd.openofficeorg.extension": [
	"oxt"
],
	"application/vnd.openxmlformats-officedocument.presentationml.presentation": [
	"pptx"
],
	"application/vnd.openxmlformats-officedocument.presentationml.slide": [
	"sldx"
],
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": [
	"ppsx"
],
	"application/vnd.openxmlformats-officedocument.presentationml.template": [
	"potx"
],
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": [
	"xlsx"
],
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": [
	"xltx"
],
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": [
	"docx"
],
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": [
	"dotx"
],
	"application/vnd.osgeo.mapguide.package": [
	"mgp"
],
	"application/vnd.osgi.dp": [
	"dp"
],
	"application/vnd.osgi.subsystem": [
	"esa"
],
	"application/vnd.palm": [
	"pdb",
	"pqa",
	"oprc"
],
	"application/vnd.pawaafile": [
	"paw"
],
	"application/vnd.pg.format": [
	"str"
],
	"application/vnd.pg.osasli": [
	"ei6"
],
	"application/vnd.picsel": [
	"efif"
],
	"application/vnd.pmi.widget": [
	"wg"
],
	"application/vnd.pocketlearn": [
	"plf"
],
	"application/vnd.powerbuilder6": [
	"pbd"
],
	"application/vnd.previewsystems.box": [
	"box"
],
	"application/vnd.proteus.magazine": [
	"mgz"
],
	"application/vnd.publishare-delta-tree": [
	"qps"
],
	"application/vnd.pvi.ptid1": [
	"ptid"
],
	"application/vnd.quark.quarkxpress": [
	"qxd",
	"qxt",
	"qwd",
	"qwt",
	"qxl",
	"qxb"
],
	"application/vnd.realvnc.bed": [
	"bed"
],
	"application/vnd.recordare.musicxml": [
	"mxl"
],
	"application/vnd.recordare.musicxml+xml": [
	"musicxml"
],
	"application/vnd.rig.cryptonote": [
	"cryptonote"
],
	"application/vnd.rim.cod": [
	"cod"
],
	"application/vnd.rn-realmedia": [
	"rm"
],
	"application/vnd.rn-realmedia-vbr": [
	"rmvb"
],
	"application/vnd.route66.link66+xml": [
	"link66"
],
	"application/vnd.sailingtracker.track": [
	"st"
],
	"application/vnd.seemail": [
	"see"
],
	"application/vnd.sema": [
	"sema"
],
	"application/vnd.semd": [
	"semd"
],
	"application/vnd.semf": [
	"semf"
],
	"application/vnd.shana.informed.formdata": [
	"ifm"
],
	"application/vnd.shana.informed.formtemplate": [
	"itp"
],
	"application/vnd.shana.informed.interchange": [
	"iif"
],
	"application/vnd.shana.informed.package": [
	"ipk"
],
	"application/vnd.simtech-mindmapper": [
	"twd",
	"twds"
],
	"application/vnd.smaf": [
	"mmf"
],
	"application/vnd.smart.teacher": [
	"teacher"
],
	"application/vnd.solent.sdkm+xml": [
	"sdkm",
	"sdkd"
],
	"application/vnd.spotfire.dxp": [
	"dxp"
],
	"application/vnd.spotfire.sfs": [
	"sfs"
],
	"application/vnd.stardivision.calc": [
	"sdc"
],
	"application/vnd.stardivision.draw": [
	"sda"
],
	"application/vnd.stardivision.impress": [
	"sdd"
],
	"application/vnd.stardivision.math": [
	"smf"
],
	"application/vnd.stardivision.writer": [
	"sdw",
	"vor"
],
	"application/vnd.stardivision.writer-global": [
	"sgl"
],
	"application/vnd.stepmania.package": [
	"smzip"
],
	"application/vnd.stepmania.stepchart": [
	"sm"
],
	"application/vnd.sun.wadl+xml": [
	"wadl"
],
	"application/vnd.sun.xml.calc": [
	"sxc"
],
	"application/vnd.sun.xml.calc.template": [
	"stc"
],
	"application/vnd.sun.xml.draw": [
	"sxd"
],
	"application/vnd.sun.xml.draw.template": [
	"std"
],
	"application/vnd.sun.xml.impress": [
	"sxi"
],
	"application/vnd.sun.xml.impress.template": [
	"sti"
],
	"application/vnd.sun.xml.math": [
	"sxm"
],
	"application/vnd.sun.xml.writer": [
	"sxw"
],
	"application/vnd.sun.xml.writer.global": [
	"sxg"
],
	"application/vnd.sun.xml.writer.template": [
	"stw"
],
	"application/vnd.sus-calendar": [
	"sus",
	"susp"
],
	"application/vnd.svd": [
	"svd"
],
	"application/vnd.symbian.install": [
	"sis",
	"sisx"
],
	"application/vnd.syncml+xml": [
	"xsm"
],
	"application/vnd.syncml.dm+wbxml": [
	"bdm"
],
	"application/vnd.syncml.dm+xml": [
	"xdm"
],
	"application/vnd.tao.intent-module-archive": [
	"tao"
],
	"application/vnd.tcpdump.pcap": [
	"pcap",
	"cap",
	"dmp"
],
	"application/vnd.tmobile-livetv": [
	"tmo"
],
	"application/vnd.trid.tpt": [
	"tpt"
],
	"application/vnd.triscape.mxs": [
	"mxs"
],
	"application/vnd.trueapp": [
	"tra"
],
	"application/vnd.ufdl": [
	"ufd",
	"ufdl"
],
	"application/vnd.uiq.theme": [
	"utz"
],
	"application/vnd.umajin": [
	"umj"
],
	"application/vnd.unity": [
	"unityweb"
],
	"application/vnd.uoml+xml": [
	"uoml"
],
	"application/vnd.vcx": [
	"vcx"
],
	"application/vnd.visio": [
	"vsd",
	"vst",
	"vss",
	"vsw"
],
	"application/vnd.visionary": [
	"vis"
],
	"application/vnd.vsf": [
	"vsf"
],
	"application/vnd.wap.wbxml": [
	"wbxml"
],
	"application/vnd.wap.wmlc": [
	"wmlc"
],
	"application/vnd.wap.wmlscriptc": [
	"wmlsc"
],
	"application/vnd.webturbo": [
	"wtb"
],
	"application/vnd.wolfram.player": [
	"nbp"
],
	"application/vnd.wordperfect": [
	"wpd"
],
	"application/vnd.wqd": [
	"wqd"
],
	"application/vnd.wt.stf": [
	"stf"
],
	"application/vnd.xara": [
	"xar"
],
	"application/vnd.xfdl": [
	"xfdl"
],
	"application/vnd.yamaha.hv-dic": [
	"hvd"
],
	"application/vnd.yamaha.hv-script": [
	"hvs"
],
	"application/vnd.yamaha.hv-voice": [
	"hvp"
],
	"application/vnd.yamaha.openscoreformat": [
	"osf"
],
	"application/vnd.yamaha.openscoreformat.osfpvg+xml": [
	"osfpvg"
],
	"application/vnd.yamaha.smaf-audio": [
	"saf"
],
	"application/vnd.yamaha.smaf-phrase": [
	"spf"
],
	"application/vnd.yellowriver-custom-menu": [
	"cmp"
],
	"application/vnd.zul": [
	"zir",
	"zirz"
],
	"application/vnd.zzazz.deck+xml": [
	"zaz"
],
	"application/voicexml+xml": [
	"vxml"
],
	"application/wasm": [
	"wasm"
],
	"application/widget": [
	"wgt"
],
	"application/winhlp": [
	"hlp"
],
	"application/wsdl+xml": [
	"wsdl"
],
	"application/wspolicy+xml": [
	"wspolicy"
],
	"application/x-7z-compressed": [
	"7z"
],
	"application/x-abiword": [
	"abw"
],
	"application/x-ace-compressed": [
	"ace"
],
	"application/x-apple-diskimage": [
],
	"application/x-arj": [
	"arj"
],
	"application/x-authorware-bin": [
	"aab",
	"x32",
	"u32",
	"vox"
],
	"application/x-authorware-map": [
	"aam"
],
	"application/x-authorware-seg": [
	"aas"
],
	"application/x-bcpio": [
	"bcpio"
],
	"application/x-bdoc": [
],
	"application/x-bittorrent": [
	"torrent"
],
	"application/x-blorb": [
	"blb",
	"blorb"
],
	"application/x-bzip": [
	"bz"
],
	"application/x-bzip2": [
	"bz2",
	"boz"
],
	"application/x-cbr": [
	"cbr",
	"cba",
	"cbt",
	"cbz",
	"cb7"
],
	"application/x-cdlink": [
	"vcd"
],
	"application/x-cfs-compressed": [
	"cfs"
],
	"application/x-chat": [
	"chat"
],
	"application/x-chess-pgn": [
	"pgn"
],
	"application/x-chrome-extension": [
	"crx"
],
	"application/x-cocoa": [
	"cco"
],
	"application/x-conference": [
	"nsc"
],
	"application/x-cpio": [
	"cpio"
],
	"application/x-csh": [
	"csh"
],
	"application/x-debian-package": [
	"udeb"
],
	"application/x-dgc-compressed": [
	"dgc"
],
	"application/x-director": [
	"dir",
	"dcr",
	"dxr",
	"cst",
	"cct",
	"cxt",
	"w3d",
	"fgd",
	"swa"
],
	"application/x-doom": [
	"wad"
],
	"application/x-dtbncx+xml": [
	"ncx"
],
	"application/x-dtbook+xml": [
	"dtb"
],
	"application/x-dtbresource+xml": [
	"res"
],
	"application/x-dvi": [
	"dvi"
],
	"application/x-envoy": [
	"evy"
],
	"application/x-eva": [
	"eva"
],
	"application/x-font-bdf": [
	"bdf"
],
	"application/x-font-ghostscript": [
	"gsf"
],
	"application/x-font-linux-psf": [
	"psf"
],
	"application/x-font-pcf": [
	"pcf"
],
	"application/x-font-snf": [
	"snf"
],
	"application/x-font-type1": [
	"pfa",
	"pfb",
	"pfm",
	"afm"
],
	"application/x-freearc": [
	"arc"
],
	"application/x-futuresplash": [
	"spl"
],
	"application/x-gca-compressed": [
	"gca"
],
	"application/x-glulx": [
	"ulx"
],
	"application/x-gnumeric": [
	"gnumeric"
],
	"application/x-gramps-xml": [
	"gramps"
],
	"application/x-gtar": [
	"gtar"
],
	"application/x-hdf": [
	"hdf"
],
	"application/x-httpd-php": [
	"php"
],
	"application/x-install-instructions": [
	"install"
],
	"application/x-iso9660-image": [
],
	"application/x-java-archive-diff": [
	"jardiff"
],
	"application/x-java-jnlp-file": [
	"jnlp"
],
	"application/x-latex": [
	"latex"
],
	"application/x-lua-bytecode": [
	"luac"
],
	"application/x-lzh-compressed": [
	"lzh",
	"lha"
],
	"application/x-makeself": [
	"run"
],
	"application/x-mie": [
	"mie"
],
	"application/x-mobipocket-ebook": [
	"prc",
	"mobi"
],
	"application/x-ms-application": [
	"application"
],
	"application/x-ms-shortcut": [
	"lnk"
],
	"application/x-ms-wmd": [
	"wmd"
],
	"application/x-ms-wmz": [
	"wmz"
],
	"application/x-ms-xbap": [
	"xbap"
],
	"application/x-msaccess": [
	"mdb"
],
	"application/x-msbinder": [
	"obd"
],
	"application/x-mscardfile": [
	"crd"
],
	"application/x-msclip": [
	"clp"
],
	"application/x-msdos-program": [
],
	"application/x-msdownload": [
	"com",
	"bat"
],
	"application/x-msmediaview": [
	"mvb",
	"m13",
	"m14"
],
	"application/x-msmetafile": [
	"wmf",
	"emf",
	"emz"
],
	"application/x-msmoney": [
	"mny"
],
	"application/x-mspublisher": [
	"pub"
],
	"application/x-msschedule": [
	"scd"
],
	"application/x-msterminal": [
	"trm"
],
	"application/x-mswrite": [
	"wri"
],
	"application/x-netcdf": [
	"nc",
	"cdf"
],
	"application/x-ns-proxy-autoconfig": [
	"pac"
],
	"application/x-nzb": [
	"nzb"
],
	"application/x-perl": [
	"pl",
	"pm"
],
	"application/x-pilot": [
],
	"application/x-pkcs12": [
	"p12",
	"pfx"
],
	"application/x-pkcs7-certificates": [
	"p7b",
	"spc"
],
	"application/x-pkcs7-certreqresp": [
	"p7r"
],
	"application/x-rar-compressed": [
	"rar"
],
	"application/x-redhat-package-manager": [
	"rpm"
],
	"application/x-research-info-systems": [
	"ris"
],
	"application/x-sea": [
	"sea"
],
	"application/x-sh": [
	"sh"
],
	"application/x-shar": [
	"shar"
],
	"application/x-shockwave-flash": [
	"swf"
],
	"application/x-silverlight-app": [
	"xap"
],
	"application/x-sql": [
	"sql"
],
	"application/x-stuffit": [
	"sit"
],
	"application/x-stuffitx": [
	"sitx"
],
	"application/x-subrip": [
	"srt"
],
	"application/x-sv4cpio": [
	"sv4cpio"
],
	"application/x-sv4crc": [
	"sv4crc"
],
	"application/x-t3vm-image": [
	"t3"
],
	"application/x-tads": [
	"gam"
],
	"application/x-tar": [
	"tar"
],
	"application/x-tcl": [
	"tcl",
	"tk"
],
	"application/x-tex": [
	"tex"
],
	"application/x-tex-tfm": [
	"tfm"
],
	"application/x-texinfo": [
	"texinfo",
	"texi"
],
	"application/x-tgif": [
	"obj"
],
	"application/x-ustar": [
	"ustar"
],
	"application/x-virtualbox-hdd": [
	"hdd"
],
	"application/x-virtualbox-ova": [
	"ova"
],
	"application/x-virtualbox-ovf": [
	"ovf"
],
	"application/x-virtualbox-vbox": [
	"vbox"
],
	"application/x-virtualbox-vbox-extpack": [
	"vbox-extpack"
],
	"application/x-virtualbox-vdi": [
	"vdi"
],
	"application/x-virtualbox-vhd": [
	"vhd"
],
	"application/x-virtualbox-vmdk": [
	"vmdk"
],
	"application/x-wais-source": [
	"src"
],
	"application/x-web-app-manifest+json": [
	"webapp"
],
	"application/x-x509-ca-cert": [
	"der",
	"crt",
	"pem"
],
	"application/x-xfig": [
	"fig"
],
	"application/x-xliff+xml": [
	"xlf"
],
	"application/x-xpinstall": [
	"xpi"
],
	"application/x-xz": [
	"xz"
],
	"application/x-zmachine": [
	"z1",
	"z2",
	"z3",
	"z4",
	"z5",
	"z6",
	"z7",
	"z8"
],
	"application/xaml+xml": [
	"xaml"
],
	"application/xcap-diff+xml": [
	"xdf"
],
	"application/xenc+xml": [
	"xenc"
],
	"application/xhtml+xml": [
	"xhtml",
	"xht"
],
	"application/xml": [
	"xml",
	"xsl",
	"xsd",
	"rng"
],
	"application/xml-dtd": [
	"dtd"
],
	"application/xop+xml": [
	"xop"
],
	"application/xproc+xml": [
	"xpl"
],
	"application/xslt+xml": [
	"xslt"
],
	"application/xspf+xml": [
	"xspf"
],
	"application/xv+xml": [
	"mxml",
	"xhvml",
	"xvml",
	"xvm"
],
	"application/yang": [
	"yang"
],
	"application/yin+xml": [
	"yin"
],
	"application/zip": [
	"zip"
],
	"audio/3gpp": [
],
	"audio/adpcm": [
	"adp"
],
	"audio/basic": [
	"au",
	"snd"
],
	"audio/midi": [
	"mid",
	"midi",
	"kar",
	"rmi"
],
	"audio/mp3": [
],
	"audio/mp4": [
	"m4a",
	"mp4a"
],
	"audio/mpeg": [
	"mpga",
	"mp2",
	"mp2a",
	"mp3",
	"m2a",
	"m3a"
],
	"audio/ogg": [
	"oga",
	"ogg",
	"spx"
],
	"audio/s3m": [
	"s3m"
],
	"audio/silk": [
	"sil"
],
	"audio/vnd.dece.audio": [
	"uva",
	"uvva"
],
	"audio/vnd.digital-winds": [
	"eol"
],
	"audio/vnd.dra": [
	"dra"
],
	"audio/vnd.dts": [
	"dts"
],
	"audio/vnd.dts.hd": [
	"dtshd"
],
	"audio/vnd.lucent.voice": [
	"lvp"
],
	"audio/vnd.ms-playready.media.pya": [
	"pya"
],
	"audio/vnd.nuera.ecelp4800": [
	"ecelp4800"
],
	"audio/vnd.nuera.ecelp7470": [
	"ecelp7470"
],
	"audio/vnd.nuera.ecelp9600": [
	"ecelp9600"
],
	"audio/vnd.rip": [
	"rip"
],
	"audio/wav": [
	"wav"
],
	"audio/wave": [
],
	"audio/webm": [
	"weba"
],
	"audio/x-aac": [
	"aac"
],
	"audio/x-aiff": [
	"aif",
	"aiff",
	"aifc"
],
	"audio/x-caf": [
	"caf"
],
	"audio/x-flac": [
	"flac"
],
	"audio/x-m4a": [
],
	"audio/x-matroska": [
	"mka"
],
	"audio/x-mpegurl": [
	"m3u"
],
	"audio/x-ms-wax": [
	"wax"
],
	"audio/x-ms-wma": [
	"wma"
],
	"audio/x-pn-realaudio": [
	"ram",
	"ra"
],
	"audio/x-pn-realaudio-plugin": [
	"rmp"
],
	"audio/x-realaudio": [
],
	"audio/x-wav": [
],
	"audio/xm": [
	"xm"
],
	"chemical/x-cdx": [
	"cdx"
],
	"chemical/x-cif": [
	"cif"
],
	"chemical/x-cmdf": [
	"cmdf"
],
	"chemical/x-cml": [
	"cml"
],
	"chemical/x-csml": [
	"csml"
],
	"chemical/x-xyz": [
	"xyz"
],
	"font/collection": [
	"ttc"
],
	"font/otf": [
	"otf"
],
	"font/ttf": [
	"ttf"
],
	"font/woff": [
	"woff"
],
	"font/woff2": [
	"woff2"
],
	"image/apng": [
	"apng"
],
	"image/bmp": [
	"bmp"
],
	"image/cgm": [
	"cgm"
],
	"image/g3fax": [
	"g3"
],
	"image/gif": [
	"gif"
],
	"image/ief": [
	"ief"
],
	"image/jp2": [
	"jp2",
	"jpg2"
],
	"image/jpeg": [
	"jpeg",
	"jpg",
	"jpe"
],
	"image/jpm": [
	"jpm"
],
	"image/jpx": [
	"jpx",
	"jpf"
],
	"image/ktx": [
	"ktx"
],
	"image/png": [
	"png"
],
	"image/prs.btif": [
	"btif"
],
	"image/sgi": [
	"sgi"
],
	"image/svg+xml": [
	"svg",
	"svgz"
],
	"image/tiff": [
	"tiff",
	"tif"
],
	"image/vnd.adobe.photoshop": [
	"psd"
],
	"image/vnd.dece.graphic": [
	"uvi",
	"uvvi",
	"uvg",
	"uvvg"
],
	"image/vnd.djvu": [
	"djvu",
	"djv"
],
	"image/vnd.dvb.subtitle": [
],
	"image/vnd.dwg": [
	"dwg"
],
	"image/vnd.dxf": [
	"dxf"
],
	"image/vnd.fastbidsheet": [
	"fbs"
],
	"image/vnd.fpx": [
	"fpx"
],
	"image/vnd.fst": [
	"fst"
],
	"image/vnd.fujixerox.edmics-mmr": [
	"mmr"
],
	"image/vnd.fujixerox.edmics-rlc": [
	"rlc"
],
	"image/vnd.ms-modi": [
	"mdi"
],
	"image/vnd.ms-photo": [
	"wdp"
],
	"image/vnd.net-fpx": [
	"npx"
],
	"image/vnd.wap.wbmp": [
	"wbmp"
],
	"image/vnd.xiff": [
	"xif"
],
	"image/webp": [
	"webp"
],
	"image/x-3ds": [
	"3ds"
],
	"image/x-cmu-raster": [
	"ras"
],
	"image/x-cmx": [
	"cmx"
],
	"image/x-freehand": [
	"fh",
	"fhc",
	"fh4",
	"fh5",
	"fh7"
],
	"image/x-icon": [
	"ico"
],
	"image/x-jng": [
	"jng"
],
	"image/x-mrsid-image": [
	"sid"
],
	"image/x-ms-bmp": [
],
	"image/x-pcx": [
	"pcx"
],
	"image/x-pict": [
	"pic",
	"pct"
],
	"image/x-portable-anymap": [
	"pnm"
],
	"image/x-portable-bitmap": [
	"pbm"
],
	"image/x-portable-graymap": [
	"pgm"
],
	"image/x-portable-pixmap": [
	"ppm"
],
	"image/x-rgb": [
	"rgb"
],
	"image/x-tga": [
	"tga"
],
	"image/x-xbitmap": [
	"xbm"
],
	"image/x-xpixmap": [
	"xpm"
],
	"image/x-xwindowdump": [
	"xwd"
],
	"message/rfc822": [
	"eml",
	"mime"
],
	"model/gltf+json": [
	"gltf"
],
	"model/gltf-binary": [
	"glb"
],
	"model/iges": [
	"igs",
	"iges"
],
	"model/mesh": [
	"msh",
	"mesh",
	"silo"
],
	"model/vnd.collada+xml": [
	"dae"
],
	"model/vnd.dwf": [
	"dwf"
],
	"model/vnd.gdl": [
	"gdl"
],
	"model/vnd.gtw": [
	"gtw"
],
	"model/vnd.mts": [
	"mts"
],
	"model/vnd.vtu": [
	"vtu"
],
	"model/vrml": [
	"wrl",
	"vrml"
],
	"model/x3d+binary": [
	"x3db",
	"x3dbz"
],
	"model/x3d+vrml": [
	"x3dv",
	"x3dvz"
],
	"model/x3d+xml": [
	"x3d",
	"x3dz"
],
	"text/cache-manifest": [
	"appcache",
	"manifest"
],
	"text/calendar": [
	"ics",
	"ifb"
],
	"text/coffeescript": [
	"coffee",
	"litcoffee"
],
	"text/css": [
	"css"
],
	"text/csv": [
	"csv"
],
	"text/hjson": [
	"hjson"
],
	"text/html": [
	"html",
	"htm",
	"shtml"
],
	"text/jade": [
	"jade"
],
	"text/jsx": [
	"jsx"
],
	"text/less": [
	"less"
],
	"text/markdown": [
	"markdown",
	"md"
],
	"text/mathml": [
	"mml"
],
	"text/n3": [
	"n3"
],
	"text/plain": [
	"txt",
	"text",
	"conf",
	"def",
	"list",
	"log",
	"in",
	"ini"
],
	"text/prs.lines.tag": [
	"dsc"
],
	"text/richtext": [
	"rtx"
],
	"text/rtf": [
],
	"text/sgml": [
	"sgml",
	"sgm"
],
	"text/slim": [
	"slim",
	"slm"
],
	"text/stylus": [
	"stylus",
	"styl"
],
	"text/tab-separated-values": [
	"tsv"
],
	"text/troff": [
	"t",
	"tr",
	"roff",
	"man",
	"me",
	"ms"
],
	"text/turtle": [
	"ttl"
],
	"text/uri-list": [
	"uri",
	"uris",
	"urls"
],
	"text/vcard": [
	"vcard"
],
	"text/vnd.curl": [
	"curl"
],
	"text/vnd.curl.dcurl": [
	"dcurl"
],
	"text/vnd.curl.mcurl": [
	"mcurl"
],
	"text/vnd.curl.scurl": [
	"scurl"
],
	"text/vnd.dvb.subtitle": [
	"sub"
],
	"text/vnd.fly": [
	"fly"
],
	"text/vnd.fmi.flexstor": [
	"flx"
],
	"text/vnd.graphviz": [
	"gv"
],
	"text/vnd.in3d.3dml": [
	"3dml"
],
	"text/vnd.in3d.spot": [
	"spot"
],
	"text/vnd.sun.j2me.app-descriptor": [
	"jad"
],
	"text/vnd.wap.wml": [
	"wml"
],
	"text/vnd.wap.wmlscript": [
	"wmls"
],
	"text/vtt": [
	"vtt"
],
	"text/x-asm": [
	"s",
	"asm"
],
	"text/x-c": [
	"c",
	"cc",
	"cxx",
	"cpp",
	"h",
	"hh",
	"dic"
],
	"text/x-component": [
	"htc"
],
	"text/x-fortran": [
	"f",
	"for",
	"f77",
	"f90"
],
	"text/x-handlebars-template": [
	"hbs"
],
	"text/x-java-source": [
	"java"
],
	"text/x-lua": [
	"lua"
],
	"text/x-markdown": [
	"mkd"
],
	"text/x-nfo": [
	"nfo"
],
	"text/x-opml": [
	"opml"
],
	"text/x-org": [
],
	"text/x-pascal": [
	"p",
	"pas"
],
	"text/x-processing": [
	"pde"
],
	"text/x-sass": [
	"sass"
],
	"text/x-scss": [
	"scss"
],
	"text/x-setext": [
	"etx"
],
	"text/x-sfv": [
	"sfv"
],
	"text/x-suse-ymp": [
	"ymp"
],
	"text/x-uuencode": [
	"uu"
],
	"text/x-vcalendar": [
	"vcs"
],
	"text/x-vcard": [
	"vcf"
],
	"text/xml": [
],
	"text/yaml": [
	"yaml",
	"yml"
],
	"video/3gpp": [
	"3gp",
	"3gpp"
],
	"video/3gpp2": [
	"3g2"
],
	"video/h261": [
	"h261"
],
	"video/h263": [
	"h263"
],
	"video/h264": [
	"h264"
],
	"video/jpeg": [
	"jpgv"
],
	"video/jpm": [
	"jpgm"
],
	"video/mj2": [
	"mj2",
	"mjp2"
],
	"video/mp2t": [
	"ts"
],
	"video/mp4": [
	"mp4",
	"mp4v",
	"mpg4"
],
	"video/mpeg": [
	"mpeg",
	"mpg",
	"mpe",
	"m1v",
	"m2v"
],
	"video/ogg": [
	"ogv"
],
	"video/quicktime": [
	"qt",
	"mov"
],
	"video/vnd.dece.hd": [
	"uvh",
	"uvvh"
],
	"video/vnd.dece.mobile": [
	"uvm",
	"uvvm"
],
	"video/vnd.dece.pd": [
	"uvp",
	"uvvp"
],
	"video/vnd.dece.sd": [
	"uvs",
	"uvvs"
],
	"video/vnd.dece.video": [
	"uvv",
	"uvvv"
],
	"video/vnd.dvb.file": [
	"dvb"
],
	"video/vnd.fvt": [
	"fvt"
],
	"video/vnd.mpegurl": [
	"mxu",
	"m4u"
],
	"video/vnd.ms-playready.media.pyv": [
	"pyv"
],
	"video/vnd.uvvu.mp4": [
	"uvu",
	"uvvu"
],
	"video/vnd.vivo": [
	"viv"
],
	"video/webm": [
	"webm"
],
	"video/x-f4v": [
	"f4v"
],
	"video/x-fli": [
	"fli"
],
	"video/x-flv": [
	"flv"
],
	"video/x-m4v": [
	"m4v"
],
	"video/x-matroska": [
	"mkv",
	"mk3d",
	"mks"
],
	"video/x-mng": [
	"mng"
],
	"video/x-ms-asf": [
	"asf",
	"asx"
],
	"video/x-ms-vob": [
	"vob"
],
	"video/x-ms-wm": [
	"wm"
],
	"video/x-ms-wmv": [
	"wmv"
],
	"video/x-ms-wmx": [
	"wmx"
],
	"video/x-ms-wvx": [
	"wvx"
],
	"video/x-msvideo": [
	"avi"
],
	"video/x-sgi-movie": [
	"movie"
],
	"video/x-smv": [
	"smv"
],
	"x-conference/x-cooltalk": [
	"ice"
]
};

var mime_1;
var hasRequiredMime;

function requireMime () {
	if (hasRequiredMime) return mime_1;
	hasRequiredMime = 1;
	var fs$1 = fs;

	function Mime() {
	  // Map of extension -> mime type
	  this.types = Object.create(null);

	  // Map of mime type -> extension
	  this.extensions = Object.create(null);
	}

	/**
	 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
	 * to an array of extensions associated with the type.  The first extension is
	 * used as the default extension for the type.
	 *
	 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
	 *
	 * @param map (Object) type definitions
	 */
	Mime.prototype.define = function (map) {
	  for (var type in map) {
	    var exts = map[type];
	    for (var i = 0; i < exts.length; i++) {
	      if (process.env.DEBUG_MIME && this.types[exts[i]]) {
	        console.warn((this._loading || "define()").replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' +
	          this.types[exts[i]] + ' to ' + type);
	      }

	      this.types[exts[i]] = type;
	    }

	    // Default extension is the first one we encounter
	    if (!this.extensions[type]) {
	      this.extensions[type] = exts[0];
	    }
	  }
	};

	/**
	 * Load an Apache2-style ".types" file
	 *
	 * This may be called multiple times (it's expected).  Where files declare
	 * overlapping types/extensions, the last file wins.
	 *
	 * @param file (String) path of file to load.
	 */
	Mime.prototype.load = function(file) {
	  this._loading = file;
	  // Read file and split into lines
	  var map = {},
	      content = fs$1.readFileSync(file, 'ascii'),
	      lines = content.split(/[\r\n]+/);

	  lines.forEach(function(line) {
	    // Clean up whitespace/comments, and split into fields
	    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
	    map[fields.shift()] = fields;
	  });

	  this.define(map);

	  this._loading = null;
	};

	/**
	 * Lookup a mime type based on extension
	 */
	Mime.prototype.lookup = function(path, fallback) {
	  var ext = path.replace(/^.*[\.\/\\]/, '').toLowerCase();

	  return this.types[ext] || fallback || this.default_type;
	};

	/**
	 * Return file extension associated with a mime type
	 */
	Mime.prototype.extension = function(mimeType) {
	  var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
	  return this.extensions[type];
	};

	// Default instance
	var mime = new Mime();

	// Define built-in types
	mime.define(require$$2$1);

	// Default type
	mime.default_type = mime.lookup('bin');

	//
	// Additional API specific to the default instance
	//

	mime.Mime = Mime;

	/**
	 * Lookup a charset based on mime type.
	 */
	mime.charsets = {
	  lookup: function(mimeType, fallback) {
	    // Assume text types are utf8
	    return (/^text\/|^application\/(javascript|json)/).test(mimeType) ? 'UTF-8' : fallback;
	  }
	};

	mime_1 = mime;
	return mime_1;
}

/**
 * Helpers.
 */

var ms;
var hasRequiredMs;

function requireMs () {
	if (hasRequiredMs) return ms;
	hasRequiredMs = 1;
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	ms = function (val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isFinite(val)) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'weeks':
	    case 'week':
	    case 'w':
	      return n * w;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (msAbs >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (msAbs >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (msAbs >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return plural(ms, msAbs, d, 'day');
	  }
	  if (msAbs >= h) {
	    return plural(ms, msAbs, h, 'hour');
	  }
	  if (msAbs >= m) {
	    return plural(ms, msAbs, m, 'minute');
	  }
	  if (msAbs >= s) {
	    return plural(ms, msAbs, s, 'second');
	  }
	  return ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, msAbs, n, name) {
	  var isPlural = msAbs >= n * 1.5;
	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	}
	return ms;
}

/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */

var rangeParser_1;
var hasRequiredRangeParser;

function requireRangeParser () {
	if (hasRequiredRangeParser) return rangeParser_1;
	hasRequiredRangeParser = 1;

	/**
	 * Module exports.
	 * @public
	 */

	rangeParser_1 = rangeParser;

	/**
	 * Parse "Range" header `str` relative to the given file `size`.
	 *
	 * @param {Number} size
	 * @param {String} str
	 * @param {Object} [options]
	 * @return {Array}
	 * @public
	 */

	function rangeParser (size, str, options) {
	  if (typeof str !== 'string') {
	    throw new TypeError('argument str must be a string')
	  }

	  var index = str.indexOf('=');

	  if (index === -1) {
	    return -2
	  }

	  // split the range string
	  var arr = str.slice(index + 1).split(',');
	  var ranges = [];

	  // add ranges type
	  ranges.type = str.slice(0, index);

	  // parse all ranges
	  for (var i = 0; i < arr.length; i++) {
	    var range = arr[i].split('-');
	    var start = parseInt(range[0], 10);
	    var end = parseInt(range[1], 10);

	    // -nnn
	    if (isNaN(start)) {
	      start = size - end;
	      end = size - 1;
	    // nnn-
	    } else if (isNaN(end)) {
	      end = size - 1;
	    }

	    // limit last-byte-pos to current length
	    if (end > size - 1) {
	      end = size - 1;
	    }

	    // invalid or unsatisifiable
	    if (isNaN(start) || isNaN(end) || start > end || start < 0) {
	      continue
	    }

	    // add range
	    ranges.push({
	      start: start,
	      end: end
	    });
	  }

	  if (ranges.length < 1) {
	    // unsatisifiable
	    return -1
	  }

	  return options && options.combine
	    ? combineRanges(ranges)
	    : ranges
	}

	/**
	 * Combine overlapping & adjacent ranges.
	 * @private
	 */

	function combineRanges (ranges) {
	  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);

	  for (var j = 0, i = 1; i < ordered.length; i++) {
	    var range = ordered[i];
	    var current = ordered[j];

	    if (range.start > current.end + 1) {
	      // next range
	      ordered[++j] = range;
	    } else if (range.end > current.end) {
	      // extend range
	      current.end = range.end;
	      current.index = Math.min(current.index, range.index);
	    }
	  }

	  // trim ordered array
	  ordered.length = j + 1;

	  // generate combined range
	  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);

	  // copy ranges type
	  combined.type = ranges.type;

	  return combined
	}

	/**
	 * Map function to add index value to ranges.
	 * @private
	 */

	function mapWithIndex (range, index) {
	  return {
	    start: range.start,
	    end: range.end,
	    index: index
	  }
	}

	/**
	 * Map function to remove index value from ranges.
	 * @private
	 */

	function mapWithoutIndex (range) {
	  return {
	    start: range.start,
	    end: range.end
	  }
	}

	/**
	 * Sort function to sort ranges by index.
	 * @private
	 */

	function sortByRangeIndex (a, b) {
	  return a.index - b.index
	}

	/**
	 * Sort function to sort ranges by start position.
	 * @private
	 */

	function sortByRangeStart (a, b) {
	  return a.start - b.start
	}
	return rangeParser_1;
}

/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredSend;

function requireSend () {
	if (hasRequiredSend) return send.exports;
	hasRequiredSend = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var createError = requireHttpErrors();
	var debug = requireSrc$3()('send');
	var deprecate = requireDepd()('send');
	var destroy = requireDestroy();
	var encodeUrl = requireEncodeurl();
	var escapeHtml = requireEscapeHtml();
	var etag = requireEtag();
	var fresh = requireFresh();
	var fs$1 = fs;
	var mime = requireMime();
	var ms = requireMs();
	var onFinished = requireOnFinished();
	var parseRange = requireRangeParser();
	var path = require$$0$4;
	var statuses = requireStatuses();
	var Stream = require$$0$9;
	var util = require$$0$6;

	/**
	 * Path function references.
	 * @private
	 */

	var extname = path.extname;
	var join = path.join;
	var normalize = path.normalize;
	var resolve = path.resolve;
	var sep = path.sep;

	/**
	 * Regular expression for identifying a bytes Range header.
	 * @private
	 */

	var BYTES_RANGE_REGEXP = /^ *bytes=/;

	/**
	 * Maximum value allowed for the max age.
	 * @private
	 */

	var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000; // 1 year

	/**
	 * Regular expression to match a path with a directory up component.
	 * @private
	 */

	var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;

	/**
	 * Module exports.
	 * @public
	 */

	send.exports = send$1;
	send.exports.mime = mime;

	/**
	 * Return a `SendStream` for `req` and `path`.
	 *
	 * @param {object} req
	 * @param {string} path
	 * @param {object} [options]
	 * @return {SendStream}
	 * @public
	 */

	function send$1 (req, path, options) {
	  return new SendStream(req, path, options)
	}

	/**
	 * Initialize a `SendStream` with the given `path`.
	 *
	 * @param {Request} req
	 * @param {String} path
	 * @param {object} [options]
	 * @private
	 */

	function SendStream (req, path, options) {
	  Stream.call(this);

	  var opts = options || {};

	  this.options = opts;
	  this.path = path;
	  this.req = req;

	  this._acceptRanges = opts.acceptRanges !== undefined
	    ? Boolean(opts.acceptRanges)
	    : true;

	  this._cacheControl = opts.cacheControl !== undefined
	    ? Boolean(opts.cacheControl)
	    : true;

	  this._etag = opts.etag !== undefined
	    ? Boolean(opts.etag)
	    : true;

	  this._dotfiles = opts.dotfiles !== undefined
	    ? opts.dotfiles
	    : 'ignore';

	  if (this._dotfiles !== 'ignore' && this._dotfiles !== 'allow' && this._dotfiles !== 'deny') {
	    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"')
	  }

	  this._hidden = Boolean(opts.hidden);

	  if (opts.hidden !== undefined) {
	    deprecate('hidden: use dotfiles: \'' + (this._hidden ? 'allow' : 'ignore') + '\' instead');
	  }

	  // legacy support
	  if (opts.dotfiles === undefined) {
	    this._dotfiles = undefined;
	  }

	  this._extensions = opts.extensions !== undefined
	    ? normalizeList(opts.extensions, 'extensions option')
	    : [];

	  this._immutable = opts.immutable !== undefined
	    ? Boolean(opts.immutable)
	    : false;

	  this._index = opts.index !== undefined
	    ? normalizeList(opts.index, 'index option')
	    : ['index.html'];

	  this._lastModified = opts.lastModified !== undefined
	    ? Boolean(opts.lastModified)
	    : true;

	  this._maxage = opts.maxAge || opts.maxage;
	  this._maxage = typeof this._maxage === 'string'
	    ? ms(this._maxage)
	    : Number(this._maxage);
	  this._maxage = !isNaN(this._maxage)
	    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)
	    : 0;

	  this._root = opts.root
	    ? resolve(opts.root)
	    : null;

	  if (!this._root && opts.from) {
	    this.from(opts.from);
	  }
	}

	/**
	 * Inherits from `Stream`.
	 */

	util.inherits(SendStream, Stream);

	/**
	 * Enable or disable etag generation.
	 *
	 * @param {Boolean} val
	 * @return {SendStream}
	 * @api public
	 */

	SendStream.prototype.etag = deprecate.function(function etag (val) {
	  this._etag = Boolean(val);
	  debug('etag %s', this._etag);
	  return this
	}, 'send.etag: pass etag as option');

	/**
	 * Enable or disable "hidden" (dot) files.
	 *
	 * @param {Boolean} path
	 * @return {SendStream}
	 * @api public
	 */

	SendStream.prototype.hidden = deprecate.function(function hidden (val) {
	  this._hidden = Boolean(val);
	  this._dotfiles = undefined;
	  debug('hidden %s', this._hidden);
	  return this
	}, 'send.hidden: use dotfiles option');

	/**
	 * Set index `paths`, set to a falsy
	 * value to disable index support.
	 *
	 * @param {String|Boolean|Array} paths
	 * @return {SendStream}
	 * @api public
	 */

	SendStream.prototype.index = deprecate.function(function index (paths) {
	  var index = !paths ? [] : normalizeList(paths, 'paths argument');
	  debug('index %o', paths);
	  this._index = index;
	  return this
	}, 'send.index: pass index as option');

	/**
	 * Set root `path`.
	 *
	 * @param {String} path
	 * @return {SendStream}
	 * @api public
	 */

	SendStream.prototype.root = function root (path) {
	  this._root = resolve(String(path));
	  debug('root %s', this._root);
	  return this
	};

	SendStream.prototype.from = deprecate.function(SendStream.prototype.root,
	  'send.from: pass root as option');

	SendStream.prototype.root = deprecate.function(SendStream.prototype.root,
	  'send.root: pass root as option');

	/**
	 * Set max-age to `maxAge`.
	 *
	 * @param {Number} maxAge
	 * @return {SendStream}
	 * @api public
	 */

	SendStream.prototype.maxage = deprecate.function(function maxage (maxAge) {
	  this._maxage = typeof maxAge === 'string'
	    ? ms(maxAge)
	    : Number(maxAge);
	  this._maxage = !isNaN(this._maxage)
	    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)
	    : 0;
	  debug('max-age %d', this._maxage);
	  return this
	}, 'send.maxage: pass maxAge as option');

	/**
	 * Emit error with `status`.
	 *
	 * @param {number} status
	 * @param {Error} [err]
	 * @private
	 */

	SendStream.prototype.error = function error (status, err) {
	  // emit if listeners instead of responding
	  if (hasListeners(this, 'error')) {
	    return this.emit('error', createHttpError(status, err))
	  }

	  var res = this.res;
	  var msg = statuses.message[status] || String(status);
	  var doc = createHtmlDocument('Error', escapeHtml(msg));

	  // clear existing headers
	  clearHeaders(res);

	  // add error headers
	  if (err && err.headers) {
	    setHeaders(res, err.headers);
	  }

	  // send basic response
	  res.statusCode = status;
	  res.setHeader('Content-Type', 'text/html; charset=UTF-8');
	  res.setHeader('Content-Length', Buffer.byteLength(doc));
	  res.setHeader('Content-Security-Policy', "default-src 'none'");
	  res.setHeader('X-Content-Type-Options', 'nosniff');
	  res.end(doc);
	};

	/**
	 * Check if the pathname ends with "/".
	 *
	 * @return {boolean}
	 * @private
	 */

	SendStream.prototype.hasTrailingSlash = function hasTrailingSlash () {
	  return this.path[this.path.length - 1] === '/'
	};

	/**
	 * Check if this is a conditional GET request.
	 *
	 * @return {Boolean}
	 * @api private
	 */

	SendStream.prototype.isConditionalGET = function isConditionalGET () {
	  return this.req.headers['if-match'] ||
	    this.req.headers['if-unmodified-since'] ||
	    this.req.headers['if-none-match'] ||
	    this.req.headers['if-modified-since']
	};

	/**
	 * Check if the request preconditions failed.
	 *
	 * @return {boolean}
	 * @private
	 */

	SendStream.prototype.isPreconditionFailure = function isPreconditionFailure () {
	  var req = this.req;
	  var res = this.res;

	  // if-match
	  var match = req.headers['if-match'];
	  if (match) {
	    var etag = res.getHeader('ETag');
	    return !etag || (match !== '*' && parseTokenList(match).every(function (match) {
	      return match !== etag && match !== 'W/' + etag && 'W/' + match !== etag
	    }))
	  }

	  // if-unmodified-since
	  var unmodifiedSince = parseHttpDate(req.headers['if-unmodified-since']);
	  if (!isNaN(unmodifiedSince)) {
	    var lastModified = parseHttpDate(res.getHeader('Last-Modified'));
	    return isNaN(lastModified) || lastModified > unmodifiedSince
	  }

	  return false
	};

	/**
	 * Strip various content header fields for a change in entity.
	 *
	 * @private
	 */

	SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields () {
	  var res = this.res;

	  res.removeHeader('Content-Encoding');
	  res.removeHeader('Content-Language');
	  res.removeHeader('Content-Length');
	  res.removeHeader('Content-Range');
	  res.removeHeader('Content-Type');
	};

	/**
	 * Respond with 304 not modified.
	 *
	 * @api private
	 */

	SendStream.prototype.notModified = function notModified () {
	  var res = this.res;
	  debug('not modified');
	  this.removeContentHeaderFields();
	  res.statusCode = 304;
	  res.end();
	};

	/**
	 * Raise error that headers already sent.
	 *
	 * @api private
	 */

	SendStream.prototype.headersAlreadySent = function headersAlreadySent () {
	  var err = new Error('Can\'t set headers after they are sent.');
	  debug('headers already sent');
	  this.error(500, err);
	};

	/**
	 * Check if the request is cacheable, aka
	 * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
	 *
	 * @return {Boolean}
	 * @api private
	 */

	SendStream.prototype.isCachable = function isCachable () {
	  var statusCode = this.res.statusCode;
	  return (statusCode >= 200 && statusCode < 300) ||
	    statusCode === 304
	};

	/**
	 * Handle stat() error.
	 *
	 * @param {Error} error
	 * @private
	 */

	SendStream.prototype.onStatError = function onStatError (error) {
	  switch (error.code) {
	    case 'ENAMETOOLONG':
	    case 'ENOENT':
	    case 'ENOTDIR':
	      this.error(404, error);
	      break
	    default:
	      this.error(500, error);
	      break
	  }
	};

	/**
	 * Check if the cache is fresh.
	 *
	 * @return {Boolean}
	 * @api private
	 */

	SendStream.prototype.isFresh = function isFresh () {
	  return fresh(this.req.headers, {
	    etag: this.res.getHeader('ETag'),
	    'last-modified': this.res.getHeader('Last-Modified')
	  })
	};

	/**
	 * Check if the range is fresh.
	 *
	 * @return {Boolean}
	 * @api private
	 */

	SendStream.prototype.isRangeFresh = function isRangeFresh () {
	  var ifRange = this.req.headers['if-range'];

	  if (!ifRange) {
	    return true
	  }

	  // if-range as etag
	  if (ifRange.indexOf('"') !== -1) {
	    var etag = this.res.getHeader('ETag');
	    return Boolean(etag && ifRange.indexOf(etag) !== -1)
	  }

	  // if-range as modified date
	  var lastModified = this.res.getHeader('Last-Modified');
	  return parseHttpDate(lastModified) <= parseHttpDate(ifRange)
	};

	/**
	 * Redirect to path.
	 *
	 * @param {string} path
	 * @private
	 */

	SendStream.prototype.redirect = function redirect (path) {
	  var res = this.res;

	  if (hasListeners(this, 'directory')) {
	    this.emit('directory', res, path);
	    return
	  }

	  if (this.hasTrailingSlash()) {
	    this.error(403);
	    return
	  }

	  var loc = encodeUrl(collapseLeadingSlashes(this.path + '/'));
	  var doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc));

	  // redirect
	  res.statusCode = 301;
	  res.setHeader('Content-Type', 'text/html; charset=UTF-8');
	  res.setHeader('Content-Length', Buffer.byteLength(doc));
	  res.setHeader('Content-Security-Policy', "default-src 'none'");
	  res.setHeader('X-Content-Type-Options', 'nosniff');
	  res.setHeader('Location', loc);
	  res.end(doc);
	};

	/**
	 * Pipe to `res.
	 *
	 * @param {Stream} res
	 * @return {Stream} res
	 * @api public
	 */

	SendStream.prototype.pipe = function pipe (res) {
	  // root path
	  var root = this._root;

	  // references
	  this.res = res;

	  // decode the path
	  var path = decode(this.path);
	  if (path === -1) {
	    this.error(400);
	    return res
	  }

	  // null byte(s)
	  if (~path.indexOf('\0')) {
	    this.error(400);
	    return res
	  }

	  var parts;
	  if (root !== null) {
	    // normalize
	    if (path) {
	      path = normalize('.' + sep + path);
	    }

	    // malicious path
	    if (UP_PATH_REGEXP.test(path)) {
	      debug('malicious path "%s"', path);
	      this.error(403);
	      return res
	    }

	    // explode path parts
	    parts = path.split(sep);

	    // join / normalize from optional root dir
	    path = normalize(join(root, path));
	  } else {
	    // ".." is malicious without "root"
	    if (UP_PATH_REGEXP.test(path)) {
	      debug('malicious path "%s"', path);
	      this.error(403);
	      return res
	    }

	    // explode path parts
	    parts = normalize(path).split(sep);

	    // resolve the path
	    path = resolve(path);
	  }

	  // dotfile handling
	  if (containsDotFile(parts)) {
	    var access = this._dotfiles;

	    // legacy support
	    if (access === undefined) {
	      access = parts[parts.length - 1][0] === '.'
	        ? (this._hidden ? 'allow' : 'ignore')
	        : 'allow';
	    }

	    debug('%s dotfile "%s"', access, path);
	    switch (access) {
	      case 'allow':
	        break
	      case 'deny':
	        this.error(403);
	        return res
	      case 'ignore':
	      default:
	        this.error(404);
	        return res
	    }
	  }

	  // index file support
	  if (this._index.length && this.hasTrailingSlash()) {
	    this.sendIndex(path);
	    return res
	  }

	  this.sendFile(path);
	  return res
	};

	/**
	 * Transfer `path`.
	 *
	 * @param {String} path
	 * @api public
	 */

	SendStream.prototype.send = function send (path, stat) {
	  var len = stat.size;
	  var options = this.options;
	  var opts = {};
	  var res = this.res;
	  var req = this.req;
	  var ranges = req.headers.range;
	  var offset = options.start || 0;

	  if (headersSent(res)) {
	    // impossible to send now
	    this.headersAlreadySent();
	    return
	  }

	  debug('pipe "%s"', path);

	  // set header fields
	  this.setHeader(path, stat);

	  // set content-type
	  this.type(path);

	  // conditional GET support
	  if (this.isConditionalGET()) {
	    if (this.isPreconditionFailure()) {
	      this.error(412);
	      return
	    }

	    if (this.isCachable() && this.isFresh()) {
	      this.notModified();
	      return
	    }
	  }

	  // adjust len to start/end options
	  len = Math.max(0, len - offset);
	  if (options.end !== undefined) {
	    var bytes = options.end - offset + 1;
	    if (len > bytes) len = bytes;
	  }

	  // Range support
	  if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
	    // parse
	    ranges = parseRange(len, ranges, {
	      combine: true
	    });

	    // If-Range support
	    if (!this.isRangeFresh()) {
	      debug('range stale');
	      ranges = -2;
	    }

	    // unsatisfiable
	    if (ranges === -1) {
	      debug('range unsatisfiable');

	      // Content-Range
	      res.setHeader('Content-Range', contentRange('bytes', len));

	      // 416 Requested Range Not Satisfiable
	      return this.error(416, {
	        headers: { 'Content-Range': res.getHeader('Content-Range') }
	      })
	    }

	    // valid (syntactically invalid/multiple ranges are treated as a regular response)
	    if (ranges !== -2 && ranges.length === 1) {
	      debug('range %j', ranges);

	      // Content-Range
	      res.statusCode = 206;
	      res.setHeader('Content-Range', contentRange('bytes', len, ranges[0]));

	      // adjust for requested range
	      offset += ranges[0].start;
	      len = ranges[0].end - ranges[0].start + 1;
	    }
	  }

	  // clone options
	  for (var prop in options) {
	    opts[prop] = options[prop];
	  }

	  // set read options
	  opts.start = offset;
	  opts.end = Math.max(offset, offset + len - 1);

	  // content-length
	  res.setHeader('Content-Length', len);

	  // HEAD support
	  if (req.method === 'HEAD') {
	    res.end();
	    return
	  }

	  this.stream(path, opts);
	};

	/**
	 * Transfer file for `path`.
	 *
	 * @param {String} path
	 * @api private
	 */
	SendStream.prototype.sendFile = function sendFile (path) {
	  var i = 0;
	  var self = this;

	  debug('stat "%s"', path);
	  fs$1.stat(path, function onstat (err, stat) {
	    if (err && err.code === 'ENOENT' && !extname(path) && path[path.length - 1] !== sep) {
	      // not found, check extensions
	      return next(err)
	    }
	    if (err) return self.onStatError(err)
	    if (stat.isDirectory()) return self.redirect(path)
	    self.emit('file', path, stat);
	    self.send(path, stat);
	  });

	  function next (err) {
	    if (self._extensions.length <= i) {
	      return err
	        ? self.onStatError(err)
	        : self.error(404)
	    }

	    var p = path + '.' + self._extensions[i++];

	    debug('stat "%s"', p);
	    fs$1.stat(p, function (err, stat) {
	      if (err) return next(err)
	      if (stat.isDirectory()) return next()
	      self.emit('file', p, stat);
	      self.send(p, stat);
	    });
	  }
	};

	/**
	 * Transfer index for `path`.
	 *
	 * @param {String} path
	 * @api private
	 */
	SendStream.prototype.sendIndex = function sendIndex (path) {
	  var i = -1;
	  var self = this;

	  function next (err) {
	    if (++i >= self._index.length) {
	      if (err) return self.onStatError(err)
	      return self.error(404)
	    }

	    var p = join(path, self._index[i]);

	    debug('stat "%s"', p);
	    fs$1.stat(p, function (err, stat) {
	      if (err) return next(err)
	      if (stat.isDirectory()) return next()
	      self.emit('file', p, stat);
	      self.send(p, stat);
	    });
	  }

	  next();
	};

	/**
	 * Stream `path` to the response.
	 *
	 * @param {String} path
	 * @param {Object} options
	 * @api private
	 */

	SendStream.prototype.stream = function stream (path, options) {
	  var self = this;
	  var res = this.res;

	  // pipe
	  var stream = fs$1.createReadStream(path, options);
	  this.emit('stream', stream);
	  stream.pipe(res);

	  // cleanup
	  function cleanup () {
	    destroy(stream, true);
	  }

	  // response finished, cleanup
	  onFinished(res, cleanup);

	  // error handling
	  stream.on('error', function onerror (err) {
	    // clean up stream early
	    cleanup();

	    // error
	    self.onStatError(err);
	  });

	  // end
	  stream.on('end', function onend () {
	    self.emit('end');
	  });
	};

	/**
	 * Set content-type based on `path`
	 * if it hasn't been explicitly set.
	 *
	 * @param {String} path
	 * @api private
	 */

	SendStream.prototype.type = function type (path) {
	  var res = this.res;

	  if (res.getHeader('Content-Type')) return

	  var type = mime.lookup(path);

	  if (!type) {
	    debug('no content-type');
	    return
	  }

	  var charset = mime.charsets.lookup(type);

	  debug('content-type %s', type);
	  res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''));
	};

	/**
	 * Set response header fields, most
	 * fields may be pre-defined.
	 *
	 * @param {String} path
	 * @param {Object} stat
	 * @api private
	 */

	SendStream.prototype.setHeader = function setHeader (path, stat) {
	  var res = this.res;

	  this.emit('headers', res, path, stat);

	  if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {
	    debug('accept ranges');
	    res.setHeader('Accept-Ranges', 'bytes');
	  }

	  if (this._cacheControl && !res.getHeader('Cache-Control')) {
	    var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000);

	    if (this._immutable) {
	      cacheControl += ', immutable';
	    }

	    debug('cache-control %s', cacheControl);
	    res.setHeader('Cache-Control', cacheControl);
	  }

	  if (this._lastModified && !res.getHeader('Last-Modified')) {
	    var modified = stat.mtime.toUTCString();
	    debug('modified %s', modified);
	    res.setHeader('Last-Modified', modified);
	  }

	  if (this._etag && !res.getHeader('ETag')) {
	    var val = etag(stat);
	    debug('etag %s', val);
	    res.setHeader('ETag', val);
	  }
	};

	/**
	 * Clear all headers from a response.
	 *
	 * @param {object} res
	 * @private
	 */

	function clearHeaders (res) {
	  var headers = getHeaderNames(res);

	  for (var i = 0; i < headers.length; i++) {
	    res.removeHeader(headers[i]);
	  }
	}

	/**
	 * Collapse all leading slashes into a single slash
	 *
	 * @param {string} str
	 * @private
	 */
	function collapseLeadingSlashes (str) {
	  for (var i = 0; i < str.length; i++) {
	    if (str[i] !== '/') {
	      break
	    }
	  }

	  return i > 1
	    ? '/' + str.substr(i)
	    : str
	}

	/**
	 * Determine if path parts contain a dotfile.
	 *
	 * @api private
	 */

	function containsDotFile (parts) {
	  for (var i = 0; i < parts.length; i++) {
	    var part = parts[i];
	    if (part.length > 1 && part[0] === '.') {
	      return true
	    }
	  }

	  return false
	}

	/**
	 * Create a Content-Range header.
	 *
	 * @param {string} type
	 * @param {number} size
	 * @param {array} [range]
	 */

	function contentRange (type, size, range) {
	  return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size
	}

	/**
	 * Create a minimal HTML document.
	 *
	 * @param {string} title
	 * @param {string} body
	 * @private
	 */

	function createHtmlDocument (title, body) {
	  return '<!DOCTYPE html>\n' +
	    '<html lang="en">\n' +
	    '<head>\n' +
	    '<meta charset="utf-8">\n' +
	    '<title>' + title + '</title>\n' +
	    '</head>\n' +
	    '<body>\n' +
	    '<pre>' + body + '</pre>\n' +
	    '</body>\n' +
	    '</html>\n'
	}

	/**
	 * Create a HttpError object from simple arguments.
	 *
	 * @param {number} status
	 * @param {Error|object} err
	 * @private
	 */

	function createHttpError (status, err) {
	  if (!err) {
	    return createError(status)
	  }

	  return err instanceof Error
	    ? createError(status, err, { expose: false })
	    : createError(status, err)
	}

	/**
	 * decodeURIComponent.
	 *
	 * Allows V8 to only deoptimize this fn instead of all
	 * of send().
	 *
	 * @param {String} path
	 * @api private
	 */

	function decode (path) {
	  try {
	    return decodeURIComponent(path)
	  } catch (err) {
	    return -1
	  }
	}

	/**
	 * Get the header names on a respnse.
	 *
	 * @param {object} res
	 * @returns {array[string]}
	 * @private
	 */

	function getHeaderNames (res) {
	  return typeof res.getHeaderNames !== 'function'
	    ? Object.keys(res._headers || {})
	    : res.getHeaderNames()
	}

	/**
	 * Determine if emitter has listeners of a given type.
	 *
	 * The way to do this check is done three different ways in Node.js >= 0.8
	 * so this consolidates them into a minimal set using instance methods.
	 *
	 * @param {EventEmitter} emitter
	 * @param {string} type
	 * @returns {boolean}
	 * @private
	 */

	function hasListeners (emitter, type) {
	  var count = typeof emitter.listenerCount !== 'function'
	    ? emitter.listeners(type).length
	    : emitter.listenerCount(type);

	  return count > 0
	}

	/**
	 * Determine if the response headers have been sent.
	 *
	 * @param {object} res
	 * @returns {boolean}
	 * @private
	 */

	function headersSent (res) {
	  return typeof res.headersSent !== 'boolean'
	    ? Boolean(res._header)
	    : res.headersSent
	}

	/**
	 * Normalize the index option into an array.
	 *
	 * @param {boolean|string|array} val
	 * @param {string} name
	 * @private
	 */

	function normalizeList (val, name) {
	  var list = [].concat(val || []);

	  for (var i = 0; i < list.length; i++) {
	    if (typeof list[i] !== 'string') {
	      throw new TypeError(name + ' must be array of strings or false')
	    }
	  }

	  return list
	}

	/**
	 * Parse an HTTP Date into a number.
	 *
	 * @param {string} date
	 * @private
	 */

	function parseHttpDate (date) {
	  var timestamp = date && Date.parse(date);

	  return typeof timestamp === 'number'
	    ? timestamp
	    : NaN
	}

	/**
	 * Parse a HTTP token list.
	 *
	 * @param {string} str
	 * @private
	 */

	function parseTokenList (str) {
	  var end = 0;
	  var list = [];
	  var start = 0;

	  // gather tokens
	  for (var i = 0, len = str.length; i < len; i++) {
	    switch (str.charCodeAt(i)) {
	      case 0x20: /*   */
	        if (start === end) {
	          start = end = i + 1;
	        }
	        break
	      case 0x2c: /* , */
	        if (start !== end) {
	          list.push(str.substring(start, end));
	        }
	        start = end = i + 1;
	        break
	      default:
	        end = i + 1;
	        break
	    }
	  }

	  // final token
	  if (start !== end) {
	    list.push(str.substring(start, end));
	  }

	  return list
	}

	/**
	 * Set an object of headers on a response.
	 *
	 * @param {object} res
	 * @param {object} headers
	 * @private
	 */

	function setHeaders (res, headers) {
	  var keys = Object.keys(headers);

	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    res.setHeader(key, headers[key]);
	  }
	}
	return send.exports;
}

var proxyAddr = {exports: {}};

/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

var forwarded_1;
var hasRequiredForwarded;

function requireForwarded () {
	if (hasRequiredForwarded) return forwarded_1;
	hasRequiredForwarded = 1;

	/**
	 * Module exports.
	 * @public
	 */

	forwarded_1 = forwarded;

	/**
	 * Get all addresses in the request, using the `X-Forwarded-For` header.
	 *
	 * @param {object} req
	 * @return {array}
	 * @public
	 */

	function forwarded (req) {
	  if (!req) {
	    throw new TypeError('argument req is required')
	  }

	  // simple header parsing
	  var proxyAddrs = parse(req.headers['x-forwarded-for'] || '');
	  var socketAddr = getSocketAddr(req);
	  var addrs = [socketAddr].concat(proxyAddrs);

	  // return all addresses
	  return addrs
	}

	/**
	 * Get the socket address for a request.
	 *
	 * @param {object} req
	 * @return {string}
	 * @private
	 */

	function getSocketAddr (req) {
	  return req.socket
	    ? req.socket.remoteAddress
	    : req.connection.remoteAddress
	}

	/**
	 * Parse the X-Forwarded-For header.
	 *
	 * @param {string} header
	 * @private
	 */

	function parse (header) {
	  var end = header.length;
	  var list = [];
	  var start = header.length;

	  // gather addresses, backwards
	  for (var i = header.length - 1; i >= 0; i--) {
	    switch (header.charCodeAt(i)) {
	      case 0x20: /*   */
	        if (start === end) {
	          start = end = i;
	        }
	        break
	      case 0x2c: /* , */
	        if (start !== end) {
	          list.push(header.substring(start, end));
	        }
	        start = end = i;
	        break
	      default:
	        start = i;
	        break
	    }
	  }

	  // final address
	  if (start !== end) {
	    list.push(header.substring(start, end));
	  }

	  return list
	}
	return forwarded_1;
}

var ipaddr$1 = {exports: {}};

var ipaddr = ipaddr$1.exports;

var hasRequiredIpaddr;

function requireIpaddr () {
	if (hasRequiredIpaddr) return ipaddr$1.exports;
	hasRequiredIpaddr = 1;
	(function (module) {
		(function() {
		  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;

		  ipaddr = {};

		  root = this;

		  if ((module !== null) && module.exports) {
		    module.exports = ipaddr;
		  } else {
		    root['ipaddr'] = ipaddr;
		  }

		  matchCIDR = function(first, second, partSize, cidrBits) {
		    var part, shift;
		    if (first.length !== second.length) {
		      throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
		    }
		    part = 0;
		    while (cidrBits > 0) {
		      shift = partSize - cidrBits;
		      if (shift < 0) {
		        shift = 0;
		      }
		      if (first[part] >> shift !== second[part] >> shift) {
		        return false;
		      }
		      cidrBits -= partSize;
		      part += 1;
		    }
		    return true;
		  };

		  ipaddr.subnetMatch = function(address, rangeList, defaultName) {
		    var k, len, rangeName, rangeSubnets, subnet;
		    if (defaultName == null) {
		      defaultName = 'unicast';
		    }
		    for (rangeName in rangeList) {
		      rangeSubnets = rangeList[rangeName];
		      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
		        rangeSubnets = [rangeSubnets];
		      }
		      for (k = 0, len = rangeSubnets.length; k < len; k++) {
		        subnet = rangeSubnets[k];
		        if (address.kind() === subnet[0].kind()) {
		          if (address.match.apply(address, subnet)) {
		            return rangeName;
		          }
		        }
		      }
		    }
		    return defaultName;
		  };

		  ipaddr.IPv4 = (function() {
		    function IPv4(octets) {
		      var k, len, octet;
		      if (octets.length !== 4) {
		        throw new Error("ipaddr: ipv4 octet count should be 4");
		      }
		      for (k = 0, len = octets.length; k < len; k++) {
		        octet = octets[k];
		        if (!((0 <= octet && octet <= 255))) {
		          throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
		        }
		      }
		      this.octets = octets;
		    }

		    IPv4.prototype.kind = function() {
		      return 'ipv4';
		    };

		    IPv4.prototype.toString = function() {
		      return this.octets.join(".");
		    };

		    IPv4.prototype.toNormalizedString = function() {
		      return this.toString();
		    };

		    IPv4.prototype.toByteArray = function() {
		      return this.octets.slice(0);
		    };

		    IPv4.prototype.match = function(other, cidrRange) {
		      var ref;
		      if (cidrRange === void 0) {
		        ref = other, other = ref[0], cidrRange = ref[1];
		      }
		      if (other.kind() !== 'ipv4') {
		        throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
		      }
		      return matchCIDR(this.octets, other.octets, 8, cidrRange);
		    };

		    IPv4.prototype.SpecialRanges = {
		      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
		      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
		      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
		      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
		      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
		      carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
		      "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
		      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
		    };

		    IPv4.prototype.range = function() {
		      return ipaddr.subnetMatch(this, this.SpecialRanges);
		    };

		    IPv4.prototype.toIPv4MappedAddress = function() {
		      return ipaddr.IPv6.parse("::ffff:" + (this.toString()));
		    };

		    IPv4.prototype.prefixLengthFromSubnetMask = function() {
		      var cidr, i, k, octet, stop, zeros, zerotable;
		      zerotable = {
		        0: 8,
		        128: 7,
		        192: 6,
		        224: 5,
		        240: 4,
		        248: 3,
		        252: 2,
		        254: 1,
		        255: 0
		      };
		      cidr = 0;
		      stop = false;
		      for (i = k = 3; k >= 0; i = k += -1) {
		        octet = this.octets[i];
		        if (octet in zerotable) {
		          zeros = zerotable[octet];
		          if (stop && zeros !== 0) {
		            return null;
		          }
		          if (zeros !== 8) {
		            stop = true;
		          }
		          cidr += zeros;
		        } else {
		          return null;
		        }
		      }
		      return 32 - cidr;
		    };

		    return IPv4;

		  })();

		  ipv4Part = "(0?\\d+|0x[a-f0-9]+)";

		  ipv4Regexes = {
		    fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
		    longValue: new RegExp("^" + ipv4Part + "$", 'i')
		  };

		  ipaddr.IPv4.parser = function(string) {
		    var match, parseIntAuto, part, shift, value;
		    parseIntAuto = function(string) {
		      if (string[0] === "0" && string[1] !== "x") {
		        return parseInt(string, 8);
		      } else {
		        return parseInt(string);
		      }
		    };
		    if (match = string.match(ipv4Regexes.fourOctet)) {
		      return (function() {
		        var k, len, ref, results;
		        ref = match.slice(1, 6);
		        results = [];
		        for (k = 0, len = ref.length; k < len; k++) {
		          part = ref[k];
		          results.push(parseIntAuto(part));
		        }
		        return results;
		      })();
		    } else if (match = string.match(ipv4Regexes.longValue)) {
		      value = parseIntAuto(match[1]);
		      if (value > 0xffffffff || value < 0) {
		        throw new Error("ipaddr: address outside defined range");
		      }
		      return ((function() {
		        var k, results;
		        results = [];
		        for (shift = k = 0; k <= 24; shift = k += 8) {
		          results.push((value >> shift) & 0xff);
		        }
		        return results;
		      })()).reverse();
		    } else {
		      return null;
		    }
		  };

		  ipaddr.IPv6 = (function() {
		    function IPv6(parts, zoneId) {
		      var i, k, l, len, part, ref;
		      if (parts.length === 16) {
		        this.parts = [];
		        for (i = k = 0; k <= 14; i = k += 2) {
		          this.parts.push((parts[i] << 8) | parts[i + 1]);
		        }
		      } else if (parts.length === 8) {
		        this.parts = parts;
		      } else {
		        throw new Error("ipaddr: ipv6 part count should be 8 or 16");
		      }
		      ref = this.parts;
		      for (l = 0, len = ref.length; l < len; l++) {
		        part = ref[l];
		        if (!((0 <= part && part <= 0xffff))) {
		          throw new Error("ipaddr: ipv6 part should fit in 16 bits");
		        }
		      }
		      if (zoneId) {
		        this.zoneId = zoneId;
		      }
		    }

		    IPv6.prototype.kind = function() {
		      return 'ipv6';
		    };

		    IPv6.prototype.toString = function() {
		      return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');
		    };

		    IPv6.prototype.toRFC5952String = function() {
		      var bestMatchIndex, bestMatchLength, match, regex, string;
		      regex = /((^|:)(0(:|$)){2,})/g;
		      string = this.toNormalizedString();
		      bestMatchIndex = 0;
		      bestMatchLength = -1;
		      while ((match = regex.exec(string))) {
		        if (match[0].length > bestMatchLength) {
		          bestMatchIndex = match.index;
		          bestMatchLength = match[0].length;
		        }
		      }
		      if (bestMatchLength < 0) {
		        return string;
		      }
		      return string.substring(0, bestMatchIndex) + '::' + string.substring(bestMatchIndex + bestMatchLength);
		    };

		    IPv6.prototype.toByteArray = function() {
		      var bytes, k, len, part, ref;
		      bytes = [];
		      ref = this.parts;
		      for (k = 0, len = ref.length; k < len; k++) {
		        part = ref[k];
		        bytes.push(part >> 8);
		        bytes.push(part & 0xff);
		      }
		      return bytes;
		    };

		    IPv6.prototype.toNormalizedString = function() {
		      var addr, part, suffix;
		      addr = ((function() {
		        var k, len, ref, results;
		        ref = this.parts;
		        results = [];
		        for (k = 0, len = ref.length; k < len; k++) {
		          part = ref[k];
		          results.push(part.toString(16));
		        }
		        return results;
		      }).call(this)).join(":");
		      suffix = '';
		      if (this.zoneId) {
		        suffix = '%' + this.zoneId;
		      }
		      return addr + suffix;
		    };

		    IPv6.prototype.toFixedLengthString = function() {
		      var addr, part, suffix;
		      addr = ((function() {
		        var k, len, ref, results;
		        ref = this.parts;
		        results = [];
		        for (k = 0, len = ref.length; k < len; k++) {
		          part = ref[k];
		          results.push(part.toString(16).padStart(4, '0'));
		        }
		        return results;
		      }).call(this)).join(":");
		      suffix = '';
		      if (this.zoneId) {
		        suffix = '%' + this.zoneId;
		      }
		      return addr + suffix;
		    };

		    IPv6.prototype.match = function(other, cidrRange) {
		      var ref;
		      if (cidrRange === void 0) {
		        ref = other, other = ref[0], cidrRange = ref[1];
		      }
		      if (other.kind() !== 'ipv6') {
		        throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
		      }
		      return matchCIDR(this.parts, other.parts, 16, cidrRange);
		    };

		    IPv6.prototype.SpecialRanges = {
		      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
		      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
		      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
		      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
		      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
		      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
		      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
		      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
		      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
		      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
		      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
		    };

		    IPv6.prototype.range = function() {
		      return ipaddr.subnetMatch(this, this.SpecialRanges);
		    };

		    IPv6.prototype.isIPv4MappedAddress = function() {
		      return this.range() === 'ipv4Mapped';
		    };

		    IPv6.prototype.toIPv4Address = function() {
		      var high, low, ref;
		      if (!this.isIPv4MappedAddress()) {
		        throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
		      }
		      ref = this.parts.slice(-2), high = ref[0], low = ref[1];
		      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
		    };

		    IPv6.prototype.prefixLengthFromSubnetMask = function() {
		      var cidr, i, k, part, stop, zeros, zerotable;
		      zerotable = {
		        0: 16,
		        32768: 15,
		        49152: 14,
		        57344: 13,
		        61440: 12,
		        63488: 11,
		        64512: 10,
		        65024: 9,
		        65280: 8,
		        65408: 7,
		        65472: 6,
		        65504: 5,
		        65520: 4,
		        65528: 3,
		        65532: 2,
		        65534: 1,
		        65535: 0
		      };
		      cidr = 0;
		      stop = false;
		      for (i = k = 7; k >= 0; i = k += -1) {
		        part = this.parts[i];
		        if (part in zerotable) {
		          zeros = zerotable[part];
		          if (stop && zeros !== 0) {
		            return null;
		          }
		          if (zeros !== 16) {
		            stop = true;
		          }
		          cidr += zeros;
		        } else {
		          return null;
		        }
		      }
		      return 128 - cidr;
		    };

		    return IPv6;

		  })();

		  ipv6Part = "(?:[0-9a-f]+::?)+";

		  zoneIndex = "%[0-9a-z]{1,}";

		  ipv6Regexes = {
		    zoneIndex: new RegExp(zoneIndex, 'i'),
		    "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", 'i'),
		    transitional: new RegExp(("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)") + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), 'i')
		  };

		  expandIPv6 = function(string, parts) {
		    var colonCount, lastColon, part, replacement, replacementCount, zoneId;
		    if (string.indexOf('::') !== string.lastIndexOf('::')) {
		      return null;
		    }
		    zoneId = (string.match(ipv6Regexes['zoneIndex']) || [])[0];
		    if (zoneId) {
		      zoneId = zoneId.substring(1);
		      string = string.replace(/%.+$/, '');
		    }
		    colonCount = 0;
		    lastColon = -1;
		    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
		      colonCount++;
		    }
		    if (string.substr(0, 2) === '::') {
		      colonCount--;
		    }
		    if (string.substr(-2, 2) === '::') {
		      colonCount--;
		    }
		    if (colonCount > parts) {
		      return null;
		    }
		    replacementCount = parts - colonCount;
		    replacement = ':';
		    while (replacementCount--) {
		      replacement += '0:';
		    }
		    string = string.replace('::', replacement);
		    if (string[0] === ':') {
		      string = string.slice(1);
		    }
		    if (string[string.length - 1] === ':') {
		      string = string.slice(0, -1);
		    }
		    parts = (function() {
		      var k, len, ref, results;
		      ref = string.split(":");
		      results = [];
		      for (k = 0, len = ref.length; k < len; k++) {
		        part = ref[k];
		        results.push(parseInt(part, 16));
		      }
		      return results;
		    })();
		    return {
		      parts: parts,
		      zoneId: zoneId
		    };
		  };

		  ipaddr.IPv6.parser = function(string) {
		    var addr, k, len, match, octet, octets, zoneId;
		    if (ipv6Regexes['native'].test(string)) {
		      return expandIPv6(string, 8);
		    } else if (match = string.match(ipv6Regexes['transitional'])) {
		      zoneId = match[6] || '';
		      addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
		      if (addr.parts) {
		        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
		        for (k = 0, len = octets.length; k < len; k++) {
		          octet = octets[k];
		          if (!((0 <= octet && octet <= 255))) {
		            return null;
		          }
		        }
		        addr.parts.push(octets[0] << 8 | octets[1]);
		        addr.parts.push(octets[2] << 8 | octets[3]);
		        return {
		          parts: addr.parts,
		          zoneId: addr.zoneId
		        };
		      }
		    }
		    return null;
		  };

		  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
		    return this.parser(string) !== null;
		  };

		  ipaddr.IPv4.isValid = function(string) {
		    try {
		      new this(this.parser(string));
		      return true;
		    } catch (error1) {
		      return false;
		    }
		  };

		  ipaddr.IPv4.isValidFourPartDecimal = function(string) {
		    if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
		      return true;
		    } else {
		      return false;
		    }
		  };

		  ipaddr.IPv6.isValid = function(string) {
		    var addr;
		    if (typeof string === "string" && string.indexOf(":") === -1) {
		      return false;
		    }
		    try {
		      addr = this.parser(string);
		      new this(addr.parts, addr.zoneId);
		      return true;
		    } catch (error1) {
		      return false;
		    }
		  };

		  ipaddr.IPv4.parse = function(string) {
		    var parts;
		    parts = this.parser(string);
		    if (parts === null) {
		      throw new Error("ipaddr: string is not formatted like ip address");
		    }
		    return new this(parts);
		  };

		  ipaddr.IPv6.parse = function(string) {
		    var addr;
		    addr = this.parser(string);
		    if (addr.parts === null) {
		      throw new Error("ipaddr: string is not formatted like ip address");
		    }
		    return new this(addr.parts, addr.zoneId);
		  };

		  ipaddr.IPv4.parseCIDR = function(string) {
		    var maskLength, match, parsed;
		    if (match = string.match(/^(.+)\/(\d+)$/)) {
		      maskLength = parseInt(match[2]);
		      if (maskLength >= 0 && maskLength <= 32) {
		        parsed = [this.parse(match[1]), maskLength];
		        Object.defineProperty(parsed, 'toString', {
		          value: function() {
		            return this.join('/');
		          }
		        });
		        return parsed;
		      }
		    }
		    throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
		  };

		  ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
		    var filledOctetCount, j, octets;
		    prefix = parseInt(prefix);
		    if (prefix < 0 || prefix > 32) {
		      throw new Error('ipaddr: invalid IPv4 prefix length');
		    }
		    octets = [0, 0, 0, 0];
		    j = 0;
		    filledOctetCount = Math.floor(prefix / 8);
		    while (j < filledOctetCount) {
		      octets[j] = 255;
		      j++;
		    }
		    if (filledOctetCount < 4) {
		      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);
		    }
		    return new this(octets);
		  };

		  ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
		    var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
		    try {
		      cidr = this.parseCIDR(string);
		      ipInterfaceOctets = cidr[0].toByteArray();
		      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
		      octets = [];
		      i = 0;
		      while (i < 4) {
		        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
		        i++;
		      }
		      return new this(octets);
		    } catch (error1) {
		      throw new Error('ipaddr: the address does not have IPv4 CIDR format');
		    }
		  };

		  ipaddr.IPv4.networkAddressFromCIDR = function(string) {
		    var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
		    try {
		      cidr = this.parseCIDR(string);
		      ipInterfaceOctets = cidr[0].toByteArray();
		      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
		      octets = [];
		      i = 0;
		      while (i < 4) {
		        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
		        i++;
		      }
		      return new this(octets);
		    } catch (error1) {
		      throw new Error('ipaddr: the address does not have IPv4 CIDR format');
		    }
		  };

		  ipaddr.IPv6.parseCIDR = function(string) {
		    var maskLength, match, parsed;
		    if (match = string.match(/^(.+)\/(\d+)$/)) {
		      maskLength = parseInt(match[2]);
		      if (maskLength >= 0 && maskLength <= 128) {
		        parsed = [this.parse(match[1]), maskLength];
		        Object.defineProperty(parsed, 'toString', {
		          value: function() {
		            return this.join('/');
		          }
		        });
		        return parsed;
		      }
		    }
		    throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
		  };

		  ipaddr.isValid = function(string) {
		    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
		  };

		  ipaddr.parse = function(string) {
		    if (ipaddr.IPv6.isValid(string)) {
		      return ipaddr.IPv6.parse(string);
		    } else if (ipaddr.IPv4.isValid(string)) {
		      return ipaddr.IPv4.parse(string);
		    } else {
		      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
		    }
		  };

		  ipaddr.parseCIDR = function(string) {
		    try {
		      return ipaddr.IPv6.parseCIDR(string);
		    } catch (error1) {
		      try {
		        return ipaddr.IPv4.parseCIDR(string);
		      } catch (error1) {
		        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
		      }
		    }
		  };

		  ipaddr.fromByteArray = function(bytes) {
		    var length;
		    length = bytes.length;
		    if (length === 4) {
		      return new ipaddr.IPv4(bytes);
		    } else if (length === 16) {
		      return new ipaddr.IPv6(bytes);
		    } else {
		      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
		    }
		  };

		  ipaddr.process = function(string) {
		    var addr;
		    addr = this.parse(string);
		    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
		      return addr.toIPv4Address();
		    } else {
		      return addr;
		    }
		  };

		}).call(ipaddr); 
	} (ipaddr$1));
	return ipaddr$1.exports;
}

/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredProxyAddr;

function requireProxyAddr () {
	if (hasRequiredProxyAddr) return proxyAddr.exports;
	hasRequiredProxyAddr = 1;

	/**
	 * Module exports.
	 * @public
	 */

	proxyAddr.exports = proxyaddr;
	proxyAddr.exports.all = alladdrs;
	proxyAddr.exports.compile = compile;

	/**
	 * Module dependencies.
	 * @private
	 */

	var forwarded = requireForwarded();
	var ipaddr = requireIpaddr();

	/**
	 * Variables.
	 * @private
	 */

	var DIGIT_REGEXP = /^[0-9]+$/;
	var isip = ipaddr.isValid;
	var parseip = ipaddr.parse;

	/**
	 * Pre-defined IP ranges.
	 * @private
	 */

	var IP_RANGES = {
	  linklocal: ['169.254.0.0/16', 'fe80::/10'],
	  loopback: ['127.0.0.1/8', '::1/128'],
	  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
	};

	/**
	 * Get all addresses in the request, optionally stopping
	 * at the first untrusted.
	 *
	 * @param {Object} request
	 * @param {Function|Array|String} [trust]
	 * @public
	 */

	function alladdrs (req, trust) {
	  // get addresses
	  var addrs = forwarded(req);

	  if (!trust) {
	    // Return all addresses
	    return addrs
	  }

	  if (typeof trust !== 'function') {
	    trust = compile(trust);
	  }

	  for (var i = 0; i < addrs.length - 1; i++) {
	    if (trust(addrs[i], i)) continue

	    addrs.length = i + 1;
	  }

	  return addrs
	}

	/**
	 * Compile argument into trust function.
	 *
	 * @param {Array|String} val
	 * @private
	 */

	function compile (val) {
	  if (!val) {
	    throw new TypeError('argument is required')
	  }

	  var trust;

	  if (typeof val === 'string') {
	    trust = [val];
	  } else if (Array.isArray(val)) {
	    trust = val.slice();
	  } else {
	    throw new TypeError('unsupported trust argument')
	  }

	  for (var i = 0; i < trust.length; i++) {
	    val = trust[i];

	    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
	      continue
	    }

	    // Splice in pre-defined range
	    val = IP_RANGES[val];
	    trust.splice.apply(trust, [i, 1].concat(val));
	    i += val.length - 1;
	  }

	  return compileTrust(compileRangeSubnets(trust))
	}

	/**
	 * Compile `arr` elements into range subnets.
	 *
	 * @param {Array} arr
	 * @private
	 */

	function compileRangeSubnets (arr) {
	  var rangeSubnets = new Array(arr.length);

	  for (var i = 0; i < arr.length; i++) {
	    rangeSubnets[i] = parseipNotation(arr[i]);
	  }

	  return rangeSubnets
	}

	/**
	 * Compile range subnet array into trust function.
	 *
	 * @param {Array} rangeSubnets
	 * @private
	 */

	function compileTrust (rangeSubnets) {
	  // Return optimized function based on length
	  var len = rangeSubnets.length;
	  return len === 0
	    ? trustNone
	    : len === 1
	      ? trustSingle(rangeSubnets[0])
	      : trustMulti(rangeSubnets)
	}

	/**
	 * Parse IP notation string into range subnet.
	 *
	 * @param {String} note
	 * @private
	 */

	function parseipNotation (note) {
	  var pos = note.lastIndexOf('/');
	  var str = pos !== -1
	    ? note.substring(0, pos)
	    : note;

	  if (!isip(str)) {
	    throw new TypeError('invalid IP address: ' + str)
	  }

	  var ip = parseip(str);

	  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
	    // Store as IPv4
	    ip = ip.toIPv4Address();
	  }

	  var max = ip.kind() === 'ipv6'
	    ? 128
	    : 32;

	  var range = pos !== -1
	    ? note.substring(pos + 1, note.length)
	    : null;

	  if (range === null) {
	    range = max;
	  } else if (DIGIT_REGEXP.test(range)) {
	    range = parseInt(range, 10);
	  } else if (ip.kind() === 'ipv4' && isip(range)) {
	    range = parseNetmask(range);
	  } else {
	    range = null;
	  }

	  if (range <= 0 || range > max) {
	    throw new TypeError('invalid range on address: ' + note)
	  }

	  return [ip, range]
	}

	/**
	 * Parse netmask string into CIDR range.
	 *
	 * @param {String} netmask
	 * @private
	 */

	function parseNetmask (netmask) {
	  var ip = parseip(netmask);
	  var kind = ip.kind();

	  return kind === 'ipv4'
	    ? ip.prefixLengthFromSubnetMask()
	    : null
	}

	/**
	 * Determine address of proxied request.
	 *
	 * @param {Object} request
	 * @param {Function|Array|String} trust
	 * @public
	 */

	function proxyaddr (req, trust) {
	  if (!req) {
	    throw new TypeError('req argument is required')
	  }

	  if (!trust) {
	    throw new TypeError('trust argument is required')
	  }

	  var addrs = alladdrs(req, trust);
	  var addr = addrs[addrs.length - 1];

	  return addr
	}

	/**
	 * Static trust function to trust nothing.
	 *
	 * @private
	 */

	function trustNone () {
	  return false
	}

	/**
	 * Compile trust function for multiple subnets.
	 *
	 * @param {Array} subnets
	 * @private
	 */

	function trustMulti (subnets) {
	  return function trust (addr) {
	    if (!isip(addr)) return false

	    var ip = parseip(addr);
	    var ipconv;
	    var kind = ip.kind();

	    for (var i = 0; i < subnets.length; i++) {
	      var subnet = subnets[i];
	      var subnetip = subnet[0];
	      var subnetkind = subnetip.kind();
	      var subnetrange = subnet[1];
	      var trusted = ip;

	      if (kind !== subnetkind) {
	        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {
	          // Incompatible IP addresses
	          continue
	        }

	        if (!ipconv) {
	          // Convert IP to match subnet IP kind
	          ipconv = subnetkind === 'ipv4'
	            ? ip.toIPv4Address()
	            : ip.toIPv4MappedAddress();
	        }

	        trusted = ipconv;
	      }

	      if (trusted.match(subnetip, subnetrange)) {
	        return true
	      }
	    }

	    return false
	  }
	}

	/**
	 * Compile trust function for single subnet.
	 *
	 * @param {Object} subnet
	 * @private
	 */

	function trustSingle (subnet) {
	  var subnetip = subnet[0];
	  var subnetkind = subnetip.kind();
	  var subnetisipv4 = subnetkind === 'ipv4';
	  var subnetrange = subnet[1];

	  return function trust (addr) {
	    if (!isip(addr)) return false

	    var ip = parseip(addr);
	    var kind = ip.kind();

	    if (kind !== subnetkind) {
	      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
	        // Incompatible IP addresses
	        return false
	      }

	      // Convert IP to match subnet IP kind
	      ip = subnetisipv4
	        ? ip.toIPv4Address()
	        : ip.toIPv4MappedAddress();
	    }

	    return ip.match(subnetip, subnetrange)
	  }
	}
	return proxyAddr.exports;
}

/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredUtils$2;

function requireUtils$2 () {
	if (hasRequiredUtils$2) return utils$2;
	hasRequiredUtils$2 = 1;
	(function (exports) {

		/**
		 * Module dependencies.
		 * @api private
		 */

		var Buffer = requireSafeBuffer$1().Buffer;
		var contentDisposition = requireContentDisposition();
		var contentType = requireContentType();
		var deprecate = requireDepd()('express');
		var flatten = requireArrayFlatten();
		var mime = requireSend().mime;
		var etag = requireEtag();
		var proxyaddr = requireProxyAddr();
		var qs = /*@__PURE__*/ requireLib$4();
		var querystring = require$$8;

		/**
		 * Return strong ETag for `body`.
		 *
		 * @param {String|Buffer} body
		 * @param {String} [encoding]
		 * @return {String}
		 * @api private
		 */

		exports.etag = createETagGenerator({ weak: false });

		/**
		 * Return weak ETag for `body`.
		 *
		 * @param {String|Buffer} body
		 * @param {String} [encoding]
		 * @return {String}
		 * @api private
		 */

		exports.wetag = createETagGenerator({ weak: true });

		/**
		 * Check if `path` looks absolute.
		 *
		 * @param {String} path
		 * @return {Boolean}
		 * @api private
		 */

		exports.isAbsolute = function(path){
		  if ('/' === path[0]) return true;
		  if (':' === path[1] && ('\\' === path[2] || '/' === path[2])) return true; // Windows device path
		  if ('\\\\' === path.substring(0, 2)) return true; // Microsoft Azure absolute path
		};

		/**
		 * Flatten the given `arr`.
		 *
		 * @param {Array} arr
		 * @return {Array}
		 * @api private
		 */

		exports.flatten = deprecate.function(flatten,
		  'utils.flatten: use array-flatten npm module instead');

		/**
		 * Normalize the given `type`, for example "html" becomes "text/html".
		 *
		 * @param {String} type
		 * @return {Object}
		 * @api private
		 */

		exports.normalizeType = function(type){
		  return ~type.indexOf('/')
		    ? acceptParams(type)
		    : { value: mime.lookup(type), params: {} };
		};

		/**
		 * Normalize `types`, for example "html" becomes "text/html".
		 *
		 * @param {Array} types
		 * @return {Array}
		 * @api private
		 */

		exports.normalizeTypes = function(types){
		  var ret = [];

		  for (var i = 0; i < types.length; ++i) {
		    ret.push(exports.normalizeType(types[i]));
		  }

		  return ret;
		};

		/**
		 * Generate Content-Disposition header appropriate for the filename.
		 * non-ascii filenames are urlencoded and a filename* parameter is added
		 *
		 * @param {String} filename
		 * @return {String}
		 * @api private
		 */

		exports.contentDisposition = deprecate.function(contentDisposition,
		  'utils.contentDisposition: use content-disposition npm module instead');

		/**
		 * Parse accept params `str` returning an
		 * object with `.value`, `.quality` and `.params`.
		 *
		 * @param {String} str
		 * @return {Object}
		 * @api private
		 */

		function acceptParams (str) {
		  var parts = str.split(/ *; */);
		  var ret = { value: parts[0], quality: 1, params: {} };

		  for (var i = 1; i < parts.length; ++i) {
		    var pms = parts[i].split(/ *= */);
		    if ('q' === pms[0]) {
		      ret.quality = parseFloat(pms[1]);
		    } else {
		      ret.params[pms[0]] = pms[1];
		    }
		  }

		  return ret;
		}

		/**
		 * Compile "etag" value to function.
		 *
		 * @param  {Boolean|String|Function} val
		 * @return {Function}
		 * @api private
		 */

		exports.compileETag = function(val) {
		  var fn;

		  if (typeof val === 'function') {
		    return val;
		  }

		  switch (val) {
		    case true:
		    case 'weak':
		      fn = exports.wetag;
		      break;
		    case false:
		      break;
		    case 'strong':
		      fn = exports.etag;
		      break;
		    default:
		      throw new TypeError('unknown value for etag function: ' + val);
		  }

		  return fn;
		};

		/**
		 * Compile "query parser" value to function.
		 *
		 * @param  {String|Function} val
		 * @return {Function}
		 * @api private
		 */

		exports.compileQueryParser = function compileQueryParser(val) {
		  var fn;

		  if (typeof val === 'function') {
		    return val;
		  }

		  switch (val) {
		    case true:
		    case 'simple':
		      fn = querystring.parse;
		      break;
		    case false:
		      fn = newObject;
		      break;
		    case 'extended':
		      fn = parseExtendedQueryString;
		      break;
		    default:
		      throw new TypeError('unknown value for query parser function: ' + val);
		  }

		  return fn;
		};

		/**
		 * Compile "proxy trust" value to function.
		 *
		 * @param  {Boolean|String|Number|Array|Function} val
		 * @return {Function}
		 * @api private
		 */

		exports.compileTrust = function(val) {
		  if (typeof val === 'function') return val;

		  if (val === true) {
		    // Support plain true/false
		    return function(){ return true };
		  }

		  if (typeof val === 'number') {
		    // Support trusting hop count
		    return function(a, i){ return i < val };
		  }

		  if (typeof val === 'string') {
		    // Support comma-separated values
		    val = val.split(',')
		      .map(function (v) { return v.trim() });
		  }

		  return proxyaddr.compile(val || []);
		};

		/**
		 * Set the charset in a given Content-Type string.
		 *
		 * @param {String} type
		 * @param {String} charset
		 * @return {String}
		 * @api private
		 */

		exports.setCharset = function setCharset(type, charset) {
		  if (!type || !charset) {
		    return type;
		  }

		  // parse type
		  var parsed = contentType.parse(type);

		  // set charset
		  parsed.parameters.charset = charset;

		  // format type
		  return contentType.format(parsed);
		};

		/**
		 * Create an ETag generator function, generating ETags with
		 * the given options.
		 *
		 * @param {object} options
		 * @return {function}
		 * @private
		 */

		function createETagGenerator (options) {
		  return function generateETag (body, encoding) {
		    var buf = !Buffer.isBuffer(body)
		      ? Buffer.from(body, encoding)
		      : body;

		    return etag(buf, options)
		  }
		}

		/**
		 * Parse an extended query string with qs.
		 *
		 * @param {String} str
		 * @return {Object}
		 * @private
		 */

		function parseExtendedQueryString(str) {
		  return qs.parse(str, {
		    allowPrototypes: true
		  });
		}

		/**
		 * Return new empty object.
		 *
		 * @return {Object}
		 * @api private
		 */

		function newObject() {
		  return {};
		} 
	} (utils$2));
	return utils$2;
}

/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredApplication;

function requireApplication () {
	if (hasRequiredApplication) return application.exports;
	hasRequiredApplication = 1;
	(function (module, exports) {

		/**
		 * Module dependencies.
		 * @private
		 */

		var finalhandler = requireFinalhandler();
		var Router = requireRouter();
		var methods = requireMethods();
		var middleware = requireInit();
		var query = requireQuery();
		var debug = requireSrc$3()('express:application');
		var View = requireView();
		var http = require$$0$b;
		var compileETag = requireUtils$2().compileETag;
		var compileQueryParser = requireUtils$2().compileQueryParser;
		var compileTrust = requireUtils$2().compileTrust;
		var deprecate = requireDepd()('express');
		var flatten = requireArrayFlatten();
		var merge = requireUtilsMerge();
		var resolve = require$$0$4.resolve;
		var setPrototypeOf = requireSetprototypeof();

		/**
		 * Module variables.
		 * @private
		 */

		var hasOwnProperty = Object.prototype.hasOwnProperty;
		var slice = Array.prototype.slice;

		/**
		 * Application prototype.
		 */

		var app = module.exports = {};

		/**
		 * Variable for trust proxy inheritance back-compat
		 * @private
		 */

		var trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';

		/**
		 * Initialize the server.
		 *
		 *   - setup default configuration
		 *   - setup default middleware
		 *   - setup route reflection methods
		 *
		 * @private
		 */

		app.init = function init() {
		  this.cache = {};
		  this.engines = {};
		  this.settings = {};

		  this.defaultConfiguration();
		};

		/**
		 * Initialize application configuration.
		 * @private
		 */

		app.defaultConfiguration = function defaultConfiguration() {
		  var env = process.env.NODE_ENV || 'development';

		  // default settings
		  this.enable('x-powered-by');
		  this.set('etag', 'weak');
		  this.set('env', env);
		  this.set('query parser', 'extended');
		  this.set('subdomain offset', 2);
		  this.set('trust proxy', false);

		  // trust proxy inherit back-compat
		  Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
		    configurable: true,
		    value: true
		  });

		  debug('booting in %s mode', env);

		  this.on('mount', function onmount(parent) {
		    // inherit trust proxy
		    if (this.settings[trustProxyDefaultSymbol] === true
		      && typeof parent.settings['trust proxy fn'] === 'function') {
		      delete this.settings['trust proxy'];
		      delete this.settings['trust proxy fn'];
		    }

		    // inherit protos
		    setPrototypeOf(this.request, parent.request);
		    setPrototypeOf(this.response, parent.response);
		    setPrototypeOf(this.engines, parent.engines);
		    setPrototypeOf(this.settings, parent.settings);
		  });

		  // setup locals
		  this.locals = Object.create(null);

		  // top-most app is mounted at /
		  this.mountpath = '/';

		  // default locals
		  this.locals.settings = this.settings;

		  // default configuration
		  this.set('view', View);
		  this.set('views', resolve('views'));
		  this.set('jsonp callback name', 'callback');

		  if (env === 'production') {
		    this.enable('view cache');
		  }

		  Object.defineProperty(this, 'router', {
		    get: function() {
		      throw new Error('\'app.router\' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.');
		    }
		  });
		};

		/**
		 * lazily adds the base router if it has not yet been added.
		 *
		 * We cannot add the base router in the defaultConfiguration because
		 * it reads app settings which might be set after that has run.
		 *
		 * @private
		 */
		app.lazyrouter = function lazyrouter() {
		  if (!this._router) {
		    this._router = new Router({
		      caseSensitive: this.enabled('case sensitive routing'),
		      strict: this.enabled('strict routing')
		    });

		    this._router.use(query(this.get('query parser fn')));
		    this._router.use(middleware.init(this));
		  }
		};

		/**
		 * Dispatch a req, res pair into the application. Starts pipeline processing.
		 *
		 * If no callback is provided, then default error handlers will respond
		 * in the event of an error bubbling through the stack.
		 *
		 * @private
		 */

		app.handle = function handle(req, res, callback) {
		  var router = this._router;

		  // final handler
		  var done = callback || finalhandler(req, res, {
		    env: this.get('env'),
		    onerror: logerror.bind(this)
		  });

		  // no routes
		  if (!router) {
		    debug('no routes defined on app');
		    done();
		    return;
		  }

		  router.handle(req, res, done);
		};

		/**
		 * Proxy `Router#use()` to add middleware to the app router.
		 * See Router#use() documentation for details.
		 *
		 * If the _fn_ parameter is an express app, then it will be
		 * mounted at the _route_ specified.
		 *
		 * @public
		 */

		app.use = function use(fn) {
		  var offset = 0;
		  var path = '/';

		  // default path to '/'
		  // disambiguate app.use([fn])
		  if (typeof fn !== 'function') {
		    var arg = fn;

		    while (Array.isArray(arg) && arg.length !== 0) {
		      arg = arg[0];
		    }

		    // first arg is the path
		    if (typeof arg !== 'function') {
		      offset = 1;
		      path = fn;
		    }
		  }

		  var fns = flatten(slice.call(arguments, offset));

		  if (fns.length === 0) {
		    throw new TypeError('app.use() requires a middleware function')
		  }

		  // setup router
		  this.lazyrouter();
		  var router = this._router;

		  fns.forEach(function (fn) {
		    // non-express app
		    if (!fn || !fn.handle || !fn.set) {
		      return router.use(path, fn);
		    }

		    debug('.use app under %s', path);
		    fn.mountpath = path;
		    fn.parent = this;

		    // restore .app property on req and res
		    router.use(path, function mounted_app(req, res, next) {
		      var orig = req.app;
		      fn.handle(req, res, function (err) {
		        setPrototypeOf(req, orig.request);
		        setPrototypeOf(res, orig.response);
		        next(err);
		      });
		    });

		    // mounted an app
		    fn.emit('mount', this);
		  }, this);

		  return this;
		};

		/**
		 * Proxy to the app `Router#route()`
		 * Returns a new `Route` instance for the _path_.
		 *
		 * Routes are isolated middleware stacks for specific paths.
		 * See the Route api docs for details.
		 *
		 * @public
		 */

		app.route = function route(path) {
		  this.lazyrouter();
		  return this._router.route(path);
		};

		/**
		 * Register the given template engine callback `fn`
		 * as `ext`.
		 *
		 * By default will `require()` the engine based on the
		 * file extension. For example if you try to render
		 * a "foo.ejs" file Express will invoke the following internally:
		 *
		 *     app.engine('ejs', require('ejs').__express);
		 *
		 * For engines that do not provide `.__express` out of the box,
		 * or if you wish to "map" a different extension to the template engine
		 * you may use this method. For example mapping the EJS template engine to
		 * ".html" files:
		 *
		 *     app.engine('html', require('ejs').renderFile);
		 *
		 * In this case EJS provides a `.renderFile()` method with
		 * the same signature that Express expects: `(path, options, callback)`,
		 * though note that it aliases this method as `ejs.__express` internally
		 * so if you're using ".ejs" extensions you don't need to do anything.
		 *
		 * Some template engines do not follow this convention, the
		 * [Consolidate.js](https://github.com/tj/consolidate.js)
		 * library was created to map all of node's popular template
		 * engines to follow this convention, thus allowing them to
		 * work seamlessly within Express.
		 *
		 * @param {String} ext
		 * @param {Function} fn
		 * @return {app} for chaining
		 * @public
		 */

		app.engine = function engine(ext, fn) {
		  if (typeof fn !== 'function') {
		    throw new Error('callback function required');
		  }

		  // get file extension
		  var extension = ext[0] !== '.'
		    ? '.' + ext
		    : ext;

		  // store engine
		  this.engines[extension] = fn;

		  return this;
		};

		/**
		 * Proxy to `Router#param()` with one added api feature. The _name_ parameter
		 * can be an array of names.
		 *
		 * See the Router#param() docs for more details.
		 *
		 * @param {String|Array} name
		 * @param {Function} fn
		 * @return {app} for chaining
		 * @public
		 */

		app.param = function param(name, fn) {
		  this.lazyrouter();

		  if (Array.isArray(name)) {
		    for (var i = 0; i < name.length; i++) {
		      this.param(name[i], fn);
		    }

		    return this;
		  }

		  this._router.param(name, fn);

		  return this;
		};

		/**
		 * Assign `setting` to `val`, or return `setting`'s value.
		 *
		 *    app.set('foo', 'bar');
		 *    app.set('foo');
		 *    // => "bar"
		 *
		 * Mounted servers inherit their parent server's settings.
		 *
		 * @param {String} setting
		 * @param {*} [val]
		 * @return {Server} for chaining
		 * @public
		 */

		app.set = function set(setting, val) {
		  if (arguments.length === 1) {
		    // app.get(setting)
		    var settings = this.settings;

		    while (settings && settings !== Object.prototype) {
		      if (hasOwnProperty.call(settings, setting)) {
		        return settings[setting]
		      }

		      settings = Object.getPrototypeOf(settings);
		    }

		    return undefined
		  }

		  debug('set "%s" to %o', setting, val);

		  // set value
		  this.settings[setting] = val;

		  // trigger matched settings
		  switch (setting) {
		    case 'etag':
		      this.set('etag fn', compileETag(val));
		      break;
		    case 'query parser':
		      this.set('query parser fn', compileQueryParser(val));
		      break;
		    case 'trust proxy':
		      this.set('trust proxy fn', compileTrust(val));

		      // trust proxy inherit back-compat
		      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
		        configurable: true,
		        value: false
		      });

		      break;
		  }

		  return this;
		};

		/**
		 * Return the app's absolute pathname
		 * based on the parent(s) that have
		 * mounted it.
		 *
		 * For example if the application was
		 * mounted as "/admin", which itself
		 * was mounted as "/blog" then the
		 * return value would be "/blog/admin".
		 *
		 * @return {String}
		 * @private
		 */

		app.path = function path() {
		  return this.parent
		    ? this.parent.path() + this.mountpath
		    : '';
		};

		/**
		 * Check if `setting` is enabled (truthy).
		 *
		 *    app.enabled('foo')
		 *    // => false
		 *
		 *    app.enable('foo')
		 *    app.enabled('foo')
		 *    // => true
		 *
		 * @param {String} setting
		 * @return {Boolean}
		 * @public
		 */

		app.enabled = function enabled(setting) {
		  return Boolean(this.set(setting));
		};

		/**
		 * Check if `setting` is disabled.
		 *
		 *    app.disabled('foo')
		 *    // => true
		 *
		 *    app.enable('foo')
		 *    app.disabled('foo')
		 *    // => false
		 *
		 * @param {String} setting
		 * @return {Boolean}
		 * @public
		 */

		app.disabled = function disabled(setting) {
		  return !this.set(setting);
		};

		/**
		 * Enable `setting`.
		 *
		 * @param {String} setting
		 * @return {app} for chaining
		 * @public
		 */

		app.enable = function enable(setting) {
		  return this.set(setting, true);
		};

		/**
		 * Disable `setting`.
		 *
		 * @param {String} setting
		 * @return {app} for chaining
		 * @public
		 */

		app.disable = function disable(setting) {
		  return this.set(setting, false);
		};

		/**
		 * Delegate `.VERB(...)` calls to `router.VERB(...)`.
		 */

		methods.forEach(function(method){
		  app[method] = function(path){
		    if (method === 'get' && arguments.length === 1) {
		      // app.get(setting)
		      return this.set(path);
		    }

		    this.lazyrouter();

		    var route = this._router.route(path);
		    route[method].apply(route, slice.call(arguments, 1));
		    return this;
		  };
		});

		/**
		 * Special-cased "all" method, applying the given route `path`,
		 * middleware, and callback to _every_ HTTP method.
		 *
		 * @param {String} path
		 * @param {Function} ...
		 * @return {app} for chaining
		 * @public
		 */

		app.all = function all(path) {
		  this.lazyrouter();

		  var route = this._router.route(path);
		  var args = slice.call(arguments, 1);

		  for (var i = 0; i < methods.length; i++) {
		    route[methods[i]].apply(route, args);
		  }

		  return this;
		};

		// del -> delete alias

		app.del = deprecate.function(app.delete, 'app.del: Use app.delete instead');

		/**
		 * Render the given view `name` name with `options`
		 * and a callback accepting an error and the
		 * rendered template string.
		 *
		 * Example:
		 *
		 *    app.render('email', { name: 'Tobi' }, function(err, html){
		 *      // ...
		 *    })
		 *
		 * @param {String} name
		 * @param {Object|Function} options or fn
		 * @param {Function} callback
		 * @public
		 */

		app.render = function render(name, options, callback) {
		  var cache = this.cache;
		  var done = callback;
		  var engines = this.engines;
		  var opts = options;
		  var renderOptions = {};
		  var view;

		  // support callback function as second arg
		  if (typeof options === 'function') {
		    done = options;
		    opts = {};
		  }

		  // merge app.locals
		  merge(renderOptions, this.locals);

		  // merge options._locals
		  if (opts._locals) {
		    merge(renderOptions, opts._locals);
		  }

		  // merge options
		  merge(renderOptions, opts);

		  // set .cache unless explicitly provided
		  if (renderOptions.cache == null) {
		    renderOptions.cache = this.enabled('view cache');
		  }

		  // primed cache
		  if (renderOptions.cache) {
		    view = cache[name];
		  }

		  // view
		  if (!view) {
		    var View = this.get('view');

		    view = new View(name, {
		      defaultEngine: this.get('view engine'),
		      root: this.get('views'),
		      engines: engines
		    });

		    if (!view.path) {
		      var dirs = Array.isArray(view.root) && view.root.length > 1
		        ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"'
		        : 'directory "' + view.root + '"';
		      var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
		      err.view = view;
		      return done(err);
		    }

		    // prime the cache
		    if (renderOptions.cache) {
		      cache[name] = view;
		    }
		  }

		  // render
		  tryRender(view, renderOptions, done);
		};

		/**
		 * Listen for connections.
		 *
		 * A node `http.Server` is returned, with this
		 * application (which is a `Function`) as its
		 * callback. If you wish to create both an HTTP
		 * and HTTPS server you may do so with the "http"
		 * and "https" modules as shown here:
		 *
		 *    var http = require('http')
		 *      , https = require('https')
		 *      , express = require('express')
		 *      , app = express();
		 *
		 *    http.createServer(app).listen(80);
		 *    https.createServer({ ... }, app).listen(443);
		 *
		 * @return {http.Server}
		 * @public
		 */

		app.listen = function listen() {
		  var server = http.createServer(this);
		  return server.listen.apply(server, arguments);
		};

		/**
		 * Log error using console.error.
		 *
		 * @param {Error} err
		 * @private
		 */

		function logerror(err) {
		  /* istanbul ignore next */
		  if (this.get('env') !== 'test') console.error(err.stack || err.toString());
		}

		/**
		 * Try rendering a view.
		 * @private
		 */

		function tryRender(view, options, callback) {
		  try {
		    view.render(options, callback);
		  } catch (err) {
		    callback(err);
		  }
		} 
	} (application));
	return application.exports;
}

var negotiator = {exports: {}};

var charset = {exports: {}};

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredCharset;

function requireCharset () {
	if (hasRequiredCharset) return charset.exports;
	hasRequiredCharset = 1;

	/**
	 * Module exports.
	 * @public
	 */

	charset.exports = preferredCharsets;
	charset.exports.preferredCharsets = preferredCharsets;

	/**
	 * Module variables.
	 * @private
	 */

	var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

	/**
	 * Parse the Accept-Charset header.
	 * @private
	 */

	function parseAcceptCharset(accept) {
	  var accepts = accept.split(',');

	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var charset = parseCharset(accepts[i].trim(), i);

	    if (charset) {
	      accepts[j++] = charset;
	    }
	  }

	  // trim accepts
	  accepts.length = j;

	  return accepts;
	}

	/**
	 * Parse a charset from the Accept-Charset header.
	 * @private
	 */

	function parseCharset(str, i) {
	  var match = simpleCharsetRegExp.exec(str);
	  if (!match) return null;

	  var charset = match[1];
	  var q = 1;
	  if (match[2]) {
	    var params = match[2].split(';');
	    for (var j = 0; j < params.length; j++) {
	      var p = params[j].trim().split('=');
	      if (p[0] === 'q') {
	        q = parseFloat(p[1]);
	        break;
	      }
	    }
	  }

	  return {
	    charset: charset,
	    q: q,
	    i: i
	  };
	}

	/**
	 * Get the priority of a charset.
	 * @private
	 */

	function getCharsetPriority(charset, accepted, index) {
	  var priority = {o: -1, q: 0, s: 0};

	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(charset, accepted[i], index);

	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }

	  return priority;
	}

	/**
	 * Get the specificity of the charset.
	 * @private
	 */

	function specify(charset, spec, index) {
	  var s = 0;
	  if(spec.charset.toLowerCase() === charset.toLowerCase()){
	    s |= 1;
	  } else if (spec.charset !== '*' ) {
	    return null
	  }

	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s
	  }
	}

	/**
	 * Get the preferred charsets from an Accept-Charset header.
	 * @public
	 */

	function preferredCharsets(accept, provided) {
	  // RFC 2616 sec 14.2: no header = *
	  var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');

	  if (!provided) {
	    // sorted list of all charsets
	    return accepts
	      .filter(isQuality)
	      .sort(compareSpecs)
	      .map(getFullCharset);
	  }

	  var priorities = provided.map(function getPriority(type, index) {
	    return getCharsetPriority(type, accepts, index);
	  });

	  // sorted list of accepted charsets
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}

	/**
	 * Compare two specs.
	 * @private
	 */

	function compareSpecs(a, b) {
	  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
	}

	/**
	 * Get full charset string.
	 * @private
	 */

	function getFullCharset(spec) {
	  return spec.charset;
	}

	/**
	 * Check if a spec has any quality.
	 * @private
	 */

	function isQuality(spec) {
	  return spec.q > 0;
	}
	return charset.exports;
}

var encoding$1 = {exports: {}};

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredEncoding$1;

function requireEncoding$1 () {
	if (hasRequiredEncoding$1) return encoding$1.exports;
	hasRequiredEncoding$1 = 1;

	/**
	 * Module exports.
	 * @public
	 */

	encoding$1.exports = preferredEncodings;
	encoding$1.exports.preferredEncodings = preferredEncodings;

	/**
	 * Module variables.
	 * @private
	 */

	var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

	/**
	 * Parse the Accept-Encoding header.
	 * @private
	 */

	function parseAcceptEncoding(accept) {
	  var accepts = accept.split(',');
	  var hasIdentity = false;
	  var minQuality = 1;

	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var encoding = parseEncoding(accepts[i].trim(), i);

	    if (encoding) {
	      accepts[j++] = encoding;
	      hasIdentity = hasIdentity || specify('identity', encoding);
	      minQuality = Math.min(minQuality, encoding.q || 1);
	    }
	  }

	  if (!hasIdentity) {
	    /*
	     * If identity doesn't explicitly appear in the accept-encoding header,
	     * it's added to the list of acceptable encoding with the lowest q
	     */
	    accepts[j++] = {
	      encoding: 'identity',
	      q: minQuality,
	      i: i
	    };
	  }

	  // trim accepts
	  accepts.length = j;

	  return accepts;
	}

	/**
	 * Parse an encoding from the Accept-Encoding header.
	 * @private
	 */

	function parseEncoding(str, i) {
	  var match = simpleEncodingRegExp.exec(str);
	  if (!match) return null;

	  var encoding = match[1];
	  var q = 1;
	  if (match[2]) {
	    var params = match[2].split(';');
	    for (var j = 0; j < params.length; j++) {
	      var p = params[j].trim().split('=');
	      if (p[0] === 'q') {
	        q = parseFloat(p[1]);
	        break;
	      }
	    }
	  }

	  return {
	    encoding: encoding,
	    q: q,
	    i: i
	  };
	}

	/**
	 * Get the priority of an encoding.
	 * @private
	 */

	function getEncodingPriority(encoding, accepted, index) {
	  var priority = {o: -1, q: 0, s: 0};

	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(encoding, accepted[i], index);

	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }

	  return priority;
	}

	/**
	 * Get the specificity of the encoding.
	 * @private
	 */

	function specify(encoding, spec, index) {
	  var s = 0;
	  if(spec.encoding.toLowerCase() === encoding.toLowerCase()){
	    s |= 1;
	  } else if (spec.encoding !== '*' ) {
	    return null
	  }

	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s
	  }
	}
	/**
	 * Get the preferred encodings from an Accept-Encoding header.
	 * @public
	 */

	function preferredEncodings(accept, provided) {
	  var accepts = parseAcceptEncoding(accept || '');

	  if (!provided) {
	    // sorted list of all encodings
	    return accepts
	      .filter(isQuality)
	      .sort(compareSpecs)
	      .map(getFullEncoding);
	  }

	  var priorities = provided.map(function getPriority(type, index) {
	    return getEncodingPriority(type, accepts, index);
	  });

	  // sorted list of accepted encodings
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}

	/**
	 * Compare two specs.
	 * @private
	 */

	function compareSpecs(a, b) {
	  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
	}

	/**
	 * Get full encoding string.
	 * @private
	 */

	function getFullEncoding(spec) {
	  return spec.encoding;
	}

	/**
	 * Check if a spec has any quality.
	 * @private
	 */

	function isQuality(spec) {
	  return spec.q > 0;
	}
	return encoding$1.exports;
}

var language = {exports: {}};

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredLanguage;

function requireLanguage () {
	if (hasRequiredLanguage) return language.exports;
	hasRequiredLanguage = 1;

	/**
	 * Module exports.
	 * @public
	 */

	language.exports = preferredLanguages;
	language.exports.preferredLanguages = preferredLanguages;

	/**
	 * Module variables.
	 * @private
	 */

	var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;

	/**
	 * Parse the Accept-Language header.
	 * @private
	 */

	function parseAcceptLanguage(accept) {
	  var accepts = accept.split(',');

	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var language = parseLanguage(accepts[i].trim(), i);

	    if (language) {
	      accepts[j++] = language;
	    }
	  }

	  // trim accepts
	  accepts.length = j;

	  return accepts;
	}

	/**
	 * Parse a language from the Accept-Language header.
	 * @private
	 */

	function parseLanguage(str, i) {
	  var match = simpleLanguageRegExp.exec(str);
	  if (!match) return null;

	  var prefix = match[1];
	  var suffix = match[2];
	  var full = prefix;

	  if (suffix) full += "-" + suffix;

	  var q = 1;
	  if (match[3]) {
	    var params = match[3].split(';');
	    for (var j = 0; j < params.length; j++) {
	      var p = params[j].split('=');
	      if (p[0] === 'q') q = parseFloat(p[1]);
	    }
	  }

	  return {
	    prefix: prefix,
	    suffix: suffix,
	    q: q,
	    i: i,
	    full: full
	  };
	}

	/**
	 * Get the priority of a language.
	 * @private
	 */

	function getLanguagePriority(language, accepted, index) {
	  var priority = {o: -1, q: 0, s: 0};

	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(language, accepted[i], index);

	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }

	  return priority;
	}

	/**
	 * Get the specificity of the language.
	 * @private
	 */

	function specify(language, spec, index) {
	  var p = parseLanguage(language);
	  if (!p) return null;
	  var s = 0;
	  if(spec.full.toLowerCase() === p.full.toLowerCase()){
	    s |= 4;
	  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
	    s |= 2;
	  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
	    s |= 1;
	  } else if (spec.full !== '*' ) {
	    return null
	  }

	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s
	  }
	}
	/**
	 * Get the preferred languages from an Accept-Language header.
	 * @public
	 */

	function preferredLanguages(accept, provided) {
	  // RFC 2616 sec 14.4: no header = *
	  var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');

	  if (!provided) {
	    // sorted list of all languages
	    return accepts
	      .filter(isQuality)
	      .sort(compareSpecs)
	      .map(getFullLanguage);
	  }

	  var priorities = provided.map(function getPriority(type, index) {
	    return getLanguagePriority(type, accepts, index);
	  });

	  // sorted list of accepted languages
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}

	/**
	 * Compare two specs.
	 * @private
	 */

	function compareSpecs(a, b) {
	  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
	}

	/**
	 * Get full language string.
	 * @private
	 */

	function getFullLanguage(spec) {
	  return spec.full;
	}

	/**
	 * Check if a spec has any quality.
	 * @private
	 */

	function isQuality(spec) {
	  return spec.q > 0;
	}
	return language.exports;
}

var mediaType = {exports: {}};

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredMediaType;

function requireMediaType () {
	if (hasRequiredMediaType) return mediaType.exports;
	hasRequiredMediaType = 1;

	/**
	 * Module exports.
	 * @public
	 */

	mediaType.exports = preferredMediaTypes;
	mediaType.exports.preferredMediaTypes = preferredMediaTypes;

	/**
	 * Module variables.
	 * @private
	 */

	var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;

	/**
	 * Parse the Accept header.
	 * @private
	 */

	function parseAccept(accept) {
	  var accepts = splitMediaTypes(accept);

	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var mediaType = parseMediaType(accepts[i].trim(), i);

	    if (mediaType) {
	      accepts[j++] = mediaType;
	    }
	  }

	  // trim accepts
	  accepts.length = j;

	  return accepts;
	}

	/**
	 * Parse a media type from the Accept header.
	 * @private
	 */

	function parseMediaType(str, i) {
	  var match = simpleMediaTypeRegExp.exec(str);
	  if (!match) return null;

	  var params = Object.create(null);
	  var q = 1;
	  var subtype = match[2];
	  var type = match[1];

	  if (match[3]) {
	    var kvps = splitParameters(match[3]).map(splitKeyValuePair);

	    for (var j = 0; j < kvps.length; j++) {
	      var pair = kvps[j];
	      var key = pair[0].toLowerCase();
	      var val = pair[1];

	      // get the value, unwrapping quotes
	      var value = val && val[0] === '"' && val[val.length - 1] === '"'
	        ? val.substr(1, val.length - 2)
	        : val;

	      if (key === 'q') {
	        q = parseFloat(value);
	        break;
	      }

	      // store parameter
	      params[key] = value;
	    }
	  }

	  return {
	    type: type,
	    subtype: subtype,
	    params: params,
	    q: q,
	    i: i
	  };
	}

	/**
	 * Get the priority of a media type.
	 * @private
	 */

	function getMediaTypePriority(type, accepted, index) {
	  var priority = {o: -1, q: 0, s: 0};

	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(type, accepted[i], index);

	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }

	  return priority;
	}

	/**
	 * Get the specificity of the media type.
	 * @private
	 */

	function specify(type, spec, index) {
	  var p = parseMediaType(type);
	  var s = 0;

	  if (!p) {
	    return null;
	  }

	  if(spec.type.toLowerCase() == p.type.toLowerCase()) {
	    s |= 4;
	  } else if(spec.type != '*') {
	    return null;
	  }

	  if(spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
	    s |= 2;
	  } else if(spec.subtype != '*') {
	    return null;
	  }

	  var keys = Object.keys(spec.params);
	  if (keys.length > 0) {
	    if (keys.every(function (k) {
	      return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
	    })) {
	      s |= 1;
	    } else {
	      return null
	    }
	  }

	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s,
	  }
	}

	/**
	 * Get the preferred media types from an Accept header.
	 * @public
	 */

	function preferredMediaTypes(accept, provided) {
	  // RFC 2616 sec 14.2: no header = */*
	  var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');

	  if (!provided) {
	    // sorted list of all types
	    return accepts
	      .filter(isQuality)
	      .sort(compareSpecs)
	      .map(getFullType);
	  }

	  var priorities = provided.map(function getPriority(type, index) {
	    return getMediaTypePriority(type, accepts, index);
	  });

	  // sorted list of accepted types
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}

	/**
	 * Compare two specs.
	 * @private
	 */

	function compareSpecs(a, b) {
	  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
	}

	/**
	 * Get full type string.
	 * @private
	 */

	function getFullType(spec) {
	  return spec.type + '/' + spec.subtype;
	}

	/**
	 * Check if a spec has any quality.
	 * @private
	 */

	function isQuality(spec) {
	  return spec.q > 0;
	}

	/**
	 * Count the number of quotes in a string.
	 * @private
	 */

	function quoteCount(string) {
	  var count = 0;
	  var index = 0;

	  while ((index = string.indexOf('"', index)) !== -1) {
	    count++;
	    index++;
	  }

	  return count;
	}

	/**
	 * Split a key value pair.
	 * @private
	 */

	function splitKeyValuePair(str) {
	  var index = str.indexOf('=');
	  var key;
	  var val;

	  if (index === -1) {
	    key = str;
	  } else {
	    key = str.substr(0, index);
	    val = str.substr(index + 1);
	  }

	  return [key, val];
	}

	/**
	 * Split an Accept header into media types.
	 * @private
	 */

	function splitMediaTypes(accept) {
	  var accepts = accept.split(',');

	  for (var i = 1, j = 0; i < accepts.length; i++) {
	    if (quoteCount(accepts[j]) % 2 == 0) {
	      accepts[++j] = accepts[i];
	    } else {
	      accepts[j] += ',' + accepts[i];
	    }
	  }

	  // trim accepts
	  accepts.length = j + 1;

	  return accepts;
	}

	/**
	 * Split a string of parameters.
	 * @private
	 */

	function splitParameters(str) {
	  var parameters = str.split(';');

	  for (var i = 1, j = 0; i < parameters.length; i++) {
	    if (quoteCount(parameters[j]) % 2 == 0) {
	      parameters[++j] = parameters[i];
	    } else {
	      parameters[j] += ';' + parameters[i];
	    }
	  }

	  // trim parameters
	  parameters.length = j + 1;

	  for (var i = 0; i < parameters.length; i++) {
	    parameters[i] = parameters[i].trim();
	  }

	  return parameters;
	}
	return mediaType.exports;
}

/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredNegotiator;

function requireNegotiator () {
	if (hasRequiredNegotiator) return negotiator.exports;
	hasRequiredNegotiator = 1;

	var preferredCharsets = requireCharset();
	var preferredEncodings = requireEncoding$1();
	var preferredLanguages = requireLanguage();
	var preferredMediaTypes = requireMediaType();

	/**
	 * Module exports.
	 * @public
	 */

	negotiator.exports = Negotiator;
	negotiator.exports.Negotiator = Negotiator;

	/**
	 * Create a Negotiator instance from a request.
	 * @param {object} request
	 * @public
	 */

	function Negotiator(request) {
	  if (!(this instanceof Negotiator)) {
	    return new Negotiator(request);
	  }

	  this.request = request;
	}

	Negotiator.prototype.charset = function charset(available) {
	  var set = this.charsets(available);
	  return set && set[0];
	};

	Negotiator.prototype.charsets = function charsets(available) {
	  return preferredCharsets(this.request.headers['accept-charset'], available);
	};

	Negotiator.prototype.encoding = function encoding(available) {
	  var set = this.encodings(available);
	  return set && set[0];
	};

	Negotiator.prototype.encodings = function encodings(available) {
	  return preferredEncodings(this.request.headers['accept-encoding'], available);
	};

	Negotiator.prototype.language = function language(available) {
	  var set = this.languages(available);
	  return set && set[0];
	};

	Negotiator.prototype.languages = function languages(available) {
	  return preferredLanguages(this.request.headers['accept-language'], available);
	};

	Negotiator.prototype.mediaType = function mediaType(available) {
	  var set = this.mediaTypes(available);
	  return set && set[0];
	};

	Negotiator.prototype.mediaTypes = function mediaTypes(available) {
	  return preferredMediaTypes(this.request.headers.accept, available);
	};

	// Backwards compatibility
	Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
	Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
	Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
	Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
	Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
	Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
	Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
	Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
	return negotiator.exports;
}

/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var accepts;
var hasRequiredAccepts;

function requireAccepts () {
	if (hasRequiredAccepts) return accepts;
	hasRequiredAccepts = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var Negotiator = requireNegotiator();
	var mime = requireMimeTypes();

	/**
	 * Module exports.
	 * @public
	 */

	accepts = Accepts;

	/**
	 * Create a new Accepts object for the given req.
	 *
	 * @param {object} req
	 * @public
	 */

	function Accepts (req) {
	  if (!(this instanceof Accepts)) {
	    return new Accepts(req)
	  }

	  this.headers = req.headers;
	  this.negotiator = new Negotiator(req);
	}

	/**
	 * Check if the given `type(s)` is acceptable, returning
	 * the best match when true, otherwise `undefined`, in which
	 * case you should respond with 406 "Not Acceptable".
	 *
	 * The `type` value may be a single mime type string
	 * such as "application/json", the extension name
	 * such as "json" or an array `["json", "html", "text/plain"]`. When a list
	 * or array is given the _best_ match, if any is returned.
	 *
	 * Examples:
	 *
	 *     // Accept: text/html
	 *     this.types('html');
	 *     // => "html"
	 *
	 *     // Accept: text/*, application/json
	 *     this.types('html');
	 *     // => "html"
	 *     this.types('text/html');
	 *     // => "text/html"
	 *     this.types('json', 'text');
	 *     // => "json"
	 *     this.types('application/json');
	 *     // => "application/json"
	 *
	 *     // Accept: text/*, application/json
	 *     this.types('image/png');
	 *     this.types('png');
	 *     // => undefined
	 *
	 *     // Accept: text/*;q=.5, application/json
	 *     this.types(['html', 'json']);
	 *     this.types('html', 'json');
	 *     // => "json"
	 *
	 * @param {String|Array} types...
	 * @return {String|Array|Boolean}
	 * @public
	 */

	Accepts.prototype.type =
	Accepts.prototype.types = function (types_) {
	  var types = types_;

	  // support flattened arguments
	  if (types && !Array.isArray(types)) {
	    types = new Array(arguments.length);
	    for (var i = 0; i < types.length; i++) {
	      types[i] = arguments[i];
	    }
	  }

	  // no types, return all requested types
	  if (!types || types.length === 0) {
	    return this.negotiator.mediaTypes()
	  }

	  // no accept header, return first given type
	  if (!this.headers.accept) {
	    return types[0]
	  }

	  var mimes = types.map(extToMime);
	  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
	  var first = accepts[0];

	  return first
	    ? types[mimes.indexOf(first)]
	    : false
	};

	/**
	 * Return accepted encodings or best fit based on `encodings`.
	 *
	 * Given `Accept-Encoding: gzip, deflate`
	 * an array sorted by quality is returned:
	 *
	 *     ['gzip', 'deflate']
	 *
	 * @param {String|Array} encodings...
	 * @return {String|Array}
	 * @public
	 */

	Accepts.prototype.encoding =
	Accepts.prototype.encodings = function (encodings_) {
	  var encodings = encodings_;

	  // support flattened arguments
	  if (encodings && !Array.isArray(encodings)) {
	    encodings = new Array(arguments.length);
	    for (var i = 0; i < encodings.length; i++) {
	      encodings[i] = arguments[i];
	    }
	  }

	  // no encodings, return all requested encodings
	  if (!encodings || encodings.length === 0) {
	    return this.negotiator.encodings()
	  }

	  return this.negotiator.encodings(encodings)[0] || false
	};

	/**
	 * Return accepted charsets or best fit based on `charsets`.
	 *
	 * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
	 * an array sorted by quality is returned:
	 *
	 *     ['utf-8', 'utf-7', 'iso-8859-1']
	 *
	 * @param {String|Array} charsets...
	 * @return {String|Array}
	 * @public
	 */

	Accepts.prototype.charset =
	Accepts.prototype.charsets = function (charsets_) {
	  var charsets = charsets_;

	  // support flattened arguments
	  if (charsets && !Array.isArray(charsets)) {
	    charsets = new Array(arguments.length);
	    for (var i = 0; i < charsets.length; i++) {
	      charsets[i] = arguments[i];
	    }
	  }

	  // no charsets, return all requested charsets
	  if (!charsets || charsets.length === 0) {
	    return this.negotiator.charsets()
	  }

	  return this.negotiator.charsets(charsets)[0] || false
	};

	/**
	 * Return accepted languages or best fit based on `langs`.
	 *
	 * Given `Accept-Language: en;q=0.8, es, pt`
	 * an array sorted by quality is returned:
	 *
	 *     ['es', 'pt', 'en']
	 *
	 * @param {String|Array} langs...
	 * @return {Array|String}
	 * @public
	 */

	Accepts.prototype.lang =
	Accepts.prototype.langs =
	Accepts.prototype.language =
	Accepts.prototype.languages = function (languages_) {
	  var languages = languages_;

	  // support flattened arguments
	  if (languages && !Array.isArray(languages)) {
	    languages = new Array(arguments.length);
	    for (var i = 0; i < languages.length; i++) {
	      languages[i] = arguments[i];
	    }
	  }

	  // no languages, return all requested languages
	  if (!languages || languages.length === 0) {
	    return this.negotiator.languages()
	  }

	  return this.negotiator.languages(languages)[0] || false
	};

	/**
	 * Convert extnames to mime.
	 *
	 * @param {String} type
	 * @return {String}
	 * @private
	 */

	function extToMime (type) {
	  return type.indexOf('/') === -1
	    ? mime.lookup(type)
	    : type
	}

	/**
	 * Check if mime is valid.
	 *
	 * @param {String} type
	 * @return {String}
	 * @private
	 */

	function validMime (type) {
	  return typeof type === 'string'
	}
	return accepts;
}

/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var request;
var hasRequiredRequest;

function requireRequest () {
	if (hasRequiredRequest) return request;
	hasRequiredRequest = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var accepts = requireAccepts();
	var deprecate = requireDepd()('express');
	var isIP = require$$0$7.isIP;
	var typeis = requireTypeIs();
	var http = require$$0$b;
	var fresh = requireFresh();
	var parseRange = requireRangeParser();
	var parse = requireParseurl();
	var proxyaddr = requireProxyAddr();

	/**
	 * Request prototype.
	 * @public
	 */

	var req = Object.create(http.IncomingMessage.prototype);

	/**
	 * Module exports.
	 * @public
	 */

	request = req;

	/**
	 * Return request header.
	 *
	 * The `Referrer` header field is special-cased,
	 * both `Referrer` and `Referer` are interchangeable.
	 *
	 * Examples:
	 *
	 *     req.get('Content-Type');
	 *     // => "text/plain"
	 *
	 *     req.get('content-type');
	 *     // => "text/plain"
	 *
	 *     req.get('Something');
	 *     // => undefined
	 *
	 * Aliased as `req.header()`.
	 *
	 * @param {String} name
	 * @return {String}
	 * @public
	 */

	req.get =
	req.header = function header(name) {
	  if (!name) {
	    throw new TypeError('name argument is required to req.get');
	  }

	  if (typeof name !== 'string') {
	    throw new TypeError('name must be a string to req.get');
	  }

	  var lc = name.toLowerCase();

	  switch (lc) {
	    case 'referer':
	    case 'referrer':
	      return this.headers.referrer
	        || this.headers.referer;
	    default:
	      return this.headers[lc];
	  }
	};

	/**
	 * To do: update docs.
	 *
	 * Check if the given `type(s)` is acceptable, returning
	 * the best match when true, otherwise `undefined`, in which
	 * case you should respond with 406 "Not Acceptable".
	 *
	 * The `type` value may be a single MIME type string
	 * such as "application/json", an extension name
	 * such as "json", a comma-delimited list such as "json, html, text/plain",
	 * an argument list such as `"json", "html", "text/plain"`,
	 * or an array `["json", "html", "text/plain"]`. When a list
	 * or array is given, the _best_ match, if any is returned.
	 *
	 * Examples:
	 *
	 *     // Accept: text/html
	 *     req.accepts('html');
	 *     // => "html"
	 *
	 *     // Accept: text/*, application/json
	 *     req.accepts('html');
	 *     // => "html"
	 *     req.accepts('text/html');
	 *     // => "text/html"
	 *     req.accepts('json, text');
	 *     // => "json"
	 *     req.accepts('application/json');
	 *     // => "application/json"
	 *
	 *     // Accept: text/*, application/json
	 *     req.accepts('image/png');
	 *     req.accepts('png');
	 *     // => undefined
	 *
	 *     // Accept: text/*;q=.5, application/json
	 *     req.accepts(['html', 'json']);
	 *     req.accepts('html', 'json');
	 *     req.accepts('html, json');
	 *     // => "json"
	 *
	 * @param {String|Array} type(s)
	 * @return {String|Array|Boolean}
	 * @public
	 */

	req.accepts = function(){
	  var accept = accepts(this);
	  return accept.types.apply(accept, arguments);
	};

	/**
	 * Check if the given `encoding`s are accepted.
	 *
	 * @param {String} ...encoding
	 * @return {String|Array}
	 * @public
	 */

	req.acceptsEncodings = function(){
	  var accept = accepts(this);
	  return accept.encodings.apply(accept, arguments);
	};

	req.acceptsEncoding = deprecate.function(req.acceptsEncodings,
	  'req.acceptsEncoding: Use acceptsEncodings instead');

	/**
	 * Check if the given `charset`s are acceptable,
	 * otherwise you should respond with 406 "Not Acceptable".
	 *
	 * @param {String} ...charset
	 * @return {String|Array}
	 * @public
	 */

	req.acceptsCharsets = function(){
	  var accept = accepts(this);
	  return accept.charsets.apply(accept, arguments);
	};

	req.acceptsCharset = deprecate.function(req.acceptsCharsets,
	  'req.acceptsCharset: Use acceptsCharsets instead');

	/**
	 * Check if the given `lang`s are acceptable,
	 * otherwise you should respond with 406 "Not Acceptable".
	 *
	 * @param {String} ...lang
	 * @return {String|Array}
	 * @public
	 */

	req.acceptsLanguages = function(){
	  var accept = accepts(this);
	  return accept.languages.apply(accept, arguments);
	};

	req.acceptsLanguage = deprecate.function(req.acceptsLanguages,
	  'req.acceptsLanguage: Use acceptsLanguages instead');

	/**
	 * Parse Range header field, capping to the given `size`.
	 *
	 * Unspecified ranges such as "0-" require knowledge of your resource length. In
	 * the case of a byte range this is of course the total number of bytes. If the
	 * Range header field is not given `undefined` is returned, `-1` when unsatisfiable,
	 * and `-2` when syntactically invalid.
	 *
	 * When ranges are returned, the array has a "type" property which is the type of
	 * range that is required (most commonly, "bytes"). Each array element is an object
	 * with a "start" and "end" property for the portion of the range.
	 *
	 * The "combine" option can be set to `true` and overlapping & adjacent ranges
	 * will be combined into a single range.
	 *
	 * NOTE: remember that ranges are inclusive, so for example "Range: users=0-3"
	 * should respond with 4 users when available, not 3.
	 *
	 * @param {number} size
	 * @param {object} [options]
	 * @param {boolean} [options.combine=false]
	 * @return {number|array}
	 * @public
	 */

	req.range = function range(size, options) {
	  var range = this.get('Range');
	  if (!range) return;
	  return parseRange(size, range, options);
	};

	/**
	 * Return the value of param `name` when present or `defaultValue`.
	 *
	 *  - Checks route placeholders, ex: _/user/:id_
	 *  - Checks body params, ex: id=12, {"id":12}
	 *  - Checks query string params, ex: ?id=12
	 *
	 * To utilize request bodies, `req.body`
	 * should be an object. This can be done by using
	 * the `bodyParser()` middleware.
	 *
	 * @param {String} name
	 * @param {Mixed} [defaultValue]
	 * @return {String}
	 * @public
	 */

	req.param = function param(name, defaultValue) {
	  var params = this.params || {};
	  var body = this.body || {};
	  var query = this.query || {};

	  var args = arguments.length === 1
	    ? 'name'
	    : 'name, default';
	  deprecate('req.param(' + args + '): Use req.params, req.body, or req.query instead');

	  if (null != params[name] && params.hasOwnProperty(name)) return params[name];
	  if (null != body[name]) return body[name];
	  if (null != query[name]) return query[name];

	  return defaultValue;
	};

	/**
	 * Check if the incoming request contains the "Content-Type"
	 * header field, and it contains the given mime `type`.
	 *
	 * Examples:
	 *
	 *      // With Content-Type: text/html; charset=utf-8
	 *      req.is('html');
	 *      req.is('text/html');
	 *      req.is('text/*');
	 *      // => true
	 *
	 *      // When Content-Type is application/json
	 *      req.is('json');
	 *      req.is('application/json');
	 *      req.is('application/*');
	 *      // => true
	 *
	 *      req.is('html');
	 *      // => false
	 *
	 * @param {String|Array} types...
	 * @return {String|false|null}
	 * @public
	 */

	req.is = function is(types) {
	  var arr = types;

	  // support flattened arguments
	  if (!Array.isArray(types)) {
	    arr = new Array(arguments.length);
	    for (var i = 0; i < arr.length; i++) {
	      arr[i] = arguments[i];
	    }
	  }

	  return typeis(this, arr);
	};

	/**
	 * Return the protocol string "http" or "https"
	 * when requested with TLS. When the "trust proxy"
	 * setting trusts the socket address, the
	 * "X-Forwarded-Proto" header field will be trusted
	 * and used if present.
	 *
	 * If you're running behind a reverse proxy that
	 * supplies https for you this may be enabled.
	 *
	 * @return {String}
	 * @public
	 */

	defineGetter(req, 'protocol', function protocol(){
	  var proto = this.connection.encrypted
	    ? 'https'
	    : 'http';
	  var trust = this.app.get('trust proxy fn');

	  if (!trust(this.connection.remoteAddress, 0)) {
	    return proto;
	  }

	  // Note: X-Forwarded-Proto is normally only ever a
	  //       single value, but this is to be safe.
	  var header = this.get('X-Forwarded-Proto') || proto;
	  var index = header.indexOf(',');

	  return index !== -1
	    ? header.substring(0, index).trim()
	    : header.trim()
	});

	/**
	 * Short-hand for:
	 *
	 *    req.protocol === 'https'
	 *
	 * @return {Boolean}
	 * @public
	 */

	defineGetter(req, 'secure', function secure(){
	  return this.protocol === 'https';
	});

	/**
	 * Return the remote address from the trusted proxy.
	 *
	 * The is the remote address on the socket unless
	 * "trust proxy" is set.
	 *
	 * @return {String}
	 * @public
	 */

	defineGetter(req, 'ip', function ip(){
	  var trust = this.app.get('trust proxy fn');
	  return proxyaddr(this, trust);
	});

	/**
	 * When "trust proxy" is set, trusted proxy addresses + client.
	 *
	 * For example if the value were "client, proxy1, proxy2"
	 * you would receive the array `["client", "proxy1", "proxy2"]`
	 * where "proxy2" is the furthest down-stream and "proxy1" and
	 * "proxy2" were trusted.
	 *
	 * @return {Array}
	 * @public
	 */

	defineGetter(req, 'ips', function ips() {
	  var trust = this.app.get('trust proxy fn');
	  var addrs = proxyaddr.all(this, trust);

	  // reverse the order (to farthest -> closest)
	  // and remove socket address
	  addrs.reverse().pop();

	  return addrs
	});

	/**
	 * Return subdomains as an array.
	 *
	 * Subdomains are the dot-separated parts of the host before the main domain of
	 * the app. By default, the domain of the app is assumed to be the last two
	 * parts of the host. This can be changed by setting "subdomain offset".
	 *
	 * For example, if the domain is "tobi.ferrets.example.com":
	 * If "subdomain offset" is not set, req.subdomains is `["ferrets", "tobi"]`.
	 * If "subdomain offset" is 3, req.subdomains is `["tobi"]`.
	 *
	 * @return {Array}
	 * @public
	 */

	defineGetter(req, 'subdomains', function subdomains() {
	  var hostname = this.hostname;

	  if (!hostname) return [];

	  var offset = this.app.get('subdomain offset');
	  var subdomains = !isIP(hostname)
	    ? hostname.split('.').reverse()
	    : [hostname];

	  return subdomains.slice(offset);
	});

	/**
	 * Short-hand for `url.parse(req.url).pathname`.
	 *
	 * @return {String}
	 * @public
	 */

	defineGetter(req, 'path', function path() {
	  return parse(this).pathname;
	});

	/**
	 * Parse the "Host" header field to a hostname.
	 *
	 * When the "trust proxy" setting trusts the socket
	 * address, the "X-Forwarded-Host" header field will
	 * be trusted.
	 *
	 * @return {String}
	 * @public
	 */

	defineGetter(req, 'hostname', function hostname(){
	  var trust = this.app.get('trust proxy fn');
	  var host = this.get('X-Forwarded-Host');

	  if (!host || !trust(this.connection.remoteAddress, 0)) {
	    host = this.get('Host');
	  } else if (host.indexOf(',') !== -1) {
	    // Note: X-Forwarded-Host is normally only ever a
	    //       single value, but this is to be safe.
	    host = host.substring(0, host.indexOf(',')).trimRight();
	  }

	  if (!host) return;

	  // IPv6 literal support
	  var offset = host[0] === '['
	    ? host.indexOf(']') + 1
	    : 0;
	  var index = host.indexOf(':', offset);

	  return index !== -1
	    ? host.substring(0, index)
	    : host;
	});

	// TODO: change req.host to return host in next major

	defineGetter(req, 'host', deprecate.function(function host(){
	  return this.hostname;
	}, 'req.host: Use req.hostname instead'));

	/**
	 * Check if the request is fresh, aka
	 * Last-Modified and/or the ETag
	 * still match.
	 *
	 * @return {Boolean}
	 * @public
	 */

	defineGetter(req, 'fresh', function(){
	  var method = this.method;
	  var res = this.res;
	  var status = res.statusCode;

	  // GET or HEAD for weak freshness validation only
	  if ('GET' !== method && 'HEAD' !== method) return false;

	  // 2xx or 304 as per rfc2616 14.26
	  if ((status >= 200 && status < 300) || 304 === status) {
	    return fresh(this.headers, {
	      'etag': res.get('ETag'),
	      'last-modified': res.get('Last-Modified')
	    })
	  }

	  return false;
	});

	/**
	 * Check if the request is stale, aka
	 * "Last-Modified" and / or the "ETag" for the
	 * resource has changed.
	 *
	 * @return {Boolean}
	 * @public
	 */

	defineGetter(req, 'stale', function stale(){
	  return !this.fresh;
	});

	/**
	 * Check if the request was an _XMLHttpRequest_.
	 *
	 * @return {Boolean}
	 * @public
	 */

	defineGetter(req, 'xhr', function xhr(){
	  var val = this.get('X-Requested-With') || '';
	  return val.toLowerCase() === 'xmlhttprequest';
	});

	/**
	 * Helper function for creating a getter on an object.
	 *
	 * @param {Object} obj
	 * @param {String} name
	 * @param {Function} getter
	 * @private
	 */
	function defineGetter(obj, name, getter) {
	  Object.defineProperty(obj, name, {
	    configurable: true,
	    enumerable: true,
	    get: getter
	  });
	}
	return request;
}

var cookieSignature = {};

/**
 * Module dependencies.
 */

var hasRequiredCookieSignature;

function requireCookieSignature () {
	if (hasRequiredCookieSignature) return cookieSignature;
	hasRequiredCookieSignature = 1;
	(function (exports) {
		var crypto = require$$0$c;

		/**
		 * Sign the given `val` with `secret`.
		 *
		 * @param {String} val
		 * @param {String} secret
		 * @return {String}
		 * @api private
		 */

		exports.sign = function(val, secret){
		  if ('string' != typeof val) throw new TypeError("Cookie value must be provided as a string.");
		  if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
		  return val + '.' + crypto
		    .createHmac('sha256', secret)
		    .update(val)
		    .digest('base64')
		    .replace(/\=+$/, '');
		};

		/**
		 * Unsign and decode the given `val` with `secret`,
		 * returning `false` if the signature is invalid.
		 *
		 * @param {String} val
		 * @param {String} secret
		 * @return {String|Boolean}
		 * @api private
		 */

		exports.unsign = function(val, secret){
		  if ('string' != typeof val) throw new TypeError("Signed cookie string must be provided.");
		  if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
		  var str = val.slice(0, val.lastIndexOf('.'))
		    , mac = exports.sign(str, secret);
		  
		  return sha1(mac) == sha1(val) ? str : false;
		};

		/**
		 * Private
		 */

		function sha1(str){
		  return crypto.createHash('sha1').update(str).digest('hex');
		} 
	} (cookieSignature));
	return cookieSignature;
}

var cookie$1 = {};

/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredCookie$1;

function requireCookie$1 () {
	if (hasRequiredCookie$1) return cookie$1;
	hasRequiredCookie$1 = 1;

	/**
	 * Module exports.
	 * @public
	 */

	cookie$1.parse = parse;
	cookie$1.serialize = serialize;

	/**
	 * Module variables.
	 * @private
	 */

	var __toString = Object.prototype.toString;

	/**
	 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
	 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
	 * which has been replaced by the token definition in RFC 7230 appendix B.
	 *
	 * cookie-name       = token
	 * token             = 1*tchar
	 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
	 *                     "*" / "+" / "-" / "." / "^" / "_" /
	 *                     "`" / "|" / "~" / DIGIT / ALPHA
	 */

	var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

	/**
	 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
	 *
	 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
	 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
	 *                     ; US-ASCII characters excluding CTLs,
	 *                     ; whitespace DQUOTE, comma, semicolon,
	 *                     ; and backslash
	 */

	var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;

	/**
	 * RegExp to match domain-value in RFC 6265 sec 4.1.1
	 *
	 * domain-value      = <subdomain>
	 *                     ; defined in [RFC1034], Section 3.5, as
	 *                     ; enhanced by [RFC1123], Section 2.1
	 * <subdomain>       = <label> | <subdomain> "." <label>
	 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
	 *                     Labels must be 63 characters or less.
	 *                     'let-dig' not 'letter' in the first char, per RFC1123
	 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
	 * <let-dig-hyp>     = <let-dig> | "-"
	 * <let-dig>         = <letter> | <digit>
	 * <letter>          = any one of the 52 alphabetic characters A through Z in
	 *                     upper case and a through z in lower case
	 * <digit>           = any one of the ten digits 0 through 9
	 *
	 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
	 *
	 * > (Note that a leading %x2E ("."), if present, is ignored even though that
	 * character is not permitted, but a trailing %x2E ("."), if present, will
	 * cause the user agent to ignore the attribute.)
	 */

	var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;

	/**
	 * RegExp to match path-value in RFC 6265 sec 4.1.1
	 *
	 * path-value        = <any CHAR except CTLs or ";">
	 * CHAR              = %x01-7F
	 *                     ; defined in RFC 5234 appendix B.1
	 */

	var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;

	/**
	 * Parse a cookie header.
	 *
	 * Parse the given cookie header string into an object
	 * The object has the various cookies as keys(names) => values
	 *
	 * @param {string} str
	 * @param {object} [opt]
	 * @return {object}
	 * @public
	 */

	function parse(str, opt) {
	  if (typeof str !== 'string') {
	    throw new TypeError('argument str must be a string');
	  }

	  var obj = {};
	  var len = str.length;
	  // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
	  if (len < 2) return obj;

	  var dec = (opt && opt.decode) || decode;
	  var index = 0;
	  var eqIdx = 0;
	  var endIdx = 0;

	  do {
	    eqIdx = str.indexOf('=', index);
	    if (eqIdx === -1) break; // No more cookie pairs.

	    endIdx = str.indexOf(';', index);

	    if (endIdx === -1) {
	      endIdx = len;
	    } else if (eqIdx > endIdx) {
	      // backtrack on prior semicolon
	      index = str.lastIndexOf(';', eqIdx - 1) + 1;
	      continue;
	    }

	    var keyStartIdx = startIndex(str, index, eqIdx);
	    var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
	    var key = str.slice(keyStartIdx, keyEndIdx);

	    // only assign once
	    if (!obj.hasOwnProperty(key)) {
	      var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
	      var valEndIdx = endIndex(str, endIdx, valStartIdx);

	      if (str.charCodeAt(valStartIdx) === 0x22 /* " */ && str.charCodeAt(valEndIdx - 1) === 0x22 /* " */) {
	        valStartIdx++;
	        valEndIdx--;
	      }

	      var val = str.slice(valStartIdx, valEndIdx);
	      obj[key] = tryDecode(val, dec);
	    }

	    index = endIdx + 1;
	  } while (index < len);

	  return obj;
	}

	function startIndex(str, index, max) {
	  do {
	    var code = str.charCodeAt(index);
	    if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index;
	  } while (++index < max);
	  return max;
	}

	function endIndex(str, index, min) {
	  while (index > min) {
	    var code = str.charCodeAt(--index);
	    if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index + 1;
	  }
	  return min;
	}

	/**
	 * Serialize data into a cookie header.
	 *
	 * Serialize a name value pair into a cookie string suitable for
	 * http headers. An optional options object specifies cookie parameters.
	 *
	 * serialize('foo', 'bar', { httpOnly: true })
	 *   => "foo=bar; httpOnly"
	 *
	 * @param {string} name
	 * @param {string} val
	 * @param {object} [opt]
	 * @return {string}
	 * @public
	 */

	function serialize(name, val, opt) {
	  var enc = (opt && opt.encode) || encodeURIComponent;

	  if (typeof enc !== 'function') {
	    throw new TypeError('option encode is invalid');
	  }

	  if (!cookieNameRegExp.test(name)) {
	    throw new TypeError('argument name is invalid');
	  }

	  var value = enc(val);

	  if (!cookieValueRegExp.test(value)) {
	    throw new TypeError('argument val is invalid');
	  }

	  var str = name + '=' + value;
	  if (!opt) return str;

	  if (null != opt.maxAge) {
	    var maxAge = Math.floor(opt.maxAge);

	    if (!isFinite(maxAge)) {
	      throw new TypeError('option maxAge is invalid')
	    }

	    str += '; Max-Age=' + maxAge;
	  }

	  if (opt.domain) {
	    if (!domainValueRegExp.test(opt.domain)) {
	      throw new TypeError('option domain is invalid');
	    }

	    str += '; Domain=' + opt.domain;
	  }

	  if (opt.path) {
	    if (!pathValueRegExp.test(opt.path)) {
	      throw new TypeError('option path is invalid');
	    }

	    str += '; Path=' + opt.path;
	  }

	  if (opt.expires) {
	    var expires = opt.expires;

	    if (!isDate(expires) || isNaN(expires.valueOf())) {
	      throw new TypeError('option expires is invalid');
	    }

	    str += '; Expires=' + expires.toUTCString();
	  }

	  if (opt.httpOnly) {
	    str += '; HttpOnly';
	  }

	  if (opt.secure) {
	    str += '; Secure';
	  }

	  if (opt.partitioned) {
	    str += '; Partitioned';
	  }

	  if (opt.priority) {
	    var priority = typeof opt.priority === 'string'
	      ? opt.priority.toLowerCase() : opt.priority;

	    switch (priority) {
	      case 'low':
	        str += '; Priority=Low';
	        break
	      case 'medium':
	        str += '; Priority=Medium';
	        break
	      case 'high':
	        str += '; Priority=High';
	        break
	      default:
	        throw new TypeError('option priority is invalid')
	    }
	  }

	  if (opt.sameSite) {
	    var sameSite = typeof opt.sameSite === 'string'
	      ? opt.sameSite.toLowerCase() : opt.sameSite;

	    switch (sameSite) {
	      case true:
	        str += '; SameSite=Strict';
	        break;
	      case 'lax':
	        str += '; SameSite=Lax';
	        break;
	      case 'strict':
	        str += '; SameSite=Strict';
	        break;
	      case 'none':
	        str += '; SameSite=None';
	        break;
	      default:
	        throw new TypeError('option sameSite is invalid');
	    }
	  }

	  return str;
	}

	/**
	 * URL-decode string value. Optimized to skip native call when no %.
	 *
	 * @param {string} str
	 * @returns {string}
	 */

	function decode (str) {
	  return str.indexOf('%') !== -1
	    ? decodeURIComponent(str)
	    : str
	}

	/**
	 * Determine if value is a Date.
	 *
	 * @param {*} val
	 * @private
	 */

	function isDate (val) {
	  return __toString.call(val) === '[object Date]';
	}

	/**
	 * Try decoding a string using a decoding function.
	 *
	 * @param {string} str
	 * @param {function} decode
	 * @private
	 */

	function tryDecode(str, decode) {
	  try {
	    return decode(str);
	  } catch (e) {
	    return str;
	  }
	}
	return cookie$1;
}

var vary = {exports: {}};

/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredVary;

function requireVary () {
	if (hasRequiredVary) return vary.exports;
	hasRequiredVary = 1;

	/**
	 * Module exports.
	 */

	vary.exports = vary$1;
	vary.exports.append = append;

	/**
	 * RegExp to match field-name in RFC 7230 sec 3.2
	 *
	 * field-name    = token
	 * token         = 1*tchar
	 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	 *               / DIGIT / ALPHA
	 *               ; any VCHAR, except delimiters
	 */

	var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

	/**
	 * Append a field to a vary header.
	 *
	 * @param {String} header
	 * @param {String|Array} field
	 * @return {String}
	 * @public
	 */

	function append (header, field) {
	  if (typeof header !== 'string') {
	    throw new TypeError('header argument is required')
	  }

	  if (!field) {
	    throw new TypeError('field argument is required')
	  }

	  // get fields array
	  var fields = !Array.isArray(field)
	    ? parse(String(field))
	    : field;

	  // assert on invalid field names
	  for (var j = 0; j < fields.length; j++) {
	    if (!FIELD_NAME_REGEXP.test(fields[j])) {
	      throw new TypeError('field argument contains an invalid header name')
	    }
	  }

	  // existing, unspecified vary
	  if (header === '*') {
	    return header
	  }

	  // enumerate current values
	  var val = header;
	  var vals = parse(header.toLowerCase());

	  // unspecified vary
	  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
	    return '*'
	  }

	  for (var i = 0; i < fields.length; i++) {
	    var fld = fields[i].toLowerCase();

	    // append value (case-preserving)
	    if (vals.indexOf(fld) === -1) {
	      vals.push(fld);
	      val = val
	        ? val + ', ' + fields[i]
	        : fields[i];
	    }
	  }

	  return val
	}

	/**
	 * Parse a vary header into an array.
	 *
	 * @param {String} header
	 * @return {Array}
	 * @private
	 */

	function parse (header) {
	  var end = 0;
	  var list = [];
	  var start = 0;

	  // gather tokens
	  for (var i = 0, len = header.length; i < len; i++) {
	    switch (header.charCodeAt(i)) {
	      case 0x20: /*   */
	        if (start === end) {
	          start = end = i + 1;
	        }
	        break
	      case 0x2c: /* , */
	        list.push(header.substring(start, end));
	        start = end = i + 1;
	        break
	      default:
	        end = i + 1;
	        break
	    }
	  }

	  // final token
	  list.push(header.substring(start, end));

	  return list
	}

	/**
	 * Mark that a request is varied on a header field.
	 *
	 * @param {Object} res
	 * @param {String|Array} field
	 * @public
	 */

	function vary$1 (res, field) {
	  if (!res || !res.getHeader || !res.setHeader) {
	    // quack quack
	    throw new TypeError('res argument is required')
	  }

	  // get existing header
	  var val = res.getHeader('Vary') || '';
	  var header = Array.isArray(val)
	    ? val.join(', ')
	    : String(val);

	  // set new header
	  if ((val = append(header, field))) {
	    res.setHeader('Vary', val);
	  }
	}
	return vary.exports;
}

/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var response;
var hasRequiredResponse;

function requireResponse () {
	if (hasRequiredResponse) return response;
	hasRequiredResponse = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var Buffer = requireSafeBuffer$1().Buffer;
	var contentDisposition = requireContentDisposition();
	var createError = requireHttpErrors();
	var deprecate = requireDepd()('express');
	var encodeUrl = requireEncodeurl$1();
	var escapeHtml = requireEscapeHtml();
	var http = require$$0$b;
	var isAbsolute = requireUtils$2().isAbsolute;
	var onFinished = requireOnFinished();
	var path = require$$0$4;
	var statuses = requireStatuses();
	var merge = requireUtilsMerge();
	var sign = requireCookieSignature().sign;
	var normalizeType = requireUtils$2().normalizeType;
	var normalizeTypes = requireUtils$2().normalizeTypes;
	var setCharset = requireUtils$2().setCharset;
	var cookie = requireCookie$1();
	var send = requireSend();
	var extname = path.extname;
	var mime = send.mime;
	var resolve = path.resolve;
	var vary = requireVary();

	/**
	 * Response prototype.
	 * @public
	 */

	var res = Object.create(http.ServerResponse.prototype);

	/**
	 * Module exports.
	 * @public
	 */

	response = res;

	/**
	 * Module variables.
	 * @private
	 */

	var charsetRegExp = /;\s*charset\s*=/;

	/**
	 * Set status `code`.
	 *
	 * @param {Number} code
	 * @return {ServerResponse}
	 * @public
	 */

	res.status = function status(code) {
	  if ((typeof code === 'string' || Math.floor(code) !== code) && code > 99 && code < 1000) {
	    deprecate('res.status(' + JSON.stringify(code) + '): use res.status(' + Math.floor(code) + ') instead');
	  }
	  this.statusCode = code;
	  return this;
	};

	/**
	 * Set Link header field with the given `links`.
	 *
	 * Examples:
	 *
	 *    res.links({
	 *      next: 'http://api.example.com/users?page=2',
	 *      last: 'http://api.example.com/users?page=5'
	 *    });
	 *
	 * @param {Object} links
	 * @return {ServerResponse}
	 * @public
	 */

	res.links = function(links){
	  var link = this.get('Link') || '';
	  if (link) link += ', ';
	  return this.set('Link', link + Object.keys(links).map(function(rel){
	    return '<' + links[rel] + '>; rel="' + rel + '"';
	  }).join(', '));
	};

	/**
	 * Send a response.
	 *
	 * Examples:
	 *
	 *     res.send(Buffer.from('wahoo'));
	 *     res.send({ some: 'json' });
	 *     res.send('<p>some html</p>');
	 *
	 * @param {string|number|boolean|object|Buffer} body
	 * @public
	 */

	res.send = function send(body) {
	  var chunk = body;
	  var encoding;
	  var req = this.req;
	  var type;

	  // settings
	  var app = this.app;

	  // allow status / body
	  if (arguments.length === 2) {
	    // res.send(body, status) backwards compat
	    if (typeof arguments[0] !== 'number' && typeof arguments[1] === 'number') {
	      deprecate('res.send(body, status): Use res.status(status).send(body) instead');
	      this.statusCode = arguments[1];
	    } else {
	      deprecate('res.send(status, body): Use res.status(status).send(body) instead');
	      this.statusCode = arguments[0];
	      chunk = arguments[1];
	    }
	  }

	  // disambiguate res.send(status) and res.send(status, num)
	  if (typeof chunk === 'number' && arguments.length === 1) {
	    // res.send(status) will set status message as text string
	    if (!this.get('Content-Type')) {
	      this.type('txt');
	    }

	    deprecate('res.send(status): Use res.sendStatus(status) instead');
	    this.statusCode = chunk;
	    chunk = statuses.message[chunk];
	  }

	  switch (typeof chunk) {
	    // string defaulting to html
	    case 'string':
	      if (!this.get('Content-Type')) {
	        this.type('html');
	      }
	      break;
	    case 'boolean':
	    case 'number':
	    case 'object':
	      if (chunk === null) {
	        chunk = '';
	      } else if (Buffer.isBuffer(chunk)) {
	        if (!this.get('Content-Type')) {
	          this.type('bin');
	        }
	      } else {
	        return this.json(chunk);
	      }
	      break;
	  }

	  // write strings in utf-8
	  if (typeof chunk === 'string') {
	    encoding = 'utf8';
	    type = this.get('Content-Type');

	    // reflect this in content-type
	    if (typeof type === 'string') {
	      this.set('Content-Type', setCharset(type, 'utf-8'));
	    }
	  }

	  // determine if ETag should be generated
	  var etagFn = app.get('etag fn');
	  var generateETag = !this.get('ETag') && typeof etagFn === 'function';

	  // populate Content-Length
	  var len;
	  if (chunk !== undefined) {
	    if (Buffer.isBuffer(chunk)) {
	      // get length of Buffer
	      len = chunk.length;
	    } else if (!generateETag && chunk.length < 1000) {
	      // just calculate length when no ETag + small chunk
	      len = Buffer.byteLength(chunk, encoding);
	    } else {
	      // convert chunk to Buffer and calculate
	      chunk = Buffer.from(chunk, encoding);
	      encoding = undefined;
	      len = chunk.length;
	    }

	    this.set('Content-Length', len);
	  }

	  // populate ETag
	  var etag;
	  if (generateETag && len !== undefined) {
	    if ((etag = etagFn(chunk, encoding))) {
	      this.set('ETag', etag);
	    }
	  }

	  // freshness
	  if (req.fresh) this.statusCode = 304;

	  // strip irrelevant headers
	  if (204 === this.statusCode || 304 === this.statusCode) {
	    this.removeHeader('Content-Type');
	    this.removeHeader('Content-Length');
	    this.removeHeader('Transfer-Encoding');
	    chunk = '';
	  }

	  // alter headers for 205
	  if (this.statusCode === 205) {
	    this.set('Content-Length', '0');
	    this.removeHeader('Transfer-Encoding');
	    chunk = '';
	  }

	  if (req.method === 'HEAD') {
	    // skip body for HEAD
	    this.end();
	  } else {
	    // respond
	    this.end(chunk, encoding);
	  }

	  return this;
	};

	/**
	 * Send JSON response.
	 *
	 * Examples:
	 *
	 *     res.json(null);
	 *     res.json({ user: 'tj' });
	 *
	 * @param {string|number|boolean|object} obj
	 * @public
	 */

	res.json = function json(obj) {
	  var val = obj;

	  // allow status / body
	  if (arguments.length === 2) {
	    // res.json(body, status) backwards compat
	    if (typeof arguments[1] === 'number') {
	      deprecate('res.json(obj, status): Use res.status(status).json(obj) instead');
	      this.statusCode = arguments[1];
	    } else {
	      deprecate('res.json(status, obj): Use res.status(status).json(obj) instead');
	      this.statusCode = arguments[0];
	      val = arguments[1];
	    }
	  }

	  // settings
	  var app = this.app;
	  var escape = app.get('json escape');
	  var replacer = app.get('json replacer');
	  var spaces = app.get('json spaces');
	  var body = stringify(val, replacer, spaces, escape);

	  // content-type
	  if (!this.get('Content-Type')) {
	    this.set('Content-Type', 'application/json');
	  }

	  return this.send(body);
	};

	/**
	 * Send JSON response with JSONP callback support.
	 *
	 * Examples:
	 *
	 *     res.jsonp(null);
	 *     res.jsonp({ user: 'tj' });
	 *
	 * @param {string|number|boolean|object} obj
	 * @public
	 */

	res.jsonp = function jsonp(obj) {
	  var val = obj;

	  // allow status / body
	  if (arguments.length === 2) {
	    // res.jsonp(body, status) backwards compat
	    if (typeof arguments[1] === 'number') {
	      deprecate('res.jsonp(obj, status): Use res.status(status).jsonp(obj) instead');
	      this.statusCode = arguments[1];
	    } else {
	      deprecate('res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead');
	      this.statusCode = arguments[0];
	      val = arguments[1];
	    }
	  }

	  // settings
	  var app = this.app;
	  var escape = app.get('json escape');
	  var replacer = app.get('json replacer');
	  var spaces = app.get('json spaces');
	  var body = stringify(val, replacer, spaces, escape);
	  var callback = this.req.query[app.get('jsonp callback name')];

	  // content-type
	  if (!this.get('Content-Type')) {
	    this.set('X-Content-Type-Options', 'nosniff');
	    this.set('Content-Type', 'application/json');
	  }

	  // fixup callback
	  if (Array.isArray(callback)) {
	    callback = callback[0];
	  }

	  // jsonp
	  if (typeof callback === 'string' && callback.length !== 0) {
	    this.set('X-Content-Type-Options', 'nosniff');
	    this.set('Content-Type', 'text/javascript');

	    // restrict callback charset
	    callback = callback.replace(/[^\[\]\w$.]/g, '');

	    if (body === undefined) {
	      // empty argument
	      body = '';
	    } else if (typeof body === 'string') {
	      // replace chars not allowed in JavaScript that are in JSON
	      body = body
	        .replace(/\u2028/g, '\\u2028')
	        .replace(/\u2029/g, '\\u2029');
	    }

	    // the /**/ is a specific security mitigation for "Rosetta Flash JSONP abuse"
	    // the typeof check is just to reduce client error noise
	    body = '/**/ typeof ' + callback + ' === \'function\' && ' + callback + '(' + body + ');';
	  }

	  return this.send(body);
	};

	/**
	 * Send given HTTP status code.
	 *
	 * Sets the response status to `statusCode` and the body of the
	 * response to the standard description from node's http.STATUS_CODES
	 * or the statusCode number if no description.
	 *
	 * Examples:
	 *
	 *     res.sendStatus(200);
	 *
	 * @param {number} statusCode
	 * @public
	 */

	res.sendStatus = function sendStatus(statusCode) {
	  var body = statuses.message[statusCode] || String(statusCode);

	  this.statusCode = statusCode;
	  this.type('txt');

	  return this.send(body);
	};

	/**
	 * Transfer the file at the given `path`.
	 *
	 * Automatically sets the _Content-Type_ response header field.
	 * The callback `callback(err)` is invoked when the transfer is complete
	 * or when an error occurs. Be sure to check `res.headersSent`
	 * if you wish to attempt responding, as the header and some data
	 * may have already been transferred.
	 *
	 * Options:
	 *
	 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
	 *   - `root`     root directory for relative filenames
	 *   - `headers`  object of headers to serve with file
	 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
	 *
	 * Other options are passed along to `send`.
	 *
	 * Examples:
	 *
	 *  The following example illustrates how `res.sendFile()` may
	 *  be used as an alternative for the `static()` middleware for
	 *  dynamic situations. The code backing `res.sendFile()` is actually
	 *  the same code, so HTTP cache support etc is identical.
	 *
	 *     app.get('/user/:uid/photos/:file', function(req, res){
	 *       var uid = req.params.uid
	 *         , file = req.params.file;
	 *
	 *       req.user.mayViewFilesFrom(uid, function(yes){
	 *         if (yes) {
	 *           res.sendFile('/uploads/' + uid + '/' + file);
	 *         } else {
	 *           res.send(403, 'Sorry! you cant see that.');
	 *         }
	 *       });
	 *     });
	 *
	 * @public
	 */

	res.sendFile = function sendFile(path, options, callback) {
	  var done = callback;
	  var req = this.req;
	  var res = this;
	  var next = req.next;
	  var opts = options || {};

	  if (!path) {
	    throw new TypeError('path argument is required to res.sendFile');
	  }

	  if (typeof path !== 'string') {
	    throw new TypeError('path must be a string to res.sendFile')
	  }

	  // support function as second arg
	  if (typeof options === 'function') {
	    done = options;
	    opts = {};
	  }

	  if (!opts.root && !isAbsolute(path)) {
	    throw new TypeError('path must be absolute or specify root to res.sendFile');
	  }

	  // create file stream
	  var pathname = encodeURI(path);
	  var file = send(req, pathname, opts);

	  // transfer
	  sendfile(res, file, opts, function (err) {
	    if (done) return done(err);
	    if (err && err.code === 'EISDIR') return next();

	    // next() all but write errors
	    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
	      next(err);
	    }
	  });
	};

	/**
	 * Transfer the file at the given `path`.
	 *
	 * Automatically sets the _Content-Type_ response header field.
	 * The callback `callback(err)` is invoked when the transfer is complete
	 * or when an error occurs. Be sure to check `res.headersSent`
	 * if you wish to attempt responding, as the header and some data
	 * may have already been transferred.
	 *
	 * Options:
	 *
	 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
	 *   - `root`     root directory for relative filenames
	 *   - `headers`  object of headers to serve with file
	 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
	 *
	 * Other options are passed along to `send`.
	 *
	 * Examples:
	 *
	 *  The following example illustrates how `res.sendfile()` may
	 *  be used as an alternative for the `static()` middleware for
	 *  dynamic situations. The code backing `res.sendfile()` is actually
	 *  the same code, so HTTP cache support etc is identical.
	 *
	 *     app.get('/user/:uid/photos/:file', function(req, res){
	 *       var uid = req.params.uid
	 *         , file = req.params.file;
	 *
	 *       req.user.mayViewFilesFrom(uid, function(yes){
	 *         if (yes) {
	 *           res.sendfile('/uploads/' + uid + '/' + file);
	 *         } else {
	 *           res.send(403, 'Sorry! you cant see that.');
	 *         }
	 *       });
	 *     });
	 *
	 * @public
	 */

	res.sendfile = function (path, options, callback) {
	  var done = callback;
	  var req = this.req;
	  var res = this;
	  var next = req.next;
	  var opts = options || {};

	  // support function as second arg
	  if (typeof options === 'function') {
	    done = options;
	    opts = {};
	  }

	  // create file stream
	  var file = send(req, path, opts);

	  // transfer
	  sendfile(res, file, opts, function (err) {
	    if (done) return done(err);
	    if (err && err.code === 'EISDIR') return next();

	    // next() all but write errors
	    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
	      next(err);
	    }
	  });
	};

	res.sendfile = deprecate.function(res.sendfile,
	  'res.sendfile: Use res.sendFile instead');

	/**
	 * Transfer the file at the given `path` as an attachment.
	 *
	 * Optionally providing an alternate attachment `filename`,
	 * and optional callback `callback(err)`. The callback is invoked
	 * when the data transfer is complete, or when an error has
	 * occurred. Be sure to check `res.headersSent` if you plan to respond.
	 *
	 * Optionally providing an `options` object to use with `res.sendFile()`.
	 * This function will set the `Content-Disposition` header, overriding
	 * any `Content-Disposition` header passed as header options in order
	 * to set the attachment and filename.
	 *
	 * This method uses `res.sendFile()`.
	 *
	 * @public
	 */

	res.download = function download (path, filename, options, callback) {
	  var done = callback;
	  var name = filename;
	  var opts = options || null;

	  // support function as second or third arg
	  if (typeof filename === 'function') {
	    done = filename;
	    name = null;
	    opts = null;
	  } else if (typeof options === 'function') {
	    done = options;
	    opts = null;
	  }

	  // support optional filename, where options may be in it's place
	  if (typeof filename === 'object' &&
	    (typeof options === 'function' || options === undefined)) {
	    name = null;
	    opts = filename;
	  }

	  // set Content-Disposition when file is sent
	  var headers = {
	    'Content-Disposition': contentDisposition(name || path)
	  };

	  // merge user-provided headers
	  if (opts && opts.headers) {
	    var keys = Object.keys(opts.headers);
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];
	      if (key.toLowerCase() !== 'content-disposition') {
	        headers[key] = opts.headers[key];
	      }
	    }
	  }

	  // merge user-provided options
	  opts = Object.create(opts);
	  opts.headers = headers;

	  // Resolve the full path for sendFile
	  var fullPath = !opts.root
	    ? resolve(path)
	    : path;

	  // send file
	  return this.sendFile(fullPath, opts, done)
	};

	/**
	 * Set _Content-Type_ response header with `type` through `mime.lookup()`
	 * when it does not contain "/", or set the Content-Type to `type` otherwise.
	 *
	 * Examples:
	 *
	 *     res.type('.html');
	 *     res.type('html');
	 *     res.type('json');
	 *     res.type('application/json');
	 *     res.type('png');
	 *
	 * @param {String} type
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.contentType =
	res.type = function contentType(type) {
	  var ct = type.indexOf('/') === -1
	    ? mime.lookup(type)
	    : type;

	  return this.set('Content-Type', ct);
	};

	/**
	 * Respond to the Acceptable formats using an `obj`
	 * of mime-type callbacks.
	 *
	 * This method uses `req.accepted`, an array of
	 * acceptable types ordered by their quality values.
	 * When "Accept" is not present the _first_ callback
	 * is invoked, otherwise the first match is used. When
	 * no match is performed the server responds with
	 * 406 "Not Acceptable".
	 *
	 * Content-Type is set for you, however if you choose
	 * you may alter this within the callback using `res.type()`
	 * or `res.set('Content-Type', ...)`.
	 *
	 *    res.format({
	 *      'text/plain': function(){
	 *        res.send('hey');
	 *      },
	 *
	 *      'text/html': function(){
	 *        res.send('<p>hey</p>');
	 *      },
	 *
	 *      'application/json': function () {
	 *        res.send({ message: 'hey' });
	 *      }
	 *    });
	 *
	 * In addition to canonicalized MIME types you may
	 * also use extnames mapped to these types:
	 *
	 *    res.format({
	 *      text: function(){
	 *        res.send('hey');
	 *      },
	 *
	 *      html: function(){
	 *        res.send('<p>hey</p>');
	 *      },
	 *
	 *      json: function(){
	 *        res.send({ message: 'hey' });
	 *      }
	 *    });
	 *
	 * By default Express passes an `Error`
	 * with a `.status` of 406 to `next(err)`
	 * if a match is not made. If you provide
	 * a `.default` callback it will be invoked
	 * instead.
	 *
	 * @param {Object} obj
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.format = function(obj){
	  var req = this.req;
	  var next = req.next;

	  var keys = Object.keys(obj)
	    .filter(function (v) { return v !== 'default' });

	  var key = keys.length > 0
	    ? req.accepts(keys)
	    : false;

	  this.vary("Accept");

	  if (key) {
	    this.set('Content-Type', normalizeType(key).value);
	    obj[key](req, this, next);
	  } else if (obj.default) {
	    obj.default(req, this, next);
	  } else {
	    next(createError(406, {
	      types: normalizeTypes(keys).map(function (o) { return o.value })
	    }));
	  }

	  return this;
	};

	/**
	 * Set _Content-Disposition_ header to _attachment_ with optional `filename`.
	 *
	 * @param {String} filename
	 * @return {ServerResponse}
	 * @public
	 */

	res.attachment = function attachment(filename) {
	  if (filename) {
	    this.type(extname(filename));
	  }

	  this.set('Content-Disposition', contentDisposition(filename));

	  return this;
	};

	/**
	 * Append additional header `field` with value `val`.
	 *
	 * Example:
	 *
	 *    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);
	 *    res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
	 *    res.append('Warning', '199 Miscellaneous warning');
	 *
	 * @param {String} field
	 * @param {String|Array} val
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.append = function append(field, val) {
	  var prev = this.get(field);
	  var value = val;

	  if (prev) {
	    // concat the new and prev vals
	    value = Array.isArray(prev) ? prev.concat(val)
	      : Array.isArray(val) ? [prev].concat(val)
	        : [prev, val];
	  }

	  return this.set(field, value);
	};

	/**
	 * Set header `field` to `val`, or pass
	 * an object of header fields.
	 *
	 * Examples:
	 *
	 *    res.set('Foo', ['bar', 'baz']);
	 *    res.set('Accept', 'application/json');
	 *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
	 *
	 * Aliased as `res.header()`.
	 *
	 * @param {String|Object} field
	 * @param {String|Array} val
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.set =
	res.header = function header(field, val) {
	  if (arguments.length === 2) {
	    var value = Array.isArray(val)
	      ? val.map(String)
	      : String(val);

	    // add charset to content-type
	    if (field.toLowerCase() === 'content-type') {
	      if (Array.isArray(value)) {
	        throw new TypeError('Content-Type cannot be set to an Array');
	      }
	      if (!charsetRegExp.test(value)) {
	        var charset = mime.charsets.lookup(value.split(';')[0]);
	        if (charset) value += '; charset=' + charset.toLowerCase();
	      }
	    }

	    this.setHeader(field, value);
	  } else {
	    for (var key in field) {
	      this.set(key, field[key]);
	    }
	  }
	  return this;
	};

	/**
	 * Get value for header `field`.
	 *
	 * @param {String} field
	 * @return {String}
	 * @public
	 */

	res.get = function(field){
	  return this.getHeader(field);
	};

	/**
	 * Clear cookie `name`.
	 *
	 * @param {String} name
	 * @param {Object} [options]
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.clearCookie = function clearCookie(name, options) {
	  if (options) {
	    if (options.maxAge) {
	      deprecate('res.clearCookie: Passing "options.maxAge" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.');
	    }
	    if (options.expires) {
	      deprecate('res.clearCookie: Passing "options.expires" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.');
	    }
	  }
	  var opts = merge({ expires: new Date(1), path: '/' }, options);

	  return this.cookie(name, '', opts);
	};

	/**
	 * Set cookie `name` to `value`, with the given `options`.
	 *
	 * Options:
	 *
	 *    - `maxAge`   max-age in milliseconds, converted to `expires`
	 *    - `signed`   sign the cookie
	 *    - `path`     defaults to "/"
	 *
	 * Examples:
	 *
	 *    // "Remember Me" for 15 minutes
	 *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
	 *
	 *    // same as above
	 *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
	 *
	 * @param {String} name
	 * @param {String|Object} value
	 * @param {Object} [options]
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.cookie = function (name, value, options) {
	  var opts = merge({}, options);
	  var secret = this.req.secret;
	  var signed = opts.signed;

	  if (signed && !secret) {
	    throw new Error('cookieParser("secret") required for signed cookies');
	  }

	  var val = typeof value === 'object'
	    ? 'j:' + JSON.stringify(value)
	    : String(value);

	  if (signed) {
	    val = 's:' + sign(val, secret);
	  }

	  if (opts.maxAge != null) {
	    var maxAge = opts.maxAge - 0;

	    if (!isNaN(maxAge)) {
	      opts.expires = new Date(Date.now() + maxAge);
	      opts.maxAge = Math.floor(maxAge / 1000);
	    }
	  }

	  if (opts.path == null) {
	    opts.path = '/';
	  }

	  this.append('Set-Cookie', cookie.serialize(name, String(val), opts));

	  return this;
	};

	/**
	 * Set the location header to `url`.
	 *
	 * The given `url` can also be "back", which redirects
	 * to the _Referrer_ or _Referer_ headers or "/".
	 *
	 * Examples:
	 *
	 *    res.location('/foo/bar').;
	 *    res.location('http://example.com');
	 *    res.location('../login');
	 *
	 * @param {String} url
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.location = function location(url) {
	  var loc;

	  // "back" is an alias for the referrer
	  if (url === 'back') {
	    deprecate('res.location("back"): use res.location(req.get("Referrer") || "/") and refer to https://dub.sh/security-redirect for best practices');
	    loc = this.req.get('Referrer') || '/';
	  } else {
	    loc = String(url);
	  }

	  return this.set('Location', encodeUrl(loc));
	};

	/**
	 * Redirect to the given `url` with optional response `status`
	 * defaulting to 302.
	 *
	 * The resulting `url` is determined by `res.location()`, so
	 * it will play nicely with mounted apps, relative paths,
	 * `"back"` etc.
	 *
	 * Examples:
	 *
	 *    res.redirect('/foo/bar');
	 *    res.redirect('http://example.com');
	 *    res.redirect(301, 'http://example.com');
	 *    res.redirect('../login'); // /blog/post/1 -> /blog/login
	 *
	 * @public
	 */

	res.redirect = function redirect(url) {
	  var address = url;
	  var body;
	  var status = 302;

	  // allow status / url
	  if (arguments.length === 2) {
	    if (typeof arguments[0] === 'number') {
	      status = arguments[0];
	      address = arguments[1];
	    } else {
	      deprecate('res.redirect(url, status): Use res.redirect(status, url) instead');
	      status = arguments[1];
	    }
	  }

	  // Set location header
	  address = this.location(address).get('Location');

	  // Support text/{plain,html} by default
	  this.format({
	    text: function(){
	      body = statuses.message[status] + '. Redirecting to ' + address;
	    },

	    html: function(){
	      var u = escapeHtml(address);
	      body = '<p>' + statuses.message[status] + '. Redirecting to ' + u + '</p>';
	    },

	    default: function(){
	      body = '';
	    }
	  });

	  // Respond
	  this.statusCode = status;
	  this.set('Content-Length', Buffer.byteLength(body));

	  if (this.req.method === 'HEAD') {
	    this.end();
	  } else {
	    this.end(body);
	  }
	};

	/**
	 * Add `field` to Vary. If already present in the Vary set, then
	 * this call is simply ignored.
	 *
	 * @param {Array|String} field
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.vary = function(field){
	  // checks for back-compat
	  if (!field || (Array.isArray(field) && !field.length)) {
	    deprecate('res.vary(): Provide a field name');
	    return this;
	  }

	  vary(this, field);

	  return this;
	};

	/**
	 * Render `view` with the given `options` and optional callback `fn`.
	 * When a callback function is given a response will _not_ be made
	 * automatically, otherwise a response of _200_ and _text/html_ is given.
	 *
	 * Options:
	 *
	 *  - `cache`     boolean hinting to the engine it should cache
	 *  - `filename`  filename of the view being rendered
	 *
	 * @public
	 */

	res.render = function render(view, options, callback) {
	  var app = this.req.app;
	  var done = callback;
	  var opts = options || {};
	  var req = this.req;
	  var self = this;

	  // support callback function as second arg
	  if (typeof options === 'function') {
	    done = options;
	    opts = {};
	  }

	  // merge res.locals
	  opts._locals = self.locals;

	  // default callback to respond
	  done = done || function (err, str) {
	    if (err) return req.next(err);
	    self.send(str);
	  };

	  // render
	  app.render(view, opts, done);
	};

	// pipe the send file stream
	function sendfile(res, file, options, callback) {
	  var done = false;
	  var streaming;

	  // request aborted
	  function onaborted() {
	    if (done) return;
	    done = true;

	    var err = new Error('Request aborted');
	    err.code = 'ECONNABORTED';
	    callback(err);
	  }

	  // directory
	  function ondirectory() {
	    if (done) return;
	    done = true;

	    var err = new Error('EISDIR, read');
	    err.code = 'EISDIR';
	    callback(err);
	  }

	  // errors
	  function onerror(err) {
	    if (done) return;
	    done = true;
	    callback(err);
	  }

	  // ended
	  function onend() {
	    if (done) return;
	    done = true;
	    callback();
	  }

	  // file
	  function onfile() {
	    streaming = false;
	  }

	  // finished
	  function onfinish(err) {
	    if (err && err.code === 'ECONNRESET') return onaborted();
	    if (err) return onerror(err);
	    if (done) return;

	    setImmediate(function () {
	      if (streaming !== false && !done) {
	        onaborted();
	        return;
	      }

	      if (done) return;
	      done = true;
	      callback();
	    });
	  }

	  // streaming
	  function onstream() {
	    streaming = true;
	  }

	  file.on('directory', ondirectory);
	  file.on('end', onend);
	  file.on('error', onerror);
	  file.on('file', onfile);
	  file.on('stream', onstream);
	  onFinished(res, onfinish);

	  if (options.headers) {
	    // set headers on successful transfer
	    file.on('headers', function headers(res) {
	      var obj = options.headers;
	      var keys = Object.keys(obj);

	      for (var i = 0; i < keys.length; i++) {
	        var k = keys[i];
	        res.setHeader(k, obj[k]);
	      }
	    });
	  }

	  // pipe
	  file.pipe(res);
	}

	/**
	 * Stringify JSON, like JSON.stringify, but v8 optimized, with the
	 * ability to escape characters that can trigger HTML sniffing.
	 *
	 * @param {*} value
	 * @param {function} replacer
	 * @param {number} spaces
	 * @param {boolean} escape
	 * @returns {string}
	 * @private
	 */

	function stringify (value, replacer, spaces, escape) {
	  // v8 checks arguments.length for optimizing simple call
	  // https://bugs.chromium.org/p/v8/issues/detail?id=4730
	  var json = replacer || spaces
	    ? JSON.stringify(value, replacer, spaces)
	    : JSON.stringify(value);

	  if (escape && typeof json === 'string') {
	    json = json.replace(/[<>&]/g, function (c) {
	      switch (c.charCodeAt(0)) {
	        case 0x3c:
	          return '\\u003c'
	        case 0x3e:
	          return '\\u003e'
	        case 0x26:
	          return '\\u0026'
	        /* istanbul ignore next: unreachable default */
	        default:
	          return c
	      }
	    });
	  }

	  return json
	}
	return response;
}

var serveStatic = {exports: {}};

/*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredServeStatic;

function requireServeStatic () {
	if (hasRequiredServeStatic) return serveStatic.exports;
	hasRequiredServeStatic = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var encodeUrl = requireEncodeurl$1();
	var escapeHtml = requireEscapeHtml();
	var parseUrl = requireParseurl();
	var resolve = require$$0$4.resolve;
	var send = requireSend();
	var url = require$$4$1;

	/**
	 * Module exports.
	 * @public
	 */

	serveStatic.exports = serveStatic$1;
	serveStatic.exports.mime = send.mime;

	/**
	 * @param {string} root
	 * @param {object} [options]
	 * @return {function}
	 * @public
	 */

	function serveStatic$1 (root, options) {
	  if (!root) {
	    throw new TypeError('root path required')
	  }

	  if (typeof root !== 'string') {
	    throw new TypeError('root path must be a string')
	  }

	  // copy options object
	  var opts = Object.create(options || null);

	  // fall-though
	  var fallthrough = opts.fallthrough !== false;

	  // default redirect
	  var redirect = opts.redirect !== false;

	  // headers listener
	  var setHeaders = opts.setHeaders;

	  if (setHeaders && typeof setHeaders !== 'function') {
	    throw new TypeError('option setHeaders must be function')
	  }

	  // setup options for send
	  opts.maxage = opts.maxage || opts.maxAge || 0;
	  opts.root = resolve(root);

	  // construct directory listener
	  var onDirectory = redirect
	    ? createRedirectDirectoryListener()
	    : createNotFoundDirectoryListener();

	  return function serveStatic (req, res, next) {
	    if (req.method !== 'GET' && req.method !== 'HEAD') {
	      if (fallthrough) {
	        return next()
	      }

	      // method not allowed
	      res.statusCode = 405;
	      res.setHeader('Allow', 'GET, HEAD');
	      res.setHeader('Content-Length', '0');
	      res.end();
	      return
	    }

	    var forwardError = !fallthrough;
	    var originalUrl = parseUrl.original(req);
	    var path = parseUrl(req).pathname;

	    // make sure redirect occurs at mount
	    if (path === '/' && originalUrl.pathname.substr(-1) !== '/') {
	      path = '';
	    }

	    // create send stream
	    var stream = send(req, path, opts);

	    // add directory handler
	    stream.on('directory', onDirectory);

	    // add headers listener
	    if (setHeaders) {
	      stream.on('headers', setHeaders);
	    }

	    // add file listener for fallthrough
	    if (fallthrough) {
	      stream.on('file', function onFile () {
	        // once file is determined, always forward error
	        forwardError = true;
	      });
	    }

	    // forward errors
	    stream.on('error', function error (err) {
	      if (forwardError || !(err.statusCode < 500)) {
	        next(err);
	        return
	      }

	      next();
	    });

	    // pipe
	    stream.pipe(res);
	  }
	}

	/**
	 * Collapse all leading slashes into a single slash
	 * @private
	 */
	function collapseLeadingSlashes (str) {
	  for (var i = 0; i < str.length; i++) {
	    if (str.charCodeAt(i) !== 0x2f /* / */) {
	      break
	    }
	  }

	  return i > 1
	    ? '/' + str.substr(i)
	    : str
	}

	/**
	 * Create a minimal HTML document.
	 *
	 * @param {string} title
	 * @param {string} body
	 * @private
	 */

	function createHtmlDocument (title, body) {
	  return '<!DOCTYPE html>\n' +
	    '<html lang="en">\n' +
	    '<head>\n' +
	    '<meta charset="utf-8">\n' +
	    '<title>' + title + '</title>\n' +
	    '</head>\n' +
	    '<body>\n' +
	    '<pre>' + body + '</pre>\n' +
	    '</body>\n' +
	    '</html>\n'
	}

	/**
	 * Create a directory listener that just 404s.
	 * @private
	 */

	function createNotFoundDirectoryListener () {
	  return function notFound () {
	    this.error(404);
	  }
	}

	/**
	 * Create a directory listener that performs a redirect.
	 * @private
	 */

	function createRedirectDirectoryListener () {
	  return function redirect (res) {
	    if (this.hasTrailingSlash()) {
	      this.error(404);
	      return
	    }

	    // get original URL
	    var originalUrl = parseUrl.original(this.req);

	    // append trailing slash
	    originalUrl.path = null;
	    originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/');

	    // reformat the URL
	    var loc = encodeUrl(url.format(originalUrl));
	    var doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc));

	    // send redirect response
	    res.statusCode = 301;
	    res.setHeader('Content-Type', 'text/html; charset=UTF-8');
	    res.setHeader('Content-Length', Buffer.byteLength(doc));
	    res.setHeader('Content-Security-Policy', "default-src 'none'");
	    res.setHeader('X-Content-Type-Options', 'nosniff');
	    res.setHeader('Location', loc);
	    res.end(doc);
	  }
	}
	return serveStatic.exports;
}

/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredExpress$1;

function requireExpress$1 () {
	if (hasRequiredExpress$1) return express$2.exports;
	hasRequiredExpress$1 = 1;
	(function (module, exports) {

		/**
		 * Module dependencies.
		 */

		var bodyParser = requireBodyParser();
		var EventEmitter = require$$0$8.EventEmitter;
		var mixin = requireMergeDescriptors();
		var proto = requireApplication();
		var Route = requireRoute();
		var Router = requireRouter();
		var req = requireRequest();
		var res = requireResponse();

		/**
		 * Expose `createApplication()`.
		 */

		exports = module.exports = createApplication;

		/**
		 * Create an express application.
		 *
		 * @return {Function}
		 * @api public
		 */

		function createApplication() {
		  var app = function(req, res, next) {
		    app.handle(req, res, next);
		  };

		  mixin(app, EventEmitter.prototype, false);
		  mixin(app, proto, false);

		  // expose the prototype that will get set on requests
		  app.request = Object.create(req, {
		    app: { configurable: true, enumerable: true, writable: true, value: app }
		  });

		  // expose the prototype that will get set on responses
		  app.response = Object.create(res, {
		    app: { configurable: true, enumerable: true, writable: true, value: app }
		  });

		  app.init();
		  return app;
		}

		/**
		 * Expose the prototypes.
		 */

		exports.application = proto;
		exports.request = req;
		exports.response = res;

		/**
		 * Expose constructors.
		 */

		exports.Route = Route;
		exports.Router = Router;

		/**
		 * Expose middleware
		 */

		exports.json = bodyParser.json;
		exports.query = requireQuery();
		exports.raw = bodyParser.raw;
		exports.static = requireServeStatic();
		exports.text = bodyParser.text;
		exports.urlencoded = bodyParser.urlencoded;

		/**
		 * Replace removed middleware with an appropriate error message.
		 */

		var removedMiddlewares = [
		  'bodyParser',
		  'compress',
		  'cookieSession',
		  'session',
		  'logger',
		  'cookieParser',
		  'favicon',
		  'responseTime',
		  'errorHandler',
		  'timeout',
		  'methodOverride',
		  'vhost',
		  'csrf',
		  'directory',
		  'limit',
		  'multipart',
		  'staticCache'
		];

		removedMiddlewares.forEach(function (name) {
		  Object.defineProperty(exports, name, {
		    get: function () {
		      throw new Error('Most middleware (like ' + name + ') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.');
		    },
		    configurable: true
		  });
		}); 
	} (express$2, express$2.exports));
	return express$2.exports;
}

/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var express$1;
var hasRequiredExpress;

function requireExpress () {
	if (hasRequiredExpress) return express$1;
	hasRequiredExpress = 1;

	express$1 = requireExpress$1();
	return express$1;
}

var expressExports = requireExpress();
var express = /*@__PURE__*/getDefaultExportFromCjs(expressExports);

var ProfileSetting;
(function (ProfileSetting) {
    ProfileSetting["NEWSLETTER_SUBSCRIPTION"] = "newsletterSubscription";
    ProfileSetting["LANGUAGE"] = "preferredLanguage";
    ProfileSetting["THEME"] = "preferredTheme";
    ProfileSetting["DATA_VIEW_MODE"] = "preferredDataViewMode";
    ProfileSetting["MENU_VIEW_MODE"] = "preferredMenuViewMode";
})(ProfileSetting || (ProfileSetting = {}));

var AssignmentClass;
(function (AssignmentClass) {
    AssignmentClass["NONE"] = "NONE";
    AssignmentClass["COURSE"] = "COURSE";
    AssignmentClass["WORKSHEET"] = "WORKSHEET";
    AssignmentClass["CONTEST"] = "CONTEST";
})(AssignmentClass || (AssignmentClass = {}));

var ProgrammingLanguage;
(function (ProgrammingLanguage) {
    ProgrammingLanguage["ICPC_C"] = "ICPC_C";
    ProgrammingLanguage["C"] = "C";
    ProgrammingLanguage["CPP"] = "CPP";
    ProgrammingLanguage["ICPC_CPP"] = "ICPC_CPP";
    ProgrammingLanguage["CPP11"] = "CPP11";
    ProgrammingLanguage["CPP14"] = "CPP14";
    ProgrammingLanguage["CPP17"] = "CPP17";
    ProgrammingLanguage["JAVA"] = "JAVA";
    ProgrammingLanguage["ICPC_PYTHON"] = "ICPC_PYTHON";
    ProgrammingLanguage["PYTHON"] = "PYTHON";
    ProgrammingLanguage["PYTHON3"] = "PYTHON3";
    ProgrammingLanguage["JAVASCRIPT"] = "JAVASCRIPT";
    ProgrammingLanguage["PSEUDOCODE_PSEINT"] = "PSEUDOCODE_PSEINT";
    ProgrammingLanguage["JSON"] = "JSON";
    ProgrammingLanguage["TEXT"] = "TEXT";
    ProgrammingLanguage["MARKDOWN"] = "MARKDOWN";
    ProgrammingLanguage["ARDUINO"] = "ARDUINO";
    ProgrammingLanguage["HTML"] = "HTML";
    ProgrammingLanguage["DOT"] = "DOT";
})(ProgrammingLanguage || (ProgrammingLanguage = {}));
var ScopeData;
(function (ScopeData) {
    ScopeData["USER"] = "USER";
    ScopeData["PROBLEM"] = "PROBLEM";
    ScopeData["CONTEST"] = "CONTEST";
    ScopeData["ATTEMPT"] = "ATTEMPT";
})(ScopeData || (ScopeData = {}));
var Status;
(function (Status) {
    Status["SUCCESS"] = "SUCCESS";
    Status["ERROR"] = "ERROR";
    Status["LOADING"] = "LOADING";
    Status["NONE"] = "NONE";
})(Status || (Status = {}));
var EntityStatus;
(function (EntityStatus) {
    EntityStatus["PUBLIC"] = "PUBLIC";
    EntityStatus["RESERVED"] = "RESERVED";
    EntityStatus["PRIVATE"] = "PRIVATE";
    EntityStatus["ARCHIVED"] = "ARCHIVED";
})(EntityStatus || (EntityStatus = {}));
var EntityAccess;
(function (EntityAccess) {
    EntityAccess["PRIVATE"] = "PRIVATE";
    EntityAccess["RESTRICTED"] = "RESTRICTED";
    EntityAccess["PUBLIC"] = "PUBLIC";
    EntityAccess["EXPOSED"] = "EXPOSED";
})(EntityAccess || (EntityAccess = {}));

var CompanyPlan;
(function (CompanyPlan) {
    CompanyPlan["FREE"] = "FREE";
    CompanyPlan["STANDARD"] = "STANDARD";
    CompanyPlan["PREMIUM"] = "PREMIUM";
    CompanyPlan["CUSTOM"] = "CUSTOM";
})(CompanyPlan || (CompanyPlan = {}));
var CompanyLogoType;
(function (CompanyLogoType) {
    CompanyLogoType["HORIZONTAL_WHITE"] = "horizontal-white";
    CompanyLogoType["HORIZONTAL_COLOR"] = "horizontal-color";
    CompanyLogoType["VERTICAL_WHITE"] = "vertical-white";
    CompanyLogoType["VERTICAL_COLOR"] = "vertical-color";
})(CompanyLogoType || (CompanyLogoType = {}));

var ContestStatus;
(function (ContestStatus) {
    ContestStatus["PUBLIC"] = "PUBLIC";
    ContestStatus["RESERVED"] = "RESERVED";
    ContestStatus["ARCHIVED"] = "ARCHIVED";
})(ContestStatus || (ContestStatus = {}));
var ContestTimeStatus;
(function (ContestTimeStatus) {
    ContestTimeStatus["UPCOMING"] = "upcoming";
    ContestTimeStatus["LIVE"] = "live";
    ContestTimeStatus["PAST"] = "past";
})(ContestTimeStatus || (ContestTimeStatus = {}));

var EntityMembersRank;
(function (EntityMembersRank) {
    EntityMembersRank["NONE"] = "NONE";
    EntityMembersRank["CLOSE"] = "CLOSE";
    EntityMembersRank["OPEN"] = "OPEN";
})(EntityMembersRank || (EntityMembersRank = {}));
var EntityState;
(function (EntityState) {
    EntityState["RELEASED"] = "RELEASED";
    EntityState["ARCHIVED"] = "ARCHIVED";
})(EntityState || (EntityState = {}));
var EntityCollection;
(function (EntityCollection) {
    EntityCollection["COMPANY"] = "COMPANY";
    EntityCollection["PROBLEM"] = "PROBLEM";
    EntityCollection["CONTEST"] = "CONTEST";
    EntityCollection["JUDGE"] = "JUDGE";
    EntityCollection["USER"] = "USER";
})(EntityCollection || (EntityCollection = {}));
var CollectionKey;
(function (CollectionKey) {
    CollectionKey["COMPANY"] = "C";
    CollectionKey["USER"] = "U";
    CollectionKey["PROBLEM"] = "P";
    CollectionKey["CLASS"] = "K";
    CollectionKey["CLASS_ASSIGNMENT"] = "KA";
    CollectionKey["CONTEST"] = "T";
    CollectionKey["COURSE"] = "R";
    CollectionKey["FILE"] = "F";
    CollectionKey["GROUP"] = "G";
    CollectionKey["JUDGE"] = "J";
    CollectionKey["WORKSHEET"] = "W";
    CollectionKey["WORKSHEET_SUBMISSIONS"] = "WS";
    CollectionKey["SUBMIT"] = "S";
    CollectionKey["LOCALE"] = "L";
})(CollectionKey || (CollectionKey = {}));
var LogOperation;
(function (LogOperation) {
    LogOperation["REMOVE"] = "REMOVE";
    LogOperation["ADD"] = "ADD";
    LogOperation["UPDATE"] = "UPDATE";
})(LogOperation || (LogOperation = {}));

var GroupType;
(function (GroupType) {
    GroupType["CLASS"] = "CLASS";
    GroupType["TEAM"] = "TEAM";
})(GroupType || (GroupType = {}));

var FileRole;
(function (FileRole) {
    FileRole["RESTRICTED"] = "RESTRICTED";
    FileRole["GUEST"] = "GUEST";
    FileRole["REGULAR"] = "REGULAR";
    FileRole["MASTER"] = "MASTER";
    FileRole["ADMIN"] = "ADMIN";
    FileRole["SUPER_ADMIN"] = "SUPER_ADMIN";
})(FileRole || (FileRole = {}));
var FileMemberRole;
(function (FileMemberRole) {
    FileMemberRole["VIEWER"] = "VIEWER";
    FileMemberRole["EDITOR"] = "EDITOR";
})(FileMemberRole || (FileMemberRole = {}));
var FileType;
(function (FileType) {
    FileType["FOLDER"] = "FOLDER";
    FileType["FILE"] = "FILE";
})(FileType || (FileType = {}));

var Judge;
(function (Judge) {
    Judge["CUSTOMER"] = "CUSTOMER";
    Judge["JUKI_JUDGE"] = "JUKI_JUDGE";
    Judge["CODEFORCES"] = "CODEFORCES";
    Judge["CODEFORCES_GYM"] = "CODEFORCES_GYM";
    Judge["JV_UMSA"] = "JV_UMSA";
    Judge["UVA_ONLINE_JUDGE"] = "UVA_ONLINE_JUDGE";
    Judge["AT_CODER"] = "AT_CODER";
    Judge["CODECHEF"] = "CODECHEF";
    Judge["TOPCODER"] = "TOPCODER";
})(Judge || (Judge = {}));
var ProblemVerdict;
(function (ProblemVerdict) {
    ProblemVerdict["NONE"] = "NONE";
    ProblemVerdict["PENDING"] = "PENDING";
    ProblemVerdict["HIDDEN"] = "HIDDEN";
    ProblemVerdict["CE"] = "CE";
    ProblemVerdict["RE"] = "RE";
    ProblemVerdict["TLE"] = "TLE";
    ProblemVerdict["MLE"] = "MLE";
    ProblemVerdict["WA"] = "WA";
    ProblemVerdict["PE"] = "PE";
    ProblemVerdict["PA"] = "PA";
    ProblemVerdict["AC"] = "AC";
})(ProblemVerdict || (ProblemVerdict = {}));
var SubmissionRunStatus;
(function (SubmissionRunStatus) {
    SubmissionRunStatus["NONE"] = "NONE";
    SubmissionRunStatus["RECEIVED"] = "RECEIVED";
    SubmissionRunStatus["COMPILING"] = "COMPILING";
    SubmissionRunStatus["COMPILED"] = "COMPILED";
    SubmissionRunStatus["COMPILATION_ERROR"] = "COMPILATION_ERROR";
    SubmissionRunStatus["FETCHING_TEST_CASES"] = "FETCHING_TEST_CASES";
    SubmissionRunStatus["RUNNING_TEST_CASE"] = "RUNNING_TEST_CASE";
    SubmissionRunStatus["RUNNING_TEST_CASES"] = "RUNNING_TEST_CASES";
    SubmissionRunStatus["RUNNING_SAMPLE_TEST_CASES"] = "RUNNING_SAMPLE_TEST_CASES";
    SubmissionRunStatus["EXECUTED_TEST_CASE"] = "EXECUTED_TEST_CASE";
    SubmissionRunStatus["FAILED_TEST_CASE"] = "FAILED_TEST_CASE";
    SubmissionRunStatus["JUDGING_TEST_CASE"] = "JUDGING_TEST_CASE";
    SubmissionRunStatus["GRADING"] = "GRADING";
    SubmissionRunStatus["FAILED"] = "FAILED";
    SubmissionRunStatus["COMPLETED"] = "COMPLETED";
})(SubmissionRunStatus || (SubmissionRunStatus = {}));
var RunnerType;
(function (RunnerType) {
    RunnerType["HIGH_PERFORMANCE"] = "HIGH_PERFORMANCE";
    RunnerType["LOW_PERFORMANCE"] = "LOW_PERFORMANCE";
})(RunnerType || (RunnerType = {}));

var TypeTestCase;
(function (TypeTestCase) {
    TypeTestCase["INPUT"] = "INPUT";
    TypeTestCase["OUTPUT"] = "OUTPUT";
})(TypeTestCase || (TypeTestCase = {}));
var ProblemInput;
(function (ProblemInput) {
    ProblemInput["STANDARD"] = "STANDARD";
    ProblemInput["INTERACTIVE"] = "INTERACTIVE";
})(ProblemInput || (ProblemInput = {}));
var ProblemOutput;
(function (ProblemOutput) {
    ProblemOutput["STANDARD"] = "STANDARD";
    ProblemOutput["DYNAMIC"] = "DYNAMIC";
    ProblemOutput["INTERACTIVE"] = "INTERACTIVE";
})(ProblemOutput || (ProblemOutput = {}));
var ProblemType;
(function (ProblemType) {
    ProblemType["STANDARD"] = "STANDARD";
    ProblemType["DYNAMIC"] = "DYNAMIC";
    ProblemType["INTERACTIVE"] = "INTERACTIVE";
})(ProblemType || (ProblemType = {}));
var ProblemScoringMode;
(function (ProblemScoringMode) {
    ProblemScoringMode["SUBTASK"] = "SUBTASK";
    ProblemScoringMode["TOTAL"] = "TOTAL";
    ProblemScoringMode["PARTIAL"] = "PARTIAL";
})(ProblemScoringMode || (ProblemScoringMode = {}));

var ErrorCode;
(function (ErrorCode) {
    // General errors
    ErrorCode["ERR400"] = "ERR400";
    ErrorCode["ERR401"] = "ERR401";
    ErrorCode["ERR403"] = "ERR403";
    ErrorCode["ERR404"] = "ERR404";
    ErrorCode["ERR405"] = "ERR405";
    ErrorCode["ERR500"] = "ERR500";
    // UI general errors
    ErrorCode["ERR9997"] = "ERR9997";
    ErrorCode["ERR9998"] = "ERR9998";
    ErrorCode["ERR9999"] = "ERR9999";
    // User errors // 'unable update nickname yet', 'User not active'
    ErrorCode["ERR0000"] = "ERR0000";
    ErrorCode["ERR0010"] = "ERR0010";
    ErrorCode["ERR0011"] = "ERR0011";
    ErrorCode["ERR0012"] = "ERR0012";
    ErrorCode["ERR0013"] = "ERR0013";
    ErrorCode["ERR0014"] = "ERR0014";
    ErrorCode["ERR0015"] = "ERR0015";
    ErrorCode["ERR0016"] = "ERR0016";
    ErrorCode["ERR0017"] = "ERR0017";
    ErrorCode["ERR0018"] = "ERR0018";
    ErrorCode["ERR0019"] = "ERR0019";
    ErrorCode["ERR0020"] = "ERR0020";
    ErrorCode["ERR0021"] = "ERR0021";
    ErrorCode["ERR0022"] = "ERR0022";
    ErrorCode["ERR0023"] = "ERR0023";
    ErrorCode["ERR0024"] = "ERR0024";
    ErrorCode["ERR0050"] = "ERR0050";
    ErrorCode["ERR0051"] = "ERR0051";
    ErrorCode["ERR0052"] = "ERR0052";
    ErrorCode["ERR0053"] = "ERR0053";
    // Problem Errors ERR01XX',
    ErrorCode["ERR0100"] = "ERR0100";
    ErrorCode["ERR0110"] = "ERR0110";
    ErrorCode["ERR0111"] = "ERR0111";
    ErrorCode["ERR0112"] = " ERR0112";
    ErrorCode["ERR0113"] = "ERR0113";
    ErrorCode["ERR0114"] = "ERR0114";
    ErrorCode["ERR0115"] = "ERR0115";
    ErrorCode["ERR0116"] = "ERR0116";
    ErrorCode["ERR0117"] = "ERR0117";
    ErrorCode["ERR0118"] = "ERR0118";
    ErrorCode["ERR0119"] = "ERR0119";
    ErrorCode["ERR0120"] = "ERR0120";
    ErrorCode["ERR0121"] = "ERR0121";
    ErrorCode["ERR0122"] = "ERR0122";
    // Contest Errors ERR02XX',
    ErrorCode["ERR0200"] = "ERR0200";
    // CRUD contest
    ErrorCode["ERR0210"] = "ERR0210";
    ErrorCode["ERR0211"] = "ERR0211";
    ErrorCode["ERR0212"] = "ERR0212";
    ErrorCode["ERR0213"] = "ERR0213";
    // permissions contest
    ErrorCode["ERR0214"] = "ERR0214";
    ErrorCode["ERR0215"] = "ERR0215";
    ErrorCode["ERR0216"] = "ERR0216";
    ErrorCode["ERR0217"] = "ERR0217";
    ErrorCode["ERR0218"] = "ERR0218";
    ErrorCode["ERR0219"] = "ERR0219";
    ErrorCode["ERR0220"] = "ERR0220";
    // CRUD scoreboard
    ErrorCode["ERR0230"] = "ERR0230";
    ErrorCode["ERR0231"] = "ERR0231";
    ErrorCode["ERR0232"] = "ERR0232";
    ErrorCode["ERR0233"] = "ERR0233";
    // permissions scoreboard
    ErrorCode["ERR0234"] = "ERR0234";
    ErrorCode["ERR0235"] = "ERR0235";
    ErrorCode["ERR0236"] = "ERR0236";
    ErrorCode["ERR0237"] = "ERR0237";
    ErrorCode["ERR0240"] = "ERR0240";
    ErrorCode["ERR0241"] = "ERR0241";
    ErrorCode["ERR0242"] = "ERR0242";
    ErrorCode["ERR0243"] = "ERR0243";
    ErrorCode["ERR0244"] = "ERR0244";
    ErrorCode["ERR0245"] = "ERR0245";
    ErrorCode["ERR0246"] = "ERR0246";
    ErrorCode["ERR0247"] = "ERR0247";
    // Submission Errors ERR03XXX',
    ErrorCode["ERR0300"] = "ERR0300";
    ErrorCode["ERR0301"] = "ERR0301";
    ErrorCode["ERR0302"] = "ERR0302";
    ErrorCode["ERR0303"] = "ERR0303";
    ErrorCode["ERR0310"] = "ERR0310";
    ErrorCode["ERR0311"] = "ERR0311";
    ErrorCode["ERR0321"] = "ERR0321";
    ErrorCode["ERR0331"] = "ERR0331";
    // Utils Errors ERR04XX
    ErrorCode["ERR0400"] = "ERR0400";
    ErrorCode["ERR0410"] = "ERR0410";
    ErrorCode["ERR0420"] = "ERR0420";
    ErrorCode["ERR0421"] = "ERR0421";
    ErrorCode["ERR0430"] = "ERR0430";
    ErrorCode["ERR0440"] = "ERR0440";
    // Team Errors ERR06XX
    ErrorCode["ERR0600"] = "ERR0600";
    ErrorCode["ERR0610"] = "ERR0610";
    ErrorCode["ERR0611"] = "ERR0611";
    ErrorCode["ERR0612"] = "ERR0612";
    ErrorCode["ERR0613"] = "ERR0613";
    ErrorCode["ERR0614"] = "ERR0614";
    ErrorCode["ERR0615"] = "ERR0615";
    ErrorCode["ERR0616"] = "ERR0665";
    ErrorCode["ERR0617"] = "ERR0617";
    ErrorCode["ERR0618"] = "ERR0618";
    ErrorCode["ERR0619"] = "ERR0619";
    // Course Errors ERR07XXX',
    // Sheets Errors ERR08XXX',
    ErrorCode["ERR0800"] = "ERR0800";
    ErrorCode["ERR0810"] = "ERR0810";
    ErrorCode["ERR0811"] = "ERR0811";
    ErrorCode["ERR0812"] = "ERR0812";
    ErrorCode["ERR0813"] = "ERR0813";
    ErrorCode["ERR0814"] = "ERR0814";
    ErrorCode["ERR0815"] = "ERR0815";
    ErrorCode["ERR0816"] = "ERR0865";
    ErrorCode["ERR0817"] = "ERR0817";
    ErrorCode["ERR0818"] = "ERR0818";
    ErrorCode["ERR0819"] = "ERR0819";
    ErrorCode["ERR0820"] = "ERR0820";
    // Company Errors ERR99XXX',
    ErrorCode["ERR9900"] = "ERR9900";
    ErrorCode["ERR9910"] = "ERR9910";
    ErrorCode["ERR9911"] = "ERR9911";
    ErrorCode["ERR9912"] = "ERR9912";
    ErrorCode["ERR9913"] = "ERR9913";
    ErrorCode["ERR9914"] = "ERR9914";
    ErrorCode["ERR9915"] = "ERR9915";
    ErrorCode["ERR9916"] = "ERR9916";
    ErrorCode["ERR9917"] = "ERR9917";
})(ErrorCode || (ErrorCode = {}));
var LogLevel;
(function (LogLevel) {
    LogLevel["FATAL"] = "FATAL";
    LogLevel["ERROR"] = "ERROR";
    LogLevel["WARN"] = "WARN";
    LogLevel["INFO"] = "INFO";
    LogLevel["DEBUG"] = "DEBUG";
    LogLevel["TRACE"] = "TRACE";
})(LogLevel || (LogLevel = {}));
var HTTPMethod;
(function (HTTPMethod) {
    HTTPMethod["POST"] = "POST";
    HTTPMethod["GET"] = "GET";
    HTTPMethod["PUT"] = "PUT";
    HTTPMethod["PATCH"] = "PATCH";
    HTTPMethod["DELETE"] = "DELETE";
})(HTTPMethod || (HTTPMethod = {}));
var JudgingState;
(function (JudgingState) {
    JudgingState["COMPILED"] = "COMPILED";
    JudgingState["TEST_CASE_EXECUTED"] = "TEST_CASE_EXECUTED";
    JudgingState["TEST_CASE_EVALUATED"] = "TEST_CASE_EVALUATED";
})(JudgingState || (JudgingState = {}));

var WorksheetType;
(function (WorksheetType) {
    WorksheetType["JK_MD"] = "JK_MD";
    WorksheetType["CODE_EDITOR"] = "CODE_EDITOR";
    WorksheetType["LIST"] = "LIST";
    WorksheetType["GRAPH"] = "GRAPH";
    WorksheetType["QUIZ_PROBLEM"] = "QUIZ_PROBLEM";
    WorksheetType["QUIZ_TEXT"] = "QUIZ_TEXT";
    WorksheetType["QUIZ_OPTIONS"] = "QUIZ_OPTIONS";
    WorksheetType["NEW_PAGE"] = "NEW_PAGE";
})(WorksheetType || (WorksheetType = {}));

var WebSocketBroadcastEvent;
(function (WebSocketBroadcastEvent) {
    WebSocketBroadcastEvent["PING"] = "PING";
    WebSocketBroadcastEvent["CODE_RUN_STATUS_NOTIFICATION"] = "CODE_RUN_STATUS_NOTIFICATION";
    WebSocketBroadcastEvent["SUBMISSION_RUN_STATUS_NOTIFICATION"] = "SUBMISSION_RUN_STATUS_NOTIFICATION";
    WebSocketBroadcastEvent["USER_NOTIFICATION"] = "USER_NOTIFICATION";
})(WebSocketBroadcastEvent || (WebSocketBroadcastEvent = {}));
var WebSocketActionEvent;
(function (WebSocketActionEvent) {
    WebSocketActionEvent["PING"] = "PING";
    WebSocketActionEvent["SUBSCRIBE_CODE_RUN_STATUS"] = "SUBSCRIBE_CODE_RUN_STATUS";
    WebSocketActionEvent["UNSUBSCRIBE_CODE_RUN_STATUS"] = "UNSUBSCRIBE_CODE_RUN_STATUS";
    WebSocketActionEvent["SUBSCRIBE_SUBMISSION_RUN_STATUS"] = "SUBSCRIBE_SUBMISSION_RUN_STATUS";
    WebSocketActionEvent["UNSUBSCRIBE_SUBMISSION_RUN_STATUS"] = "UNSUBSCRIBE_SUBMISSION_RUN_STATUS";
})(WebSocketActionEvent || (WebSocketActionEvent = {}));
var WebSocketResponseEvent;
(function (WebSocketResponseEvent) {
    WebSocketResponseEvent["PONG"] = "PONG";
    WebSocketResponseEvent["CODE_RUN_STATUS_MESSAGE"] = "CODE_RUN_STATUS_MESSAGE";
    WebSocketResponseEvent["SUBMISSION_RUN_STATUS_MESSAGE"] = "SUBMISSION_RUN_STATUS_MESSAGE";
    WebSocketResponseEvent["USER_MESSAGE"] = "USER_MESSAGE";
})(WebSocketResponseEvent || (WebSocketResponseEvent = {}));

var DataViewMode;
(function (DataViewMode) {
    DataViewMode["CARDS"] = "CARDS";
    DataViewMode["ROWS"] = "ROWS";
})(DataViewMode || (DataViewMode = {}));
var MenuViewMode;
(function (MenuViewMode) {
    MenuViewMode["HORIZONTAL"] = "HORIZONTAL";
    MenuViewMode["VERTICAL"] = "VERTICAL";
})(MenuViewMode || (MenuViewMode = {}));
var Role;
(function (Role) {
    Role["SUPER_ADMIN"] = "SUPER_ADMIN";
    Role["ADMIN"] = "ADMIN";
    Role["MASTER"] = "MASTER";
    Role["MANAGER"] = "MANAGER";
    Role["REGULAR"] = "REGULAR";
    Role["LIMITED"] = "LIMITED";
    Role["GUEST"] = "GUEST";
    Role["RESTRICTED"] = "RESTRICTED";
})(Role || (Role = {}));

var WorkingIn;
(function (WorkingIn) {
    WorkingIn["NOTHING"] = "NOTHING";
    WorkingIn["SEND_SUBMISSION"] = "SEND_SUBMISSION";
    WorkingIn["TRACKING_SUBMISSION"] = "TRACKING_SUBMISSION";
    WorkingIn["CRAWLING_LANGUAGES"] = "CRAWLING_LANGUAGES";
    WorkingIn["CRAWLING_PROBLEM_DATA"] = "CRAWLING_PROBLEM_DATA";
})(WorkingIn || (WorkingIn = {}));
const GCC_VERSION = `gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0
Copyright (C) 2021 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE`;
const GPP_VERSION = `g++ (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0
Copyright (C) 2021 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.`;
const JAVAC_VERSION = `javac 17.0.9`;
const NODE_VERSION = `v16.20.2`;
const PYTHON3_VERSION = 'Python 3.10.12';
const PYPY3_VERSION = `Python 3.9.18 (7.3.15+dfsg-1~ppa1~ubuntu22.04, Jan 18 2024, 17:27:41)
[PyPy 7.3.15 with GCC 11.4.0]`;
({
    [ProgrammingLanguage.ICPC_C]: {
        value: ProgrammingLanguage.ICPC_C,
        label: 'ICPC C',
        mime: 'text/x-csrc',
        fileExtension: ['c'],
        monacoKey: 'c',
        codeMirrorKey: 'c',
        compilePattern: 'gcc -x c -g -O2 -std=gnu11 -static -lm -o ' +
            '{{folder_path}}/{{compiled_file_name}} {{folder_path}}/{{source_file_name}}',
        runPattern: '{{folder_path}}/{{compiled_file_name}}',
        templateSourceCode: '#include <stdio.h>\n \nint main(void) {\n \n  printf("Hello World\\n");\n \n  return 0;\n}',
        hasBuildFile: true,
        executable: 'gcc',
        executableVersion: GCC_VERSION,
    },
    [ProgrammingLanguage.C]: {
        value: ProgrammingLanguage.C,
        label: 'C',
        mime: 'text/x-csrc',
        fileExtension: ['c'],
        monacoKey: 'c',
        codeMirrorKey: 'c',
        compilePattern: 'gcc -static -fno-optimize-sibling-calls -fno-strict-aliasing -DONLINE_JUDGE -fno-asm -lm -s -O2 -o ' +
            '{{folder_path}}/{{compiled_file_name}} {{folder_path}}/{{source_file_name}}',
        runPattern: '{{folder_path}}/{{compiled_file_name}}',
        templateSourceCode: '#include <stdio.h>\n \nint main(void) {\n \n  printf("Hello World\\n");\n \n  return 0;\n}',
        hasBuildFile: true,
        executable: 'gcc',
        executableVersion: GCC_VERSION,
    },
    [ProgrammingLanguage.ICPC_CPP]: {
        value: ProgrammingLanguage.ICPC_CPP,
        label: 'ICPC C++',
        mime: 'text/x-c++src',
        fileExtension: ['cpp', 'c++', 'cxx', 'cc'],
        monacoKey: 'cpp',
        codeMirrorKey: 'cpp',
        compilePattern: 'g++ -x c++ -g -O2 -std=gnu++20 -static -o ' +
            '{{folder_path}}/{{compiled_file_name}} {{folder_path}}/{{source_file_name}}',
        runPattern: '{{folder_path}}/{{compiled_file_name}}',
        templateSourceCode: '#include <iostream>\n\nusing namespace std;\n\n' +
            'int main() {\n  \n  cout << "Hello World" << endl;\n  \n  return 0;\n}',
        hasBuildFile: true,
        executable: 'g++',
        executableVersion: GPP_VERSION,
    },
    [ProgrammingLanguage.CPP]: {
        value: ProgrammingLanguage.CPP,
        label: 'C++',
        mime: 'text/x-c++src',
        fileExtension: ['cpp', 'c++', 'cxx', 'cc'],
        monacoKey: 'cpp',
        codeMirrorKey: 'cpp',
        compilePattern: 'g++ -static -DONLINE_JUDGE -lm -s -x c++ -O2 -o ' +
            '{{folder_path}}/{{compiled_file_name}} {{folder_path}}/{{source_file_name}}',
        runPattern: '{{folder_path}}/{{compiled_file_name}}',
        templateSourceCode: '#include <iostream>\n\nusing namespace std;\n\n' +
            'int main() {\n  \n  cout << "Hello World" << endl;\n  \n  return 0;\n}',
        hasBuildFile: true,
        executable: 'g++',
        executableVersion: GPP_VERSION,
    },
    [ProgrammingLanguage.CPP11]: {
        value: ProgrammingLanguage.CPP11,
        label: 'C++ 11',
        mime: 'text/x-c++src',
        fileExtension: ['cpp', 'c++', 'cxx', 'cc'],
        monacoKey: 'cpp',
        codeMirrorKey: 'cpp',
        compilePattern: 'g++ -static -DONLINE_JUDGE -lm -s -x c++ -O2 -std=c++11 -o ' +
            '{{folder_path}}/{{compiled_file_name}} {{folder_path}}/{{source_file_name}}',
        // compilePattern: 'g++ -O2 -s -Wall -std=c++11 -o {{folder_path}}/{{compiled_file_name}} {{folder_path}}/{{source_file_name}} -lm',
        runPattern: '{{folder_path}}/{{compiled_file_name}}',
        templateSourceCode: '#include <iostream>\n\nusing namespace std;\n\n' +
            'int main() {\n  \n  cout << "Hello World" << endl;\n  \n  return 0;\n}',
        hasBuildFile: true,
        executable: 'g++',
        executableVersion: GPP_VERSION,
    },
    [ProgrammingLanguage.CPP14]: {
        value: ProgrammingLanguage.CPP14,
        label: 'C++ 14',
        mime: 'text/x-c++src',
        fileExtension: ['cpp', 'c++', 'cxx', 'cc'],
        monacoKey: 'cpp',
        codeMirrorKey: 'cpp',
        // compilePattern: 'g++ -O2 -s -Wall -std=c++14 -o {{folder_path}}/{{compiled_file_name}} {{folder_path}}/{{source_file_name}} -lm',
        compilePattern: 'g++ -static -DONLINE_JUDGE -lm -s -x c++ -O2 -std=c++14 -o ' +
            '{{folder_path}}/{{compiled_file_name}} {{folder_path}}/{{source_file_name}}',
        runPattern: '{{folder_path}}/{{compiled_file_name}}',
        templateSourceCode: '#include <iostream>\n\nusing namespace std;\n\n' +
            'int main() {\n  \n  cout << "Hello World" << endl;\n  \n  return 0;\n}',
        hasBuildFile: true,
        executable: 'g++',
        executableVersion: GPP_VERSION,
    },
    [ProgrammingLanguage.CPP17]: {
        value: ProgrammingLanguage.CPP17,
        label: 'C++ 17',
        mime: 'text/x-c++src',
        fileExtension: ['cpp', 'c++', 'cxx', 'cc'],
        monacoKey: 'cpp',
        codeMirrorKey: 'cpp',
        // compilePattern: 'g++ -O2 -s -Wall -std=c++17 -o {{folder_path}}/{{compiled_file_name}} {{folder_path}}/{{source_file_name}} -lm',
        compilePattern: 'g++ -static -DONLINE_JUDGE -lm -s -x c++ -O2 -std=c++17 -o ' +
            '{{folder_path}}/{{compiled_file_name}} {{folder_path}}/{{source_file_name}}',
        runPattern: '{{folder_path}}/{{compiled_file_name}}',
        templateSourceCode: '#include <iostream>\n\nusing namespace std;\n\n' +
            'int main() {\n  \n  cout << "Hello World" << endl;\n  \n  return 0;\n}',
        hasBuildFile: true,
        executable: 'g++',
        executableVersion: GPP_VERSION,
    },
    [ProgrammingLanguage.JAVA]: {
        value: ProgrammingLanguage.JAVA,
        label: 'Java',
        mime: 'text/x-java',
        fileExtension: ['java'],
        monacoKey: 'java',
        codeMirrorKey: 'java',
        compilePattern: 'javac -cp \'.;*\' {{folder_path}}/{{source_file_name}}',
        // compilePattern: 'javac {{folder_path}}/{{source_file_name}}',
        // runPattern: 'java -cp {{folder_path}} {{class_name}}'
        runPattern: 'java -Xmx512M -Xss64M -DONLINE_JUDGE=true -Duser.language=en -Duser.region=US -Duser.variant=US -cp ' +
            '{{folder_path}} {{class_name}}',
        templateSourceCode: 'class Main {\n  public static void main (String[] args) {' +
            '\n    \n    System.out.println("Hello World");\n    \n  }\n}',
        hasBuildFile: true,
        executable: 'javac',
        executableVersion: JAVAC_VERSION,
    },
    [ProgrammingLanguage.ICPC_PYTHON]: {
        value: ProgrammingLanguage.ICPC_PYTHON,
        label: 'ICPC Python',
        mime: 'text/x-python',
        fileExtension: ['py'],
        monacoKey: 'python',
        codeMirrorKey: 'python',
        compilePattern: 'pypy3 -m py_compile {{folder_path}}/{{source_file_name}}',
        runPattern: 'python {{folder_path}}/{{source_file_name}}',
        templateSourceCode: 'print("Hello World\\n")',
        hasBuildFile: false,
        executable: 'pypy3',
        executableVersion: PYPY3_VERSION,
    },
    [ProgrammingLanguage.PYTHON]: {
        value: ProgrammingLanguage.PYTHON,
        label: 'Python',
        mime: 'text/x-python',
        fileExtension: ['py'],
        monacoKey: 'python',
        codeMirrorKey: 'python',
        compilePattern: 'python -m py_compile {{folder_path}}/{{source_file_name}}',
        runPattern: 'python {{folder_path}}/{{source_file_name}}',
        templateSourceCode: 'print("Hello World\\n")',
        hasBuildFile: false,
        executable: 'python',
        executableVersion: '',
    },
    [ProgrammingLanguage.PYTHON3]: {
        value: ProgrammingLanguage.PYTHON3,
        label: 'Python 3',
        mime: 'text/x-python',
        fileExtension: ['py'],
        monacoKey: 'python',
        codeMirrorKey: 'python',
        compilePattern: 'python3 -m py_compile {{folder_path}}/{{source_file_name}}',
        runPattern: 'python3 {{folder_path}}/{{source_file_name}}',
        templateSourceCode: 'print("Hello World\\n")',
        hasBuildFile: false,
        executable: 'python3',
        executableVersion: PYTHON3_VERSION,
    },
    [ProgrammingLanguage.JAVASCRIPT]: {
        value: ProgrammingLanguage.JAVASCRIPT,
        label: 'Node.JS',
        mime: 'application/x-javascript',
        fileExtension: ['js'],
        monacoKey: 'javascript',
        codeMirrorKey: 'javascript',
        compilePattern: '',
        runPattern: 'node {{folder_path}}/{{source_file_name}}',
        templateSourceCode: 'console.log("Hello World\\n")',
        hasBuildFile: false,
        executable: 'node',
        executableVersion: NODE_VERSION,
    },
    [ProgrammingLanguage.PSEUDOCODE_PSEINT]: {
        value: ProgrammingLanguage.PSEUDOCODE_PSEINT,
        label: 'Pseudo-cdigo (PSeInt)',
        mime: 'text/plain',
        fileExtension: ['psc'],
        monacoKey: 'text',
        codeMirrorKey: 'pseudocode-pseint',
        compilePattern: 'jk-pseint {{folder_path}}/{{source_file_name}} --norun --nouser'
            + ' && jk-pseint {{folder_path}}/{{source_file_name}} --draw {{folder_path}}/{{source_file_name}}.psd'
            + ' && jk-psexport {{folder_path}}/{{source_file_name}}.psd {{folder_path}}/{{source_file_name}}.cpp --lang=cpp'
            + ' && g++ -x c++ -g -O2 -std=gnu++20 -static -o ' +
            '{{folder_path}}/{{compiled_file_name}} {{folder_path}}/{{source_file_name}}.cpp',
        runPattern: '{{folder_path}}/{{compiled_file_name}}',
        templateSourceCode: 'Algoritmo HOLA_MUNDO\n\tImprimir "Hello World"\nFinAlgoritmo\n',
        hasBuildFile: false,
        executable: '',
        executableVersion: '',
    },
    [ProgrammingLanguage.JSON]: {
        value: ProgrammingLanguage.JSON,
        label: 'JSON',
        mime: 'application/json',
        fileExtension: ['json'],
        monacoKey: 'json',
        codeMirrorKey: 'javascript',
        compilePattern: '',
        runPattern: '',
        templateSourceCode: '{\n  \n}',
        hasBuildFile: false,
        executable: '',
        executableVersion: '',
    },
    [ProgrammingLanguage.TEXT]: {
        value: ProgrammingLanguage.TEXT,
        label: 'plain text',
        mime: 'text/plain',
        fileExtension: ['txt', 'text'],
        monacoKey: 'text',
        codeMirrorKey: 'text',
        compilePattern: '',
        runPattern: '',
        templateSourceCode: '',
        hasBuildFile: false,
        executable: '',
        executableVersion: '',
    }, // asc txt text diff pot
    [ProgrammingLanguage.MARKDOWN]: {
        value: ProgrammingLanguage.MARKDOWN,
        label: 'Markdown',
        mime: 'text/plain',
        fileExtension: ['md'],
        monacoKey: 'markdown',
        codeMirrorKey: 'markdown',
        compilePattern: '',
        runPattern: '',
        templateSourceCode: '# Hello World\n',
        hasBuildFile: false,
        executable: '',
        executableVersion: '',
    },
    [ProgrammingLanguage.ARDUINO]: {
        value: ProgrammingLanguage.ARDUINO,
        label: 'Arduino',
        mime: 'text/plain',
        fileExtension: ['c', 'cpp', 'pde', 'h', 'ino'],
        monacoKey: 'c',
        codeMirrorKey: 'c',
        compilePattern: '',
        runPattern: '',
        templateSourceCode: '',
        hasBuildFile: false,
        executable: '',
        executableVersion: '',
    },
    [ProgrammingLanguage.HTML]: {
        value: ProgrammingLanguage.HTML,
        label: 'HTML',
        mime: 'text/HTML',
        fileExtension: ['html'],
        monacoKey: 'html',
        codeMirrorKey: 'html',
        compilePattern: '',
        runPattern: '',
        templateSourceCode: '',
        hasBuildFile: false,
        executable: '',
        executableVersion: '',
    },
    [ProgrammingLanguage.DOT]: {
        value: ProgrammingLanguage.DOT,
        label: 'DOT',
        mime: 'text/plain',
        fileExtension: ['dot'],
        monacoKey: 'dot',
        codeMirrorKey: 'dot',
        compilePattern: '',
        runPattern: '',
        templateSourceCode: '',
        hasBuildFile: false,
        executable: '',
        executableVersion: '',
    },
});
({
    [CompanyPlan.FREE]: {
        value: CompanyPlan.FREE,
        label: 'free',
        description: 'the resources, runners and compilers, are shared with the juki.app giving priority to juki.app',
    },
    [CompanyPlan.STANDARD]: {
        value: CompanyPlan.STANDARD,
        label: 'standard',
        description: 'the resources are dedicated, 1 runner and 1 compiler',
    },
    [CompanyPlan.PREMIUM]: {
        value: CompanyPlan.PREMIUM,
        label: 'premium',
        description: 'the resources are dedicated and on demand use with at least 1 runner and 1 compiler',
    },
    [CompanyPlan.CUSTOM]: {
        value: CompanyPlan.CUSTOM,
        label: 'custom',
        description: 'the resources are dedicated and on demand use with at least 1 (settable) runner and 1 (settable) compiler',
    },
});

({
    [ContestStatus.PUBLIC]: {
        value: ContestStatus.PUBLIC,
        label: 'public',
        description: 'the contest will appear in the contest list and the users will have access according to their roles',
    },
    [ContestStatus.RESERVED]: {
        value: ContestStatus.RESERVED,
        label: 'reserved',
        description: 'the contest will appear in the contest list only for contest members and the users will have access according to their roles',
    },
    [ContestStatus.ARCHIVED]: {
        value: ContestStatus.ARCHIVED,
        label: 'archived',
        description: 'the contest will not appear for anyone, contact the administrator to see it again',
    },
});
function isObjectJson(obj) {
    try {
        return typeof JSON.stringify(obj) === 'string';
    }
    catch (e) {
        return false;
    }
}
function chunkString(str, size) {
    const numChunks = Math.ceil(str.length / size);
    const chunks = new Array(numChunks);
    for (let i = 0, o = 0; i < numChunks; ++i, o += size) {
        chunks[i] = str.substr(o, size);
    }
    return chunks;
}

/* eslint-disable no-extend-native */
Date.prototype.changeYear = function (year) {
    const newDate = new Date(this);
    newDate.setFullYear(year);
    return newDate;
};
Date.prototype.changeMonth = function (monthIndex) {
    const newDate = new Date(this);
    newDate.setMonth(monthIndex);
    return newDate;
};
Date.prototype.changeDay = function (date) {
    const newDate = new Date(this);
    newDate.setDate(date);
    return newDate;
};
Date.prototype.changeHours = function (hours) {
    const newDate = new Date(this);
    newDate.setHours(hours);
    return newDate;
};
Date.prototype.changeMinutes = function (minutes) {
    const newDate = new Date(this);
    newDate.setMinutes(minutes);
    return newDate;
};
Date.prototype.changeSeconds = function (seconds) {
    const newDate = new Date(this);
    newDate.setSeconds(seconds);
    return newDate;
};
Date.prototype.changeMilliseconds = function (milliseconds) {
    const newDate = new Date(this);
    newDate.setMilliseconds(milliseconds);
    return newDate;
};
Date.prototype.decreaseYear = function (count = 1) {
    return this.changeYear(this.getFullYear() - count);
};
Date.prototype.increaseYear = function (count = 1) {
    return this.changeYear(this.getFullYear() + count);
};
Date.prototype.decreaseMonth = function () {
    const newDate = new Date(this);
    newDate.setMonth(newDate.getMonth() - 1);
    return newDate;
};
Date.prototype.increaseMonth = function () {
    const newDate = new Date(this);
    newDate.setMonth(newDate.getMonth() + 1);
    return newDate;
};
Date.prototype.increaseDay = function () {
    const newDate = new Date(this);
    newDate.setDate(newDate.getDate() + 1);
    return newDate;
};
Date.prototype.decreaseDay = function () {
    const newDate = new Date(this);
    newDate.setDate(newDate.getDate() + 1);
    return newDate;
};
Date.prototype.startOfYear = function () {
    const newDate = new Date(this);
    newDate.setMonth(0);
    return newDate.startOfMonth();
};
Date.prototype.endOfYear = function () {
    const nextMonth = this.increaseYear().startOfYear();
    return new Date(nextMonth.getTime() - 1);
};
Date.prototype.startOfMonth = function () {
    const newDate = new Date(this);
    newDate.setDate(1);
    return newDate.startOfDay();
};
Date.prototype.endOfMonth = function () {
    const nextMonth = this.increaseMonth().startOfMonth();
    return new Date(nextMonth.getTime() - 1);
};
Date.prototype.startOfWeek = function () {
    const newDate = new Date(this);
    while (newDate.getDay()) {
        newDate.setDate(newDate.getDate() - 1);
    }
    return newDate.startOfDay();
};
Date.prototype.endOfWeek = function () {
    const newDate = new Date(this);
    while (newDate.getDay() < 6) {
        newDate.setDate(newDate.getDate() - 1);
    }
    return newDate.endOfDay();
};
Date.prototype.startOfDay = function () {
    const newDate = new Date(this);
    newDate.setHours(0, 0, 0, 0);
    return newDate;
};
Date.prototype.endOfDay = function () {
    const newDate = new Date(this);
    newDate.setHours(23, 59, 59, 999);
    return newDate;
};
Date.prototype.startOfHour = function () {
    const newDate = new Date(this);
    newDate.setMinutes(0, 0, 0);
    return newDate;
};
Date.prototype.endOfHour = function () {
    const newDate = new Date(this);
    newDate.setMinutes(59, 59, 999);
    return newDate;
};
Date.prototype.startOfMinute = function () {
    const newDate = new Date(this);
    newDate.setSeconds(0, 0);
    return newDate;
};
Date.prototype.endOfMinute = function () {
    const newDate = new Date(this);
    newDate.setSeconds(59, 999);
    return newDate;
};
Date.prototype.startOfSecond = function () {
    const newDate = new Date(this);
    newDate.setMilliseconds(0);
    return newDate;
};
Date.prototype.endOfSecond = function () {
    const newDate = new Date(this);
    newDate.setMilliseconds(999);
    return newDate;
};
Date.prototype.isToday = function () {
    const today = new Date();
    return this.isSameDay(today);
};
Date.prototype.isEqual = function (date) {
    return this.getTime() === date.getTime();
};
Date.prototype.isSameYear = function (date) {
    return this.getFullYear() === date.getFullYear();
};
Date.prototype.isSameMonth = function (date) {
    return this.isSameYear(date) && this.getMonth() === date.getMonth();
};
Date.prototype.isSameDay = function (date) {
    return this.isSameMonth(date) && this.getDate() === date.getDate();
};
Date.prototype.isSameHour = function (date) {
    return this.isSameDay(date) && this.getHours() === date.getHours();
};
Date.prototype.isSameMinute = function (date) {
    return this.isSameHour(date) && this.getMinutes() === date.getMinutes();
};
Date.prototype.isSameSecond = function (date) {
    return this.isSameMinute(date) && this.getSeconds() === date.getSeconds();
};
Date.prototype.isSameMillisecond = function (date) {
    return this.isEqual(date);
};
Date.prototype.isValidDate = function () {
    return this instanceof Date && !isNaN(this.getTime());
};
Date.prototype.isYearAfter = function (date) {
    return this.getFullYear() > date.getFullYear();
};
Date.prototype.isMonthAfter = function (date) {
    return this.isYearAfter(date) || (this.isSameYear(date) && this.getMonth() > date.getMonth());
};
Date.prototype.isDayAfter = function (date) {
    return this.isMonthAfter(date) || (this.isSameMonth(date) && this.getDate() > date.getDate());
};
Date.prototype.isHoursAfter = function (date) {
    return this.isDayAfter(date) || (this.isSameDay(date) && this.getHours() > date.getHours());
};
Date.prototype.isMinutesAfter = function (date) {
    return this.isHoursAfter(date) || (this.isSameHour(date) && this.getMinutes() > date.getMinutes());
};
Date.prototype.isSecondsAfter = function (date) {
    return this.isMinutesAfter(date) || (this.isSameMinute(date) && this.getSeconds() > date.getSeconds());
};
Date.prototype.isMillisecondsAfter = function (date) {
    return this.isSecondsAfter(date) || (this.isSameSecond(date) && this.getMilliseconds() > date.getMilliseconds());
};
Date.prototype.isAfter = function (date) {
    return this.getTime() > date.getTime();
};
Date.prototype.isYearBefore = function (date) {
    return this.getFullYear() < date.getFullYear();
};
Date.prototype.isMonthBefore = function (date) {
    return this.isYearBefore(date) || (this.isSameYear(date) && this.getMonth() < date.getMonth());
};
Date.prototype.isDayBefore = function (date) {
    return this.isMonthBefore(date) || (this.isSameMonth(date) && this.getDate() < date.getDate());
};
Date.prototype.isHoursBefore = function (date) {
    return this.isDayBefore(date) || (this.isSameDay(date) && this.getHours() < date.getHours());
};
Date.prototype.isMinutesBefore = function (date) {
    return this.isHoursBefore(date) || (this.isSameHour(date) && this.getMinutes() < date.getMinutes());
};
Date.prototype.isSecondsBefore = function (date) {
    return this.isMinutesBefore(date) || (this.isSameMinute(date) && this.getSeconds() < date.getSeconds());
};
Date.prototype.isMillisecondsBefore = function (date) {
    return this.isSecondsBefore(date) || (this.isSameSecond(date) && this.getMilliseconds() < date.getMilliseconds());
};
Date.prototype.isBefore = function (date) {
    return this.getTime() < date.getTime();
};
Date.prototype.isWithinInterval = function ({ start, end }, cmp = '[]') {
    return (cmp.charAt(0) === '[' ? this.isEqual(start) || this.isAfter(start) : this.isAfter(start)) &&
        (cmp.charAt(1) === '[' ? this.isEqual(end) || this.isBefore(end) : this.isBefore(end));
};

const ERROR = {
    // Http Errors
    [ErrorCode.ERR500]: { value: ErrorCode.ERR500, message: 'internal server error', status: 500 },
    [ErrorCode.ERR400]: { value: ErrorCode.ERR400, message: 'bad request', status: 400 },
    [ErrorCode.ERR401]: { value: ErrorCode.ERR401, message: 'unauthorized', status: 401 },
    [ErrorCode.ERR403]: { value: ErrorCode.ERR403, message: 'forbidden', status: 403 },
    [ErrorCode.ERR404]: { value: ErrorCode.ERR404, message: 'not found', status: 404 },
    [ErrorCode.ERR405]: { value: ErrorCode.ERR405, message: 'method not allowed', status: 405 },
    // UI general errors
    [ErrorCode.ERR9997]: { value: ErrorCode.ERR9997, message: 'aborted request', status: 400 },
    [ErrorCode.ERR9998]: { value: ErrorCode.ERR9998, message: 'error on response', status: 400 },
    [ErrorCode.ERR9999]: { value: ErrorCode.ERR9999, message: 'service no found', status: 400 },
    // COMPANY ERRORS ERR99XX
    [ErrorCode.ERR9900]: { value: ErrorCode.ERR0000, message: 'internal server error on company service', status: 500 },
    // Company server errors
    [ErrorCode.ERR9910]: { value: ErrorCode.ERR9910, message: 'company not created', status: 500 },
    [ErrorCode.ERR9911]: { value: ErrorCode.ERR9911, message: 'company not found', status: 500 },
    [ErrorCode.ERR9912]: { value: ErrorCode.ERR9912, message: 'company not updated', status: 500 },
    [ErrorCode.ERR9913]: { value: ErrorCode.ERR9913, message: 'company not deleted', status: 500 },
    // Company user permission error
    [ErrorCode.ERR9914]: { value: ErrorCode.ERR9914, message: 'not allowed to create the company', status: 400 },
    [ErrorCode.ERR9915]: { value: ErrorCode.ERR9915, message: 'not allowed to view the company', status: 400 },
    [ErrorCode.ERR9916]: { value: ErrorCode.ERR9916, message: 'not allowed to updated the company', status: 400 },
    [ErrorCode.ERR9917]: { value: ErrorCode.ERR9917, message: 'not allowed to deleted the company', status: 400 },
    // USER ERRORS ERR00XX
    [ErrorCode.ERR0000]: { value: ErrorCode.ERR0000, message: 'internal server error on users service', status: 500 },
    // User server errors
    [ErrorCode.ERR0010]: { value: ErrorCode.ERR0010, message: 'user not created', status: 500 },
    [ErrorCode.ERR0011]: { value: ErrorCode.ERR0011, message: 'user not found', status: 500 },
    [ErrorCode.ERR0012]: { value: ErrorCode.ERR0012, message: 'user not updated', status: 500 },
    [ErrorCode.ERR0013]: { value: ErrorCode.ERR0013, message: 'user not deleted', status: 500 },
    // User user permission error
    [ErrorCode.ERR0014]: { value: ErrorCode.ERR0014, message: 'not allowed to create the user', status: 400 },
    [ErrorCode.ERR0015]: { value: ErrorCode.ERR0015, message: 'not allowed to view the user', status: 400 },
    [ErrorCode.ERR0016]: { value: ErrorCode.ERR0016, message: 'not allowed to updated the user', status: 400 },
    [ErrorCode.ERR0017]: { value: ErrorCode.ERR0017, message: 'not allowed to deleted the user', status: 400 },
    // User status permissions errors
    [ErrorCode.ERR0018]: { value: ErrorCode.ERR0018, message: 'user is reported', status: 400 },
    [ErrorCode.ERR0019]: { value: ErrorCode.ERR0019, message: 'user is archived', status: 400 },
    // User others permissions errors
    [ErrorCode.ERR0020]: { value: ErrorCode.ERR0020, message: 'user with email requested not found', status: 400 },
    [ErrorCode.ERR0021]: { value: ErrorCode.ERR0021, message: 'user with nickname requested not found', status: 400 },
    [ErrorCode.ERR0022]: { value: ErrorCode.ERR0022, message: 'the email is already registered', status: 400 },
    [ErrorCode.ERR0023]: { value: ErrorCode.ERR0023, message: 'the nickname is already taken', status: 400 },
    [ErrorCode.ERR0024]: { value: ErrorCode.ERR0024, message: 'incorrect password', status: 400 },
    // User sessions errors
    [ErrorCode.ERR0050]: { value: ErrorCode.ERR0050, message: 'user session not created', status: 500 },
    [ErrorCode.ERR0051]: { value: ErrorCode.ERR0051, message: 'user session not found', status: 500 },
    [ErrorCode.ERR0052]: { value: ErrorCode.ERR0052, message: 'user session not updated', status: 500 },
    [ErrorCode.ERR0053]: { value: ErrorCode.ERR0053, message: 'user session not deleted', status: 500 },
    // PROBLEM ERRORS ERR01XX
    [ErrorCode.ERR0100]: { value: ErrorCode.ERR0100, message: 'internal server error on problems service', status: 500 },
    // Problem server errors
    [ErrorCode.ERR0110]: { value: ErrorCode.ERR0110, message: 'problem not created', status: 500 },
    [ErrorCode.ERR0111]: { value: ErrorCode.ERR0111, message: 'problem not found', status: 500 },
    [ErrorCode.ERR0112]: { value: ErrorCode.ERR0112, message: 'problem not updated', status: 500 },
    [ErrorCode.ERR0113]: { value: ErrorCode.ERR0113, message: 'problem not deleted', status: 500 },
    // Problem user permission error
    [ErrorCode.ERR0114]: { value: ErrorCode.ERR0114, message: 'not allowed to create the problem', status: 400 },
    [ErrorCode.ERR0115]: { value: ErrorCode.ERR0115, message: 'not allowed to view the problem', status: 400 },
    [ErrorCode.ERR0116]: { value: ErrorCode.ERR0116, message: 'not allowed to updated the problem', status: 400 },
    [ErrorCode.ERR0117]: { value: ErrorCode.ERR0117, message: 'not allowed to deleted the problem', status: 400 },
    // Problem others permissions errors
    [ErrorCode.ERR0118]: { value: ErrorCode.ERR0118, message: 'problem mode not supported', status: 500 },
    [ErrorCode.ERR0119]: { value: ErrorCode.ERR0119, message: 'problem type not supported', status: 500 },
    [ErrorCode.ERR0120]: { value: ErrorCode.ERR0120, message: 'problem time limit must be a number', status: 500 },
    [ErrorCode.ERR0121]: { value: ErrorCode.ERR0121, message: 'problem memory limit must be number', status: 500 },
    [ErrorCode.ERR0122]: { value: ErrorCode.ERR0122, message: 'test case file empty', status: 400 },
    // Contest Errors ERR02XX
    [ErrorCode.ERR0200]: { value: ErrorCode.ERR0200, message: 'internal server error on contests service', status: 500 },
    // Contest Server Error
    [ErrorCode.ERR0210]: { value: ErrorCode.ERR0210, message: 'contest not created', status: 500 },
    [ErrorCode.ERR0211]: { value: ErrorCode.ERR0211, message: 'contest not found', status: 500 },
    [ErrorCode.ERR0212]: { value: ErrorCode.ERR0212, message: 'contest not updated', status: 500 },
    [ErrorCode.ERR0213]: { value: ErrorCode.ERR0213, message: 'contest not deleted', status: 500 },
    // Contest User Permission error
    [ErrorCode.ERR0214]: { value: ErrorCode.ERR0214, message: 'not allowed to create the contest', status: 400 },
    [ErrorCode.ERR0215]: { value: ErrorCode.ERR0215, message: 'not allowed to view the contest', status: 400 },
    [ErrorCode.ERR0216]: { value: ErrorCode.ERR0216, message: 'not allowed to updated the contest', status: 400 },
    [ErrorCode.ERR0217]: { value: ErrorCode.ERR0217, message: 'not allowed to deleted the contest', status: 400 },
    // Contest Others permissions errors
    [ErrorCode.ERR0218]: { value: ErrorCode.ERR0218, message: 'not allowed to register to the contest', status: 400 },
    [ErrorCode.ERR0219]: { value: ErrorCode.ERR0219, message: 'is already registered', status: 400 },
    [ErrorCode.ERR0220]: { value: ErrorCode.ERR0220, message: 'not allowed to view contests', status: 400 },
    [ErrorCode.ERR0230]: { value: ErrorCode.ERR0230, message: 'scoreboard not created', status: 500 },
    [ErrorCode.ERR0231]: { value: ErrorCode.ERR0231, message: 'scoreboard not found', status: 500 },
    [ErrorCode.ERR0232]: { value: ErrorCode.ERR0232, message: 'scoreboard not updated', status: 500 },
    [ErrorCode.ERR0233]: { value: ErrorCode.ERR0233, message: 'scoreboard not deleted', status: 500 },
    [ErrorCode.ERR0234]: { value: ErrorCode.ERR0234, message: 'not allowed to create the scoreboard', status: 400 },
    [ErrorCode.ERR0235]: { value: ErrorCode.ERR0235, message: 'not allowed to view the scoreboard', status: 400 },
    [ErrorCode.ERR0236]: { value: ErrorCode.ERR0236, message: 'not allowed to update the scoreboard', status: 400 },
    [ErrorCode.ERR0237]: { value: ErrorCode.ERR0237, message: 'not allowed to delete the scoreboard', status: 400 },
    [ErrorCode.ERR0240]: { value: ErrorCode.ERR0240, message: 'clarification not created', status: 500 },
    [ErrorCode.ERR0241]: { value: ErrorCode.ERR0241, message: 'clarification not found', status: 500 },
    [ErrorCode.ERR0242]: { value: ErrorCode.ERR0242, message: 'clarification not updated', status: 500 },
    [ErrorCode.ERR0243]: { value: ErrorCode.ERR0243, message: 'clarification not deleted', status: 500 },
    [ErrorCode.ERR0244]: { value: ErrorCode.ERR0244, message: 'not allowed to submit clarification', status: 400 },
    [ErrorCode.ERR0245]: { value: ErrorCode.ERR0245, message: 'not allowed to view clarification', status: 400 },
    [ErrorCode.ERR0246]: { value: ErrorCode.ERR0246, message: 'not allowed to update clarification', status: 400 },
    [ErrorCode.ERR0247]: { value: ErrorCode.ERR0247, message: 'not allowed to delete clarification', status: 400 },
    // Submission Errors ERR03XXX
    [ErrorCode.ERR0300]: { value: ErrorCode.ERR0300, message: 'internal server error on submissions service', status: 500 },
    [ErrorCode.ERR0301]: { value: ErrorCode.ERR0301, message: 'submission not found', status: 500 },
    [ErrorCode.ERR0302]: { value: ErrorCode.ERR0302, message: 'submission not created', status: 500 },
    [ErrorCode.ERR0303]: { value: ErrorCode.ERR0303, message: 'submission not updated', status: 500 },
    [ErrorCode.ERR0310]: { value: ErrorCode.ERR0310, message: 'source empty', status: 400 },
    [ErrorCode.ERR0311]: { value: ErrorCode.ERR0311, message: 'programming language not supported', status: 400 },
    [ErrorCode.ERR0321]: { value: ErrorCode.ERR0321, message: 'not allowed submit the problem in the contest', status: 400 },
    [ErrorCode.ERR0331]: { value: ErrorCode.ERR0331, message: 'judgement unavailable', status: 400 },
    // Utils Errors ERR04XX
    [ErrorCode.ERR0400]: { value: ErrorCode.ERR0400, message: 'internal server error on utils services', status: 500 },
    [ErrorCode.ERR0410]: { value: ErrorCode.ERR0410, message: 'empty image', status: 400 },
    [ErrorCode.ERR0420]: { value: ErrorCode.ERR0420, message: '', status: 400 }, // codes
    [ErrorCode.ERR0421]: { value: ErrorCode.ERR0421, message: 'compilation failed', status: 400 }, // codes
    [ErrorCode.ERR0430]: { value: ErrorCode.ERR0430, message: '', status: 400 }, // files
    [ErrorCode.ERR0440]: { value: ErrorCode.ERR0440, message: 'the email could not be sent', status: 400 }, // mails
    // TEAMS ERRORS ERR06XX
    [ErrorCode.ERR0600]: { value: ErrorCode.ERR0600, message: 'internal server error on teams service', status: 500 },
    // Teams server errors
    [ErrorCode.ERR0610]: { value: ErrorCode.ERR0610, message: 'team not created', status: 400 },
    [ErrorCode.ERR0611]: { value: ErrorCode.ERR0611, message: 'team not found', status: 400 },
    [ErrorCode.ERR0612]: { value: ErrorCode.ERR0612, message: 'team not updated', status: 400 },
    [ErrorCode.ERR0613]: { value: ErrorCode.ERR0613, message: 'team not deleted', status: 400 },
    // Teams user permission error
    [ErrorCode.ERR0614]: { value: ErrorCode.ERR0614, message: 'not allowed to create the team', status: 400 },
    [ErrorCode.ERR0615]: { value: ErrorCode.ERR0615, message: 'not allowed to view the team', status: 400 },
    [ErrorCode.ERR0616]: { value: ErrorCode.ERR0616, message: 'not allowed to updated the team', status: 400 },
    [ErrorCode.ERR0617]: { value: ErrorCode.ERR0617, message: 'not allowed to deleted the team', status: 400 },
    // Teams status permission error
    [ErrorCode.ERR0618]: { value: ErrorCode.ERR0618, message: 'team is reported', status: 400 },
    [ErrorCode.ERR0619]: { value: ErrorCode.ERR0619, message: 'team is archived', status: 400 },
    // FILES ERRORS ERR08XX
    [ErrorCode.ERR0800]: { value: ErrorCode.ERR0800, message: 'internal server error on files service', status: 500 },
    // Files server errors
    [ErrorCode.ERR0810]: { value: ErrorCode.ERR0810, message: 'file not created', status: 400 },
    [ErrorCode.ERR0811]: { value: ErrorCode.ERR0811, message: 'file not found', status: 400 },
    [ErrorCode.ERR0812]: { value: ErrorCode.ERR0812, message: 'file not updated', status: 400 },
    [ErrorCode.ERR0813]: { value: ErrorCode.ERR0813, message: 'file not deleted', status: 400 },
    // Files user permission error
    [ErrorCode.ERR0814]: { value: ErrorCode.ERR0814, message: 'not allowed to create the file', status: 400 },
    [ErrorCode.ERR0815]: { value: ErrorCode.ERR0815, message: 'not allowed to view the file', status: 400 },
    [ErrorCode.ERR0816]: { value: ErrorCode.ERR0816, message: 'not allowed to updated the file', status: 400 },
    [ErrorCode.ERR0817]: { value: ErrorCode.ERR0817, message: 'not allowed to deleted the file', status: 400 },
    // Files status permission error
    [ErrorCode.ERR0818]: { value: ErrorCode.ERR0818, message: 'file is reserved', status: 400 },
    [ErrorCode.ERR0819]: { value: ErrorCode.ERR0819, message: 'file is private', status: 400 },
    [ErrorCode.ERR0820]: { value: ErrorCode.ERR0820, message: 'file is archived', status: 400 },
};

class JkError extends Error {
    constructor(code, custom) {
        const message = custom?.message || ERROR[code].message;
        super(message);
        this.message = message;
        this.code = code;
        if (custom?.stack) {
            this.stack = custom?.stack;
        }
    }
}

/* eslint-disable no-extend-native */
Number.prototype.padStart = function (maxLength, fillString = '0') {
    return (this + '').padStart(maxLength, fillString);
};
Number.prototype.padEnd = function (maxLength, fillString = '0') {
    return (this + '').padEnd(maxLength, fillString);
};

function toJkError(err) {
    const error = new Error();
    let code = err?.code;
    if (!(code in ErrorCode)) {
        code = ErrorCode.ERR500;
    }
    return new JkError(code, { message: err?.message || error.message, stack: err?.stack || error.stack });
}
function errorsResponse(message, ...errors) {
    return {
        success: false,
        message: message,
        errors: errors.map(error => ({
            code: error.code,
            message: error.message,
            detail: error.stack || new Error().stack || '',
        })),
    };
}
function contentResponse(message, content) {
    return {
        success: true,
        message,
        content,
    };
}
function contentsResponse(message, contents, meta) {
    return {
        success: true,
        message,
        contents,
        meta,
    };
}

({
    [Judge.CUSTOMER]: {
        value: Judge.CUSTOMER,
        label: '',
        logo: 'https://images.juki.pub/c/juki-judge-logo-horizontal-color.svg',
        logoSize: [883.991, 435],
        url: '',
        getLoginUrl: () => '',
        getProfileUrl: () => '',
        getSubmitUrl: () => '',
        getSubmissionUrl: () => '',
        getProblemUrl: (key) => `/problem/view/${key}`,
        getUserSubmissionsUrl: () => '',
    },
    [Judge.JUKI_JUDGE]: {
        value: Judge.JUKI_JUDGE,
        label: 'Juki Judge',
        logo: 'https://images.juki.pub/c/juki-judge-logo-horizontal-color.svg',
        logoSize: [883.991, 435],
        url: 'https://judge.juki.app',
        getLoginUrl: () => '',
        getProfileUrl: () => '',
        getSubmitUrl: () => '',
        getSubmissionUrl: () => '',
        getProblemUrl: (key) => `https://judge.juki.app/problem/view/${key}`,
        getUserSubmissionsUrl: () => '',
    },
    [Judge.CODEFORCES]: {
        value: Judge.CODEFORCES,
        label: 'Codeforces',
        logo: 'https://images.juki.pub/c/codeforces-logo-horizontal-color.svg',
        logoSize: [1232.75, 145.12],
        url: 'https://codeforces.com',
        getLoginUrl: () => 'https://codeforces.com/enter',
        getProfileUrl: () => '',
        getSubmitUrl: () => 'https://codeforces.com/problemset/submit',
        getSubmissionUrl: (problemKey, submissionId) => {
            const [contestId] = problemKey.split('-');
            return `https://codeforces.com/problemset/submission/${contestId}/${submissionId}`;
        },
        getProblemUrl: (problemKey) => {
            const [contestId, index] = problemKey.split('-');
            return `https://codeforces.com/problemset/problem/${contestId}/${index}`;
        },
        getUserSubmissionsUrl: () => '',
    },
    [Judge.CODEFORCES_GYM]: {
        value: Judge.CODEFORCES_GYM,
        label: 'Codeforces Gym',
        logo: 'https://images.juki.pub/c/codeforces-logo-horizontal-color.svg',
        logoSize: [1232.75, 145.12],
        url: 'https://codeforces.com',
        getLoginUrl: () => 'https://codeforces.com/enter',
        getProfileUrl: () => '',
        getSubmitUrl: (problemKey) => {
            const [gymContestId, index] = problemKey.split('-');
            return `https://codeforces.com/gym/${gymContestId}/submit`;
        },
        getSubmissionUrl: (problemKey, submissionId) => {
            const [gymContestId] = problemKey.split('-');
            return `https://codeforces.com/gym/${gymContestId}/submission/${submissionId}`;
        },
        getProblemUrl: (problemKey) => {
            const [gymContestId, index] = problemKey.split('-');
            return `https://codeforces.com/gym/${gymContestId}/problem/${index}`;
        },
        getUserSubmissionsUrl: () => '',
    },
    [Judge.JV_UMSA]: {
        value: Judge.JV_UMSA,
        label: 'Juez Virtual UMSA',
        logo: 'https://images.juki.pub/c/codeforces-logo-horizontal-color.svg',
        logoSize: [1232.75, 145.12],
        url: 'https://jv.umsa.bo',
        getLoginUrl: () => 'https://jv.umsa.bo/oj/login.php',
        getProfileUrl: () => 'https://jv.umsa.bo/oj/userInfo.php',
        getSubmitUrl: (problemKey) => {
            // single problem: '1019'
            // cib problem: '1019-A'
            const isContestProblem = problemKey.includes('-');
            // A -> 0, B -> 1, C -> 2, D -> 3, E -> 4, F -> 5, G -> 6, H -> 7, I -> 8, J -> 9
            const params = problemKey.split('-');
            return isContestProblem
                ? `https://jv.umsa.bo/oj/submitpage.php?cid=${params[0]}&pid=${params[1].charCodeAt(0) - 65}`
                : `https://jv.umsa.bo/oj/submitpage.php?id=${problemKey}`;
        },
        getSubmissionUrl: (problemKey, submissionId, username) => {
            // return `https://jv.umsa.bo/status.php?problem_id=&user_id=${username}&language=-1&jresult=-1`;
            return `https://jv.umsa.bo/oj/showsource.php?id=${submissionId}`;
        },
        getProblemUrl: (problemKey) => {
            const isContestProblem = problemKey.includes('-');
            const params = problemKey.split('-');
            return isContestProblem
                ? `https://jv.umsa.bo/oj/problem.php?cid=${params[0]}&pid=${params[1].charCodeAt(0) - 65}`
                : `https://jv.umsa.bo/oj/problem.php?id=${problemKey}`;
        },
        getUserSubmissionsUrl: (username) => `https://jv.umsa.bo/oj/status.php?user_id=${username}`,
    },
    [Judge.UVA_ONLINE_JUDGE]: {
        value: Judge.UVA_ONLINE_JUDGE,
        label: 'Uva Online Judge',
        logo: 'https://images.juki.pub/c/uva-online-judge-logo-color.png',
        logoSize: [150, 135.994],
        url: 'https://onlinejudge.org',
        getLoginUrl: () => '',
        getProfileUrl: () => '',
        getSubmitUrl: () => '',
        getSubmissionUrl: () => '',
        getProblemUrl: () => '',
        getUserSubmissionsUrl: () => '',
    },
    [Judge.AT_CODER]: {
        value: Judge.AT_CODER,
        label: 'AtCoder',
        logo: 'https://images.juki.pub/c/at-coder-logo-color.png',
        logoSize: [762.997, 675],
        url: 'https://atcoder.jp',
        getLoginUrl: () => '',
        getProfileUrl: () => '',
        getSubmitUrl: () => '',
        getSubmissionUrl: () => '',
        getProblemUrl: () => '',
        getUserSubmissionsUrl: () => '',
    },
    [Judge.CODECHEF]: {
        value: Judge.CODECHEF,
        label: 'Codechef',
        logo: 'https://images.juki.pub/c/codechef-logo-color.svg',
        logoSize: [1207.7, 453.17],
        url: 'https://www.codechef.com',
        getLoginUrl: () => '',
        getProfileUrl: () => '',
        getSubmitUrl: () => '',
        getSubmissionUrl: () => '',
        getProblemUrl: () => '',
        getUserSubmissionsUrl: () => '',
    },
    [Judge.TOPCODER]: {
        value: Judge.TOPCODER,
        label: 'Topcoder',
        logo: 'https://images.juki.pub/c/topcoder-logo-color.png',
        logoSize: [971.99, 415.99],
        url: 'https://www.topcoder.com',
        getLoginUrl: () => '',
        getProfileUrl: () => '',
        getSubmitUrl: () => '',
        getSubmissionUrl: () => '',
        getProblemUrl: () => '',
        getUserSubmissionsUrl: () => '',
    },
});
[
    ProblemScoringMode.TOTAL,
    ProblemScoringMode.SUBTASK,
    ProblemScoringMode.PARTIAL,
];
[
    ProblemType.STANDARD,
    ProblemType.DYNAMIC,
];
[
    ProgrammingLanguage.ICPC_C,
    ProgrammingLanguage.C,
    ProgrammingLanguage.ICPC_CPP,
    ProgrammingLanguage.CPP,
    ProgrammingLanguage.CPP11,
    ProgrammingLanguage.CPP14,
    ProgrammingLanguage.CPP17,
    ProgrammingLanguage.JAVA,
    ProgrammingLanguage.JAVASCRIPT,
    ProgrammingLanguage.ICPC_PYTHON,
    ProgrammingLanguage.PYTHON,
    ProgrammingLanguage.PYTHON3,
    ProgrammingLanguage.PSEUDOCODE_PSEINT,
];
[
    ProgrammingLanguage.ICPC_C,
    ProgrammingLanguage.C,
    ProgrammingLanguage.ICPC_CPP,
    ProgrammingLanguage.CPP11,
    ProgrammingLanguage.CPP14,
    ProgrammingLanguage.CPP17,
    ProgrammingLanguage.JAVA,
    ProgrammingLanguage.JAVASCRIPT,
    ProgrammingLanguage.ICPC_PYTHON,
    ProgrammingLanguage.PYTHON,
    ProgrammingLanguage.PYTHON3,
    ProgrammingLanguage.PSEUDOCODE_PSEINT,
];
({
    [ProblemVerdict.NONE]: { value: ProblemVerdict.NONE, label: 'none', color: '#555555' },
    [ProblemVerdict.PENDING]: { value: ProblemVerdict.PENDING, label: 'pending', color: '#79B6FD' },
    [ProblemVerdict.HIDDEN]: { value: ProblemVerdict.HIDDEN, label: 'hidden', color: '#555555' },
    [ProblemVerdict.AC]: { value: ProblemVerdict.AC, label: 'accepted', color: '#43D787' },
    [ProblemVerdict.PE]: { value: ProblemVerdict.PE, label: 'presentation error', color: '#55db93' },
    [ProblemVerdict.PA]: { value: ProblemVerdict.PA, label: 'partial accepted', color: '#55db93' },
    [ProblemVerdict.CE]: { value: ProblemVerdict.CE, label: 'compilation error', color: '#FE9F9F' },
    [ProblemVerdict.RE]: { value: ProblemVerdict.RE, label: 'runtime error', color: '#FE9F9F' },
    [ProblemVerdict.TLE]: { value: ProblemVerdict.TLE, label: 'time limit exceed', color: '#FE9F9F' },
    [ProblemVerdict.MLE]: { value: ProblemVerdict.MLE, label: 'memory limit exceed', color: '#FE9F9F' },
    [ProblemVerdict.WA]: { value: ProblemVerdict.WA, label: 'wrong answer', color: '#FE9F9F' },
});
[
    ProblemVerdict.NONE,
    ProblemVerdict.PENDING,
    ProblemVerdict.AC,
    ProblemVerdict.PE,
    ProblemVerdict.PA,
    ProblemVerdict.CE,
    ProblemVerdict.RE,
    ProblemVerdict.TLE,
    ProblemVerdict.MLE,
    ProblemVerdict.WA,
];
({
    [SubmissionRunStatus.NONE]: { value: SubmissionRunStatus.NONE, label: 'none' }, // status
    [SubmissionRunStatus.RECEIVED]: { value: SubmissionRunStatus.RECEIVED, label: 'received' }, // state
    [SubmissionRunStatus.COMPILING]: { value: SubmissionRunStatus.COMPILING, label: 'compiling' }, // state
    [SubmissionRunStatus.COMPILED]: { value: SubmissionRunStatus.COMPILED, label: 'compiled' }, // status
    [SubmissionRunStatus.COMPILATION_ERROR]: { value: SubmissionRunStatus.COMPILATION_ERROR, label: 'compilation error' }, // status
    [SubmissionRunStatus.FETCHING_TEST_CASES]: {
        value: SubmissionRunStatus.FETCHING_TEST_CASES,
        label: 'fetching test cases',
    }, // state
    [SubmissionRunStatus.RUNNING_TEST_CASE]: { value: SubmissionRunStatus.RUNNING_TEST_CASE, label: 'running test case' }, // state
    [SubmissionRunStatus.RUNNING_TEST_CASES]: {
        value: SubmissionRunStatus.RUNNING_TEST_CASES,
        label: 'running test cases',
    }, // state
    [SubmissionRunStatus.RUNNING_SAMPLE_TEST_CASES]: {
        value: SubmissionRunStatus.RUNNING_SAMPLE_TEST_CASES,
        label: 'running sample test cases',
    }, // state
    [SubmissionRunStatus.EXECUTED_TEST_CASE]: {
        value: SubmissionRunStatus.EXECUTED_TEST_CASE,
        label: 'executed test case',
    }, // status
    [SubmissionRunStatus.FAILED_TEST_CASE]: { value: SubmissionRunStatus.FAILED_TEST_CASE, label: 'failed test case' }, // status
    [SubmissionRunStatus.JUDGING_TEST_CASE]: { value: SubmissionRunStatus.JUDGING_TEST_CASE, label: 'judging test case' }, // state
    [SubmissionRunStatus.GRADING]: { value: SubmissionRunStatus.GRADING, label: 'grading' }, // status
    [SubmissionRunStatus.FAILED]: { value: SubmissionRunStatus.FAILED, label: 'failed' }, // status
    [SubmissionRunStatus.COMPLETED]: { value: SubmissionRunStatus.COMPLETED, label: 'completed' }, // status
});
({
    [RunnerType.HIGH_PERFORMANCE]: { value: RunnerType.HIGH_PERFORMANCE, label: 'high performance' },
    [RunnerType.LOW_PERFORMANCE]: { value: RunnerType.LOW_PERFORMANCE, label: 'low performance' },
});

({
    [ProblemInput.STANDARD]: { value: ProblemInput.STANDARD, label: 'standard' },
    [ProblemInput.INTERACTIVE]: { value: ProblemInput.INTERACTIVE, label: 'interactive' },
});
({
    [ProblemOutput.STANDARD]: { value: ProblemOutput.STANDARD, label: 'standard' },
    [ProblemOutput.DYNAMIC]: { value: ProblemOutput.DYNAMIC, label: 'dynamic' },
    [ProblemOutput.INTERACTIVE]: { value: ProblemOutput.INTERACTIVE, label: 'interactive' },
});
[ProblemScoringMode.TOTAL, ProblemScoringMode.SUBTASK, ProblemScoringMode.PARTIAL];
({
    [ProblemScoringMode.TOTAL]: {
        value: ProblemScoringMode.TOTAL,
        label: 'total',
        description: 'if all test cases are Accepted the result is Accepted '
            + 'otherwise it will be Runtime Error, Time Limited Exceeded, Memory Limited Exceeded, Wrong Answer or Presentation Error in that order.',
    },
    [ProblemScoringMode.SUBTASK]: {
        value: ProblemScoringMode.SUBTASK,
        label: 'subtask',
        description: 'the test cases are grouped and each group of test cases is assigned a score, '
            + 'if all test cases in a group are Accepted then the score assigned to that group of test cases is added to total score, '
            + 'if total score is equal to the sum of the assigned scores of all groups of test cases then the result is Accepted, '
            + 'otherwise if the total score is greater than zero the result is Partial Accepted with the total accumulated score, '
            + 'otherwise it will be Runtime Error, Time Limited Exceeded, Memory Limited Exceeded, Wrong Answer or Presentation Error in that order.',
    },
    [ProblemScoringMode.PARTIAL]: {
        value: ProblemScoringMode.PARTIAL,
        label: 'partial',
        description: 'the test cases are grouped and each group is associated with X points, '
            + 'and each test case in a group scores X points ',
    },
});
[ProblemType.STANDARD, ProblemType.DYNAMIC, ProblemType.INTERACTIVE];
({
    [ProblemType.STANDARD]: {
        value: ProblemType.STANDARD,
        label: 'standard',
        description: 'The contestant submit a single source code in one of the allowed programming languages. '
            + 'The source code is either standalone or to be compiled. '
            + 'The resulting user\'s executable does I/O standard input and output. '
            + 'The output produced by the contestant\'s program is then compared to the correct output using a simple diff algorithm.',
    },
    [ProblemType.INTERACTIVE]: {
        value: ProblemType.INTERACTIVE, label: 'interactive', description: 'developing..',
    },
    [ProblemType.DYNAMIC]: {
        value: ProblemType.DYNAMIC,
        label: 'dynamic',
        description: 'The contestant submit a single source code in one of the allowed programming languages. '
            + 'The user\'s source code is either standalone or to be compiled. '
            + 'The resulting user\'s executable does I/O standard input and output. '
            + 'The output produced by the contestant\'s program is saved. '
            + 'The problem editor save a single source code in C++ 17. '
            + 'The editor\'s source code can read judge input filepath argv[1], judge output filepath argv[2], user\'s output filepath argv[3], user\'s error filepath argv[4], user\'s log filepath argv[5], user\'s source filepath argv[6] and submission information filepath argv[7] (companyId, submitId, runId, userId, contestId, problemId, language, userNickname, timestamp). '
            + 'The resulting editor\'s executable should be "AC" or a number between 1 and 100 for partial accepted',
    },
});

({
    [FileType.FILE]: { value: FileType.FILE, label: 'file' },
    [FileType.FOLDER]: { value: FileType.FOLDER, label: 'folder' },
});
({
    [FileRole.RESTRICTED]: { value: FileRole.RESTRICTED, label: 'restricted', level: 5 },
    [FileRole.GUEST]: { value: FileRole.GUEST, label: 'guest', level: 4 },
    [FileRole.REGULAR]: { value: FileRole.REGULAR, label: 'regular', level: 3 },
    [FileRole.MASTER]: { value: FileRole.MASTER, label: 'master', level: 2 },
    [FileRole.ADMIN]: { value: FileRole.ADMIN, label: 'admin', level: 1 },
    [FileRole.SUPER_ADMIN]: { value: FileRole.SUPER_ADMIN, label: 'super admin', level: 0 },
});
({
    [EntityState.RELEASED]: {
        value: EntityState.RELEASED,
        label: 'released',
    },
    [EntityState.ARCHIVED]: {
        value: EntityState.ARCHIVED,
        label: 'archived',
    },
});
({
    [EntityAccess.PRIVATE]: {
        value: EntityAccess.PRIVATE,
        label: 'private',
        description: 'the record will be visible and editable only to the owner',
    },
    [EntityAccess.RESTRICTED]: {
        value: EntityAccess.RESTRICTED,
        label: 'restricted',
        description: 'the record will be visible to viewers and the owner and editable to editors and the owner',
    },
    [EntityAccess.PUBLIC]: {
        value: EntityAccess.PUBLIC,
        label: 'public',
        description: 'the record will be visible to anyone and editable to editors and the owner',
    },
    [EntityAccess.EXPOSED]: {
        value: EntityAccess.EXPOSED,
        label: 'exposed',
        description: 'the record will be visible and editable to anyone',
    },
});

var MemberType;
(function (MemberType) {
    MemberType["USER"] = "USER";
    MemberType["TEAM"] = "TEAM";
})(MemberType || (MemberType = {}));

var cookieParser$1 = {exports: {}};

var cookie = {};

/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredCookie;

function requireCookie () {
	if (hasRequiredCookie) return cookie;
	hasRequiredCookie = 1;

	/**
	 * Module exports.
	 * @public
	 */

	cookie.parse = parse;
	cookie.serialize = serialize;

	/**
	 * Module variables.
	 * @private
	 */

	var __toString = Object.prototype.toString;
	var __hasOwnProperty = Object.prototype.hasOwnProperty;

	/**
	 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
	 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
	 * which has been replaced by the token definition in RFC 7230 appendix B.
	 *
	 * cookie-name       = token
	 * token             = 1*tchar
	 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
	 *                     "*" / "+" / "-" / "." / "^" / "_" /
	 *                     "`" / "|" / "~" / DIGIT / ALPHA
	 */

	var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

	/**
	 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
	 *
	 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
	 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
	 *                     ; US-ASCII characters excluding CTLs,
	 *                     ; whitespace DQUOTE, comma, semicolon,
	 *                     ; and backslash
	 */

	var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;

	/**
	 * RegExp to match domain-value in RFC 6265 sec 4.1.1
	 *
	 * domain-value      = <subdomain>
	 *                     ; defined in [RFC1034], Section 3.5, as
	 *                     ; enhanced by [RFC1123], Section 2.1
	 * <subdomain>       = <label> | <subdomain> "." <label>
	 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
	 *                     Labels must be 63 characters or less.
	 *                     'let-dig' not 'letter' in the first char, per RFC1123
	 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
	 * <let-dig-hyp>     = <let-dig> | "-"
	 * <let-dig>         = <letter> | <digit>
	 * <letter>          = any one of the 52 alphabetic characters A through Z in
	 *                     upper case and a through z in lower case
	 * <digit>           = any one of the ten digits 0 through 9
	 *
	 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
	 *
	 * > (Note that a leading %x2E ("."), if present, is ignored even though that
	 * character is not permitted, but a trailing %x2E ("."), if present, will
	 * cause the user agent to ignore the attribute.)
	 */

	var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;

	/**
	 * RegExp to match path-value in RFC 6265 sec 4.1.1
	 *
	 * path-value        = <any CHAR except CTLs or ";">
	 * CHAR              = %x01-7F
	 *                     ; defined in RFC 5234 appendix B.1
	 */

	var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;

	/**
	 * Parse a cookie header.
	 *
	 * Parse the given cookie header string into an object
	 * The object has the various cookies as keys(names) => values
	 *
	 * @param {string} str
	 * @param {object} [opt]
	 * @return {object}
	 * @public
	 */

	function parse(str, opt) {
	  if (typeof str !== 'string') {
	    throw new TypeError('argument str must be a string');
	  }

	  var obj = {};
	  var len = str.length;
	  // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
	  if (len < 2) return obj;

	  var dec = (opt && opt.decode) || decode;
	  var index = 0;
	  var eqIdx = 0;
	  var endIdx = 0;

	  do {
	    eqIdx = str.indexOf('=', index);
	    if (eqIdx === -1) break; // No more cookie pairs.

	    endIdx = str.indexOf(';', index);

	    if (endIdx === -1) {
	      endIdx = len;
	    } else if (eqIdx > endIdx) {
	      // backtrack on prior semicolon
	      index = str.lastIndexOf(';', eqIdx - 1) + 1;
	      continue;
	    }

	    var keyStartIdx = startIndex(str, index, eqIdx);
	    var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
	    var key = str.slice(keyStartIdx, keyEndIdx);

	    // only assign once
	    if (!__hasOwnProperty.call(obj, key)) {
	      var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
	      var valEndIdx = endIndex(str, endIdx, valStartIdx);

	      if (str.charCodeAt(valStartIdx) === 0x22 /* " */ && str.charCodeAt(valEndIdx - 1) === 0x22 /* " */) {
	        valStartIdx++;
	        valEndIdx--;
	      }

	      var val = str.slice(valStartIdx, valEndIdx);
	      obj[key] = tryDecode(val, dec);
	    }

	    index = endIdx + 1;
	  } while (index < len);

	  return obj;
	}

	function startIndex(str, index, max) {
	  do {
	    var code = str.charCodeAt(index);
	    if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index;
	  } while (++index < max);
	  return max;
	}

	function endIndex(str, index, min) {
	  while (index > min) {
	    var code = str.charCodeAt(--index);
	    if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index + 1;
	  }
	  return min;
	}

	/**
	 * Serialize data into a cookie header.
	 *
	 * Serialize a name value pair into a cookie string suitable for
	 * http headers. An optional options object specifies cookie parameters.
	 *
	 * serialize('foo', 'bar', { httpOnly: true })
	 *   => "foo=bar; httpOnly"
	 *
	 * @param {string} name
	 * @param {string} val
	 * @param {object} [opt]
	 * @return {string}
	 * @public
	 */

	function serialize(name, val, opt) {
	  var enc = (opt && opt.encode) || encodeURIComponent;

	  if (typeof enc !== 'function') {
	    throw new TypeError('option encode is invalid');
	  }

	  if (!cookieNameRegExp.test(name)) {
	    throw new TypeError('argument name is invalid');
	  }

	  var value = enc(val);

	  if (!cookieValueRegExp.test(value)) {
	    throw new TypeError('argument val is invalid');
	  }

	  var str = name + '=' + value;
	  if (!opt) return str;

	  if (null != opt.maxAge) {
	    var maxAge = Math.floor(opt.maxAge);

	    if (!isFinite(maxAge)) {
	      throw new TypeError('option maxAge is invalid')
	    }

	    str += '; Max-Age=' + maxAge;
	  }

	  if (opt.domain) {
	    if (!domainValueRegExp.test(opt.domain)) {
	      throw new TypeError('option domain is invalid');
	    }

	    str += '; Domain=' + opt.domain;
	  }

	  if (opt.path) {
	    if (!pathValueRegExp.test(opt.path)) {
	      throw new TypeError('option path is invalid');
	    }

	    str += '; Path=' + opt.path;
	  }

	  if (opt.expires) {
	    var expires = opt.expires;

	    if (!isDate(expires) || isNaN(expires.valueOf())) {
	      throw new TypeError('option expires is invalid');
	    }

	    str += '; Expires=' + expires.toUTCString();
	  }

	  if (opt.httpOnly) {
	    str += '; HttpOnly';
	  }

	  if (opt.secure) {
	    str += '; Secure';
	  }

	  if (opt.partitioned) {
	    str += '; Partitioned';
	  }

	  if (opt.priority) {
	    var priority = typeof opt.priority === 'string'
	      ? opt.priority.toLowerCase() : opt.priority;

	    switch (priority) {
	      case 'low':
	        str += '; Priority=Low';
	        break
	      case 'medium':
	        str += '; Priority=Medium';
	        break
	      case 'high':
	        str += '; Priority=High';
	        break
	      default:
	        throw new TypeError('option priority is invalid')
	    }
	  }

	  if (opt.sameSite) {
	    var sameSite = typeof opt.sameSite === 'string'
	      ? opt.sameSite.toLowerCase() : opt.sameSite;

	    switch (sameSite) {
	      case true:
	        str += '; SameSite=Strict';
	        break;
	      case 'lax':
	        str += '; SameSite=Lax';
	        break;
	      case 'strict':
	        str += '; SameSite=Strict';
	        break;
	      case 'none':
	        str += '; SameSite=None';
	        break;
	      default:
	        throw new TypeError('option sameSite is invalid');
	    }
	  }

	  return str;
	}

	/**
	 * URL-decode string value. Optimized to skip native call when no %.
	 *
	 * @param {string} str
	 * @returns {string}
	 */

	function decode (str) {
	  return str.indexOf('%') !== -1
	    ? decodeURIComponent(str)
	    : str
	}

	/**
	 * Determine if value is a Date.
	 *
	 * @param {*} val
	 * @private
	 */

	function isDate (val) {
	  return __toString.call(val) === '[object Date]';
	}

	/**
	 * Try decoding a string using a decoding function.
	 *
	 * @param {string} str
	 * @param {function} decode
	 * @private
	 */

	function tryDecode(str, decode) {
	  try {
	    return decode(str);
	  } catch (e) {
	    return str;
	  }
	}
	return cookie;
}

/*!
 * cookie-parser
 * Copyright(c) 2014 TJ Holowaychuk
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredCookieParser;

function requireCookieParser () {
	if (hasRequiredCookieParser) return cookieParser$1.exports;
	hasRequiredCookieParser = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var cookie = requireCookie();
	var signature = requireCookieSignature();

	/**
	 * Module exports.
	 * @public
	 */

	cookieParser$1.exports = cookieParser;
	cookieParser$1.exports.JSONCookie = JSONCookie;
	cookieParser$1.exports.JSONCookies = JSONCookies;
	cookieParser$1.exports.signedCookie = signedCookie;
	cookieParser$1.exports.signedCookies = signedCookies;

	/**
	 * Parse Cookie header and populate `req.cookies`
	 * with an object keyed by the cookie names.
	 *
	 * @param {string|array} [secret] A string (or array of strings) representing cookie signing secret(s).
	 * @param {Object} [options]
	 * @return {Function}
	 * @public
	 */

	function cookieParser (secret, options) {
	  var secrets = !secret || Array.isArray(secret)
	    ? (secret || [])
	    : [secret];

	  return function cookieParser (req, res, next) {
	    if (req.cookies) {
	      return next()
	    }

	    var cookies = req.headers.cookie;

	    req.secret = secrets[0];
	    req.cookies = Object.create(null);
	    req.signedCookies = Object.create(null);

	    // no cookies
	    if (!cookies) {
	      return next()
	    }

	    req.cookies = cookie.parse(cookies, options);

	    // parse signed cookies
	    if (secrets.length !== 0) {
	      req.signedCookies = signedCookies(req.cookies, secrets);
	      req.signedCookies = JSONCookies(req.signedCookies);
	    }

	    // parse JSON cookies
	    req.cookies = JSONCookies(req.cookies);

	    next();
	  }
	}

	/**
	 * Parse JSON cookie string.
	 *
	 * @param {String} str
	 * @return {Object} Parsed object or undefined if not json cookie
	 * @public
	 */

	function JSONCookie (str) {
	  if (typeof str !== 'string' || str.substr(0, 2) !== 'j:') {
	    return undefined
	  }

	  try {
	    return JSON.parse(str.slice(2))
	  } catch (err) {
	    return undefined
	  }
	}

	/**
	 * Parse JSON cookies.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @public
	 */

	function JSONCookies (obj) {
	  var cookies = Object.keys(obj);
	  var key;
	  var val;

	  for (var i = 0; i < cookies.length; i++) {
	    key = cookies[i];
	    val = JSONCookie(obj[key]);

	    if (val) {
	      obj[key] = val;
	    }
	  }

	  return obj
	}

	/**
	 * Parse a signed cookie string, return the decoded value.
	 *
	 * @param {String} str signed cookie string
	 * @param {string|array} secret
	 * @return {String} decoded value
	 * @public
	 */

	function signedCookie (str, secret) {
	  if (typeof str !== 'string') {
	    return undefined
	  }

	  if (str.substr(0, 2) !== 's:') {
	    return str
	  }

	  var secrets = !secret || Array.isArray(secret)
	    ? (secret || [])
	    : [secret];

	  for (var i = 0; i < secrets.length; i++) {
	    var val = signature.unsign(str.slice(2), secrets[i]);

	    if (val !== false) {
	      return val
	    }
	  }

	  return false
	}

	/**
	 * Parse signed cookies, returning an object containing the decoded key/value
	 * pairs, while removing the signed key from obj.
	 *
	 * @param {Object} obj
	 * @param {string|array} secret
	 * @return {Object}
	 * @public
	 */

	function signedCookies (obj, secret) {
	  var cookies = Object.keys(obj);
	  var dec;
	  var key;
	  var ret = Object.create(null);
	  var val;

	  for (var i = 0; i < cookies.length; i++) {
	    key = cookies[i];
	    val = obj[key];
	    dec = signedCookie(val, secret);

	    if (val !== dec) {
	      ret[key] = dec;
	      delete obj[key];
	    }
	  }

	  return ret
	}
	return cookieParser$1.exports;
}

var cookieParserExports = requireCookieParser();
var cookieParser = /*@__PURE__*/getDefaultExportFromCjs(cookieParserExports);

var lib$3 = {exports: {}};

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

var objectAssign;
var hasRequiredObjectAssign;

function requireObjectAssign () {
	if (hasRequiredObjectAssign) return objectAssign;
	hasRequiredObjectAssign = 1;
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};
	return objectAssign;
}

var hasRequiredLib$3;

function requireLib$3 () {
	if (hasRequiredLib$3) return lib$3.exports;
	hasRequiredLib$3 = 1;
	(function () {

	  var assign = requireObjectAssign();
	  var vary = requireVary();

	  var defaults = {
	    origin: '*',
	    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
	    preflightContinue: false,
	    optionsSuccessStatus: 204
	  };

	  function isString(s) {
	    return typeof s === 'string' || s instanceof String;
	  }

	  function isOriginAllowed(origin, allowedOrigin) {
	    if (Array.isArray(allowedOrigin)) {
	      for (var i = 0; i < allowedOrigin.length; ++i) {
	        if (isOriginAllowed(origin, allowedOrigin[i])) {
	          return true;
	        }
	      }
	      return false;
	    } else if (isString(allowedOrigin)) {
	      return origin === allowedOrigin;
	    } else if (allowedOrigin instanceof RegExp) {
	      return allowedOrigin.test(origin);
	    } else {
	      return !!allowedOrigin;
	    }
	  }

	  function configureOrigin(options, req) {
	    var requestOrigin = req.headers.origin,
	      headers = [],
	      isAllowed;

	    if (!options.origin || options.origin === '*') {
	      // allow any origin
	      headers.push([{
	        key: 'Access-Control-Allow-Origin',
	        value: '*'
	      }]);
	    } else if (isString(options.origin)) {
	      // fixed origin
	      headers.push([{
	        key: 'Access-Control-Allow-Origin',
	        value: options.origin
	      }]);
	      headers.push([{
	        key: 'Vary',
	        value: 'Origin'
	      }]);
	    } else {
	      isAllowed = isOriginAllowed(requestOrigin, options.origin);
	      // reflect origin
	      headers.push([{
	        key: 'Access-Control-Allow-Origin',
	        value: isAllowed ? requestOrigin : false
	      }]);
	      headers.push([{
	        key: 'Vary',
	        value: 'Origin'
	      }]);
	    }

	    return headers;
	  }

	  function configureMethods(options) {
	    var methods = options.methods;
	    if (methods.join) {
	      methods = options.methods.join(','); // .methods is an array, so turn it into a string
	    }
	    return {
	      key: 'Access-Control-Allow-Methods',
	      value: methods
	    };
	  }

	  function configureCredentials(options) {
	    if (options.credentials === true) {
	      return {
	        key: 'Access-Control-Allow-Credentials',
	        value: 'true'
	      };
	    }
	    return null;
	  }

	  function configureAllowedHeaders(options, req) {
	    var allowedHeaders = options.allowedHeaders || options.headers;
	    var headers = [];

	    if (!allowedHeaders) {
	      allowedHeaders = req.headers['access-control-request-headers']; // .headers wasn't specified, so reflect the request headers
	      headers.push([{
	        key: 'Vary',
	        value: 'Access-Control-Request-Headers'
	      }]);
	    } else if (allowedHeaders.join) {
	      allowedHeaders = allowedHeaders.join(','); // .headers is an array, so turn it into a string
	    }
	    if (allowedHeaders && allowedHeaders.length) {
	      headers.push([{
	        key: 'Access-Control-Allow-Headers',
	        value: allowedHeaders
	      }]);
	    }

	    return headers;
	  }

	  function configureExposedHeaders(options) {
	    var headers = options.exposedHeaders;
	    if (!headers) {
	      return null;
	    } else if (headers.join) {
	      headers = headers.join(','); // .headers is an array, so turn it into a string
	    }
	    if (headers && headers.length) {
	      return {
	        key: 'Access-Control-Expose-Headers',
	        value: headers
	      };
	    }
	    return null;
	  }

	  function configureMaxAge(options) {
	    var maxAge = (typeof options.maxAge === 'number' || options.maxAge) && options.maxAge.toString();
	    if (maxAge && maxAge.length) {
	      return {
	        key: 'Access-Control-Max-Age',
	        value: maxAge
	      };
	    }
	    return null;
	  }

	  function applyHeaders(headers, res) {
	    for (var i = 0, n = headers.length; i < n; i++) {
	      var header = headers[i];
	      if (header) {
	        if (Array.isArray(header)) {
	          applyHeaders(header, res);
	        } else if (header.key === 'Vary' && header.value) {
	          vary(res, header.value);
	        } else if (header.value) {
	          res.setHeader(header.key, header.value);
	        }
	      }
	    }
	  }

	  function cors(options, req, res, next) {
	    var headers = [],
	      method = req.method && req.method.toUpperCase && req.method.toUpperCase();

	    if (method === 'OPTIONS') {
	      // preflight
	      headers.push(configureOrigin(options, req));
	      headers.push(configureCredentials(options));
	      headers.push(configureMethods(options));
	      headers.push(configureAllowedHeaders(options, req));
	      headers.push(configureMaxAge(options));
	      headers.push(configureExposedHeaders(options));
	      applyHeaders(headers, res);

	      if (options.preflightContinue) {
	        next();
	      } else {
	        // Safari (and potentially other browsers) need content-length 0,
	        //   for 204 or they just hang waiting for a body
	        res.statusCode = options.optionsSuccessStatus;
	        res.setHeader('Content-Length', '0');
	        res.end();
	      }
	    } else {
	      // actual response
	      headers.push(configureOrigin(options, req));
	      headers.push(configureCredentials(options));
	      headers.push(configureExposedHeaders(options));
	      applyHeaders(headers, res);
	      next();
	    }
	  }

	  function middlewareWrapper(o) {
	    // if options are static (either via defaults or custom options passed in), wrap in a function
	    var optionsCallback = null;
	    if (typeof o === 'function') {
	      optionsCallback = o;
	    } else {
	      optionsCallback = function (req, cb) {
	        cb(null, o);
	      };
	    }

	    return function corsMiddleware(req, res, next) {
	      optionsCallback(req, function (err, options) {
	        if (err) {
	          next(err);
	        } else {
	          var corsOptions = assign({}, defaults, options);
	          var originCallback = null;
	          if (corsOptions.origin && typeof corsOptions.origin === 'function') {
	            originCallback = corsOptions.origin;
	          } else if (corsOptions.origin) {
	            originCallback = function (origin, cb) {
	              cb(null, corsOptions.origin);
	            };
	          }

	          if (originCallback) {
	            originCallback(req.headers.origin, function (err2, origin) {
	              if (err2 || !origin) {
	                next(err2);
	              } else {
	                corsOptions.origin = origin;
	                cors(corsOptions, req, res, next);
	              }
	            });
	          } else {
	            next();
	          }
	        }
	      });
	    };
	  }

	  // can pass either an options hash, an options delegate, or nothing
	  lib$3.exports = middlewareWrapper;

	}());
	return lib$3.exports;
}

var libExports$1 = requireLib$3();
var cors = /*@__PURE__*/getDefaultExportFromCjs(libExports$1);

const getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
    let httpHandler = runtimeConfig.httpHandler;
    return {
        setHttpHandler(handler) {
            httpHandler = handler;
        },
        httpHandler() {
            return httpHandler;
        },
        updateHttpClientConfig(key, value) {
            httpHandler.updateHttpClientConfig(key, value);
        },
        httpHandlerConfigs() {
            return httpHandler.httpHandlerConfigs();
        },
    };
};
const resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
    return {
        httpHandler: httpHandlerExtensionConfiguration.httpHandler(),
    };
};

var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));

var FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

const SMITHY_CONTEXT_KEY = "__smithy_context";

exports.IniSectionType = void 0;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(exports.IniSectionType || (exports.IniSectionType = {}));

var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

class HttpRequest {
    constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol
            ? options.protocol.slice(-1) !== ":"
                ? `${options.protocol}:`
                : options.protocol
            : "https:";
        this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
    }
    static clone(request) {
        const cloned = new HttpRequest({
            ...request,
            headers: { ...request.headers },
        });
        if (cloned.query) {
            cloned.query = cloneQuery(cloned.query);
        }
        return cloned;
    }
    static isInstance(request) {
        if (!request) {
            return false;
        }
        const req = request;
        return ("method" in req &&
            "protocol" in req &&
            "hostname" in req &&
            "path" in req &&
            typeof req["query"] === "object" &&
            typeof req["headers"] === "object");
    }
    clone() {
        return HttpRequest.clone(this);
    }
}
function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [...param] : param,
        };
    }, {});
}

class HttpResponse {
    constructor(options) {
        this.statusCode = options.statusCode;
        this.reason = options.reason;
        this.headers = options.headers || {};
        this.body = options.body;
    }
    static isInstance(response) {
        if (!response)
            return false;
        const resp = response;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
}

function resolveHostHeaderConfig(input) {
    return input;
}
const hostHeaderMiddleware = (options) => (next) => async (args) => {
    if (!HttpRequest.isInstance(args.request))
        return next(args);
    const { request } = args;
    const { handlerProtocol = "" } = options.requestHandler.metadata || {};
    if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
        delete request.headers["host"];
        request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
    }
    else if (!request.headers["host"]) {
        let host = request.hostname;
        if (request.port != null)
            host += `:${request.port}`;
        request.headers["host"] = host;
    }
    return next(args);
};
const hostHeaderMiddlewareOptions = {
    name: "hostHeaderMiddleware",
    step: "build",
    priority: "low",
    tags: ["HOST"],
    override: true,
};
const getHostHeaderPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
    },
});

const loggerMiddleware = () => (next, context) => async (args) => {
    try {
        const response = await next(args);
        const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
        const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
        const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
        const { $metadata, ...outputWithoutMetadata } = response.output;
        logger?.info?.({
            clientName,
            commandName,
            input: inputFilterSensitiveLog(args.input),
            output: outputFilterSensitiveLog(outputWithoutMetadata),
            metadata: $metadata,
        });
        return response;
    }
    catch (error) {
        const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
        const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
        logger?.error?.({
            clientName,
            commandName,
            input: inputFilterSensitiveLog(args.input),
            error,
            metadata: error.$metadata,
        });
        throw error;
    }
};
const loggerMiddlewareOptions = {
    name: "loggerMiddleware",
    tags: ["LOGGER"],
    step: "initialize",
    override: true,
};
const getLoggerPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
    },
});

const TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
const ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
const ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
const recursionDetectionMiddleware = (options) => (next) => async (args) => {
    const { request } = args;
    if (!HttpRequest.isInstance(request) ||
        options.runtime !== "node" ||
        request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
        return next(args);
    }
    const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
    const traceId = process.env[ENV_TRACE_ID];
    const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
    if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
        request.headers[TRACE_ID_HEADER_NAME] = traceId;
    }
    return next({
        ...args,
        request,
    });
};
const addRecursionDetectionMiddlewareOptions = {
    step: "build",
    tags: ["RECURSION_DETECTION"],
    name: "recursionDetectionMiddleware",
    override: true,
    priority: "low",
};
const getRecursionDetectionPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(recursionDetectionMiddleware(options), addRecursionDetectionMiddlewareOptions);
    },
});

const getSmithyContext = (context) => context[SMITHY_CONTEXT_KEY] || (context[SMITHY_CONTEXT_KEY] = {});

const normalizeProvider$1 = (input) => {
    if (typeof input === "function")
        return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
};

function convertHttpAuthSchemesToMap(httpAuthSchemes) {
    const map = new Map();
    for (const scheme of httpAuthSchemes) {
        map.set(scheme.schemeId, scheme);
    }
    return map;
}
const httpAuthSchemeMiddleware = (config, mwOptions) => (next, context) => async (args) => {
    const options = config.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config, context, args.input));
    const authSchemes = convertHttpAuthSchemesToMap(config.httpAuthSchemes);
    const smithyContext = getSmithyContext(context);
    const failureReasons = [];
    for (const option of options) {
        const scheme = authSchemes.get(option.schemeId);
        if (!scheme) {
            failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` was not enabled for this service.`);
            continue;
        }
        const identityProvider = scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config));
        if (!identityProvider) {
            failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` did not have an IdentityProvider configured.`);
            continue;
        }
        const { identityProperties = {}, signingProperties = {} } = option.propertiesExtractor?.(config, context) || {};
        option.identityProperties = Object.assign(option.identityProperties || {}, identityProperties);
        option.signingProperties = Object.assign(option.signingProperties || {}, signingProperties);
        smithyContext.selectedHttpAuthScheme = {
            httpAuthOption: option,
            identity: await identityProvider(option.identityProperties),
            signer: scheme.signer,
        };
        break;
    }
    if (!smithyContext.selectedHttpAuthScheme) {
        throw new Error(failureReasons.join("\n"));
    }
    return next(args);
};

const httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: "endpointV2Middleware",
};
const getHttpAuthSchemeEndpointRuleSetPlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider, }) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {
            httpAuthSchemeParametersProvider,
            identityProviderConfigProvider,
        }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);
    },
});

const deserializerMiddleware = (options, deserializer) => (next) => async (args) => {
    const { response } = await next(args);
    try {
        const parsed = await deserializer(response, options);
        return {
            response,
            output: parsed,
        };
    }
    catch (error) {
        Object.defineProperty(error, "$response", {
            value: response,
        });
        if (!("$metadata" in error)) {
            const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
            error.message += "\n  " + hint;
            if (typeof error.$responseBodyText !== "undefined") {
                if (error.$response) {
                    error.$response.body = error.$responseBodyText;
                }
            }
        }
        throw error;
    }
};

const serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
    const endpoint = context.endpointV2?.url && options.urlParser
        ? async () => options.urlParser(context.endpointV2.url)
        : options.endpoint;
    if (!endpoint) {
        throw new Error("No valid endpoint provider available.");
    }
    const request = await serializer(args.input, { ...options, endpoint });
    return next({
        ...args,
        request,
    });
};

const deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true,
};
const serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true,
};
function getSerdePlugin(config, serializer, deserializer) {
    return {
        applyToStack: (commandStack) => {
            commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
            commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
        },
    };
}

({
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: serializerMiddlewareOption.name,
});

const defaultErrorHandler$1 = (signingProperties) => (error) => {
    throw error;
};
const defaultSuccessHandler$1 = (httpResponse, signingProperties) => { };
const httpSigningMiddleware = (config) => (next, context) => async (args) => {
    if (!HttpRequest.isInstance(args.request)) {
        return next(args);
    }
    const smithyContext = getSmithyContext(context);
    const scheme = smithyContext.selectedHttpAuthScheme;
    if (!scheme) {
        throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
    }
    const { httpAuthOption: { signingProperties = {} }, identity, signer, } = scheme;
    const output = await next({
        ...args,
        request: await signer.sign(args.request, identity, signingProperties),
    }).catch((signer.errorHandler || defaultErrorHandler$1)(signingProperties));
    (signer.successHandler || defaultSuccessHandler$1)(output.response, signingProperties);
    return output;
};

const httpSigningMiddlewareOptions = {
    step: "finalizeRequest",
    tags: ["HTTP_SIGNING"],
    name: "httpSigningMiddleware",
    aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
    override: true,
    relation: "after",
    toMiddleware: "retryMiddleware",
};
const getHttpSigningPlugin = (config) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(httpSigningMiddleware(), httpSigningMiddlewareOptions);
    },
});

const normalizeProvider = (input) => {
    if (typeof input === "function")
        return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
};

const isArrayBuffer = (arg) => (typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer) ||
    Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

const fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
    if (!isArrayBuffer(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return require$$0$a.Buffer.from(input, offset, length);
};
const fromString$1 = (input, encoding) => {
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? require$$0$a.Buffer.from(input, encoding) : require$$0$a.Buffer.from(input);
};

const BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
const fromBase64 = (input) => {
    if ((input.length * 3) % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = fromString$1(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};

const fromUtf8$1 = (input) => {
    const buf = fromString$1(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};

const toUint8Array = (data) => {
    if (typeof data === "string") {
        return fromUtf8$1(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
};

const toUtf8 = (input) => {
    if (typeof input === "string") {
        return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
};

const toBase64 = (_input) => {
    let input;
    if (typeof _input === "string") {
        input = fromUtf8$1(_input);
    }
    else {
        input = _input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
    }
    return fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("base64");
};

function transformToString(payload, encoding = "utf-8") {
    if (encoding === "base64") {
        return toBase64(payload);
    }
    return toUtf8(payload);
}
function transformFromString(str, encoding) {
    if (encoding === "base64") {
        return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
    }
    return Uint8ArrayBlobAdapter.mutate(fromUtf8$1(str));
}

class Uint8ArrayBlobAdapter extends Uint8Array {
    static fromString(source, encoding = "utf-8") {
        switch (typeof source) {
            case "string":
                return transformFromString(source, encoding);
            default:
                throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
        }
    }
    static mutate(source) {
        Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
        return source;
    }
    transformToString(encoding = "utf-8") {
        return transformToString(this, encoding);
    }
}

const getAwsChunkedEncodingStream = (readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined &&
        checksumAlgorithmFn !== undefined &&
        checksumLocationName !== undefined &&
        streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const awsChunkedEncodingStream = new require$$0$9.Readable({ read: () => { } });
    readableStream.on("data", (data) => {
        const length = bodyLengthChecker(data) || 0;
        awsChunkedEncodingStream.push(`${length.toString(16)}\r\n`);
        awsChunkedEncodingStream.push(data);
        awsChunkedEncodingStream.push("\r\n");
    });
    readableStream.on("end", async () => {
        awsChunkedEncodingStream.push(`0\r\n`);
        if (checksumRequired) {
            const checksum = base64Encoder(await digest);
            awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r\n`);
            awsChunkedEncodingStream.push(`\r\n`);
        }
        awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
};

const escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
const hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;

function buildQueryString(query) {
    const parts = [];
    for (let key of Object.keys(query).sort()) {
        const value = query[key];
        key = escapeUri(key);
        if (Array.isArray(value)) {
            for (let i = 0, iLen = value.length; i < iLen; i++) {
                parts.push(`${key}=${escapeUri(value[i])}`);
            }
        }
        else {
            let qsEntry = key;
            if (value || typeof value === "string") {
                qsEntry += `=${escapeUri(value)}`;
            }
            parts.push(qsEntry);
        }
    }
    return parts.join("&");
}

const NODEJS_TIMEOUT_ERROR_CODES$1 = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];

const getTransformedHeaders = (headers) => {
    const transformedHeaders = {};
    for (const name of Object.keys(headers)) {
        const headerValues = headers[name];
        transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
    }
    return transformedHeaders;
};

const timing = {
    setTimeout: (cb, ms) => setTimeout(cb, ms),
    clearTimeout: (timeoutId) => clearTimeout(timeoutId),
};

const DEFER_EVENT_LISTENER_TIME$2 = 1000;
const setConnectionTimeout = (request, reject, timeoutInMs = 0) => {
    if (!timeoutInMs) {
        return -1;
    }
    const registerTimeout = (offset) => {
        const timeoutId = timing.setTimeout(() => {
            request.destroy();
            reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
                name: "TimeoutError",
            }));
        }, timeoutInMs - offset);
        const doWithSocket = (socket) => {
            if (socket?.connecting) {
                socket.on("connect", () => {
                    timing.clearTimeout(timeoutId);
                });
            }
            else {
                timing.clearTimeout(timeoutId);
            }
        };
        if (request.socket) {
            doWithSocket(request.socket);
        }
        else {
            request.on("socket", doWithSocket);
        }
    };
    if (timeoutInMs < 2000) {
        registerTimeout(0);
        return 0;
    }
    return timing.setTimeout(registerTimeout.bind(null, DEFER_EVENT_LISTENER_TIME$2), DEFER_EVENT_LISTENER_TIME$2);
};

const DEFER_EVENT_LISTENER_TIME$1 = 3000;
const setSocketKeepAlive = (request, { keepAlive, keepAliveMsecs }, deferTimeMs = DEFER_EVENT_LISTENER_TIME$1) => {
    if (keepAlive !== true) {
        return -1;
    }
    const registerListener = () => {
        if (request.socket) {
            request.socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
        }
        else {
            request.on("socket", (socket) => {
                socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
            });
        }
    };
    if (deferTimeMs === 0) {
        registerListener();
        return 0;
    }
    return timing.setTimeout(registerListener, deferTimeMs);
};

const DEFER_EVENT_LISTENER_TIME = 3000;
const setSocketTimeout = (request, reject, timeoutInMs = 0) => {
    const registerTimeout = (offset) => {
        request.setTimeout(timeoutInMs - offset, () => {
            request.destroy();
            reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
        });
    };
    if (0 < timeoutInMs && timeoutInMs < 6000) {
        registerTimeout(0);
        return 0;
    }
    return timing.setTimeout(registerTimeout.bind(null, timeoutInMs === 0 ? 0 : DEFER_EVENT_LISTENER_TIME), DEFER_EVENT_LISTENER_TIME);
};

const MIN_WAIT_TIME = 1000;
async function writeRequestBody(httpRequest, request, maxContinueTimeoutMs = MIN_WAIT_TIME) {
    const headers = request.headers ?? {};
    const expect = headers["Expect"] || headers["expect"];
    let timeoutId = -1;
    let sendBody = true;
    if (expect === "100-continue") {
        sendBody = await Promise.race([
            new Promise((resolve) => {
                timeoutId = Number(timing.setTimeout(resolve, Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
            }),
            new Promise((resolve) => {
                httpRequest.on("continue", () => {
                    timing.clearTimeout(timeoutId);
                    resolve(true);
                });
                httpRequest.on("response", () => {
                    timing.clearTimeout(timeoutId);
                    resolve(false);
                });
                httpRequest.on("error", () => {
                    timing.clearTimeout(timeoutId);
                    resolve(false);
                });
            }),
        ]);
    }
    if (sendBody) {
        writeBody(httpRequest, request.body);
    }
}
function writeBody(httpRequest, body) {
    if (body instanceof require$$0$9.Readable) {
        body.pipe(httpRequest);
        return;
    }
    if (body) {
        if (Buffer.isBuffer(body) || typeof body === "string") {
            httpRequest.end(body);
            return;
        }
        const uint8 = body;
        if (typeof uint8 === "object" &&
            uint8.buffer &&
            typeof uint8.byteOffset === "number" &&
            typeof uint8.byteLength === "number") {
            httpRequest.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
            return;
        }
        httpRequest.end(Buffer.from(body));
        return;
    }
    httpRequest.end();
}

class NodeHttpHandler {
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttpHandler(instanceOrOptions);
    }
    static checkSocketUsage(agent, socketWarningTimestamp, logger = console) {
        const { sockets, requests, maxSockets } = agent;
        if (typeof maxSockets !== "number" || maxSockets === Infinity) {
            return socketWarningTimestamp;
        }
        const interval = 15000;
        if (Date.now() - interval < socketWarningTimestamp) {
            return socketWarningTimestamp;
        }
        if (sockets && requests) {
            for (const origin in sockets) {
                const socketsInUse = sockets[origin]?.length ?? 0;
                const requestsEnqueued = requests[origin]?.length ?? 0;
                if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
                    logger?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`);
                    return Date.now();
                }
            }
        }
        return socketWarningTimestamp;
    }
    constructor(options) {
        this.socketWarningTimestamp = 0;
        this.metadata = { handlerProtocol: "http/1.1" };
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((_options) => {
                    resolve(this.resolveDefaultConfig(_options));
                })
                    .catch(reject);
            }
            else {
                resolve(this.resolveDefaultConfig(options));
            }
        });
    }
    resolveDefaultConfig(options) {
        const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
            connectionTimeout,
            requestTimeout: requestTimeout ?? socketTimeout,
            httpAgent: (() => {
                if (httpAgent instanceof require$$0$b.Agent || typeof httpAgent?.destroy === "function") {
                    return httpAgent;
                }
                return new require$$0$b.Agent({ keepAlive, maxSockets, ...httpAgent });
            })(),
            httpsAgent: (() => {
                if (httpsAgent instanceof https.Agent || typeof httpsAgent?.destroy === "function") {
                    return httpsAgent;
                }
                return new https.Agent({ keepAlive, maxSockets, ...httpsAgent });
            })(),
            logger: console,
        };
    }
    destroy() {
        this.config?.httpAgent?.destroy();
        this.config?.httpsAgent?.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        return new Promise((_resolve, _reject) => {
            let writeRequestBodyPromise = undefined;
            const timeouts = [];
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                timeouts.forEach(timing.clearTimeout);
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                timeouts.forEach(timing.clearTimeout);
                _reject(arg);
            };
            if (!this.config) {
                throw new Error("Node HTTP request handler config is not resolved");
            }
            if (abortSignal?.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const isSSL = request.protocol === "https:";
            const agent = isSSL ? this.config.httpsAgent : this.config.httpAgent;
            timeouts.push(timing.setTimeout(() => {
                this.socketWarningTimestamp = NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp, this.config.logger);
            }, this.config.socketAcquisitionWarningTimeout ??
                (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000)));
            const queryString = buildQueryString(request.query || {});
            let auth = undefined;
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}`;
            }
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            let hostname = request.hostname ?? "";
            if (hostname[0] === "[" && hostname.endsWith("]")) {
                hostname = request.hostname.slice(1, -1);
            }
            else {
                hostname = request.hostname;
            }
            const nodeHttpsOptions = {
                headers: request.headers,
                host: hostname,
                method: request.method,
                path,
                port: request.port,
                agent,
                auth,
            };
            const requestFunc = isSSL ? https.request : require$$0$b.request;
            const req = requestFunc(nodeHttpsOptions, (res) => {
                const httpResponse = new HttpResponse({
                    statusCode: res.statusCode || -1,
                    reason: res.statusMessage,
                    headers: getTransformedHeaders(res.headers),
                    body: res,
                });
                resolve({ response: httpResponse });
            });
            req.on("error", (err) => {
                if (NODEJS_TIMEOUT_ERROR_CODES$1.includes(err.code)) {
                    reject(Object.assign(err, { name: "TimeoutError" }));
                }
                else {
                    reject(err);
                }
            });
            if (abortSignal) {
                const onAbort = () => {
                    req.destroy();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
                if (typeof abortSignal.addEventListener === "function") {
                    const signal = abortSignal;
                    signal.addEventListener("abort", onAbort, { once: true });
                    req.once("close", () => signal.removeEventListener("abort", onAbort));
                }
                else {
                    abortSignal.onabort = onAbort;
                }
            }
            timeouts.push(setConnectionTimeout(req, reject, this.config.connectionTimeout));
            timeouts.push(setSocketTimeout(req, reject, this.config.requestTimeout));
            const httpAgent = nodeHttpsOptions.agent;
            if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
                timeouts.push(setSocketKeepAlive(req, {
                    keepAlive: httpAgent.keepAlive,
                    keepAliveMsecs: httpAgent.keepAliveMsecs,
                }));
            }
            writeRequestBodyPromise = writeRequestBody(req, request, this.config.requestTimeout).catch((e) => {
                timeouts.forEach(timing.clearTimeout);
                return _reject(e);
            });
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

let Collector$1 = class Collector extends require$$0$9.Writable {
    constructor() {
        super(...arguments);
        this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
        this.bufferedBytes.push(chunk);
        callback();
    }
};

const streamCollector$1 = (stream) => {
    if (isReadableStreamInstance(stream)) {
        return collectReadableStream(stream);
    }
    return new Promise((resolve, reject) => {
        const collector = new Collector$1();
        stream.pipe(collector);
        stream.on("error", (err) => {
            collector.end();
            reject(err);
        });
        collector.on("error", reject);
        collector.on("finish", function () {
            const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
            resolve(bytes);
        });
    });
};
const isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;
async function collectReadableStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}

const streamCollector = async (stream) => {
    if ((typeof Blob === "function" && stream instanceof Blob) || stream.constructor?.name === "Blob") {
        return new Uint8Array(await stream.arrayBuffer());
    }
    return collectStream(stream);
};
async function collectStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}

const SHORT_TO_HEX = {};
const HEX_TO_SHORT = {};
for (let i = 0; i < 256; i++) {
    let encodedByte = i.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i;
}
function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i = 0; i < encoded.length; i += 2) {
        const encodedByte = encoded.slice(i, i + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
            out[i / 2] = HEX_TO_SHORT[encodedByte];
        }
        else {
            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
    }
    return out;
}
function toHex(bytes) {
    let out = "";
    for (let i = 0; i < bytes.byteLength; i++) {
        out += SHORT_TO_HEX[bytes[i]];
    }
    return out;
}

const isReadableStream = (stream) => typeof ReadableStream === "function" &&
    (stream?.constructor?.name === ReadableStream.name || stream instanceof ReadableStream);
const isBlob = (blob) => {
    return typeof Blob === "function" && (blob?.constructor?.name === Blob.name || blob instanceof Blob);
};

const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED$1 = "The stream has already been transformed.";
const sdkStreamMixin$1 = (stream) => {
    if (!isBlobInstance(stream) && !isReadableStream(stream)) {
        const name = stream?.__proto__?.constructor?.name || stream;
        throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED$1);
        }
        transformed = true;
        return await streamCollector(stream);
    };
    const blobToWebStream = (blob) => {
        if (typeof blob.stream !== "function") {
            throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\n" +
                "If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
        }
        return blob.stream();
    };
    return Object.assign(stream, {
        transformToByteArray: transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === "base64") {
                return toBase64(buf);
            }
            else if (encoding === "hex") {
                return toHex(buf);
            }
            else if (encoding === undefined || encoding === "utf8" || encoding === "utf-8") {
                return toUtf8(buf);
            }
            else if (typeof TextDecoder === "function") {
                return new TextDecoder(encoding).decode(buf);
            }
            else {
                throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED$1);
            }
            transformed = true;
            if (isBlobInstance(stream)) {
                return blobToWebStream(stream);
            }
            else if (isReadableStream(stream)) {
                return stream;
            }
            else {
                throw new Error(`Cannot transform payload to web stream, got ${stream}`);
            }
        },
    });
};
const isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;

const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdkStreamMixin = (stream) => {
    if (!(stream instanceof require$$0$9.Readable)) {
        try {
            return sdkStreamMixin$1(stream);
        }
        catch (e) {
            const name = stream?.__proto__?.constructor?.name || stream;
            throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
        }
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector$1(stream);
    };
    return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === undefined || Buffer.isEncoding(encoding)) {
                return fromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
            }
            else {
                const decoder = new TextDecoder(encoding);
                return decoder.decode(buf);
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            if (stream.readableFlowing !== null) {
                throw new Error("The stream has been consumed by other callbacks.");
            }
            if (typeof require$$0$9.Readable.toWeb !== "function") {
                throw new Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");
            }
            transformed = true;
            return require$$0$9.Readable.toWeb(stream);
        },
    });
};

async function splitStream$1(stream) {
    if (typeof stream.stream === "function") {
        stream = stream.stream();
    }
    const readableStream = stream;
    return readableStream.tee();
}

async function splitStream(stream) {
    if (isReadableStream(stream) || isBlob(stream)) {
        return splitStream$1(stream);
    }
    const stream1 = new require$$0$9.PassThrough();
    const stream2 = new require$$0$9.PassThrough();
    stream.pipe(stream1);
    stream.pipe(stream2);
    return [stream1, stream2];
}

async function headStream$1(stream, bytes) {
    let byteLengthCounter = 0;
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            byteLengthCounter += value?.byteLength ?? 0;
        }
        if (byteLengthCounter >= bytes) {
            break;
        }
        isDone = done;
    }
    reader.releaseLock();
    const collected = new Uint8Array(Math.min(bytes, byteLengthCounter));
    let offset = 0;
    for (const chunk of chunks) {
        if (chunk.byteLength > collected.byteLength - offset) {
            collected.set(chunk.subarray(0, collected.byteLength - offset), offset);
            break;
        }
        else {
            collected.set(chunk, offset);
        }
        offset += chunk.length;
    }
    return collected;
}

const headStream = (stream, bytes) => {
    if (isReadableStream(stream)) {
        return headStream$1(stream, bytes);
    }
    return new Promise((resolve, reject) => {
        const collector = new Collector();
        collector.limit = bytes;
        stream.pipe(collector);
        stream.on("error", (err) => {
            collector.end();
            reject(err);
        });
        collector.on("error", reject);
        collector.on("finish", function () {
            const bytes = new Uint8Array(Buffer.concat(this.buffers));
            resolve(bytes);
        });
    });
};
class Collector extends require$$0$9.Writable {
    constructor() {
        super(...arguments);
        this.buffers = [];
        this.limit = Infinity;
        this.bytesBuffered = 0;
    }
    _write(chunk, encoding, callback) {
        this.buffers.push(chunk);
        this.bytesBuffered += chunk.byteLength ?? 0;
        if (this.bytesBuffered >= this.limit) {
            const excess = this.bytesBuffered - this.limit;
            const tailBuffer = this.buffers[this.buffers.length - 1];
            this.buffers[this.buffers.length - 1] = tailBuffer.subarray(0, tailBuffer.byteLength - excess);
            this.emit("finish");
        }
        callback();
    }
}

const collectBody$1 = async (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
        return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
    }
    const fromContext = context.streamCollector(streamBody);
    return Uint8ArrayBlobAdapter.mutate(await fromContext);
};

function extendedEncodeURIComponent(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
}

const resolvedPath = (resolvedPath, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
    if (input != null && input[memberName] !== undefined) {
        const labelValue = labelValueProvider();
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
        }
        resolvedPath = resolvedPath.replace(uriLabel, isGreedyLabel
            ? labelValue
                .split("/")
                .map((segment) => extendedEncodeURIComponent(segment))
                .join("/")
            : extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: " + memberName + ".");
    }
    return resolvedPath;
};

function requestBuilder(input, context) {
    return new RequestBuilder(input, context);
}
class RequestBuilder {
    constructor(input, context) {
        this.input = input;
        this.context = context;
        this.query = {};
        this.method = "";
        this.headers = {};
        this.path = "";
        this.body = null;
        this.hostname = "";
        this.resolvePathStack = [];
    }
    async build() {
        const { hostname, protocol = "https", port, path: basePath } = await this.context.endpoint();
        this.path = basePath;
        for (const resolvePath of this.resolvePathStack) {
            resolvePath(this.path);
        }
        return new HttpRequest({
            protocol,
            hostname: this.hostname || hostname,
            port,
            method: this.method,
            path: this.path,
            query: this.query,
            body: this.body,
            headers: this.headers,
        });
    }
    hn(hostname) {
        this.hostname = hostname;
        return this;
    }
    bp(uriLabel) {
        this.resolvePathStack.push((basePath) => {
            this.path = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + uriLabel;
        });
        return this;
    }
    p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {
        this.resolvePathStack.push((path) => {
            this.path = resolvedPath(path, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);
        });
        return this;
    }
    h(headers) {
        this.headers = headers;
        return this;
    }
    q(query) {
        this.query = query;
        return this;
    }
    b(body) {
        this.body = body;
        return this;
    }
    m(method) {
        this.method = method;
        return this;
    }
}

function setFeature$1(context, feature, value) {
    if (!context.__smithy_context) {
        context.__smithy_context = {
            features: {},
        };
    }
    else if (!context.__smithy_context.features) {
        context.__smithy_context.features = {};
    }
    context.__smithy_context.features[feature] = value;
}

class DefaultIdentityProviderConfig {
    constructor(config) {
        this.authSchemes = new Map();
        for (const [key, value] of Object.entries(config)) {
            if (value !== undefined) {
                this.authSchemes.set(key, value);
            }
        }
    }
    getIdentityProvider(schemeId) {
        return this.authSchemes.get(schemeId);
    }
}

const createIsIdentityExpiredFunction = (expirationMs) => (identity) => doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs;
const EXPIRATION_MS = 300000;
const isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
const doesIdentityRequireRefresh = (identity) => identity.expiration !== undefined;
const memoizeIdentityProvider = (provider, isExpired, requiresRefresh) => {
    if (provider === undefined) {
        return undefined;
    }
    const normalizedProvider = typeof provider !== "function" ? async () => Promise.resolve(provider) : provider;
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async (options) => {
        if (!pending) {
            pending = normalizedProvider(options);
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        }
        finally {
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options) => {
            if (!hasResult || options?.forceRefresh) {
                resolved = await coalesceProvider(options);
            }
            return resolved;
        };
    }
    return async (options) => {
        if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider(options);
        }
        if (isConstant) {
            return resolved;
        }
        if (!requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider(options);
            return resolved;
        }
        return resolved;
    };
};

const DEFAULT_UA_APP_ID = undefined;
function isValidUserAgentAppId(appId) {
    if (appId === undefined) {
        return true;
    }
    return typeof appId === "string" && appId.length <= 50;
}
function resolveUserAgentConfig(input) {
    const normalizedAppIdProvider = normalizeProvider(input.userAgentAppId ?? DEFAULT_UA_APP_ID);
    return {
        ...input,
        customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent,
        userAgentAppId: async () => {
            const appId = await normalizedAppIdProvider();
            if (!isValidUserAgentAppId(appId)) {
                const logger = input.logger?.constructor?.name === "NoOpLogger" || !input.logger ? console : input.logger;
                if (typeof appId !== "string") {
                    logger?.warn("userAgentAppId must be a string or undefined.");
                }
                else if (appId.length > 50) {
                    logger?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.");
                }
            }
            return appId;
        },
    };
}

class EndpointCache {
    constructor({ size, params }) {
        this.data = new Map();
        this.parameters = [];
        this.capacity = size ?? 50;
        if (params) {
            this.parameters = params;
        }
    }
    get(endpointParams, resolver) {
        const key = this.hash(endpointParams);
        if (key === false) {
            return resolver();
        }
        if (!this.data.has(key)) {
            if (this.data.size > this.capacity + 10) {
                const keys = this.data.keys();
                let i = 0;
                while (true) {
                    const { value, done } = keys.next();
                    this.data.delete(value);
                    if (done || ++i > 10) {
                        break;
                    }
                }
            }
            this.data.set(key, resolver());
        }
        return this.data.get(key);
    }
    size() {
        return this.data.size;
    }
    hash(endpointParams) {
        let buffer = "";
        const { parameters } = this;
        if (parameters.length === 0) {
            return false;
        }
        for (const param of parameters) {
            const val = String(endpointParams[param] ?? "");
            if (val.includes("|;")) {
                return false;
            }
            buffer += val + "|;";
        }
        return buffer;
    }
}

const IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
const isIpAddress = (value) => IP_V4_REGEX.test(value) || (value.startsWith("[") && value.endsWith("]"));

const VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
const isValidHostLabel = (value, allowSubDomains = false) => {
    if (!allowSubDomains) {
        return VALID_HOST_LABEL_REGEX.test(value);
    }
    const labels = value.split(".");
    for (const label of labels) {
        if (!isValidHostLabel(label)) {
            return false;
        }
    }
    return true;
};

const customEndpointFunctions = {};

const debugId = "endpoints";

function toDebugString(input) {
    if (typeof input !== "object" || input == null) {
        return input;
    }
    if ("ref" in input) {
        return `$${toDebugString(input.ref)}`;
    }
    if ("fn" in input) {
        return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
    }
    return JSON.stringify(input, null, 2);
}

class EndpointError extends Error {
    constructor(message) {
        super(message);
        this.name = "EndpointError";
    }
}

const booleanEquals = (value1, value2) => value1 === value2;

const getAttrPathList = (path) => {
    const parts = path.split(".");
    const pathList = [];
    for (const part of parts) {
        const squareBracketIndex = part.indexOf("[");
        if (squareBracketIndex !== -1) {
            if (part.indexOf("]") !== part.length - 1) {
                throw new EndpointError(`Path: '${path}' does not end with ']'`);
            }
            const arrayIndex = part.slice(squareBracketIndex + 1, -1);
            if (Number.isNaN(parseInt(arrayIndex))) {
                throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
            }
            if (squareBracketIndex !== 0) {
                pathList.push(part.slice(0, squareBracketIndex));
            }
            pathList.push(arrayIndex);
        }
        else {
            pathList.push(part);
        }
    }
    return pathList;
};

const getAttr = (value, path) => getAttrPathList(path).reduce((acc, index) => {
    if (typeof acc !== "object") {
        throw new EndpointError(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
    }
    else if (Array.isArray(acc)) {
        return acc[parseInt(index)];
    }
    return acc[index];
}, value);

const isSet = (value) => value != null;

const not = (value) => !value;

const DEFAULT_PORTS = {
    [EndpointURLScheme.HTTP]: 80,
    [EndpointURLScheme.HTTPS]: 443,
};
const parseURL = (value) => {
    const whatwgURL = (() => {
        try {
            if (value instanceof URL) {
                return value;
            }
            if (typeof value === "object" && "hostname" in value) {
                const { hostname, port, protocol = "", path = "", query = {} } = value;
                const url = new URL(`${protocol}//${hostname}${port ? `:${port}` : ""}${path}`);
                url.search = Object.entries(query)
                    .map(([k, v]) => `${k}=${v}`)
                    .join("&");
                return url;
            }
            return new URL(value);
        }
        catch (error) {
            return null;
        }
    })();
    if (!whatwgURL) {
        console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
        return null;
    }
    const urlString = whatwgURL.href;
    const { host, hostname, pathname, protocol, search } = whatwgURL;
    if (search) {
        return null;
    }
    const scheme = protocol.slice(0, -1);
    if (!Object.values(EndpointURLScheme).includes(scheme)) {
        return null;
    }
    const isIp = isIpAddress(hostname);
    const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) ||
        (typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`));
    const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
    return {
        scheme,
        authority,
        path: pathname,
        normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
        isIp,
    };
};

const stringEquals = (value1, value2) => value1 === value2;

const substring = (input, start, stop, reverse) => {
    if (start >= stop || input.length < stop) {
        return null;
    }
    if (!reverse) {
        return input.substring(start, stop);
    }
    return input.substring(input.length - stop, input.length - start);
};

const uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);

const endpointFunctions = {
    booleanEquals,
    getAttr,
    isSet,
    isValidHostLabel,
    not,
    parseURL,
    stringEquals,
    substring,
    uriEncode,
};

const evaluateTemplate = (template, options) => {
    const evaluatedTemplateArr = [];
    const templateContext = {
        ...options.endpointParams,
        ...options.referenceRecord,
    };
    let currentIndex = 0;
    while (currentIndex < template.length) {
        const openingBraceIndex = template.indexOf("{", currentIndex);
        if (openingBraceIndex === -1) {
            evaluatedTemplateArr.push(template.slice(currentIndex));
            break;
        }
        evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
        const closingBraceIndex = template.indexOf("}", openingBraceIndex);
        if (closingBraceIndex === -1) {
            evaluatedTemplateArr.push(template.slice(openingBraceIndex));
            break;
        }
        if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
            evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
            currentIndex = closingBraceIndex + 2;
        }
        const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
        if (parameterName.includes("#")) {
            const [refName, attrName] = parameterName.split("#");
            evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
        }
        else {
            evaluatedTemplateArr.push(templateContext[parameterName]);
        }
        currentIndex = closingBraceIndex + 1;
    }
    return evaluatedTemplateArr.join("");
};

const getReferenceValue = ({ ref }, options) => {
    const referenceRecord = {
        ...options.endpointParams,
        ...options.referenceRecord,
    };
    return referenceRecord[ref];
};

const evaluateExpression = (obj, keyName, options) => {
    if (typeof obj === "string") {
        return evaluateTemplate(obj, options);
    }
    else if (obj["fn"]) {
        return callFunction(obj, options);
    }
    else if (obj["ref"]) {
        return getReferenceValue(obj, options);
    }
    throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
};

const callFunction = ({ fn, argv }, options) => {
    const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression(arg, "arg", options));
    const fnSegments = fn.split(".");
    if (fnSegments[0] in customEndpointFunctions && fnSegments[1] != null) {
        return customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
    }
    return endpointFunctions[fn](...evaluatedArgs);
};

const evaluateCondition = ({ assign, ...fnArgs }, options) => {
    if (assign && assign in options.referenceRecord) {
        throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
    }
    const value = callFunction(fnArgs, options);
    options.logger?.debug?.(`${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
    return {
        result: value === "" ? true : !!value,
        ...(assign != null && { toAssign: { name: assign, value } }),
    };
};

const evaluateConditions = (conditions = [], options) => {
    const conditionsReferenceRecord = {};
    for (const condition of conditions) {
        const { result, toAssign } = evaluateCondition(condition, {
            ...options,
            referenceRecord: {
                ...options.referenceRecord,
                ...conditionsReferenceRecord,
            },
        });
        if (!result) {
            return { result };
        }
        if (toAssign) {
            conditionsReferenceRecord[toAssign.name] = toAssign.value;
            options.logger?.debug?.(`${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
        }
    }
    return { result: true, referenceRecord: conditionsReferenceRecord };
};

const getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
    ...acc,
    [headerKey]: headerVal.map((headerValEntry) => {
        const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
        if (typeof processedExpr !== "string") {
            throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
        }
        return processedExpr;
    }),
}), {});

const getEndpointProperty = (property, options) => {
    if (Array.isArray(property)) {
        return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
    }
    switch (typeof property) {
        case "string":
            return evaluateTemplate(property, options);
        case "object":
            if (property === null) {
                throw new EndpointError(`Unexpected endpoint property: ${property}`);
            }
            return getEndpointProperties(property, options);
        case "boolean":
            return property;
        default:
            throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
    }
};

const getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
    ...acc,
    [propertyKey]: getEndpointProperty(propertyVal, options),
}), {});

const getEndpointUrl = (endpointUrl, options) => {
    const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
    if (typeof expression === "string") {
        try {
            return new URL(expression);
        }
        catch (error) {
            console.error(`Failed to construct URL with ${expression}`, error);
            throw error;
        }
    }
    throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
};

const evaluateEndpointRule = (endpointRule, options) => {
    const { conditions, endpoint } = endpointRule;
    const { result, referenceRecord } = evaluateConditions(conditions, options);
    if (!result) {
        return;
    }
    const endpointRuleOptions = {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord },
    };
    const { url, properties, headers } = endpoint;
    options.logger?.debug?.(`${debugId} Resolving endpoint from template: ${toDebugString(endpoint)}`);
    return {
        ...(headers != undefined && {
            headers: getEndpointHeaders(headers, endpointRuleOptions),
        }),
        ...(properties != undefined && {
            properties: getEndpointProperties(properties, endpointRuleOptions),
        }),
        url: getEndpointUrl(url, endpointRuleOptions),
    };
};

const evaluateErrorRule = (errorRule, options) => {
    const { conditions, error } = errorRule;
    const { result, referenceRecord } = evaluateConditions(conditions, options);
    if (!result) {
        return;
    }
    throw new EndpointError(evaluateExpression(error, "Error", {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord },
    }));
};

const evaluateTreeRule = (treeRule, options) => {
    const { conditions, rules } = treeRule;
    const { result, referenceRecord } = evaluateConditions(conditions, options);
    if (!result) {
        return;
    }
    return evaluateRules(rules, {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord },
    });
};

const evaluateRules = (rules, options) => {
    for (const rule of rules) {
        if (rule.type === "endpoint") {
            const endpointOrUndefined = evaluateEndpointRule(rule, options);
            if (endpointOrUndefined) {
                return endpointOrUndefined;
            }
        }
        else if (rule.type === "error") {
            evaluateErrorRule(rule, options);
        }
        else if (rule.type === "tree") {
            const endpointOrUndefined = evaluateTreeRule(rule, options);
            if (endpointOrUndefined) {
                return endpointOrUndefined;
            }
        }
        else {
            throw new EndpointError(`Unknown endpoint rule: ${rule}`);
        }
    }
    throw new EndpointError(`Rules evaluation failed`);
};

const resolveEndpoint = (ruleSetObject, options) => {
    const { endpointParams, logger } = options;
    const { parameters, rules } = ruleSetObject;
    options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
    const paramsWithDefault = Object.entries(parameters)
        .filter(([, v]) => v.default != null)
        .map(([k, v]) => [k, v.default]);
    if (paramsWithDefault.length > 0) {
        for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
            endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
        }
    }
    const requiredParams = Object.entries(parameters)
        .filter(([, v]) => v.required)
        .map(([k]) => k);
    for (const requiredParam of requiredParams) {
        if (endpointParams[requiredParam] == null) {
            throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
        }
    }
    const endpoint = evaluateRules(rules, { endpointParams, logger, referenceRecord: {} });
    options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);
    return endpoint;
};

const isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
    if (allowSubDomains) {
        for (const label of value.split(".")) {
            if (!isVirtualHostableS3Bucket(label)) {
                return false;
            }
        }
        return true;
    }
    if (!isValidHostLabel(value)) {
        return false;
    }
    if (value.length < 3 || value.length > 63) {
        return false;
    }
    if (value !== value.toLowerCase()) {
        return false;
    }
    if (isIpAddress(value)) {
        return false;
    }
    return true;
};

const ARN_DELIMITER = ":";
const RESOURCE_DELIMITER = "/";
const parseArn = (value) => {
    const segments = value.split(ARN_DELIMITER);
    if (segments.length < 6)
        return null;
    const [arn, partition, service, region, accountId, ...resourcePath] = segments;
    if (arn !== "arn" || partition === "" || service === "" || resourcePath.join(ARN_DELIMITER) === "")
        return null;
    const resourceId = resourcePath.map((resource) => resource.split(RESOURCE_DELIMITER)).flat();
    return {
        partition,
        service,
        region,
        accountId,
        resourceId,
    };
};

var partitions = [
	{
		id: "aws",
		outputs: {
			dnsSuffix: "amazonaws.com",
			dualStackDnsSuffix: "api.aws",
			implicitGlobalRegion: "us-east-1",
			name: "aws",
			supportsDualStack: true,
			supportsFIPS: true
		},
		regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
		regions: {
			"af-south-1": {
				description: "Africa (Cape Town)"
			},
			"ap-east-1": {
				description: "Asia Pacific (Hong Kong)"
			},
			"ap-northeast-1": {
				description: "Asia Pacific (Tokyo)"
			},
			"ap-northeast-2": {
				description: "Asia Pacific (Seoul)"
			},
			"ap-northeast-3": {
				description: "Asia Pacific (Osaka)"
			},
			"ap-south-1": {
				description: "Asia Pacific (Mumbai)"
			},
			"ap-south-2": {
				description: "Asia Pacific (Hyderabad)"
			},
			"ap-southeast-1": {
				description: "Asia Pacific (Singapore)"
			},
			"ap-southeast-2": {
				description: "Asia Pacific (Sydney)"
			},
			"ap-southeast-3": {
				description: "Asia Pacific (Jakarta)"
			},
			"ap-southeast-4": {
				description: "Asia Pacific (Melbourne)"
			},
			"ap-southeast-5": {
				description: "Asia Pacific (Malaysia)"
			},
			"aws-global": {
				description: "AWS Standard global region"
			},
			"ca-central-1": {
				description: "Canada (Central)"
			},
			"ca-west-1": {
				description: "Canada West (Calgary)"
			},
			"eu-central-1": {
				description: "Europe (Frankfurt)"
			},
			"eu-central-2": {
				description: "Europe (Zurich)"
			},
			"eu-north-1": {
				description: "Europe (Stockholm)"
			},
			"eu-south-1": {
				description: "Europe (Milan)"
			},
			"eu-south-2": {
				description: "Europe (Spain)"
			},
			"eu-west-1": {
				description: "Europe (Ireland)"
			},
			"eu-west-2": {
				description: "Europe (London)"
			},
			"eu-west-3": {
				description: "Europe (Paris)"
			},
			"il-central-1": {
				description: "Israel (Tel Aviv)"
			},
			"me-central-1": {
				description: "Middle East (UAE)"
			},
			"me-south-1": {
				description: "Middle East (Bahrain)"
			},
			"sa-east-1": {
				description: "South America (Sao Paulo)"
			},
			"us-east-1": {
				description: "US East (N. Virginia)"
			},
			"us-east-2": {
				description: "US East (Ohio)"
			},
			"us-west-1": {
				description: "US West (N. California)"
			},
			"us-west-2": {
				description: "US West (Oregon)"
			}
		}
	},
	{
		id: "aws-cn",
		outputs: {
			dnsSuffix: "amazonaws.com.cn",
			dualStackDnsSuffix: "api.amazonwebservices.com.cn",
			implicitGlobalRegion: "cn-northwest-1",
			name: "aws-cn",
			supportsDualStack: true,
			supportsFIPS: true
		},
		regionRegex: "^cn\\-\\w+\\-\\d+$",
		regions: {
			"aws-cn-global": {
				description: "AWS China global region"
			},
			"cn-north-1": {
				description: "China (Beijing)"
			},
			"cn-northwest-1": {
				description: "China (Ningxia)"
			}
		}
	},
	{
		id: "aws-us-gov",
		outputs: {
			dnsSuffix: "amazonaws.com",
			dualStackDnsSuffix: "api.aws",
			implicitGlobalRegion: "us-gov-west-1",
			name: "aws-us-gov",
			supportsDualStack: true,
			supportsFIPS: true
		},
		regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
		regions: {
			"aws-us-gov-global": {
				description: "AWS GovCloud (US) global region"
			},
			"us-gov-east-1": {
				description: "AWS GovCloud (US-East)"
			},
			"us-gov-west-1": {
				description: "AWS GovCloud (US-West)"
			}
		}
	},
	{
		id: "aws-iso",
		outputs: {
			dnsSuffix: "c2s.ic.gov",
			dualStackDnsSuffix: "c2s.ic.gov",
			implicitGlobalRegion: "us-iso-east-1",
			name: "aws-iso",
			supportsDualStack: false,
			supportsFIPS: true
		},
		regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
		regions: {
			"aws-iso-global": {
				description: "AWS ISO (US) global region"
			},
			"us-iso-east-1": {
				description: "US ISO East"
			},
			"us-iso-west-1": {
				description: "US ISO WEST"
			}
		}
	},
	{
		id: "aws-iso-b",
		outputs: {
			dnsSuffix: "sc2s.sgov.gov",
			dualStackDnsSuffix: "sc2s.sgov.gov",
			implicitGlobalRegion: "us-isob-east-1",
			name: "aws-iso-b",
			supportsDualStack: false,
			supportsFIPS: true
		},
		regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
		regions: {
			"aws-iso-b-global": {
				description: "AWS ISOB (US) global region"
			},
			"us-isob-east-1": {
				description: "US ISOB East (Ohio)"
			}
		}
	},
	{
		id: "aws-iso-e",
		outputs: {
			dnsSuffix: "cloud.adc-e.uk",
			dualStackDnsSuffix: "cloud.adc-e.uk",
			implicitGlobalRegion: "eu-isoe-west-1",
			name: "aws-iso-e",
			supportsDualStack: false,
			supportsFIPS: true
		},
		regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
		regions: {
			"eu-isoe-west-1": {
				description: "EU ISOE West"
			}
		}
	},
	{
		id: "aws-iso-f",
		outputs: {
			dnsSuffix: "csp.hci.ic.gov",
			dualStackDnsSuffix: "csp.hci.ic.gov",
			implicitGlobalRegion: "us-isof-south-1",
			name: "aws-iso-f",
			supportsDualStack: false,
			supportsFIPS: true
		},
		regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
		regions: {
		}
	}
];
var version$5 = "1.1";
var partitionsInfo = {
	partitions: partitions,
	version: version$5
};

let selectedPartitionsInfo = partitionsInfo;
const partition = (value) => {
    const { partitions } = selectedPartitionsInfo;
    for (const partition of partitions) {
        const { regions, outputs } = partition;
        for (const [region, regionData] of Object.entries(regions)) {
            if (region === value) {
                return {
                    ...outputs,
                    ...regionData,
                };
            }
        }
    }
    for (const partition of partitions) {
        const { regionRegex, outputs } = partition;
        if (new RegExp(regionRegex).test(value)) {
            return {
                ...outputs,
            };
        }
    }
    const DEFAULT_PARTITION = partitions.find((partition) => partition.id === "aws");
    if (!DEFAULT_PARTITION) {
        throw new Error("Provided region was not found in the partition array or regex," +
            " and default partition with id 'aws' doesn't exist.");
    }
    return {
        ...DEFAULT_PARTITION.outputs,
    };
};

const awsEndpointFunctions = {
    isVirtualHostableS3Bucket: isVirtualHostableS3Bucket,
    parseArn: parseArn,
    partition: partition,
};
customEndpointFunctions.aws = awsEndpointFunctions;

const state = {
    warningEmitted: false,
};
const emitWarningIfUnsupportedVersion$1 = (version) => {
    if (version && !state.warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 18) {
        state.warningEmitted = true;
        process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 16.x on January 6, 2025.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/74kJMmI`);
    }
};

function setCredentialFeature(credentials, feature, value) {
    if (!credentials.$source) {
        credentials.$source = {};
    }
    credentials.$source[feature] = value;
    return credentials;
}

function setFeature(context, feature, value) {
    if (!context.__aws_sdk_context) {
        context.__aws_sdk_context = {
            features: {},
        };
    }
    else if (!context.__aws_sdk_context.features) {
        context.__aws_sdk_context.features = {};
    }
    context.__aws_sdk_context.features[feature] = value;
}

const getDateHeader = (response) => HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : undefined;

const getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);

const isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 300000;

const getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
    const clockTimeInMs = Date.parse(clockTime);
    if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
        return clockTimeInMs - Date.now();
    }
    return currentSystemClockOffset;
};

const throwSigningPropertyError = (name, property) => {
    if (!property) {
        throw new Error(`Property \`${name}\` is not resolved for AWS SDK SigV4Auth`);
    }
    return property;
};
const validateSigningProperties = async (signingProperties) => {
    const context = throwSigningPropertyError("context", signingProperties.context);
    const config = throwSigningPropertyError("config", signingProperties.config);
    const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
    const signerFunction = throwSigningPropertyError("signer", config.signer);
    const signer = await signerFunction(authScheme);
    const signingRegion = signingProperties?.signingRegion;
    const signingRegionSet = signingProperties?.signingRegionSet;
    const signingName = signingProperties?.signingName;
    return {
        config,
        signer,
        signingRegion,
        signingRegionSet,
        signingName,
    };
};
class AwsSdkSigV4Signer {
    async sign(httpRequest, identity, signingProperties) {
        if (!HttpRequest.isInstance(httpRequest)) {
            throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
        }
        const validatedProps = await validateSigningProperties(signingProperties);
        const { config, signer } = validatedProps;
        let { signingRegion, signingName } = validatedProps;
        const handlerExecutionContext = signingProperties.context;
        if (handlerExecutionContext?.authSchemes?.length ?? 0 > 1) {
            const [first, second] = handlerExecutionContext.authSchemes;
            if (first?.name === "sigv4a" && second?.name === "sigv4") {
                signingRegion = second?.signingRegion ?? signingRegion;
                signingName = second?.signingName ?? signingName;
            }
        }
        const signedRequest = await signer.sign(httpRequest, {
            signingDate: getSkewCorrectedDate(config.systemClockOffset),
            signingRegion: signingRegion,
            signingService: signingName,
        });
        return signedRequest;
    }
    errorHandler(signingProperties) {
        return (error) => {
            const serverTime = error.ServerTime ?? getDateHeader(error.$response);
            if (serverTime) {
                const config = throwSigningPropertyError("config", signingProperties.config);
                const initialSystemClockOffset = config.systemClockOffset;
                config.systemClockOffset = getUpdatedSystemClockOffset(serverTime, config.systemClockOffset);
                const clockSkewCorrected = config.systemClockOffset !== initialSystemClockOffset;
                if (clockSkewCorrected && error.$metadata) {
                    error.$metadata.clockSkewCorrected = true;
                }
            }
            throw error;
        };
    }
    successHandler(httpResponse, signingProperties) {
        const dateHeader = getDateHeader(httpResponse);
        if (dateHeader) {
            const config = throwSigningPropertyError("config", signingProperties.config);
            config.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, config.systemClockOffset);
        }
    }
}

class AwsSdkSigV4ASigner extends AwsSdkSigV4Signer {
    async sign(httpRequest, identity, signingProperties) {
        if (!HttpRequest.isInstance(httpRequest)) {
            throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
        }
        const { config, signer, signingRegion, signingRegionSet, signingName } = await validateSigningProperties(signingProperties);
        const configResolvedSigningRegionSet = await config.sigv4aSigningRegionSet?.();
        const multiRegionOverride = (configResolvedSigningRegionSet ??
            signingRegionSet ?? [signingRegion]).join(",");
        const signedRequest = await signer.sign(httpRequest, {
            signingDate: getSkewCorrectedDate(config.systemClockOffset),
            signingRegion: multiRegionOverride,
            signingService: signingName,
        });
        return signedRequest;
    }
}

class ProviderError extends Error {
    constructor(message, options = true) {
        let logger;
        let tryNextLink = true;
        if (typeof options === "boolean") {
            logger = undefined;
            tryNextLink = options;
        }
        else if (options != null && typeof options === "object") {
            logger = options.logger;
            tryNextLink = options.tryNextLink ?? true;
        }
        super(message);
        this.name = "ProviderError";
        this.tryNextLink = tryNextLink;
        Object.setPrototypeOf(this, ProviderError.prototype);
        logger?.debug?.(`@smithy/property-provider ${tryNextLink ? "->" : "(!)"} ${message}`);
    }
    static from(error, options = true) {
        return Object.assign(new this(error.message, options), error);
    }
}

class CredentialsProviderError extends ProviderError {
    constructor(message, options = true) {
        super(message, options);
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}

const chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

const fromStatic$1 = (staticValue) => () => Promise.resolve(staticValue);

const memoize = (provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async () => {
        if (!pending) {
            pending = provider();
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        }
        finally {
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options) => {
            if (!hasResult || options?.forceRefresh) {
                resolved = await coalesceProvider();
            }
            return resolved;
        };
    }
    return async (options) => {
        if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider();
        }
        if (isConstant) {
            return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider();
            return resolved;
        }
        return resolved;
    };
};

const resolveAwsSdkSigV4AConfig = (config) => {
    config.sigv4aSigningRegionSet = normalizeProvider(config.sigv4aSigningRegionSet);
    return config;
};
const NODE_SIGV4A_CONFIG_OPTIONS = {
    environmentVariableSelector(env) {
        if (env.AWS_SIGV4A_SIGNING_REGION_SET) {
            return env.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((_) => _.trim());
        }
        throw new ProviderError("AWS_SIGV4A_SIGNING_REGION_SET not set in env.", {
            tryNextLink: true,
        });
    },
    configFileSelector(profile) {
        if (profile.sigv4a_signing_region_set) {
            return (profile.sigv4a_signing_region_set ?? "").split(",").map((_) => _.trim());
        }
        throw new ProviderError("sigv4a_signing_region_set not set in profile.", {
            tryNextLink: true,
        });
    },
    default: undefined,
};

const ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
const CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
const AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
const SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
const EXPIRES_QUERY_PARAM = "X-Amz-Expires";
const SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
const TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
const AUTH_HEADER = "authorization";
const AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
const DATE_HEADER = "date";
const GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
const SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
const SHA256_HEADER = "x-amz-content-sha256";
const TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
const ALWAYS_UNSIGNABLE_HEADERS = {
    authorization: true,
    "cache-control": true,
    connection: true,
    expect: true,
    from: true,
    "keep-alive": true,
    "max-forwards": true,
    pragma: true,
    referer: true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true,
    "user-agent": true,
    "x-amzn-trace-id": true,
};
const PROXY_HEADER_PATTERN = /^proxy-/;
const SEC_HEADER_PATTERN = /^sec-/;
const ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
const EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
const UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
const MAX_CACHE_SIZE = 50;
const KEY_TYPE_IDENTIFIER = "aws4_request";
const MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;

const signingKeyCache = {};
const cacheQueue = [];
const createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
const getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
    const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
    const cacheKey = `${shortDate}:${region}:${service}:${toHex(credsHash)}:${credentials.sessionToken}`;
    if (cacheKey in signingKeyCache) {
        return signingKeyCache[cacheKey];
    }
    cacheQueue.push(cacheKey);
    while (cacheQueue.length > MAX_CACHE_SIZE) {
        delete signingKeyCache[cacheQueue.shift()];
    }
    let key = `AWS4${credentials.secretAccessKey}`;
    for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
        key = await hmac(sha256Constructor, key, signable);
    }
    return (signingKeyCache[cacheKey] = key);
};
const hmac = (ctor, secret, data) => {
    const hash = new ctor(secret);
    hash.update(toUint8Array(data));
    return hash.digest();
};

const getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
    const canonical = {};
    for (const headerName of Object.keys(headers).sort()) {
        if (headers[headerName] == undefined) {
            continue;
        }
        const canonicalHeaderName = headerName.toLowerCase();
        if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS ||
            unsignableHeaders?.has(canonicalHeaderName) ||
            PROXY_HEADER_PATTERN.test(canonicalHeaderName) ||
            SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
            if (!signableHeaders || (signableHeaders && !signableHeaders.has(canonicalHeaderName))) {
                continue;
            }
        }
        canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
    }
    return canonical;
};

const getCanonicalQuery = ({ query = {} }) => {
    const keys = [];
    const serialized = {};
    for (const key of Object.keys(query)) {
        if (key.toLowerCase() === SIGNATURE_HEADER) {
            continue;
        }
        const encodedKey = escapeUri(key);
        keys.push(encodedKey);
        const value = query[key];
        if (typeof value === "string") {
            serialized[encodedKey] = `${encodedKey}=${escapeUri(value)}`;
        }
        else if (Array.isArray(value)) {
            serialized[encodedKey] = value
                .slice(0)
                .reduce((encoded, value) => encoded.concat([`${encodedKey}=${escapeUri(value)}`]), [])
                .sort()
                .join("&");
        }
    }
    return keys
        .sort()
        .map((key) => serialized[key])
        .filter((serialized) => serialized)
        .join("&");
};

const getPayloadHash = async ({ headers, body }, hashConstructor) => {
    for (const headerName of Object.keys(headers)) {
        if (headerName.toLowerCase() === SHA256_HEADER) {
            return headers[headerName];
        }
    }
    if (body == undefined) {
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    }
    else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer(body)) {
        const hashCtor = new hashConstructor();
        hashCtor.update(toUint8Array(body));
        return toHex(await hashCtor.digest());
    }
    return UNSIGNED_PAYLOAD;
};

class HeaderFormatter {
    format(headers) {
        const chunks = [];
        for (const headerName of Object.keys(headers)) {
            const bytes = fromUtf8$1(headerName);
            chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
        }
        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
        let position = 0;
        for (const chunk of chunks) {
            out.set(chunk, position);
            position += chunk.byteLength;
        }
        return out;
    }
    formatHeaderValue(header) {
        switch (header.type) {
            case "boolean":
                return Uint8Array.from([header.value ? 0 : 1]);
            case "byte":
                return Uint8Array.from([2, header.value]);
            case "short":
                const shortView = new DataView(new ArrayBuffer(3));
                shortView.setUint8(0, 3);
                shortView.setInt16(1, header.value, false);
                return new Uint8Array(shortView.buffer);
            case "integer":
                const intView = new DataView(new ArrayBuffer(5));
                intView.setUint8(0, 4);
                intView.setInt32(1, header.value, false);
                return new Uint8Array(intView.buffer);
            case "long":
                const longBytes = new Uint8Array(9);
                longBytes[0] = 5;
                longBytes.set(header.value.bytes, 1);
                return longBytes;
            case "binary":
                const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
                binView.setUint8(0, 6);
                binView.setUint16(1, header.value.byteLength, false);
                const binBytes = new Uint8Array(binView.buffer);
                binBytes.set(header.value, 3);
                return binBytes;
            case "string":
                const utf8Bytes = fromUtf8$1(header.value);
                const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
                strView.setUint8(0, 7);
                strView.setUint16(1, utf8Bytes.byteLength, false);
                const strBytes = new Uint8Array(strView.buffer);
                strBytes.set(utf8Bytes, 3);
                return strBytes;
            case "timestamp":
                const tsBytes = new Uint8Array(9);
                tsBytes[0] = 8;
                tsBytes.set(Int64$1.fromNumber(header.value.valueOf()).bytes, 1);
                return tsBytes;
            case "uuid":
                if (!UUID_PATTERN$1.test(header.value)) {
                    throw new Error(`Invalid UUID received: ${header.value}`);
                }
                const uuidBytes = new Uint8Array(17);
                uuidBytes[0] = 9;
                uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
                return uuidBytes;
        }
    }
}
var HEADER_VALUE_TYPE$1;
(function (HEADER_VALUE_TYPE) {
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolTrue"] = 0] = "boolTrue";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolFalse"] = 1] = "boolFalse";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byte"] = 2] = "byte";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["short"] = 3] = "short";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["integer"] = 4] = "integer";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["long"] = 5] = "long";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byteArray"] = 6] = "byteArray";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["string"] = 7] = "string";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["timestamp"] = 8] = "timestamp";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE$1 || (HEADER_VALUE_TYPE$1 = {}));
const UUID_PATTERN$1 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
let Int64$1 = class Int64 {
    constructor(bytes) {
        this.bytes = bytes;
        if (bytes.byteLength !== 8) {
            throw new Error("Int64 buffers must be exactly 8 bytes");
        }
    }
    static fromNumber(number) {
        if (number > 9223372036854776000 || number < -9223372036854776000) {
            throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
        }
        const bytes = new Uint8Array(8);
        for (let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {
            bytes[i] = remaining;
        }
        if (number < 0) {
            negate$1(bytes);
        }
        return new Int64(bytes);
    }
    valueOf() {
        const bytes = this.bytes.slice(0);
        const negative = bytes[0] & 0b10000000;
        if (negative) {
            negate$1(bytes);
        }
        return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);
    }
    toString() {
        return String(this.valueOf());
    }
};
function negate$1(bytes) {
    for (let i = 0; i < 8; i++) {
        bytes[i] ^= 0xff;
    }
    for (let i = 7; i > -1; i--) {
        bytes[i]++;
        if (bytes[i] !== 0)
            break;
    }
}

const hasHeader = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
            return true;
        }
    }
    return false;
};

const moveHeadersToQuery = (request, options = {}) => {
    const { headers, query = {} } = HttpRequest.clone(request);
    for (const name of Object.keys(headers)) {
        const lname = name.toLowerCase();
        if ((lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname)) ||
            options.hoistableHeaders?.has(lname)) {
            query[name] = headers[name];
            delete headers[name];
        }
    }
    return {
        ...request,
        headers,
        query,
    };
};

const prepareRequest = (request) => {
    request = HttpRequest.clone(request);
    for (const headerName of Object.keys(request.headers)) {
        if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
            delete request.headers[headerName];
        }
    }
    return request;
};

const iso8601 = (time) => toDate$1(time)
    .toISOString()
    .replace(/\.\d{3}Z$/, "Z");
const toDate$1 = (time) => {
    if (typeof time === "number") {
        return new Date(time * 1000);
    }
    if (typeof time === "string") {
        if (Number(time)) {
            return new Date(Number(time) * 1000);
        }
        return new Date(time);
    }
    return time;
};

class SignatureV4 {
    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {
        this.headerFormatter = new HeaderFormatter();
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
        this.regionProvider = normalizeProvider$1(region);
        this.credentialProvider = normalizeProvider$1(credentials);
    }
    async presign(originalRequest, options = {}) {
        const { signingDate = new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, hoistableHeaders, signingRegion, signingService, } = options;
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? (await this.regionProvider());
        const { longDate, shortDate } = formatDate(signingDate);
        if (expiresIn > MAX_PRESIGNED_TTL) {
            return Promise.reject("Signature version 4 presigned URLs" + " must have an expiration date less than one week in" + " the future");
        }
        const scope = createScope(shortDate, region, signingService ?? this.service);
        const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders, hoistableHeaders });
        if (credentials.sessionToken) {
            request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
        }
        request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
        request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
        request.query[AMZ_DATE_QUERY_PARAM] = longDate;
        request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
        request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
        request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
        return request;
    }
    async sign(toSign, options) {
        if (typeof toSign === "string") {
            return this.signString(toSign, options);
        }
        else if (toSign.headers && toSign.payload) {
            return this.signEvent(toSign, options);
        }
        else if (toSign.message) {
            return this.signMessage(toSign, options);
        }
        else {
            return this.signRequest(toSign, options);
        }
    }
    async signEvent({ headers, payload }, { signingDate = new Date(), priorSignature, signingRegion, signingService }) {
        const region = signingRegion ?? (await this.regionProvider());
        const { shortDate, longDate } = formatDate(signingDate);
        const scope = createScope(shortDate, region, signingService ?? this.service);
        const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
        const hash = new this.sha256();
        hash.update(headers);
        const hashedHeaders = toHex(await hash.digest());
        const stringToSign = [
            EVENT_ALGORITHM_IDENTIFIER,
            longDate,
            scope,
            priorSignature,
            hashedHeaders,
            hashedPayload,
        ].join("\n");
        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
    }
    async signMessage(signableMessage, { signingDate = new Date(), signingRegion, signingService }) {
        const promise = this.signEvent({
            headers: this.headerFormatter.format(signableMessage.message.headers),
            payload: signableMessage.message.body,
        }, {
            signingDate,
            signingRegion,
            signingService,
            priorSignature: signableMessage.priorSignature,
        });
        return promise.then((signature) => {
            return { message: signableMessage.message, signature };
        });
    }
    async signString(stringToSign, { signingDate = new Date(), signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? (await this.regionProvider());
        const { shortDate } = formatDate(signingDate);
        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
        hash.update(toUint8Array(stringToSign));
        return toHex(await hash.digest());
    }
    async signRequest(requestToSign, { signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService, } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? (await this.regionProvider());
        const request = prepareRequest(requestToSign);
        const { longDate, shortDate } = formatDate(signingDate);
        const scope = createScope(shortDate, region, signingService ?? this.service);
        request.headers[AMZ_DATE_HEADER] = longDate;
        if (credentials.sessionToken) {
            request.headers[TOKEN_HEADER] = credentials.sessionToken;
        }
        const payloadHash = await getPayloadHash(request, this.sha256);
        if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
            request.headers[SHA256_HEADER] = payloadHash;
        }
        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
        request.headers[AUTH_HEADER] =
            `${ALGORITHM_IDENTIFIER} ` +
                `Credential=${credentials.accessKeyId}/${scope}, ` +
                `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` +
                `Signature=${signature}`;
        return request;
    }
    createCanonicalRequest(request, canonicalHeaders, payloadHash) {
        const sortedHeaders = Object.keys(canonicalHeaders).sort();
        return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
    }
    async createStringToSign(longDate, credentialScope, canonicalRequest) {
        const hash = new this.sha256();
        hash.update(toUint8Array(canonicalRequest));
        const hashedRequest = await hash.digest();
        return `${ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${toHex(hashedRequest)}`;
    }
    getCanonicalPath({ path }) {
        if (this.uriEscapePath) {
            const normalizedPathSegments = [];
            for (const pathSegment of path.split("/")) {
                if (pathSegment?.length === 0)
                    continue;
                if (pathSegment === ".")
                    continue;
                if (pathSegment === "..") {
                    normalizedPathSegments.pop();
                }
                else {
                    normalizedPathSegments.push(pathSegment);
                }
            }
            const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
            const doubleEncoded = escapeUri(normalizedPath);
            return doubleEncoded.replace(/%2F/g, "/");
        }
        return path;
    }
    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
        const hash = new this.sha256(await keyPromise);
        hash.update(toUint8Array(stringToSign));
        return toHex(await hash.digest());
    }
    getSigningKey(credentials, region, shortDate, service) {
        return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
    }
    validateResolvedCredentials(credentials) {
        if (typeof credentials !== "object" ||
            typeof credentials.accessKeyId !== "string" ||
            typeof credentials.secretAccessKey !== "string") {
            throw new Error("Resolved credential object is not valid");
        }
    }
}
const formatDate = (now) => {
    const longDate = iso8601(now).replace(/[\-:]/g, "");
    return {
        longDate,
        shortDate: longDate.slice(0, 8),
    };
};
const getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(";");

const resolveAwsSdkSigV4Config = (config) => {
    let isUserSupplied = false;
    let normalizedCreds;
    if (config.credentials) {
        isUserSupplied = true;
        normalizedCreds = memoizeIdentityProvider(config.credentials, isIdentityExpired, doesIdentityRequireRefresh);
    }
    if (!normalizedCreds) {
        if (config.credentialDefaultProvider) {
            normalizedCreds = normalizeProvider(config.credentialDefaultProvider(Object.assign({}, config, {
                parentClientConfig: config,
            })));
        }
        else {
            normalizedCreds = async () => {
                throw new Error("`credentials` is missing");
            };
        }
    }
    const { signingEscapePath = true, systemClockOffset = config.systemClockOffset || 0, sha256, } = config;
    let signer;
    if (config.signer) {
        signer = normalizeProvider(config.signer);
    }
    else if (config.regionInfoProvider) {
        signer = () => normalizeProvider(config.region)()
            .then(async (region) => [
            (await config.regionInfoProvider(region, {
                useFipsEndpoint: await config.useFipsEndpoint(),
                useDualstackEndpoint: await config.useDualstackEndpoint(),
            })) || {},
            region,
        ])
            .then(([regionInfo, region]) => {
            const { signingRegion, signingService } = regionInfo;
            config.signingRegion = config.signingRegion || signingRegion || region;
            config.signingName = config.signingName || signingService || config.serviceId;
            const params = {
                ...config,
                credentials: normalizedCreds,
                region: config.signingRegion,
                service: config.signingName,
                sha256,
                uriEscapePath: signingEscapePath,
            };
            const SignerCtor = config.signerConstructor || SignatureV4;
            return new SignerCtor(params);
        });
    }
    else {
        signer = async (authScheme) => {
            authScheme = Object.assign({}, {
                name: "sigv4",
                signingName: config.signingName || config.defaultSigningName,
                signingRegion: await normalizeProvider(config.region)(),
                properties: {},
            }, authScheme);
            const signingRegion = authScheme.signingRegion;
            const signingService = authScheme.signingName;
            config.signingRegion = config.signingRegion || signingRegion;
            config.signingName = config.signingName || signingService || config.serviceId;
            const params = {
                ...config,
                credentials: normalizedCreds,
                region: config.signingRegion,
                service: config.signingName,
                sha256,
                uriEscapePath: signingEscapePath,
            };
            const SignerCtor = config.signerConstructor || SignatureV4;
            return new SignerCtor(params);
        };
    }
    return {
        ...config,
        systemClockOffset,
        signingEscapePath,
        credentials: isUserSupplied
            ? async () => normalizedCreds().then((creds) => setCredentialFeature(creds, "CREDENTIALS_CODE", "e"))
            : normalizedCreds,
        signer,
    };
};

const getAllAliases = (name, aliases) => {
    const _aliases = [];
    if (name) {
        _aliases.push(name);
    }
    if (aliases) {
        for (const alias of aliases) {
            _aliases.push(alias);
        }
    }
    return _aliases;
};
const getMiddlewareNameWithAliases = (name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
};
const constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = new Set();
    const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] ||
        priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            const aliases = getAllAliases(entry.name, entry.aliases);
            if (aliases.includes(toRemove)) {
                isRemoved = true;
                for (const alias of aliases) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            if (entry.middleware === toRemove) {
                isRemoved = true;
                for (const alias of getAllAliases(entry.name, entry.aliases)) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const cloneTo = (toStack) => {
        absoluteEntries.forEach((entry) => {
            toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
            toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        toStack.identifyOnResolve?.(stack.identifyOnResolve());
        return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
            if (entry.toMiddleware) {
                const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                if (toMiddleware === undefined) {
                    if (debug) {
                        return;
                    }
                    throw new Error(`${entry.toMiddleware} is not found when adding ` +
                        `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` +
                        `middleware ${entry.relation} ${entry.toMiddleware}`);
                }
                if (entry.relation === "after") {
                    toMiddleware.after.push(entry);
                }
                if (entry.relation === "before") {
                    toMiddleware.before.push(entry);
                }
            }
        });
        const mainChain = sort(normalizedAbsoluteEntries)
            .map(expandRelativeMiddlewareList)
            .reduce((wholeList, expandedMiddlewareList) => {
            wholeList.push(...expandedMiddlewareList);
            return wholeList;
        }, []);
        return mainChain;
    };
    const stack = {
        add: (middleware, options = {}) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                step: "initialize",
                priority: "normal",
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = absoluteEntries[toOverrideIndex];
                        if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` +
                                `${toOverride.priority} priority in ${toOverride.step} step cannot ` +
                                `be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` +
                                `${entry.priority} priority in ${entry.step} step.`);
                        }
                        absoluteEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = relativeEntries[toOverrideIndex];
                        if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` +
                                `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                                `by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` +
                                `"${entry.toMiddleware}" middleware.`);
                        }
                        relativeEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            relativeEntries.push(entry);
        },
        clone: () => cloneTo(constructStack()),
        use: (plugin) => {
            plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
            if (typeof toRemove === "string")
                return removeByName(toRemove);
            else
                return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const { tags, name, aliases: _aliases } = entry;
                if (tags && tags.includes(toRemove)) {
                    const aliases = getAllAliases(name, _aliases);
                    for (const alias of aliases) {
                        entriesNameSet.delete(alias);
                    }
                    isRemoved = true;
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        },
        concat: (from) => {
            const cloned = cloneTo(constructStack());
            cloned.use(from);
            cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
            return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
            return getMiddlewareList(true).map((mw) => {
                const step = mw.step ??
                    mw.relation +
                        " " +
                        mw.toMiddleware;
                return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
            });
        },
        identifyOnResolve(toggle) {
            if (typeof toggle === "boolean")
                identifyOnResolve = toggle;
            return identifyOnResolve;
        },
        resolve: (handler, context) => {
            for (const middleware of getMiddlewareList()
                .map((entry) => entry.middleware)
                .reverse()) {
                handler = middleware(handler, context);
            }
            if (identifyOnResolve) {
                console.log(stack.identify());
            }
            return handler;
        },
    };
    return stack;
};
const stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1,
};
const priorityWeights = {
    high: 3,
    normal: 2,
    low: 1,
};

class Client {
    constructor(config) {
        this.config = config;
        this.middlewareStack = constructStack();
    }
    send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const useHandlerCache = options === undefined && this.config.cacheMiddleware === true;
        let handler;
        if (useHandlerCache) {
            if (!this.handlers) {
                this.handlers = new WeakMap();
            }
            const handlers = this.handlers;
            if (handlers.has(command.constructor)) {
                handler = handlers.get(command.constructor);
            }
            else {
                handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
                handlers.set(command.constructor, handler);
            }
        }
        else {
            delete this.handlers;
            handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        }
        if (callback) {
            handler(command)
                .then((result) => callback(null, result.output), (err) => callback(err))
                .catch(() => { });
        }
        else {
            return handler(command).then((result) => result.output);
        }
    }
    destroy() {
        this.config?.requestHandler?.destroy?.();
        delete this.handlers;
    }
}

class Command {
    constructor() {
        this.middlewareStack = constructStack();
    }
    static classBuilder() {
        return new ClassBuilder();
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }) {
        for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
            this.middlewareStack.use(mw);
        }
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog,
            outputFilterSensitiveLog,
            [SMITHY_CONTEXT_KEY]: {
                commandInstance: this,
                ...smithyContext,
            },
            ...additionalContext,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
}
class ClassBuilder {
    constructor() {
        this._init = () => { };
        this._ep = {};
        this._middlewareFn = () => [];
        this._commandName = "";
        this._clientName = "";
        this._additionalContext = {};
        this._smithyContext = {};
        this._inputFilterSensitiveLog = (_) => _;
        this._outputFilterSensitiveLog = (_) => _;
        this._serializer = null;
        this._deserializer = null;
    }
    init(cb) {
        this._init = cb;
    }
    ep(endpointParameterInstructions) {
        this._ep = endpointParameterInstructions;
        return this;
    }
    m(middlewareSupplier) {
        this._middlewareFn = middlewareSupplier;
        return this;
    }
    s(service, operation, smithyContext = {}) {
        this._smithyContext = {
            service,
            operation,
            ...smithyContext,
        };
        return this;
    }
    c(additionalContext = {}) {
        this._additionalContext = additionalContext;
        return this;
    }
    n(clientName, commandName) {
        this._clientName = clientName;
        this._commandName = commandName;
        return this;
    }
    f(inputFilter = (_) => _, outputFilter = (_) => _) {
        this._inputFilterSensitiveLog = inputFilter;
        this._outputFilterSensitiveLog = outputFilter;
        return this;
    }
    ser(serializer) {
        this._serializer = serializer;
        return this;
    }
    de(deserializer) {
        this._deserializer = deserializer;
        return this;
    }
    build() {
        const closure = this;
        let CommandRef;
        return (CommandRef = class extends Command {
            static getEndpointParameterInstructions() {
                return closure._ep;
            }
            constructor(...[input]) {
                super();
                this.serialize = closure._serializer;
                this.deserialize = closure._deserializer;
                this.input = input ?? {};
                closure._init(this);
            }
            resolveMiddleware(stack, configuration, options) {
                return this.resolveMiddlewareWithContext(stack, configuration, options, {
                    CommandCtor: CommandRef,
                    middlewareFn: closure._middlewareFn,
                    clientName: closure._clientName,
                    commandName: closure._commandName,
                    inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
                    outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
                    smithyContext: closure._smithyContext,
                    additionalContext: closure._additionalContext,
                });
            }
        });
    }
}

const SENSITIVE_STRING = "***SensitiveInformation***";

const parseBoolean = (value) => {
    switch (value) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error(`Unable to parse boolean value "${value}"`);
    }
};
const expectNumber = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
            if (String(parsed) !== String(value)) {
                logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
            }
            return parsed;
        }
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
const expectFloat32 = (value) => {
    const expected = expectNumber(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
    }
    return expected;
};
const expectLong = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
const expectInt32 = (value) => expectSizedInt(value, 32);
const expectShort = (value) => expectSizedInt(value, 16);
const expectByte = (value) => expectSizedInt(value, 8);
const expectSizedInt = (value, size) => {
    const expected = expectLong(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
};
const castInt = (value, size) => {
    switch (size) {
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
const expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
const expectObject = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
const expectString = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
        logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
const strictParseFloat32 = (value) => {
    if (typeof value == "string") {
        return expectFloat32(parseNumber(value));
    }
    return expectFloat32(value);
};
const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
const parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
};
const strictParseInt32 = (value) => {
    if (typeof value === "string") {
        return expectInt32(parseNumber(value));
    }
    return expectInt32(value);
};
const strictParseShort = (value) => {
    if (typeof value === "string") {
        return expectShort(parseNumber(value));
    }
    return expectShort(value);
};
const strictParseByte = (value) => {
    if (typeof value === "string") {
        return expectByte(parseNumber(value));
    }
    return expectByte(value);
};
const stackTraceWarning = (message) => {
    return String(new TypeError(message).stack || message)
        .split("\n")
        .slice(0, 5)
        .filter((s) => !s.includes("stackTraceWarning"))
        .join("\n");
};
const logger = {
    warn: console.warn,
};

const MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
const RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
const parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
};
const RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
const parseRfc3339DateTimeWithOffset = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
        date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date;
};
const buildDate = (year, month, day, time) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
};
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const validateDayOfMonth = (year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
    }
    if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
};
const isLeapYear = (year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
const parseDateValue = (value, type, lower, upper) => {
    const dateVal = strictParseByte(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
};
const parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
        return 0;
    }
    return strictParseFloat32("0." + value) * 1000;
};
const parseOffsetToMilliseconds = (value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
        direction = 1;
    }
    else if (directionStr == "-") {
        direction = -1;
    }
    else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
};
const stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
    }
    if (idx === 0) {
        return value;
    }
    return value.slice(idx);
};

class ServiceException extends Error {
    constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, ServiceException.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
    }
}
const decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions)
        .filter(([, v]) => v !== undefined)
        .forEach(([k, v]) => {
        if (exception[k] == undefined || exception[k] === "") {
            exception[k] = v;
        }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
};

const throwDefaultError$1 = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata$1(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
        name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata,
    });
    throw decorateServiceException(response, parsedBody);
};
const withBaseException = (ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
        throwDefaultError$1({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
};
const deserializeMetadata$1 = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});

const loadConfigsForDefaultMode = (mode) => {
    switch (mode) {
        case "standard":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "in-region":
            return {
                retryMode: "standard",
                connectionTimeout: 1100,
            };
        case "cross-region":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "mobile":
            return {
                retryMode: "standard",
                connectionTimeout: 30000,
            };
        default:
            return {};
    }
};

let warningEmitted = false;
const emitWarningIfUnsupportedVersion = (version) => {
    if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 16) {
        warningEmitted = true;
    }
};

const getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in AlgorithmId) {
        const algorithmId = AlgorithmId[id];
        if (runtimeConfig[algorithmId] === undefined) {
            continue;
        }
        checksumAlgorithms.push({
            algorithmId: () => algorithmId,
            checksumConstructor: () => runtimeConfig[algorithmId],
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
const resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

const getRetryConfiguration = (runtimeConfig) => {
    let _retryStrategy = runtimeConfig.retryStrategy;
    return {
        setRetryStrategy(retryStrategy) {
            _retryStrategy = retryStrategy;
        },
        retryStrategy() {
            return _retryStrategy;
        },
    };
};
const resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
    const runtimeConfig = {};
    runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
    return runtimeConfig;
};

const getDefaultExtensionConfiguration = (runtimeConfig) => {
    return {
        ...getChecksumConfiguration(runtimeConfig),
        ...getRetryConfiguration(runtimeConfig),
    };
};
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...resolveChecksumRuntimeConfig(config),
        ...resolveRetryRuntimeConfig(config),
    };
};

const getValueFromTextNode = (obj) => {
    const textNodeName = "#text";
    for (const key in obj) {
        if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== undefined) {
            obj[key] = obj[key][textNodeName];
        }
        else if (typeof obj[key] === "object" && obj[key] !== null) {
            obj[key] = getValueFromTextNode(obj[key]);
        }
    }
    return obj;
};

const isSerializableHeaderValue = (value) => {
    return value != null;
};

class NoOpLogger {
    trace() { }
    debug() { }
    info() { }
    warn() { }
    error() { }
}

function map$1(arg0, arg1, arg2) {
    let target;
    let filter;
    let instructions;
    if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
        target = {};
        instructions = arg0;
    }
    else {
        target = arg0;
        if (typeof arg1 === "function") {
            filter = arg1;
            instructions = arg2;
            return mapWithFilter(target, filter, instructions);
        }
        else {
            instructions = arg1;
        }
    }
    for (const key of Object.keys(instructions)) {
        if (!Array.isArray(instructions[key])) {
            target[key] = instructions[key];
            continue;
        }
        applyInstruction(target, null, instructions, key);
    }
    return target;
}
const take = (source, instructions) => {
    const out = {};
    for (const key in instructions) {
        applyInstruction(out, source, instructions, key);
    }
    return out;
};
const mapWithFilter = (target, filter, instructions) => {
    return map$1(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
        if (Array.isArray(value)) {
            _instructions[key] = value;
        }
        else {
            if (typeof value === "function") {
                _instructions[key] = [filter, value()];
            }
            else {
                _instructions[key] = [filter, value];
            }
        }
        return _instructions;
    }, {}));
};
const applyInstruction = (target, source, instructions, targetKey) => {
    if (source !== null) {
        let instruction = instructions[targetKey];
        if (typeof instruction === "function") {
            instruction = [, instruction];
        }
        const [filter = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
        if ((typeof filter === "function" && filter(source[sourceKey])) || (typeof filter !== "function" && !!filter)) {
            target[targetKey] = valueFn(source[sourceKey]);
        }
        return;
    }
    let [filter, value] = instructions[targetKey];
    if (typeof value === "function") {
        let _value;
        const defaultFilterPassed = filter === undefined && (_value = value()) != null;
        const customFilterPassed = (typeof filter === "function" && !!filter(void 0)) || (typeof filter !== "function" && !!filter);
        if (defaultFilterPassed) {
            target[targetKey] = _value;
        }
        else if (customFilterPassed) {
            target[targetKey] = value();
        }
    }
    else {
        const defaultFilterPassed = filter === undefined && value != null;
        const customFilterPassed = (typeof filter === "function" && !!filter(value)) || (typeof filter !== "function" && !!filter);
        if (defaultFilterPassed || customFilterPassed) {
            target[targetKey] = value;
        }
    }
};
const nonNullish = (_) => _ != null;
const pass = (_) => _;

const collectBodyString = (streamBody, context) => collectBody$1(streamBody, context).then((body) => context.utf8Encoder(body));

var validator = {};

var util = {};

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	(function (exports) {

		const nameStartChar = ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
		const nameChar = nameStartChar + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
		const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*';
		const regexName = new RegExp('^' + nameRegexp + '$');

		const getAllMatches = function(string, regex) {
		  const matches = [];
		  let match = regex.exec(string);
		  while (match) {
		    const allmatches = [];
		    allmatches.startIndex = regex.lastIndex - match[0].length;
		    const len = match.length;
		    for (let index = 0; index < len; index++) {
		      allmatches.push(match[index]);
		    }
		    matches.push(allmatches);
		    match = regex.exec(string);
		  }
		  return matches;
		};

		const isName = function(string) {
		  const match = regexName.exec(string);
		  return !(match === null || typeof match === 'undefined');
		};

		exports.isExist = function(v) {
		  return typeof v !== 'undefined';
		};

		exports.isEmptyObject = function(obj) {
		  return Object.keys(obj).length === 0;
		};

		/**
		 * Copy all the properties of a into b.
		 * @param {*} target
		 * @param {*} a
		 */
		exports.merge = function(target, a, arrayMode) {
		  if (a) {
		    const keys = Object.keys(a); // will return an array of own properties
		    const len = keys.length; //don't make it inline
		    for (let i = 0; i < len; i++) {
		      if (arrayMode === 'strict') {
		        target[keys[i]] = [ a[keys[i]] ];
		      } else {
		        target[keys[i]] = a[keys[i]];
		      }
		    }
		  }
		};
		/* exports.merge =function (b,a){
		  return Object.assign(b,a);
		} */

		exports.getValue = function(v) {
		  if (exports.isExist(v)) {
		    return v;
		  } else {
		    return '';
		  }
		};

		// const fakeCall = function(a) {return a;};
		// const fakeCallNoReturn = function() {};

		exports.isName = isName;
		exports.getAllMatches = getAllMatches;
		exports.nameRegexp = nameRegexp; 
	} (util));
	return util;
}

var hasRequiredValidator;

function requireValidator () {
	if (hasRequiredValidator) return validator;
	hasRequiredValidator = 1;

	const util = requireUtil();

	const defaultOptions = {
	  allowBooleanAttributes: false, //A tag can have attributes without any value
	  unpairedTags: []
	};

	//const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
	validator.validate = function (xmlData, options) {
	  options = Object.assign({}, defaultOptions, options);

	  //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
	  //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
	  //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE
	  const tags = [];
	  let tagFound = false;

	  //indicates that the root tag has been closed (aka. depth 0 has been reached)
	  let reachedRoot = false;

	  if (xmlData[0] === '\ufeff') {
	    // check for byte order mark (BOM)
	    xmlData = xmlData.substr(1);
	  }
	  
	  for (let i = 0; i < xmlData.length; i++) {

	    if (xmlData[i] === '<' && xmlData[i+1] === '?') {
	      i+=2;
	      i = readPI(xmlData,i);
	      if (i.err) return i;
	    }else if (xmlData[i] === '<') {
	      //starting of tag
	      //read until you reach to '>' avoiding any '>' in attribute value
	      let tagStartPos = i;
	      i++;
	      
	      if (xmlData[i] === '!') {
	        i = readCommentAndCDATA(xmlData, i);
	        continue;
	      } else {
	        let closingTag = false;
	        if (xmlData[i] === '/') {
	          //closing tag
	          closingTag = true;
	          i++;
	        }
	        //read tagname
	        let tagName = '';
	        for (; i < xmlData.length &&
	          xmlData[i] !== '>' &&
	          xmlData[i] !== ' ' &&
	          xmlData[i] !== '\t' &&
	          xmlData[i] !== '\n' &&
	          xmlData[i] !== '\r'; i++
	        ) {
	          tagName += xmlData[i];
	        }
	        tagName = tagName.trim();
	        //console.log(tagName);

	        if (tagName[tagName.length - 1] === '/') {
	          //self closing tag without attributes
	          tagName = tagName.substring(0, tagName.length - 1);
	          //continue;
	          i--;
	        }
	        if (!validateTagName(tagName)) {
	          let msg;
	          if (tagName.trim().length === 0) {
	            msg = "Invalid space after '<'.";
	          } else {
	            msg = "Tag '"+tagName+"' is an invalid name.";
	          }
	          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));
	        }

	        const result = readAttributeStr(xmlData, i);
	        if (result === false) {
	          return getErrorObject('InvalidAttr', "Attributes for '"+tagName+"' have open quote.", getLineNumberForPosition(xmlData, i));
	        }
	        let attrStr = result.value;
	        i = result.index;

	        if (attrStr[attrStr.length - 1] === '/') {
	          //self closing tag
	          const attrStrStart = i - attrStr.length;
	          attrStr = attrStr.substring(0, attrStr.length - 1);
	          const isValid = validateAttributeString(attrStr, options);
	          if (isValid === true) {
	            tagFound = true;
	            //continue; //text may presents after self closing tag
	          } else {
	            //the result from the nested function returns the position of the error within the attribute
	            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
	            //this gives us the absolute index in the entire xml, which we can use to find the line at last
	            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
	          }
	        } else if (closingTag) {
	          if (!result.tagClosed) {
	            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
	          } else if (attrStr.trim().length > 0) {
	            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
	          } else if (tags.length === 0) {
	            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
	          } else {
	            const otg = tags.pop();
	            if (tagName !== otg.tagName) {
	              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
	              return getErrorObject('InvalidTag',
	                "Expected closing tag '"+otg.tagName+"' (opened in line "+openPos.line+", col "+openPos.col+") instead of closing tag '"+tagName+"'.",
	                getLineNumberForPosition(xmlData, tagStartPos));
	            }

	            //when there are no more tags, we reached the root level.
	            if (tags.length == 0) {
	              reachedRoot = true;
	            }
	          }
	        } else {
	          const isValid = validateAttributeString(attrStr, options);
	          if (isValid !== true) {
	            //the result from the nested function returns the position of the error within the attribute
	            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
	            //this gives us the absolute index in the entire xml, which we can use to find the line at last
	            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
	          }

	          //if the root level has been reached before ...
	          if (reachedRoot === true) {
	            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));
	          } else if(options.unpairedTags.indexOf(tagName) !== -1); else {
	            tags.push({tagName, tagStartPos});
	          }
	          tagFound = true;
	        }

	        //skip tag text value
	        //It may include comments and CDATA value
	        for (i++; i < xmlData.length; i++) {
	          if (xmlData[i] === '<') {
	            if (xmlData[i + 1] === '!') {
	              //comment or CADATA
	              i++;
	              i = readCommentAndCDATA(xmlData, i);
	              continue;
	            } else if (xmlData[i+1] === '?') {
	              i = readPI(xmlData, ++i);
	              if (i.err) return i;
	            } else {
	              break;
	            }
	          } else if (xmlData[i] === '&') {
	            const afterAmp = validateAmpersand(xmlData, i);
	            if (afterAmp == -1)
	              return getErrorObject('InvalidChar', "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
	            i = afterAmp;
	          }else {
	            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
	              return getErrorObject('InvalidXml', "Extra text at the end", getLineNumberForPosition(xmlData, i));
	            }
	          }
	        } //end of reading tag text value
	        if (xmlData[i] === '<') {
	          i--;
	        }
	      }
	    } else {
	      if ( isWhiteSpace(xmlData[i])) {
	        continue;
	      }
	      return getErrorObject('InvalidChar', "char '"+xmlData[i]+"' is not expected.", getLineNumberForPosition(xmlData, i));
	    }
	  }

	  if (!tagFound) {
	    return getErrorObject('InvalidXml', 'Start tag expected.', 1);
	  }else if (tags.length == 1) {
	      return getErrorObject('InvalidTag', "Unclosed tag '"+tags[0].tagName+"'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
	  }else if (tags.length > 0) {
	      return getErrorObject('InvalidXml', "Invalid '"+
	          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\r?\n/g, '')+
	          "' found.", {line: 1, col: 1});
	  }

	  return true;
	};

	function isWhiteSpace(char){
	  return char === ' ' || char === '\t' || char === '\n'  || char === '\r';
	}
	/**
	 * Read Processing insstructions and skip
	 * @param {*} xmlData
	 * @param {*} i
	 */
	function readPI(xmlData, i) {
	  const start = i;
	  for (; i < xmlData.length; i++) {
	    if (xmlData[i] == '?' || xmlData[i] == ' ') {
	      //tagname
	      const tagname = xmlData.substr(start, i - start);
	      if (i > 5 && tagname === 'xml') {
	        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));
	      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
	        //check if valid attribut string
	        i++;
	        break;
	      } else {
	        continue;
	      }
	    }
	  }
	  return i;
	}

	function readCommentAndCDATA(xmlData, i) {
	  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
	    //comment
	    for (i += 3; i < xmlData.length; i++) {
	      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {
	        i += 2;
	        break;
	      }
	    }
	  } else if (
	    xmlData.length > i + 8 &&
	    xmlData[i + 1] === 'D' &&
	    xmlData[i + 2] === 'O' &&
	    xmlData[i + 3] === 'C' &&
	    xmlData[i + 4] === 'T' &&
	    xmlData[i + 5] === 'Y' &&
	    xmlData[i + 6] === 'P' &&
	    xmlData[i + 7] === 'E'
	  ) {
	    let angleBracketsCount = 1;
	    for (i += 8; i < xmlData.length; i++) {
	      if (xmlData[i] === '<') {
	        angleBracketsCount++;
	      } else if (xmlData[i] === '>') {
	        angleBracketsCount--;
	        if (angleBracketsCount === 0) {
	          break;
	        }
	      }
	    }
	  } else if (
	    xmlData.length > i + 9 &&
	    xmlData[i + 1] === '[' &&
	    xmlData[i + 2] === 'C' &&
	    xmlData[i + 3] === 'D' &&
	    xmlData[i + 4] === 'A' &&
	    xmlData[i + 5] === 'T' &&
	    xmlData[i + 6] === 'A' &&
	    xmlData[i + 7] === '['
	  ) {
	    for (i += 8; i < xmlData.length; i++) {
	      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {
	        i += 2;
	        break;
	      }
	    }
	  }

	  return i;
	}

	const doubleQuote = '"';
	const singleQuote = "'";

	/**
	 * Keep reading xmlData until '<' is found outside the attribute value.
	 * @param {string} xmlData
	 * @param {number} i
	 */
	function readAttributeStr(xmlData, i) {
	  let attrStr = '';
	  let startChar = '';
	  let tagClosed = false;
	  for (; i < xmlData.length; i++) {
	    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
	      if (startChar === '') {
	        startChar = xmlData[i];
	      } else if (startChar !== xmlData[i]) ; else {
	        startChar = '';
	      }
	    } else if (xmlData[i] === '>') {
	      if (startChar === '') {
	        tagClosed = true;
	        break;
	      }
	    }
	    attrStr += xmlData[i];
	  }
	  if (startChar !== '') {
	    return false;
	  }

	  return {
	    value: attrStr,
	    index: i,
	    tagClosed: tagClosed
	  };
	}

	/**
	 * Select all the attributes whether valid or invalid.
	 */
	const validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g');

	//attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

	function validateAttributeString(attrStr, options) {
	  //console.log("start:"+attrStr+":end");

	  //if(attrStr.trim().length === 0) return true; //empty string

	  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
	  const attrNames = {};

	  for (let i = 0; i < matches.length; i++) {
	    if (matches[i][1].length === 0) {
	      //nospace before attribute name: a="sd"b="saf"
	      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' has no space in starting.", getPositionFromMatch(matches[i]))
	    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {
	      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' is without value.", getPositionFromMatch(matches[i]));
	    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
	      //independent attribute: ab
	      return getErrorObject('InvalidAttr', "boolean attribute '"+matches[i][2]+"' is not allowed.", getPositionFromMatch(matches[i]));
	    }
	    /* else if(matches[i][6] === undefined){//attribute without value: ab=
	                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
	                } */
	    const attrName = matches[i][2];
	    if (!validateAttrName(attrName)) {
	      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is an invalid name.", getPositionFromMatch(matches[i]));
	    }
	    if (!attrNames.hasOwnProperty(attrName)) {
	      //check for duplicate attribute.
	      attrNames[attrName] = 1;
	    } else {
	      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is repeated.", getPositionFromMatch(matches[i]));
	    }
	  }

	  return true;
	}

	function validateNumberAmpersand(xmlData, i) {
	  let re = /\d/;
	  if (xmlData[i] === 'x') {
	    i++;
	    re = /[\da-fA-F]/;
	  }
	  for (; i < xmlData.length; i++) {
	    if (xmlData[i] === ';')
	      return i;
	    if (!xmlData[i].match(re))
	      break;
	  }
	  return -1;
	}

	function validateAmpersand(xmlData, i) {
	  // https://www.w3.org/TR/xml/#dt-charref
	  i++;
	  if (xmlData[i] === ';')
	    return -1;
	  if (xmlData[i] === '#') {
	    i++;
	    return validateNumberAmpersand(xmlData, i);
	  }
	  let count = 0;
	  for (; i < xmlData.length; i++, count++) {
	    if (xmlData[i].match(/\w/) && count < 20)
	      continue;
	    if (xmlData[i] === ';')
	      break;
	    return -1;
	  }
	  return i;
	}

	function getErrorObject(code, message, lineNumber) {
	  return {
	    err: {
	      code: code,
	      msg: message,
	      line: lineNumber.line || lineNumber,
	      col: lineNumber.col,
	    },
	  };
	}

	function validateAttrName(attrName) {
	  return util.isName(attrName);
	}

	// const startsWithXML = /^xml/i;

	function validateTagName(tagname) {
	  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;
	}

	//this function returns the line number for the character at the given index
	function getLineNumberForPosition(xmlData, index) {
	  const lines = xmlData.substring(0, index).split(/\r?\n/);
	  return {
	    line: lines.length,

	    // column number is last line's length + 1, because column numbering starts at 1:
	    col: lines[lines.length - 1].length + 1
	  };
	}

	//this function returns the position of the first character of match within attrStr
	function getPositionFromMatch(match) {
	  return match.startIndex + match[1].length;
	}
	return validator;
}

var OptionsBuilder = {};

var hasRequiredOptionsBuilder;

function requireOptionsBuilder () {
	if (hasRequiredOptionsBuilder) return OptionsBuilder;
	hasRequiredOptionsBuilder = 1;
	const defaultOptions = {
	    preserveOrder: false,
	    attributeNamePrefix: '@_',
	    attributesGroupName: false,
	    textNodeName: '#text',
	    ignoreAttributes: true,
	    removeNSPrefix: false, // remove NS from tag name or attribute name if true
	    allowBooleanAttributes: false, //a tag can have attributes without any value
	    //ignoreRootElement : false,
	    parseTagValue: true,
	    parseAttributeValue: false,
	    trimValues: true, //Trim string values of tag and attributes
	    cdataPropName: false,
	    numberParseOptions: {
	      hex: true,
	      leadingZeros: true,
	      eNotation: true
	    },
	    tagValueProcessor: function(tagName, val) {
	      return val;
	    },
	    attributeValueProcessor: function(attrName, val) {
	      return val;
	    },
	    stopNodes: [], //nested tags will not be parsed even for errors
	    alwaysCreateTextNode: false,
	    isArray: () => false,
	    commentPropName: false,
	    unpairedTags: [],
	    processEntities: true,
	    htmlEntities: false,
	    ignoreDeclaration: false,
	    ignorePiTags: false,
	    transformTagName: false,
	    transformAttributeName: false,
	    updateTag: function(tagName, jPath, attrs){
	      return tagName
	    },
	    // skipEmptyListItem: false
	};
	   
	const buildOptions = function(options) {
	    return Object.assign({}, defaultOptions, options);
	};

	OptionsBuilder.buildOptions = buildOptions;
	OptionsBuilder.defaultOptions = defaultOptions;
	return OptionsBuilder;
}

var xmlNode;
var hasRequiredXmlNode;

function requireXmlNode () {
	if (hasRequiredXmlNode) return xmlNode;
	hasRequiredXmlNode = 1;

	class XmlNode{
	  constructor(tagname) {
	    this.tagname = tagname;
	    this.child = []; //nested tags, text, cdata, comments in order
	    this[":@"] = {}; //attributes map
	  }
	  add(key,val){
	    // this.child.push( {name : key, val: val, isCdata: isCdata });
	    if(key === "__proto__") key = "#__proto__";
	    this.child.push( {[key]: val });
	  }
	  addChild(node) {
	    if(node.tagname === "__proto__") node.tagname = "#__proto__";
	    if(node[":@"] && Object.keys(node[":@"]).length > 0){
	      this.child.push( { [node.tagname]: node.child, [":@"]: node[":@"] });
	    }else {
	      this.child.push( { [node.tagname]: node.child });
	    }
	  };
	}

	xmlNode = XmlNode;
	return xmlNode;
}

var DocTypeReader;
var hasRequiredDocTypeReader;

function requireDocTypeReader () {
	if (hasRequiredDocTypeReader) return DocTypeReader;
	hasRequiredDocTypeReader = 1;
	const util = requireUtil();

	//TODO: handle comments
	function readDocType(xmlData, i){
	    
	    const entities = {};
	    if( xmlData[i + 3] === 'O' &&
	         xmlData[i + 4] === 'C' &&
	         xmlData[i + 5] === 'T' &&
	         xmlData[i + 6] === 'Y' &&
	         xmlData[i + 7] === 'P' &&
	         xmlData[i + 8] === 'E')
	    {    
	        i = i+9;
	        let angleBracketsCount = 1;
	        let hasBody = false, comment = false;
	        let exp = "";
	        for(;i<xmlData.length;i++){
	            if (xmlData[i] === '<' && !comment) { //Determine the tag type
	                if( hasBody && isEntity(xmlData, i)){
	                    i += 7; 
	                    [entityName, val,i] = readEntityExp(xmlData,i+1);
	                    if(val.indexOf("&") === -1) //Parameter entities are not supported
	                        entities[ validateEntityName(entityName) ] = {
	                            regx : RegExp( `&${entityName};`,"g"),
	                            val: val
	                        };
	                }
	                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported
	                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported
	                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported
	                else comment = true;

	                angleBracketsCount++;
	                exp = "";
	            } else if (xmlData[i] === '>') { //Read tag content
	                if(comment){
	                    if( xmlData[i - 1] === "-" && xmlData[i - 2] === "-"){
	                        comment = false;
	                        angleBracketsCount--;
	                    }
	                }else {
	                    angleBracketsCount--;
	                }
	                if (angleBracketsCount === 0) {
	                  break;
	                }
	            }else if( xmlData[i] === '['){
	                hasBody = true;
	            }else {
	                exp += xmlData[i];
	            }
	        }
	        if(angleBracketsCount !== 0){
	            throw new Error(`Unclosed DOCTYPE`);
	        }
	    }else {
	        throw new Error(`Invalid Tag instead of DOCTYPE`);
	    }
	    return {entities, i};
	}

	function readEntityExp(xmlData,i){
	    //External entities are not supported
	    //    <!ENTITY ext SYSTEM "http://normal-website.com" >

	    //Parameter entities are not supported
	    //    <!ENTITY entityname "&anotherElement;">

	    //Internal entities are supported
	    //    <!ENTITY entityname "replacement text">
	    
	    //read EntityName
	    let entityName = "";
	    for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"' ); i++) {
	        // if(xmlData[i] === " ") continue;
	        // else 
	        entityName += xmlData[i];
	    }
	    entityName = entityName.trim();
	    if(entityName.indexOf(" ") !== -1) throw new Error("External entites are not supported");

	    //read Entity Value
	    const startChar = xmlData[i++];
	    let val = "";
	    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {
	        val += xmlData[i];
	    }
	    return [entityName, val, i];
	}
	function isEntity(xmlData, i){
	    if(xmlData[i+1] === '!' &&
	    xmlData[i+2] === 'E' &&
	    xmlData[i+3] === 'N' &&
	    xmlData[i+4] === 'T' &&
	    xmlData[i+5] === 'I' &&
	    xmlData[i+6] === 'T' &&
	    xmlData[i+7] === 'Y') return true
	    return false
	}
	function isElement(xmlData, i){
	    if(xmlData[i+1] === '!' &&
	    xmlData[i+2] === 'E' &&
	    xmlData[i+3] === 'L' &&
	    xmlData[i+4] === 'E' &&
	    xmlData[i+5] === 'M' &&
	    xmlData[i+6] === 'E' &&
	    xmlData[i+7] === 'N' &&
	    xmlData[i+8] === 'T') return true
	    return false
	}

	function isAttlist(xmlData, i){
	    if(xmlData[i+1] === '!' &&
	    xmlData[i+2] === 'A' &&
	    xmlData[i+3] === 'T' &&
	    xmlData[i+4] === 'T' &&
	    xmlData[i+5] === 'L' &&
	    xmlData[i+6] === 'I' &&
	    xmlData[i+7] === 'S' &&
	    xmlData[i+8] === 'T') return true
	    return false
	}
	function isNotation(xmlData, i){
	    if(xmlData[i+1] === '!' &&
	    xmlData[i+2] === 'N' &&
	    xmlData[i+3] === 'O' &&
	    xmlData[i+4] === 'T' &&
	    xmlData[i+5] === 'A' &&
	    xmlData[i+6] === 'T' &&
	    xmlData[i+7] === 'I' &&
	    xmlData[i+8] === 'O' &&
	    xmlData[i+9] === 'N') return true
	    return false
	}

	function validateEntityName(name){
	    if (util.isName(name))
		return name;
	    else
	        throw new Error(`Invalid entity name ${name}`);
	}

	DocTypeReader = readDocType;
	return DocTypeReader;
}

var strnum;
var hasRequiredStrnum;

function requireStrnum () {
	if (hasRequiredStrnum) return strnum;
	hasRequiredStrnum = 1;
	const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
	const numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
	// const octRegex = /0x[a-z0-9]+/;
	// const binRegex = /0x[a-z0-9]+/;


	//polyfill
	if (!Number.parseInt && window.parseInt) {
	    Number.parseInt = window.parseInt;
	}
	if (!Number.parseFloat && window.parseFloat) {
	    Number.parseFloat = window.parseFloat;
	}

	  
	const consider = {
	    hex :  true,
	    leadingZeros: true,
	    decimalPoint: "\.",
	    eNotation: true
	    //skipLike: /regex/
	};

	function toNumber(str, options = {}){
	    // const options = Object.assign({}, consider);
	    // if(opt.leadingZeros === false){
	    //     options.leadingZeros = false;
	    // }else if(opt.hex === false){
	    //     options.hex = false;
	    // }

	    options = Object.assign({}, consider, options );
	    if(!str || typeof str !== "string" ) return str;
	    
	    let trimmedStr  = str.trim();
	    // if(trimmedStr === "0.0") return 0;
	    // else if(trimmedStr === "+0.0") return 0;
	    // else if(trimmedStr === "-0.0") return -0;

	    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;
	    else if (options.hex && hexRegex.test(trimmedStr)) {
	        return Number.parseInt(trimmedStr, 16);
	    // } else if (options.parseOct && octRegex.test(str)) {
	    //     return Number.parseInt(val, 8);
	    // }else if (options.parseBin && binRegex.test(str)) {
	    //     return Number.parseInt(val, 2);
	    }else {
	        //separate negative sign, leading zeros, and rest number
	        const match = numRegex.exec(trimmedStr);
	        if(match){
	            const sign = match[1];
	            const leadingZeros = match[2];
	            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros
	            //trim ending zeros for floating number
	            
	            const eNotation = match[4] || match[6];
	            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str; //-0123
	            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str; //0123
	            else {//no leading zeros or leading zeros are allowed
	                const num = Number(trimmedStr);
	                const numStr = "" + num;
	                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation
	                    if(options.eNotation) return num;
	                    else return str;
	                }else if(eNotation){ //given number has enotation
	                    if(options.eNotation) return num;
	                    else return str;
	                }else if(trimmedStr.indexOf(".") !== -1){ //floating number
	                    // const decimalPart = match[5].substr(1);
	                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf("."));

	                    
	                    // const p = numStr.indexOf(".");
	                    // const givenIntPart = numStr.substr(0,p);
	                    // const givenDecPart = numStr.substr(p+1);
	                    if(numStr === "0" && (numTrimmedByZeros === "") ) return num; //0.0
	                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000
	                    else if( sign && numStr === "-"+numTrimmedByZeros) return num;
	                    else return str;
	                }
	                
	                if(leadingZeros){
	                    // if(numTrimmedByZeros === numStr){
	                    //     if(options.leadingZeros) return num;
	                    //     else return str;
	                    // }else return str;
	                    if(numTrimmedByZeros === numStr) return num;
	                    else if(sign+numTrimmedByZeros === numStr) return num;
	                    else return str;
	                }

	                if(trimmedStr === numStr) return num;
	                else if(trimmedStr === sign+numStr) return num;
	                // else{
	                //     //number with +/- sign
	                //     trimmedStr.test(/[-+][0-9]);

	                // }
	                return str;
	            }
	            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;
	            
	        }else { //non-numeric string
	            return str;
	        }
	    }
	}

	/**
	 * 
	 * @param {string} numStr without leading zeros
	 * @returns 
	 */
	function trimZeros(numStr){
	    if(numStr && numStr.indexOf(".") !== -1){//float
	        numStr = numStr.replace(/0+$/, ""); //remove ending zeros
	        if(numStr === ".")  numStr = "0";
	        else if(numStr[0] === ".")  numStr = "0"+numStr;
	        else if(numStr[numStr.length-1] === ".")  numStr = numStr.substr(0,numStr.length-1);
	        return numStr;
	    }
	    return numStr;
	}
	strnum = toNumber;
	return strnum;
}

var OrderedObjParser_1;
var hasRequiredOrderedObjParser;

function requireOrderedObjParser () {
	if (hasRequiredOrderedObjParser) return OrderedObjParser_1;
	hasRequiredOrderedObjParser = 1;
	///@ts-check

	const util = requireUtil();
	const xmlNode = requireXmlNode();
	const readDocType = requireDocTypeReader();
	const toNumber = requireStrnum();

	// const regx =
	//   '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'
	//   .replace(/NAME/g, util.nameRegexp);

	//const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
	//const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");

	class OrderedObjParser{
	  constructor(options){
	    this.options = options;
	    this.currentNode = null;
	    this.tagsNodeStack = [];
	    this.docTypeEntities = {};
	    this.lastEntities = {
	      "apos" : { regex: /&(apos|#39|#x27);/g, val : "'"},
	      "gt" : { regex: /&(gt|#62|#x3E);/g, val : ">"},
	      "lt" : { regex: /&(lt|#60|#x3C);/g, val : "<"},
	      "quot" : { regex: /&(quot|#34|#x22);/g, val : "\""},
	    };
	    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : "&"};
	    this.htmlEntities = {
	      "space": { regex: /&(nbsp|#160);/g, val: " " },
	      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
	      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
	      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
	      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
	      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
	      "cent" : { regex: /&(cent|#162);/g, val: "" },
	      "pound" : { regex: /&(pound|#163);/g, val: "" },
	      "yen" : { regex: /&(yen|#165);/g, val: "" },
	      "euro" : { regex: /&(euro|#8364);/g, val: "" },
	      "copyright" : { regex: /&(copy|#169);/g, val: "" },
	      "reg" : { regex: /&(reg|#174);/g, val: "" },
	      "inr" : { regex: /&(inr|#8377);/g, val: "" },
	      "num_dec": { regex: /&#([0-9]{1,7});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },
	      "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 16)) },
	    };
	    this.addExternalEntities = addExternalEntities;
	    this.parseXml = parseXml;
	    this.parseTextData = parseTextData;
	    this.resolveNameSpace = resolveNameSpace;
	    this.buildAttributesMap = buildAttributesMap;
	    this.isItStopNode = isItStopNode;
	    this.replaceEntitiesValue = replaceEntitiesValue;
	    this.readStopNodeData = readStopNodeData;
	    this.saveTextToParentTag = saveTextToParentTag;
	    this.addChild = addChild;
	  }

	}

	function addExternalEntities(externalEntities){
	  const entKeys = Object.keys(externalEntities);
	  for (let i = 0; i < entKeys.length; i++) {
	    const ent = entKeys[i];
	    this.lastEntities[ent] = {
	       regex: new RegExp("&"+ent+";","g"),
	       val : externalEntities[ent]
	    };
	  }
	}

	/**
	 * @param {string} val
	 * @param {string} tagName
	 * @param {string} jPath
	 * @param {boolean} dontTrim
	 * @param {boolean} hasAttributes
	 * @param {boolean} isLeafNode
	 * @param {boolean} escapeEntities
	 */
	function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
	  if (val !== undefined) {
	    if (this.options.trimValues && !dontTrim) {
	      val = val.trim();
	    }
	    if(val.length > 0){
	      if(!escapeEntities) val = this.replaceEntitiesValue(val);
	      
	      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
	      if(newval === null || newval === undefined){
	        //don't parse
	        return val;
	      }else if(typeof newval !== typeof val || newval !== val){
	        //overwrite
	        return newval;
	      }else if(this.options.trimValues){
	        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
	      }else {
	        const trimmedVal = val.trim();
	        if(trimmedVal === val){
	          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
	        }else {
	          return val;
	        }
	      }
	    }
	  }
	}

	function resolveNameSpace(tagname) {
	  if (this.options.removeNSPrefix) {
	    const tags = tagname.split(':');
	    const prefix = tagname.charAt(0) === '/' ? '/' : '';
	    if (tags[0] === 'xmlns') {
	      return '';
	    }
	    if (tags.length === 2) {
	      tagname = prefix + tags[1];
	    }
	  }
	  return tagname;
	}

	//TODO: change regex to capture NS
	//const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
	const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', 'gm');

	function buildAttributesMap(attrStr, jPath, tagName) {
	  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {
	    // attrStr = attrStr.replace(/\r?\n/g, ' ');
	    //attrStr = attrStr || attrStr.trim();

	    const matches = util.getAllMatches(attrStr, attrsRegx);
	    const len = matches.length; //don't make it inline
	    const attrs = {};
	    for (let i = 0; i < len; i++) {
	      const attrName = this.resolveNameSpace(matches[i][1]);
	      let oldVal = matches[i][4];
	      let aName = this.options.attributeNamePrefix + attrName;
	      if (attrName.length) {
	        if (this.options.transformAttributeName) {
	          aName = this.options.transformAttributeName(aName);
	        }
	        if(aName === "__proto__") aName  = "#__proto__";
	        if (oldVal !== undefined) {
	          if (this.options.trimValues) {
	            oldVal = oldVal.trim();
	          }
	          oldVal = this.replaceEntitiesValue(oldVal);
	          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
	          if(newVal === null || newVal === undefined){
	            //don't parse
	            attrs[aName] = oldVal;
	          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){
	            //overwrite
	            attrs[aName] = newVal;
	          }else {
	            //parse
	            attrs[aName] = parseValue(
	              oldVal,
	              this.options.parseAttributeValue,
	              this.options.numberParseOptions
	            );
	          }
	        } else if (this.options.allowBooleanAttributes) {
	          attrs[aName] = true;
	        }
	      }
	    }
	    if (!Object.keys(attrs).length) {
	      return;
	    }
	    if (this.options.attributesGroupName) {
	      const attrCollection = {};
	      attrCollection[this.options.attributesGroupName] = attrs;
	      return attrCollection;
	    }
	    return attrs
	  }
	}

	const parseXml = function(xmlData) {
	  xmlData = xmlData.replace(/\r\n?/g, "\n"); //TODO: remove this line
	  const xmlObj = new xmlNode('!xml');
	  let currentNode = xmlObj;
	  let textData = "";
	  let jPath = "";
	  for(let i=0; i< xmlData.length; i++){//for each char in XML data
	    const ch = xmlData[i];
	    if(ch === '<'){
	      // const nextIndex = i+1;
	      // const _2ndChar = xmlData[nextIndex];
	      if( xmlData[i+1] === '/') {//Closing Tag
	        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
	        let tagName = xmlData.substring(i+2,closeIndex).trim();

	        if(this.options.removeNSPrefix){
	          const colonIndex = tagName.indexOf(":");
	          if(colonIndex !== -1){
	            tagName = tagName.substr(colonIndex+1);
	          }
	        }

	        if(this.options.transformTagName) {
	          tagName = this.options.transformTagName(tagName);
	        }

	        if(currentNode){
	          textData = this.saveTextToParentTag(textData, currentNode, jPath);
	        }

	        //check if last tag of nested tag was unpaired tag
	        const lastTagName = jPath.substring(jPath.lastIndexOf(".")+1);
	        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){
	          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
	        }
	        let propIndex = 0;
	        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){
	          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1);
	          this.tagsNodeStack.pop();
	        }else {
	          propIndex = jPath.lastIndexOf(".");
	        }
	        jPath = jPath.substring(0, propIndex);

	        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope
	        textData = "";
	        i = closeIndex;
	      } else if( xmlData[i+1] === '?') {

	        let tagData = readTagExp(xmlData,i, false, "?>");
	        if(!tagData) throw new Error("Pi Tag is not closed.");

	        textData = this.saveTextToParentTag(textData, currentNode, jPath);
	        if( (this.options.ignoreDeclaration && tagData.tagName === "?xml") || this.options.ignorePiTags);else {
	  
	          const childNode = new xmlNode(tagData.tagName);
	          childNode.add(this.options.textNodeName, "");
	          
	          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){
	            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
	          }
	          this.addChild(currentNode, childNode, jPath);

	        }


	        i = tagData.closeIndex + 1;
	      } else if(xmlData.substr(i + 1, 3) === '!--') {
	        const endIndex = findClosingIndex(xmlData, "-->", i+4, "Comment is not closed.");
	        if(this.options.commentPropName){
	          const comment = xmlData.substring(i + 4, endIndex - 2);

	          textData = this.saveTextToParentTag(textData, currentNode, jPath);

	          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);
	        }
	        i = endIndex;
	      } else if( xmlData.substr(i + 1, 2) === '!D') {
	        const result = readDocType(xmlData, i);
	        this.docTypeEntities = result.entities;
	        i = result.i;
	      }else if(xmlData.substr(i + 1, 2) === '![') {
	        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
	        const tagExp = xmlData.substring(i + 9,closeIndex);

	        textData = this.saveTextToParentTag(textData, currentNode, jPath);

	        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
	        if(val == undefined) val = "";

	        //cdata should be set even if it is 0 length string
	        if(this.options.cdataPropName){
	          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);
	        }else {
	          currentNode.add(this.options.textNodeName, val);
	        }
	        
	        i = closeIndex + 2;
	      }else {//Opening tag
	        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);
	        let tagName= result.tagName;
	        const rawTagName = result.rawTagName;
	        let tagExp = result.tagExp;
	        let attrExpPresent = result.attrExpPresent;
	        let closeIndex = result.closeIndex;

	        if (this.options.transformTagName) {
	          tagName = this.options.transformTagName(tagName);
	        }
	        
	        //save text as child node
	        if (currentNode && textData) {
	          if(currentNode.tagname !== '!xml'){
	            //when nested tag is found
	            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
	          }
	        }

	        //check if last tag was unpaired tag
	        const lastTag = currentNode;
	        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){
	          currentNode = this.tagsNodeStack.pop();
	          jPath = jPath.substring(0, jPath.lastIndexOf("."));
	        }
	        if(tagName !== xmlObj.tagname){
	          jPath += jPath ? "." + tagName : tagName;
	        }
	        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
	          let tagContent = "";
	          //self-closing tag
	          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
	            if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
	              tagName = tagName.substr(0, tagName.length - 1);
	              jPath = jPath.substr(0, jPath.length - 1);
	              tagExp = tagName;
	            }else {
	              tagExp = tagExp.substr(0, tagExp.length - 1);
	            }
	            i = result.closeIndex;
	          }
	          //unpaired tag
	          else if(this.options.unpairedTags.indexOf(tagName) !== -1){
	            
	            i = result.closeIndex;
	          }
	          //normal tag
	          else {
	            //read until closing tag is found
	            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
	            if(!result) throw new Error(`Unexpected end of ${rawTagName}`);
	            i = result.i;
	            tagContent = result.tagContent;
	          }

	          const childNode = new xmlNode(tagName);
	          if(tagName !== tagExp && attrExpPresent){
	            childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
	          }
	          if(tagContent) {
	            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
	          }
	          
	          jPath = jPath.substr(0, jPath.lastIndexOf("."));
	          childNode.add(this.options.textNodeName, tagContent);
	          
	          this.addChild(currentNode, childNode, jPath);
	        }else {
	  //selfClosing tag
	          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
	            if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
	              tagName = tagName.substr(0, tagName.length - 1);
	              jPath = jPath.substr(0, jPath.length - 1);
	              tagExp = tagName;
	            }else {
	              tagExp = tagExp.substr(0, tagExp.length - 1);
	            }
	            
	            if(this.options.transformTagName) {
	              tagName = this.options.transformTagName(tagName);
	            }

	            const childNode = new xmlNode(tagName);
	            if(tagName !== tagExp && attrExpPresent){
	              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
	            }
	            this.addChild(currentNode, childNode, jPath);
	            jPath = jPath.substr(0, jPath.lastIndexOf("."));
	          }
	    //opening tag
	          else {
	            const childNode = new xmlNode( tagName);
	            this.tagsNodeStack.push(currentNode);
	            
	            if(tagName !== tagExp && attrExpPresent){
	              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
	            }
	            this.addChild(currentNode, childNode, jPath);
	            currentNode = childNode;
	          }
	          textData = "";
	          i = closeIndex;
	        }
	      }
	    }else {
	      textData += xmlData[i];
	    }
	  }
	  return xmlObj.child;
	};

	function addChild(currentNode, childNode, jPath){
	  const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
	  if(result === false);else if(typeof result === "string"){
	    childNode.tagname = result;
	    currentNode.addChild(childNode);
	  }else {
	    currentNode.addChild(childNode);
	  }
	}

	const replaceEntitiesValue = function(val){

	  if(this.options.processEntities){
	    for(let entityName in this.docTypeEntities){
	      const entity = this.docTypeEntities[entityName];
	      val = val.replace( entity.regx, entity.val);
	    }
	    for(let entityName in this.lastEntities){
	      const entity = this.lastEntities[entityName];
	      val = val.replace( entity.regex, entity.val);
	    }
	    if(this.options.htmlEntities){
	      for(let entityName in this.htmlEntities){
	        const entity = this.htmlEntities[entityName];
	        val = val.replace( entity.regex, entity.val);
	      }
	    }
	    val = val.replace( this.ampEntity.regex, this.ampEntity.val);
	  }
	  return val;
	};
	function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
	  if (textData) { //store previously collected data as textNode
	    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0;
	    
	    textData = this.parseTextData(textData,
	      currentNode.tagname,
	      jPath,
	      false,
	      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
	      isLeafNode);

	    if (textData !== undefined && textData !== "")
	      currentNode.add(this.options.textNodeName, textData);
	    textData = "";
	  }
	  return textData;
	}

	//TODO: use jPath to simplify the logic
	/**
	 * 
	 * @param {string[]} stopNodes 
	 * @param {string} jPath
	 * @param {string} currentTagName 
	 */
	function isItStopNode(stopNodes, jPath, currentTagName){
	  const allNodesExp = "*." + currentTagName;
	  for (const stopNodePath in stopNodes) {
	    const stopNodeExp = stopNodes[stopNodePath];
	    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;
	  }
	  return false;
	}

	/**
	 * Returns the tag Expression and where it is ending handling single-double quotes situation
	 * @param {string} xmlData 
	 * @param {number} i starting index
	 * @returns 
	 */
	function tagExpWithClosingIndex(xmlData, i, closingChar = ">"){
	  let attrBoundary;
	  let tagExp = "";
	  for (let index = i; index < xmlData.length; index++) {
	    let ch = xmlData[index];
	    if (attrBoundary) {
	        if (ch === attrBoundary) attrBoundary = "";//reset
	    } else if (ch === '"' || ch === "'") {
	        attrBoundary = ch;
	    } else if (ch === closingChar[0]) {
	      if(closingChar[1]){
	        if(xmlData[index + 1] === closingChar[1]){
	          return {
	            data: tagExp,
	            index: index
	          }
	        }
	      }else {
	        return {
	          data: tagExp,
	          index: index
	        }
	      }
	    } else if (ch === '\t') {
	      ch = " ";
	    }
	    tagExp += ch;
	  }
	}

	function findClosingIndex(xmlData, str, i, errMsg){
	  const closingIndex = xmlData.indexOf(str, i);
	  if(closingIndex === -1){
	    throw new Error(errMsg)
	  }else {
	    return closingIndex + str.length - 1;
	  }
	}

	function readTagExp(xmlData,i, removeNSPrefix, closingChar = ">"){
	  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);
	  if(!result) return;
	  let tagExp = result.data;
	  const closeIndex = result.index;
	  const separatorIndex = tagExp.search(/\s/);
	  let tagName = tagExp;
	  let attrExpPresent = true;
	  if(separatorIndex !== -1){//separate tag name and attributes expression
	    tagName = tagExp.substring(0, separatorIndex);
	    tagExp = tagExp.substring(separatorIndex + 1).trimStart();
	  }

	  const rawTagName = tagName;
	  if(removeNSPrefix){
	    const colonIndex = tagName.indexOf(":");
	    if(colonIndex !== -1){
	      tagName = tagName.substr(colonIndex+1);
	      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
	    }
	  }

	  return {
	    tagName: tagName,
	    tagExp: tagExp,
	    closeIndex: closeIndex,
	    attrExpPresent: attrExpPresent,
	    rawTagName: rawTagName,
	  }
	}
	/**
	 * find paired tag for a stop node
	 * @param {string} xmlData 
	 * @param {string} tagName 
	 * @param {number} i 
	 */
	function readStopNodeData(xmlData, tagName, i){
	  const startIndex = i;
	  // Starting at 1 since we already have an open tag
	  let openTagCount = 1;

	  for (; i < xmlData.length; i++) {
	    if( xmlData[i] === "<"){ 
	      if (xmlData[i+1] === "/") {//close tag
	          const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
	          let closeTagName = xmlData.substring(i+2,closeIndex).trim();
	          if(closeTagName === tagName){
	            openTagCount--;
	            if (openTagCount === 0) {
	              return {
	                tagContent: xmlData.substring(startIndex, i),
	                i : closeIndex
	              }
	            }
	          }
	          i=closeIndex;
	        } else if(xmlData[i+1] === '?') { 
	          const closeIndex = findClosingIndex(xmlData, "?>", i+1, "StopNode is not closed.");
	          i=closeIndex;
	        } else if(xmlData.substr(i + 1, 3) === '!--') { 
	          const closeIndex = findClosingIndex(xmlData, "-->", i+3, "StopNode is not closed.");
	          i=closeIndex;
	        } else if(xmlData.substr(i + 1, 2) === '![') { 
	          const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
	          i=closeIndex;
	        } else {
	          const tagData = readTagExp(xmlData, i, '>');

	          if (tagData) {
	            const openTagName = tagData && tagData.tagName;
	            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== "/") {
	              openTagCount++;
	            }
	            i=tagData.closeIndex;
	          }
	        }
	      }
	  }//end for loop
	}

	function parseValue(val, shouldParse, options) {
	  if (shouldParse && typeof val === 'string') {
	    //console.log(options)
	    const newval = val.trim();
	    if(newval === 'true' ) return true;
	    else if(newval === 'false' ) return false;
	    else return toNumber(val, options);
	  } else {
	    if (util.isExist(val)) {
	      return val;
	    } else {
	      return '';
	    }
	  }
	}


	OrderedObjParser_1 = OrderedObjParser;
	return OrderedObjParser_1;
}

var node2json = {};

var hasRequiredNode2json;

function requireNode2json () {
	if (hasRequiredNode2json) return node2json;
	hasRequiredNode2json = 1;

	/**
	 * 
	 * @param {array} node 
	 * @param {any} options 
	 * @returns 
	 */
	function prettify(node, options){
	  return compress( node, options);
	}

	/**
	 * 
	 * @param {array} arr 
	 * @param {object} options 
	 * @param {string} jPath 
	 * @returns object
	 */
	function compress(arr, options, jPath){
	  let text;
	  const compressedObj = {};
	  for (let i = 0; i < arr.length; i++) {
	    const tagObj = arr[i];
	    const property = propName(tagObj);
	    let newJpath = "";
	    if(jPath === undefined) newJpath = property;
	    else newJpath = jPath + "." + property;

	    if(property === options.textNodeName){
	      if(text === undefined) text = tagObj[property];
	      else text += "" + tagObj[property];
	    }else if(property === undefined){
	      continue;
	    }else if(tagObj[property]){
	      
	      let val = compress(tagObj[property], options, newJpath);
	      const isLeaf = isLeafTag(val, options);

	      if(tagObj[":@"]){
	        assignAttributes( val, tagObj[":@"], newJpath, options);
	      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){
	        val = val[options.textNodeName];
	      }else if(Object.keys(val).length === 0){
	        if(options.alwaysCreateTextNode) val[options.textNodeName] = "";
	        else val = "";
	      }

	      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
	        if(!Array.isArray(compressedObj[property])) {
	            compressedObj[property] = [ compressedObj[property] ];
	        }
	        compressedObj[property].push(val);
	      }else {
	        //TODO: if a node is not an array, then check if it should be an array
	        //also determine if it is a leaf node
	        if (options.isArray(property, newJpath, isLeaf )) {
	          compressedObj[property] = [val];
	        }else {
	          compressedObj[property] = val;
	        }
	      }
	    }
	    
	  }
	  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;
	  if(typeof text === "string"){
	    if(text.length > 0) compressedObj[options.textNodeName] = text;
	  }else if(text !== undefined) compressedObj[options.textNodeName] = text;
	  return compressedObj;
	}

	function propName(obj){
	  const keys = Object.keys(obj);
	  for (let i = 0; i < keys.length; i++) {
	    const key = keys[i];
	    if(key !== ":@") return key;
	  }
	}

	function assignAttributes(obj, attrMap, jpath, options){
	  if (attrMap) {
	    const keys = Object.keys(attrMap);
	    const len = keys.length; //don't make it inline
	    for (let i = 0; i < len; i++) {
	      const atrrName = keys[i];
	      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
	        obj[atrrName] = [ attrMap[atrrName] ];
	      } else {
	        obj[atrrName] = attrMap[atrrName];
	      }
	    }
	  }
	}

	function isLeafTag(obj, options){
	  const { textNodeName } = options;
	  const propCount = Object.keys(obj).length;
	  
	  if (propCount === 0) {
	    return true;
	  }

	  if (
	    propCount === 1 &&
	    (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)
	  ) {
	    return true;
	  }

	  return false;
	}
	node2json.prettify = prettify;
	return node2json;
}

var XMLParser_1;
var hasRequiredXMLParser;

function requireXMLParser () {
	if (hasRequiredXMLParser) return XMLParser_1;
	hasRequiredXMLParser = 1;
	const { buildOptions} = requireOptionsBuilder();
	const OrderedObjParser = requireOrderedObjParser();
	const { prettify} = requireNode2json();
	const validator = requireValidator();

	class XMLParser{
	    
	    constructor(options){
	        this.externalEntities = {};
	        this.options = buildOptions(options);
	        
	    }
	    /**
	     * Parse XML dats to JS object 
	     * @param {string|Buffer} xmlData 
	     * @param {boolean|Object} validationOption 
	     */
	    parse(xmlData,validationOption){
	        if(typeof xmlData === "string");else if( xmlData.toString){
	            xmlData = xmlData.toString();
	        }else {
	            throw new Error("XML data is accepted in String or Bytes[] form.")
	        }
	        if( validationOption){
	            if(validationOption === true) validationOption = {}; //validate with default options
	            
	            const result = validator.validate(xmlData, validationOption);
	            if (result !== true) {
	              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )
	            }
	          }
	        const orderedObjParser = new OrderedObjParser(this.options);
	        orderedObjParser.addExternalEntities(this.externalEntities);
	        const orderedResult = orderedObjParser.parseXml(xmlData);
	        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;
	        else return prettify(orderedResult, this.options);
	    }

	    /**
	     * Add Entity which is not by default supported by this library
	     * @param {string} key 
	     * @param {string} value 
	     */
	    addEntity(key, value){
	        if(value.indexOf("&") !== -1){
	            throw new Error("Entity value can't have '&'")
	        }else if(key.indexOf("&") !== -1 || key.indexOf(";") !== -1){
	            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'")
	        }else if(value === "&"){
	            throw new Error("An entity with value '&' is not permitted");
	        }else {
	            this.externalEntities[key] = value;
	        }
	    }
	}

	XMLParser_1 = XMLParser;
	return XMLParser_1;
}

var orderedJs2Xml;
var hasRequiredOrderedJs2Xml;

function requireOrderedJs2Xml () {
	if (hasRequiredOrderedJs2Xml) return orderedJs2Xml;
	hasRequiredOrderedJs2Xml = 1;
	const EOL = "\n";

	/**
	 * 
	 * @param {array} jArray 
	 * @param {any} options 
	 * @returns 
	 */
	function toXml(jArray, options) {
	    let indentation = "";
	    if (options.format && options.indentBy.length > 0) {
	        indentation = EOL;
	    }
	    return arrToStr(jArray, options, "", indentation);
	}

	function arrToStr(arr, options, jPath, indentation) {
	    let xmlStr = "";
	    let isPreviousElementTag = false;

	    for (let i = 0; i < arr.length; i++) {
	        const tagObj = arr[i];
	        const tagName = propName(tagObj);
	        if(tagName === undefined) continue;

	        let newJPath = "";
	        if (jPath.length === 0) newJPath = tagName;
	        else newJPath = `${jPath}.${tagName}`;

	        if (tagName === options.textNodeName) {
	            let tagText = tagObj[tagName];
	            if (!isStopNode(newJPath, options)) {
	                tagText = options.tagValueProcessor(tagName, tagText);
	                tagText = replaceEntitiesValue(tagText, options);
	            }
	            if (isPreviousElementTag) {
	                xmlStr += indentation;
	            }
	            xmlStr += tagText;
	            isPreviousElementTag = false;
	            continue;
	        } else if (tagName === options.cdataPropName) {
	            if (isPreviousElementTag) {
	                xmlStr += indentation;
	            }
	            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
	            isPreviousElementTag = false;
	            continue;
	        } else if (tagName === options.commentPropName) {
	            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
	            isPreviousElementTag = true;
	            continue;
	        } else if (tagName[0] === "?") {
	            const attStr = attr_to_str(tagObj[":@"], options);
	            const tempInd = tagName === "?xml" ? "" : indentation;
	            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
	            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : ""; //remove extra spacing
	            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;
	            isPreviousElementTag = true;
	            continue;
	        }
	        let newIdentation = indentation;
	        if (newIdentation !== "") {
	            newIdentation += options.indentBy;
	        }
	        const attStr = attr_to_str(tagObj[":@"], options);
	        const tagStart = indentation + `<${tagName}${attStr}`;
	        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
	        if (options.unpairedTags.indexOf(tagName) !== -1) {
	            if (options.suppressUnpairedNode) xmlStr += tagStart + ">";
	            else xmlStr += tagStart + "/>";
	        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
	            xmlStr += tagStart + "/>";
	        } else if (tagValue && tagValue.endsWith(">")) {
	            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
	        } else {
	            xmlStr += tagStart + ">";
	            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
	                xmlStr += indentation + options.indentBy + tagValue + indentation;
	            } else {
	                xmlStr += tagValue;
	            }
	            xmlStr += `</${tagName}>`;
	        }
	        isPreviousElementTag = true;
	    }

	    return xmlStr;
	}

	function propName(obj) {
	    const keys = Object.keys(obj);
	    for (let i = 0; i < keys.length; i++) {
	        const key = keys[i];
	        if(!obj.hasOwnProperty(key)) continue;
	        if (key !== ":@") return key;
	    }
	}

	function attr_to_str(attrMap, options) {
	    let attrStr = "";
	    if (attrMap && !options.ignoreAttributes) {
	        for (let attr in attrMap) {
	            if(!attrMap.hasOwnProperty(attr)) continue;
	            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
	            attrVal = replaceEntitiesValue(attrVal, options);
	            if (attrVal === true && options.suppressBooleanAttributes) {
	                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
	            } else {
	                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
	            }
	        }
	    }
	    return attrStr;
	}

	function isStopNode(jPath, options) {
	    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
	    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
	    for (let index in options.stopNodes) {
	        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName) return true;
	    }
	    return false;
	}

	function replaceEntitiesValue(textValue, options) {
	    if (textValue && textValue.length > 0 && options.processEntities) {
	        for (let i = 0; i < options.entities.length; i++) {
	            const entity = options.entities[i];
	            textValue = textValue.replace(entity.regex, entity.val);
	        }
	    }
	    return textValue;
	}
	orderedJs2Xml = toXml;
	return orderedJs2Xml;
}

var json2xml;
var hasRequiredJson2xml;

function requireJson2xml () {
	if (hasRequiredJson2xml) return json2xml;
	hasRequiredJson2xml = 1;
	//parse Empty Node as self closing node
	const buildFromOrderedJs = requireOrderedJs2Xml();

	const defaultOptions = {
	  attributeNamePrefix: '@_',
	  attributesGroupName: false,
	  textNodeName: '#text',
	  ignoreAttributes: true,
	  cdataPropName: false,
	  format: false,
	  indentBy: '  ',
	  suppressEmptyNode: false,
	  suppressUnpairedNode: true,
	  suppressBooleanAttributes: true,
	  tagValueProcessor: function(key, a) {
	    return a;
	  },
	  attributeValueProcessor: function(attrName, a) {
	    return a;
	  },
	  preserveOrder: false,
	  commentPropName: false,
	  unpairedTags: [],
	  entities: [
	    { regex: new RegExp("&", "g"), val: "&amp;" },//it must be on top
	    { regex: new RegExp(">", "g"), val: "&gt;" },
	    { regex: new RegExp("<", "g"), val: "&lt;" },
	    { regex: new RegExp("\'", "g"), val: "&apos;" },
	    { regex: new RegExp("\"", "g"), val: "&quot;" }
	  ],
	  processEntities: true,
	  stopNodes: [],
	  // transformTagName: false,
	  // transformAttributeName: false,
	  oneListGroup: false
	};

	function Builder(options) {
	  this.options = Object.assign({}, defaultOptions, options);
	  if (this.options.ignoreAttributes || this.options.attributesGroupName) {
	    this.isAttribute = function(/*a*/) {
	      return false;
	    };
	  } else {
	    this.attrPrefixLen = this.options.attributeNamePrefix.length;
	    this.isAttribute = isAttribute;
	  }

	  this.processTextOrObjNode = processTextOrObjNode;

	  if (this.options.format) {
	    this.indentate = indentate;
	    this.tagEndChar = '>\n';
	    this.newLine = '\n';
	  } else {
	    this.indentate = function() {
	      return '';
	    };
	    this.tagEndChar = '>';
	    this.newLine = '';
	  }
	}

	Builder.prototype.build = function(jObj) {
	  if(this.options.preserveOrder){
	    return buildFromOrderedJs(jObj, this.options);
	  }else {
	    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){
	      jObj = {
	        [this.options.arrayNodeName] : jObj
	      };
	    }
	    return this.j2x(jObj, 0).val;
	  }
	};

	Builder.prototype.j2x = function(jObj, level) {
	  let attrStr = '';
	  let val = '';
	  for (let key in jObj) {
	    if(!Object.prototype.hasOwnProperty.call(jObj, key)) continue;
	    if (typeof jObj[key] === 'undefined') {
	      // supress undefined node only if it is not an attribute
	      if (this.isAttribute(key)) {
	        val += '';
	      }
	    } else if (jObj[key] === null) {
	      // null attribute should be ignored by the attribute list, but should not cause the tag closing
	      if (this.isAttribute(key)) {
	        val += '';
	      } else if (key[0] === '?') {
	        val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
	      } else {
	        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
	      }
	      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
	    } else if (jObj[key] instanceof Date) {
	      val += this.buildTextValNode(jObj[key], key, '', level);
	    } else if (typeof jObj[key] !== 'object') {
	      //premitive type
	      const attr = this.isAttribute(key);
	      if (attr) {
	        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);
	      }else {
	        //tag value
	        if (key === this.options.textNodeName) {
	          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);
	          val += this.replaceEntitiesValue(newval);
	        } else {
	          val += this.buildTextValNode(jObj[key], key, '', level);
	        }
	      }
	    } else if (Array.isArray(jObj[key])) {
	      //repeated nodes
	      const arrLen = jObj[key].length;
	      let listTagVal = "";
	      let listTagAttr = "";
	      for (let j = 0; j < arrLen; j++) {
	        const item = jObj[key][j];
	        if (typeof item === 'undefined') ; else if (item === null) {
	          if(key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
	          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
	          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
	        } else if (typeof item === 'object') {
	          if(this.options.oneListGroup){
	            const result = this.j2x(item, level + 1);
	            listTagVal += result.val;
	            if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
	              listTagAttr += result.attrStr;
	            }
	          }else {
	            listTagVal += this.processTextOrObjNode(item, key, level);
	          }
	        } else {
	          if (this.options.oneListGroup) {
	            let textValue = this.options.tagValueProcessor(key, item);
	            textValue = this.replaceEntitiesValue(textValue);
	            listTagVal += textValue;
	          } else {
	            listTagVal += this.buildTextValNode(item, key, '', level);
	          }
	        }
	      }
	      if(this.options.oneListGroup){
	        listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
	      }
	      val += listTagVal;
	    } else {
	      //nested node
	      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
	        const Ks = Object.keys(jObj[key]);
	        const L = Ks.length;
	        for (let j = 0; j < L; j++) {
	          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);
	        }
	      } else {
	        val += this.processTextOrObjNode(jObj[key], key, level);
	      }
	    }
	  }
	  return {attrStr: attrStr, val: val};
	};

	Builder.prototype.buildAttrPairStr = function(attrName, val){
	  val = this.options.attributeValueProcessor(attrName, '' + val);
	  val = this.replaceEntitiesValue(val);
	  if (this.options.suppressBooleanAttributes && val === "true") {
	    return ' ' + attrName;
	  } else return ' ' + attrName + '="' + val + '"';
	};

	function processTextOrObjNode (object, key, level) {
	  const result = this.j2x(object, level + 1);
	  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
	    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
	  } else {
	    return this.buildObjectNode(result.val, key, result.attrStr, level);
	  }
	}

	Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
	  if(val === ""){
	    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;
	    else {
	      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
	    }
	  }else {

	    let tagEndExp = '</' + key + this.tagEndChar;
	    let piClosingChar = "";
	    
	    if(key[0] === "?") {
	      piClosingChar = "?";
	      tagEndExp = "";
	    }
	  
	    // attrStr is an empty string in case the attribute came as undefined or null
	    if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {
	      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );
	    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
	      return this.indentate(level) + `<!--${val}-->` + this.newLine;
	    }else {
	      return (
	        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +
	        val +
	        this.indentate(level) + tagEndExp    );
	    }
	  }
	};

	Builder.prototype.closeTag = function(key){
	  let closeTag = "";
	  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired
	    if(!this.options.suppressUnpairedNode) closeTag = "/";
	  }else if(this.options.suppressEmptyNode){ //empty
	    closeTag = "/";
	  }else {
	    closeTag = `></${key}`;
	  }
	  return closeTag;
	};

	Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
	  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
	    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;
	  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
	    return this.indentate(level) + `<!--${val}-->` +  this.newLine;
	  }else if(key[0] === "?") {//PI tag
	    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; 
	  }else {
	    let textValue = this.options.tagValueProcessor(key, val);
	    textValue = this.replaceEntitiesValue(textValue);
	  
	    if( textValue === ''){
	      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
	    }else {
	      return this.indentate(level) + '<' + key + attrStr + '>' +
	         textValue +
	        '</' + key + this.tagEndChar;
	    }
	  }
	};

	Builder.prototype.replaceEntitiesValue = function(textValue){
	  if(textValue && textValue.length > 0 && this.options.processEntities){
	    for (let i=0; i<this.options.entities.length; i++) {
	      const entity = this.options.entities[i];
	      textValue = textValue.replace(entity.regex, entity.val);
	    }
	  }
	  return textValue;
	};

	function indentate(level) {
	  return this.options.indentBy.repeat(level);
	}

	function isAttribute(name /*, options*/) {
	  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
	    return name.substr(this.attrPrefixLen);
	  } else {
	    return false;
	  }
	}

	json2xml = Builder;
	return json2xml;
}

var fxp;
var hasRequiredFxp;

function requireFxp () {
	if (hasRequiredFxp) return fxp;
	hasRequiredFxp = 1;

	const validator = requireValidator();
	const XMLParser = requireXMLParser();
	const XMLBuilder = requireJson2xml();

	fxp = {
	  XMLParser: XMLParser,
	  XMLValidator: validator,
	  XMLBuilder: XMLBuilder
	};
	return fxp;
}

var fxpExports = requireFxp();

const parseXmlBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new fxpExports.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        let parsedObj;
        try {
            parsedObj = parser.parse(encoded, true);
        }
        catch (e) {
            if (e && typeof e === "object") {
                Object.defineProperty(e, "$responseBodyText", {
                    value: encoded,
                });
            }
            throw e;
        }
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return getValueFromTextNode(parsedObjToReturn);
    }
    return {};
});
const parseXmlErrorBody = async (errorBody, context) => {
    const value = await parseXmlBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const loadRestXmlErrorCode = (output, data) => {
    if (data?.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (data?.Code !== undefined) {
        return data.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};

const ACCOUNT_ID_ENDPOINT_REGEX = /\d{12}\.ddb/;
async function checkFeatures(context, config, args) {
    const request = args.request;
    if (request?.headers?.["smithy-protocol"] === "rpc-v2-cbor") {
        setFeature(context, "PROTOCOL_RPC_V2_CBOR", "M");
    }
    if (typeof config.retryStrategy === "function") {
        const retryStrategy = await config.retryStrategy();
        if (typeof retryStrategy.acquireInitialRetryToken === "function") {
            if (retryStrategy.constructor?.name?.includes("Adaptive")) {
                setFeature(context, "RETRY_MODE_ADAPTIVE", "F");
            }
            else {
                setFeature(context, "RETRY_MODE_STANDARD", "E");
            }
        }
        else {
            setFeature(context, "RETRY_MODE_LEGACY", "D");
        }
    }
    if (typeof config.accountIdEndpointMode === "function") {
        const endpointV2 = context.endpointV2;
        if (String(endpointV2?.url?.hostname).match(ACCOUNT_ID_ENDPOINT_REGEX)) {
            setFeature(context, "ACCOUNT_ID_ENDPOINT", "O");
        }
        switch (await config.accountIdEndpointMode?.()) {
            case "disabled":
                setFeature(context, "ACCOUNT_ID_MODE_DISABLED", "Q");
                break;
            case "preferred":
                setFeature(context, "ACCOUNT_ID_MODE_PREFERRED", "P");
                break;
            case "required":
                setFeature(context, "ACCOUNT_ID_MODE_REQUIRED", "R");
                break;
        }
    }
    const identity = context.__smithy_context?.selectedHttpAuthScheme?.identity;
    if (identity?.$source) {
        const credentials = identity;
        if (credentials.accountId) {
            setFeature(context, "RESOLVED_ACCOUNT_ID", "T");
        }
        for (const [key, value] of Object.entries(credentials.$source ?? {})) {
            setFeature(context, key, value);
        }
    }
}

const USER_AGENT = "user-agent";
const X_AMZ_USER_AGENT = "x-amz-user-agent";
const SPACE = " ";
const UA_NAME_SEPARATOR = "/";
const UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
const UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
const UA_ESCAPE_CHAR = "-";

const BYTE_LIMIT = 1024;
function encodeFeatures(features) {
    let buffer = "";
    for (const key in features) {
        const val = features[key];
        if (buffer.length + val.length + 1 <= BYTE_LIMIT) {
            if (buffer.length) {
                buffer += "," + val;
            }
            else {
                buffer += val;
            }
            continue;
        }
        break;
    }
    return buffer;
}

const userAgentMiddleware = (options) => (next, context) => async (args) => {
    const { request } = args;
    if (!HttpRequest.isInstance(request)) {
        return next(args);
    }
    const { headers } = request;
    const userAgent = context?.userAgent?.map(escapeUserAgent) || [];
    const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
    await checkFeatures(context, options, args);
    const awsContext = context;
    defaultUserAgent.push(`m/${encodeFeatures(Object.assign({}, context.__smithy_context?.features, awsContext.__aws_sdk_context?.features))}`);
    const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
    const appId = await options.userAgentAppId();
    if (appId) {
        defaultUserAgent.push(escapeUserAgent([`app/${appId}`]));
    }
    const sdkUserAgentValue = ([])
        .concat([...defaultUserAgent, ...userAgent, ...customUserAgent])
        .join(SPACE);
    const normalUAValue = [
        ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
        ...customUserAgent,
    ].join(SPACE);
    if (options.runtime !== "browser") {
        if (normalUAValue) {
            headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT]
                ? `${headers[USER_AGENT]} ${normalUAValue}`
                : normalUAValue;
        }
        headers[USER_AGENT] = sdkUserAgentValue;
    }
    else {
        headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
    }
    return next({
        ...args,
        request,
    });
};
const escapeUserAgent = (userAgentPair) => {
    const name = userAgentPair[0]
        .split(UA_NAME_SEPARATOR)
        .map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR))
        .join(UA_NAME_SEPARATOR);
    const version = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
    const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR);
    const prefix = name.substring(0, prefixSeparatorIndex);
    let uaName = name.substring(prefixSeparatorIndex + 1);
    if (prefix === "api") {
        uaName = uaName.toLowerCase();
    }
    return [prefix, uaName, version]
        .filter((item) => item && item.length > 0)
        .reduce((acc, item, index) => {
        switch (index) {
            case 0:
                return item;
            case 1:
                return `${acc}/${item}`;
            default:
                return `${acc}#${item}`;
        }
    }, "");
};
const getUserAgentMiddlewareOptions = {
    name: "getUserAgentMiddleware",
    step: "build",
    priority: "low",
    tags: ["SET_USER_AGENT", "USER_AGENT"],
    override: true,
};
const getUserAgentPlugin = (config) => ({
    applyToStack: (clientStack) => {
        clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);
    },
});

const booleanSelector = (obj, key, type) => {
    if (!(key in obj))
        return undefined;
    if (obj[key] === "true")
        return true;
    if (obj[key] === "false")
        return false;
    throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
};

var SelectorType$1;
(function (SelectorType) {
    SelectorType["ENV"] = "env";
    SelectorType["CONFIG"] = "shared config entry";
})(SelectorType$1 || (SelectorType$1 = {}));

const ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
const CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
const NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => booleanSelector(env, ENV_USE_DUALSTACK_ENDPOINT, SelectorType$1.ENV),
    configFileSelector: (profile) => booleanSelector(profile, CONFIG_USE_DUALSTACK_ENDPOINT, SelectorType$1.CONFIG),
    default: false,
};

const ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
const CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
const NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => booleanSelector(env, ENV_USE_FIPS_ENDPOINT, SelectorType$1.ENV),
    configFileSelector: (profile) => booleanSelector(profile, CONFIG_USE_FIPS_ENDPOINT, SelectorType$1.CONFIG),
    default: false,
};

const REGION_ENV_NAME = "AWS_REGION";
const REGION_INI_NAME = "region";
const NODE_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[REGION_ENV_NAME],
    configFileSelector: (profile) => profile[REGION_INI_NAME],
    default: () => {
        throw new Error("Region is missing");
    },
};
const NODE_REGION_CONFIG_FILE_OPTIONS = {
    preferredFile: "credentials",
};

const isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));

const getRealRegion = (region) => isFipsRegion(region)
    ? ["fips-aws-global", "aws-fips"].includes(region)
        ? "us-east-1"
        : region.replace(/fips-(dkr-|prod-)?|-fips/, "")
    : region;

const resolveRegionConfig = (input) => {
    const { region, useFipsEndpoint } = input;
    if (!region) {
        throw new Error("Region is missing");
    }
    return {
        ...input,
        region: async () => {
            if (typeof region === "string") {
                return getRealRegion(region);
            }
            const providedRegion = await region();
            return getRealRegion(providedRegion);
        },
        useFipsEndpoint: async () => {
            const providedRegion = typeof region === "string" ? region : await region();
            if (isFipsRegion(providedRegion)) {
                return true;
            }
            return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
        },
    };
};

const CONTENT_LENGTH_HEADER = "content-length";
function contentLengthMiddleware(bodyLengthChecker) {
    return (next) => async (args) => {
        const request = args.request;
        if (HttpRequest.isInstance(request)) {
            const { body, headers } = request;
            if (body &&
                Object.keys(headers)
                    .map((str) => str.toLowerCase())
                    .indexOf(CONTENT_LENGTH_HEADER) === -1) {
                try {
                    const length = bodyLengthChecker(body);
                    request.headers = {
                        ...request.headers,
                        [CONTENT_LENGTH_HEADER]: String(length),
                    };
                }
                catch (error) {
                }
            }
        }
        return next({
            ...args,
            request,
        });
    };
}
const contentLengthMiddlewareOptions = {
    step: "build",
    tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
    name: "contentLengthMiddleware",
    override: true,
};
const getContentLengthPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
    },
});

const resolveParamsForS3 = async (endpointParams) => {
    const bucket = endpointParams?.Bucket || "";
    if (typeof endpointParams.Bucket === "string") {
        endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
    }
    if (isArnBucketName(bucket)) {
        if (endpointParams.ForcePathStyle === true) {
            throw new Error("Path-style addressing cannot be used with ARN buckets");
        }
    }
    else if (!isDnsCompatibleBucketName(bucket) ||
        (bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:")) ||
        bucket.toLowerCase() !== bucket ||
        bucket.length < 3) {
        endpointParams.ForcePathStyle = true;
    }
    if (endpointParams.DisableMultiRegionAccessPoints) {
        endpointParams.disableMultiRegionAccessPoints = true;
        endpointParams.DisableMRAP = true;
    }
    return endpointParams;
};
const DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
const IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
const DOTS_PATTERN = /\.\./;
const isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
const isArnBucketName = (bucketName) => {
    const [arn, partition, service, , , bucket] = bucketName.split(":");
    const isArn = arn === "arn" && bucketName.split(":").length >= 6;
    const isValidArn = Boolean(isArn && partition && service && bucket);
    if (isArn && !isValidArn) {
        throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
    }
    return isValidArn;
};

const createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
    const configProvider = async () => {
        const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
        if (typeof configValue === "function") {
            return configValue();
        }
        return configValue;
    };
    if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
        return async () => {
            const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
            const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
            return configValue;
        };
    }
    if (configKey === "accountId" || canonicalEndpointParamKey === "AccountId") {
        return async () => {
            const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
            const configValue = credentials?.accountId ?? credentials?.AccountId;
            return configValue;
        };
    }
    if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
        return async () => {
            const endpoint = await configProvider();
            if (endpoint && typeof endpoint === "object") {
                if ("url" in endpoint) {
                    return endpoint.url.href;
                }
                if ("hostname" in endpoint) {
                    const { protocol, hostname, port, path } = endpoint;
                    return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
                }
            }
            return endpoint;
        };
    }
    return configProvider;
};

function getSelectorName(functionString) {
    try {
        const constants = new Set(Array.from(functionString.match(/([A-Z_]){3,}/g) ?? []));
        constants.delete("CONFIG");
        constants.delete("CONFIG_PREFIX_SEPARATOR");
        constants.delete("ENV");
        return [...constants].join(", ");
    }
    catch (e) {
        return functionString;
    }
}

const fromEnv$1 = (envVarSelector, logger) => async () => {
    try {
        const config = envVarSelector(process.env);
        if (config === undefined) {
            throw new Error();
        }
        return config;
    }
    catch (e) {
        throw new CredentialsProviderError(e.message || `Not found in ENV: ${getSelectorName(envVarSelector.toString())}`, { logger });
    }
};

const homeDirCache = {};
const getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
        return `${process.geteuid()}`;
    }
    return "DEFAULT";
};
const getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${require$$0$4.sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey])
        homeDirCache[homeDirCacheKey] = os.homedir();
    return homeDirCache[homeDirCacheKey];
};

const ENV_PROFILE = "AWS_PROFILE";
const DEFAULT_PROFILE = "default";
const getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;

const getConfigData = (data) => Object.entries(data)
    .filter(([key]) => {
    const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
        return false;
    }
    return Object.values(exports.IniSectionType).includes(key.substring(0, indexOfSeparator));
})
    .reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === exports.IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
}, {
    ...(data.default && { default: data.default }),
});

const ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || require$$0$4.join(getHomeDir(), ".aws", "config");

const ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || require$$0$4.join(getHomeDir(), ".aws", "credentials");

const prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
const profileNameBlockList = ["__proto__", "profile __proto__"];
const parseIni = (iniData) => {
    const map = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
            currentSection = undefined;
            currentSubSection = undefined;
            const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
            const matches = prefixKeyRegex.exec(sectionName);
            if (matches) {
                const [, prefix, , name] = matches;
                if (Object.values(exports.IniSectionType).includes(prefix)) {
                    currentSection = [prefix, name].join(CONFIG_PREFIX_SEPARATOR);
                }
            }
            else {
                currentSection = sectionName;
            }
            if (profileNameBlockList.includes(sectionName)) {
                throw new Error(`Found invalid profile name "${sectionName}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = trimmedLine.indexOf("=");
            if (![0, -1].includes(indexOfEqualsSign)) {
                const [name, value] = [
                    trimmedLine.substring(0, indexOfEqualsSign).trim(),
                    trimmedLine.substring(indexOfEqualsSign + 1).trim(),
                ];
                if (value === "") {
                    currentSubSection = name;
                }
                else {
                    if (currentSubSection && iniLine.trimStart() === iniLine) {
                        currentSubSection = undefined;
                    }
                    map[currentSection] = map[currentSection] || {};
                    const key = currentSubSection ? [currentSubSection, name].join(CONFIG_PREFIX_SEPARATOR) : name;
                    map[currentSection][key] = value;
                }
            }
        }
    }
    return map;
};

const { readFile } = fs.promises;
const filePromisesHash = {};
const slurpFile = (path, options) => {
    if (!filePromisesHash[path] || options?.ignoreCache) {
        filePromisesHash[path] = readFile(path, "utf8");
    }
    return filePromisesHash[path];
};

const swallowError = () => ({});
const CONFIG_PREFIX_SEPARATOR = ".";
const loadSharedConfigFiles = async (init = {}) => {
    const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath() } = init;
    const homeDir = getHomeDir();
    const relativeHomeDirPrefix = "~/";
    let resolvedFilepath = filepath;
    if (filepath.startsWith(relativeHomeDirPrefix)) {
        resolvedFilepath = require$$0$4.join(homeDir, filepath.slice(2));
    }
    let resolvedConfigFilepath = configFilepath;
    if (configFilepath.startsWith(relativeHomeDirPrefix)) {
        resolvedConfigFilepath = require$$0$4.join(homeDir, configFilepath.slice(2));
    }
    const parsedFiles = await Promise.all([
        slurpFile(resolvedConfigFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni)
            .then(getConfigData)
            .catch(swallowError),
        slurpFile(resolvedFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni)
            .catch(swallowError),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};

const fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
    const profile = getProfileName(init);
    const { configFile, credentialsFile } = await loadSharedConfigFiles(init);
    const profileFromCredentials = credentialsFile[profile] || {};
    const profileFromConfig = configFile[profile] || {};
    const mergedProfile = preferredFile === "config"
        ? { ...profileFromCredentials, ...profileFromConfig }
        : { ...profileFromConfig, ...profileFromCredentials };
    try {
        const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
        const configValue = configSelector(mergedProfile, cfgFile);
        if (configValue === undefined) {
            throw new Error();
        }
        return configValue;
    }
    catch (e) {
        throw new CredentialsProviderError(e.message || `Not found in config files w/ profile [${profile}]: ${getSelectorName(configSelector.toString())}`, { logger: init.logger });
    }
};

const isFunction = (func) => typeof func === "function";
const fromStatic = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : fromStatic$1(defaultValue);

const loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => memoize(chain(fromEnv$1(environmentVariableSelector), fromSharedConfigFiles(configFileSelector, configuration), fromStatic(defaultValue)));

const ENV_ENDPOINT_URL = "AWS_ENDPOINT_URL";
const CONFIG_ENDPOINT_URL = "endpoint_url";
const getEndpointUrlConfig = (serviceId) => ({
    environmentVariableSelector: (env) => {
        const serviceSuffixParts = serviceId.split(" ").map((w) => w.toUpperCase());
        const serviceEndpointUrl = env[[ENV_ENDPOINT_URL, ...serviceSuffixParts].join("_")];
        if (serviceEndpointUrl)
            return serviceEndpointUrl;
        const endpointUrl = env[ENV_ENDPOINT_URL];
        if (endpointUrl)
            return endpointUrl;
        return undefined;
    },
    configFileSelector: (profile, config) => {
        if (config && profile.services) {
            const servicesSection = config[["services", profile.services].join(CONFIG_PREFIX_SEPARATOR)];
            if (servicesSection) {
                const servicePrefixParts = serviceId.split(" ").map((w) => w.toLowerCase());
                const endpointUrl = servicesSection[[servicePrefixParts.join("_"), CONFIG_ENDPOINT_URL].join(CONFIG_PREFIX_SEPARATOR)];
                if (endpointUrl)
                    return endpointUrl;
            }
        }
        const endpointUrl = profile[CONFIG_ENDPOINT_URL];
        if (endpointUrl)
            return endpointUrl;
        return undefined;
    },
    default: undefined,
});

const getEndpointFromConfig = async (serviceId) => loadConfig(getEndpointUrlConfig(serviceId ?? ""))();

function parseQueryString(querystring) {
    const query = {};
    querystring = querystring.replace(/^\?/, "");
    if (querystring) {
        for (const pair of querystring.split("&")) {
            let [key, value = null] = pair.split("=");
            key = decodeURIComponent(key);
            if (value) {
                value = decodeURIComponent(value);
            }
            if (!(key in query)) {
                query[key] = value;
            }
            else if (Array.isArray(query[key])) {
                query[key].push(value);
            }
            else {
                query[key] = [query[key], value];
            }
        }
    }
    return query;
}

const parseUrl = (url) => {
    if (typeof url === "string") {
        return parseUrl(new URL(url));
    }
    const { hostname, pathname, port, protocol, search } = url;
    let query;
    if (search) {
        query = parseQueryString(search);
    }
    return {
        hostname,
        port: port ? parseInt(port) : undefined,
        protocol,
        path: pathname,
        query,
    };
};

const toEndpointV1 = (endpoint) => {
    if (typeof endpoint === "object") {
        if ("url" in endpoint) {
            return parseUrl(endpoint.url);
        }
        return endpoint;
    }
    return parseUrl(endpoint);
};

const getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
    if (!clientConfig.endpoint) {
        let endpointFromConfig;
        if (clientConfig.serviceConfiguredEndpoint) {
            endpointFromConfig = await clientConfig.serviceConfiguredEndpoint();
        }
        else {
            endpointFromConfig = await getEndpointFromConfig(clientConfig.serviceId);
        }
        if (endpointFromConfig) {
            clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
        }
    }
    const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
    if (typeof clientConfig.endpointProvider !== "function") {
        throw new Error("config.endpointProvider is not set.");
    }
    const endpoint = clientConfig.endpointProvider(endpointParams, context);
    return endpoint;
};
const resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
    const endpointParams = {};
    const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
    for (const [name, instruction] of Object.entries(instructions)) {
        switch (instruction.type) {
            case "staticContextParams":
                endpointParams[name] = instruction.value;
                break;
            case "contextParams":
                endpointParams[name] = commandInput[instruction.name];
                break;
            case "clientContextParams":
            case "builtInParams":
                endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
                break;
            default:
                throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
        }
    }
    if (Object.keys(instructions).length === 0) {
        Object.assign(endpointParams, clientConfig);
    }
    if (String(clientConfig.serviceId).toLowerCase() === "s3") {
        await resolveParamsForS3(endpointParams);
    }
    return endpointParams;
};

const endpointMiddleware = ({ config, instructions, }) => {
    return (next, context) => async (args) => {
        if (config.endpoint) {
            setFeature$1(context, "ENDPOINT_OVERRIDE", "N");
        }
        const endpoint = await getEndpointFromInstructions(args.input, {
            getEndpointParameterInstructions() {
                return instructions;
            },
        }, { ...config }, context);
        context.endpointV2 = endpoint;
        context.authSchemes = endpoint.properties?.authSchemes;
        const authScheme = context.authSchemes?.[0];
        if (authScheme) {
            context["signing_region"] = authScheme.signingRegion;
            context["signing_service"] = authScheme.signingName;
            const smithyContext = getSmithyContext(context);
            const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
            if (httpAuthOption) {
                httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
                    signing_region: authScheme.signingRegion,
                    signingRegion: authScheme.signingRegion,
                    signing_service: authScheme.signingName,
                    signingName: authScheme.signingName,
                    signingRegionSet: authScheme.signingRegionSet,
                }, authScheme.properties);
            }
        }
        return next({
            ...args,
        });
    };
};

const endpointMiddlewareOptions = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: serializerMiddlewareOption.name,
};
const getEndpointPlugin = (config, instructions) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(endpointMiddleware({
            config,
            instructions,
        }), endpointMiddlewareOptions);
    },
});

const resolveEndpointConfig = (input) => {
    const tls = input.tls ?? true;
    const { endpoint } = input;
    const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider$1(endpoint)()) : undefined;
    const isCustomEndpoint = !!endpoint;
    const resolvedConfig = {
        ...input,
        endpoint: customEndpointProvider,
        tls,
        isCustomEndpoint,
        useDualstackEndpoint: normalizeProvider$1(input.useDualstackEndpoint ?? false),
        useFipsEndpoint: normalizeProvider$1(input.useFipsEndpoint ?? false),
    };
    let configuredEndpointPromise = undefined;
    resolvedConfig.serviceConfiguredEndpoint = async () => {
        if (input.serviceId && !configuredEndpointPromise) {
            configuredEndpointPromise = getEndpointFromConfig(input.serviceId);
        }
        return configuredEndpointPromise;
    };
    return resolvedConfig;
};

var RETRY_MODES;
(function (RETRY_MODES) {
    RETRY_MODES["STANDARD"] = "standard";
    RETRY_MODES["ADAPTIVE"] = "adaptive";
})(RETRY_MODES || (RETRY_MODES = {}));
const DEFAULT_MAX_ATTEMPTS = 3;
const DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;

const THROTTLING_ERROR_CODES = [
    "BandwidthLimitExceeded",
    "EC2ThrottledException",
    "LimitExceededException",
    "PriorRequestNotComplete",
    "ProvisionedThroughputExceededException",
    "RequestLimitExceeded",
    "RequestThrottled",
    "RequestThrottledException",
    "SlowDown",
    "ThrottledException",
    "Throttling",
    "ThrottlingException",
    "TooManyRequestsException",
    "TransactionInProgressException",
];
const TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
const TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
const NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];

const isClockSkewCorrectedError = (error) => error.$metadata?.clockSkewCorrected;
const isThrottlingError = (error) => error.$metadata?.httpStatusCode === 429 ||
    THROTTLING_ERROR_CODES.includes(error.name) ||
    error.$retryable?.throttling == true;
const isTransientError = (error, depth = 0) => isClockSkewCorrectedError(error) ||
    TRANSIENT_ERROR_CODES.includes(error.name) ||
    NODEJS_TIMEOUT_ERROR_CODES.includes(error?.code || "") ||
    TRANSIENT_ERROR_STATUS_CODES.includes(error.$metadata?.httpStatusCode || 0) ||
    (error.cause !== undefined && depth <= 10 && isTransientError(error.cause, depth + 1));
const isServerError = (error) => {
    if (error.$metadata?.httpStatusCode !== undefined) {
        const statusCode = error.$metadata.httpStatusCode;
        if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
            return true;
        }
        return false;
    }
    return false;
};

class DefaultRateLimiter {
    constructor(options) {
        this.currentCapacity = 0;
        this.enabled = false;
        this.lastMaxRate = 0;
        this.measuredTxRate = 0;
        this.requestCount = 0;
        this.lastTimestamp = 0;
        this.timeWindow = 0;
        this.beta = options?.beta ?? 0.7;
        this.minCapacity = options?.minCapacity ?? 1;
        this.minFillRate = options?.minFillRate ?? 0.5;
        this.scaleConstant = options?.scaleConstant ?? 0.4;
        this.smooth = options?.smooth ?? 0.8;
        const currentTimeInSeconds = this.getCurrentTimeInSeconds();
        this.lastThrottleTime = currentTimeInSeconds;
        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
        this.fillRate = this.minFillRate;
        this.maxCapacity = this.minCapacity;
    }
    getCurrentTimeInSeconds() {
        return Date.now() / 1000;
    }
    async getSendToken() {
        return this.acquireTokenBucket(1);
    }
    async acquireTokenBucket(amount) {
        if (!this.enabled) {
            return;
        }
        this.refillTokenBucket();
        if (amount > this.currentCapacity) {
            const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;
            await new Promise((resolve) => DefaultRateLimiter.setTimeoutFn(resolve, delay));
        }
        this.currentCapacity = this.currentCapacity - amount;
    }
    refillTokenBucket() {
        const timestamp = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
            this.lastTimestamp = timestamp;
            return;
        }
        const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
        this.lastTimestamp = timestamp;
    }
    updateClientSendingRate(response) {
        let calculatedRate;
        this.updateMeasuredRate();
        if (isThrottlingError(response)) {
            const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
            this.lastMaxRate = rateToUse;
            this.calculateTimeWindow();
            this.lastThrottleTime = this.getCurrentTimeInSeconds();
            calculatedRate = this.cubicThrottle(rateToUse);
            this.enableTokenBucket();
        }
        else {
            this.calculateTimeWindow();
            calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
        }
        const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(newRate);
    }
    calculateTimeWindow() {
        this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));
    }
    cubicThrottle(rateToUse) {
        return this.getPrecise(rateToUse * this.beta);
    }
    cubicSuccess(timestamp) {
        return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
    }
    enableTokenBucket() {
        this.enabled = true;
    }
    updateTokenBucketRate(newRate) {
        this.refillTokenBucket();
        this.fillRate = Math.max(newRate, this.minFillRate);
        this.maxCapacity = Math.max(newRate, this.minCapacity);
        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
    }
    updateMeasuredRate() {
        const t = this.getCurrentTimeInSeconds();
        const timeBucket = Math.floor(t * 2) / 2;
        this.requestCount++;
        if (timeBucket > this.lastTxRateBucket) {
            const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
            this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
            this.requestCount = 0;
            this.lastTxRateBucket = timeBucket;
        }
    }
    getPrecise(num) {
        return parseFloat(num.toFixed(8));
    }
}
DefaultRateLimiter.setTimeoutFn = setTimeout;

const DEFAULT_RETRY_DELAY_BASE = 100;
const MAXIMUM_RETRY_DELAY = 20 * 1000;
const THROTTLING_RETRY_DELAY_BASE = 500;
const INITIAL_RETRY_TOKENS = 500;
const RETRY_COST = 5;
const TIMEOUT_RETRY_COST = 10;
const NO_RETRY_INCREMENT = 1;
const INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
const REQUEST_HEADER = "amz-sdk-request";

const getDefaultRetryBackoffStrategy = () => {
    let delayBase = DEFAULT_RETRY_DELAY_BASE;
    const computeNextBackoffDelay = (attempts) => {
        return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
    };
    const setDelayBase = (delay) => {
        delayBase = delay;
    };
    return {
        computeNextBackoffDelay,
        setDelayBase,
    };
};

const createDefaultRetryToken = ({ retryDelay, retryCount, retryCost, }) => {
    const getRetryCount = () => retryCount;
    const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY, retryDelay);
    const getRetryCost = () => retryCost;
    return {
        getRetryCount,
        getRetryDelay,
        getRetryCost,
    };
};

class StandardRetryStrategy {
    constructor(maxAttempts) {
        this.maxAttempts = maxAttempts;
        this.mode = RETRY_MODES.STANDARD;
        this.capacity = INITIAL_RETRY_TOKENS;
        this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();
        this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
    }
    async acquireInitialRetryToken(retryTokenScope) {
        return createDefaultRetryToken({
            retryDelay: DEFAULT_RETRY_DELAY_BASE,
            retryCount: 0,
        });
    }
    async refreshRetryTokenForRetry(token, errorInfo) {
        const maxAttempts = await this.getMaxAttempts();
        if (this.shouldRetry(token, errorInfo, maxAttempts)) {
            const errorType = errorInfo.errorType;
            this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
            const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
            const retryDelay = errorInfo.retryAfterHint
                ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType)
                : delayFromErrorType;
            const capacityCost = this.getCapacityCost(errorType);
            this.capacity -= capacityCost;
            return createDefaultRetryToken({
                retryDelay,
                retryCount: token.getRetryCount() + 1,
                retryCost: capacityCost,
            });
        }
        throw new Error("No retry token available");
    }
    recordSuccess(token) {
        this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));
    }
    getCapacity() {
        return this.capacity;
    }
    async getMaxAttempts() {
        try {
            return await this.maxAttemptsProvider();
        }
        catch (error) {
            console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
            return DEFAULT_MAX_ATTEMPTS;
        }
    }
    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
        const attempts = tokenToRenew.getRetryCount() + 1;
        return (attempts < maxAttempts &&
            this.capacity >= this.getCapacityCost(errorInfo.errorType) &&
            this.isRetryableError(errorInfo.errorType));
    }
    getCapacityCost(errorType) {
        return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
    }
    isRetryableError(errorType) {
        return errorType === "THROTTLING" || errorType === "TRANSIENT";
    }
}

class AdaptiveRetryStrategy {
    constructor(maxAttemptsProvider, options) {
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.mode = RETRY_MODES.ADAPTIVE;
        const { rateLimiter } = options ?? {};
        this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();
        this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
    }
    async acquireInitialRetryToken(retryTokenScope) {
        await this.rateLimiter.getSendToken();
        return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        this.rateLimiter.updateClientSendingRate(errorInfo);
        return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
    }
    recordSuccess(token) {
        this.rateLimiter.updateClientSendingRate({});
        this.standardRetryStrategy.recordSuccess(token);
    }
}

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}

function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native = {
  randomUUID
};

function v4(options, buf, offset) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }

  options = options || {};
  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  return unsafeStringify(rnds);
}

const asSdkError = (error) => {
    if (error instanceof Error)
        return error;
    if (error instanceof Object)
        return Object.assign(new Error(), error);
    if (typeof error === "string")
        return new Error(error);
    return new Error(`AWS SDK error wrapper for ${error}`);
};

const ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
const CONFIG_MAX_ATTEMPTS = "max_attempts";
const NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => {
        const value = env[ENV_MAX_ATTEMPTS];
        if (!value)
            return undefined;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
            throw new Error(`Environment variable ${ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
    },
    configFileSelector: (profile) => {
        const value = profile[CONFIG_MAX_ATTEMPTS];
        if (!value)
            return undefined;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
            throw new Error(`Shared config file entry ${CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
    },
    default: DEFAULT_MAX_ATTEMPTS,
};
const resolveRetryConfig = (input) => {
    const { retryStrategy } = input;
    const maxAttempts = normalizeProvider$1(input.maxAttempts ?? DEFAULT_MAX_ATTEMPTS);
    return {
        ...input,
        maxAttempts,
        retryStrategy: async () => {
            if (retryStrategy) {
                return retryStrategy;
            }
            const retryMode = await normalizeProvider$1(input.retryMode)();
            if (retryMode === RETRY_MODES.ADAPTIVE) {
                return new AdaptiveRetryStrategy(maxAttempts);
            }
            return new StandardRetryStrategy(maxAttempts);
        },
    };
};
const ENV_RETRY_MODE = "AWS_RETRY_MODE";
const CONFIG_RETRY_MODE = "retry_mode";
const NODE_RETRY_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[ENV_RETRY_MODE],
    configFileSelector: (profile) => profile[CONFIG_RETRY_MODE],
    default: DEFAULT_RETRY_MODE,
};

const isStreamingPayload = (request) => request?.body instanceof require$$0$9.Readable ||
    (typeof ReadableStream !== "undefined" && request?.body instanceof ReadableStream);

const retryMiddleware = (options) => (next, context) => async (args) => {
    let retryStrategy = await options.retryStrategy();
    const maxAttempts = await options.maxAttempts();
    if (isRetryStrategyV2(retryStrategy)) {
        retryStrategy = retryStrategy;
        let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
        let lastError = new Error();
        let attempts = 0;
        let totalRetryDelay = 0;
        const { request } = args;
        const isRequest = HttpRequest.isInstance(request);
        if (isRequest) {
            request.headers[INVOCATION_ID_HEADER] = v4();
        }
        while (true) {
            try {
                if (isRequest) {
                    request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
                }
                const { response, output } = await next(args);
                retryStrategy.recordSuccess(retryToken);
                output.$metadata.attempts = attempts + 1;
                output.$metadata.totalRetryDelay = totalRetryDelay;
                return { response, output };
            }
            catch (e) {
                const retryErrorInfo = getRetryErrorInfo(e);
                lastError = asSdkError(e);
                if (isRequest && isStreamingPayload(request)) {
                    (context.logger instanceof NoOpLogger ? console : context.logger)?.warn("An error was encountered in a non-retryable streaming request.");
                    throw lastError;
                }
                try {
                    retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
                }
                catch (refreshError) {
                    if (!lastError.$metadata) {
                        lastError.$metadata = {};
                    }
                    lastError.$metadata.attempts = attempts + 1;
                    lastError.$metadata.totalRetryDelay = totalRetryDelay;
                    throw lastError;
                }
                attempts = retryToken.getRetryCount();
                const delay = retryToken.getRetryDelay();
                totalRetryDelay += delay;
                await new Promise((resolve) => setTimeout(resolve, delay));
            }
        }
    }
    else {
        retryStrategy = retryStrategy;
        if (retryStrategy?.mode)
            context.userAgent = [...(context.userAgent || []), ["cfg/retry-mode", retryStrategy.mode]];
        return retryStrategy.retry(next, args);
    }
};
const isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" &&
    typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" &&
    typeof retryStrategy.recordSuccess !== "undefined";
const getRetryErrorInfo = (error) => {
    const errorInfo = {
        error,
        errorType: getRetryErrorType(error),
    };
    const retryAfterHint = getRetryAfterHint(error.$response);
    if (retryAfterHint) {
        errorInfo.retryAfterHint = retryAfterHint;
    }
    return errorInfo;
};
const getRetryErrorType = (error) => {
    if (isThrottlingError(error))
        return "THROTTLING";
    if (isTransientError(error))
        return "TRANSIENT";
    if (isServerError(error))
        return "SERVER_ERROR";
    return "CLIENT_ERROR";
};
const retryMiddlewareOptions = {
    name: "retryMiddleware",
    tags: ["RETRY"],
    step: "finalizeRequest",
    priority: "high",
    override: true,
};
const getRetryPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
    },
});
const getRetryAfterHint = (response) => {
    if (!HttpResponse.isInstance(response))
        return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
        return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
        return new Date(retryAfterSeconds * 1000);
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate;
};

const ENV_KEY = "AWS_ACCESS_KEY_ID";
const ENV_SECRET = "AWS_SECRET_ACCESS_KEY";
const ENV_SESSION = "AWS_SESSION_TOKEN";
const ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION";
const ENV_CREDENTIAL_SCOPE = "AWS_CREDENTIAL_SCOPE";
const ENV_ACCOUNT_ID = "AWS_ACCOUNT_ID";
const fromEnv = (init) => async () => {
    init?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
    const accessKeyId = process.env[ENV_KEY];
    const secretAccessKey = process.env[ENV_SECRET];
    const sessionToken = process.env[ENV_SESSION];
    const expiry = process.env[ENV_EXPIRATION];
    const credentialScope = process.env[ENV_CREDENTIAL_SCOPE];
    const accountId = process.env[ENV_ACCOUNT_ID];
    if (accessKeyId && secretAccessKey) {
        const credentials = {
            accessKeyId,
            secretAccessKey,
            ...(sessionToken && { sessionToken }),
            ...(expiry && { expiration: new Date(expiry) }),
            ...(credentialScope && { credentialScope }),
            ...(accountId && { accountId }),
        };
        setCredentialFeature(credentials, "CREDENTIALS_ENV_VARS", "g");
        return credentials;
    }
    throw new CredentialsProviderError("Unable to find environment variable credentials.", { logger: init?.logger });
};

const ENV_IMDS_DISABLED$1 = "AWS_EC2_METADATA_DISABLED";
const remoteProvider = async (init) => {
    const { ENV_CMDS_FULL_URI, ENV_CMDS_RELATIVE_URI, fromContainerMetadata, fromInstanceMetadata } = await Promise.resolve().then(function () { return require('./index-CtlNO4Zj.js'); });
    if (process.env[ENV_CMDS_RELATIVE_URI] || process.env[ENV_CMDS_FULL_URI]) {
        init.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata");
        const { fromHttp } = await Promise.resolve().then(function () { return require('./index-BcMmeiiO.js'); });
        return chain(fromHttp(init), fromContainerMetadata(init));
    }
    if (process.env[ENV_IMDS_DISABLED$1]) {
        return async () => {
            throw new CredentialsProviderError("EC2 Instance Metadata Service access disabled", { logger: init.logger });
        };
    }
    init.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata");
    return fromInstanceMetadata(init);
};

let multipleCredentialSourceWarningEmitted = false;
const defaultProvider = (init = {}) => memoize(chain(async () => {
    const profile = init.profile ?? process.env[ENV_PROFILE];
    if (profile) {
        const envStaticCredentialsAreSet = process.env[ENV_KEY] && process.env[ENV_SECRET];
        if (envStaticCredentialsAreSet) {
            if (!multipleCredentialSourceWarningEmitted) {
                const warnFn = init.logger?.warn && init.logger?.constructor?.name !== "NoOpLogger" ? init.logger.warn : console.warn;
                warnFn(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`);
                multipleCredentialSourceWarningEmitted = true;
            }
        }
        throw new CredentialsProviderError("AWS_PROFILE is set, skipping fromEnv provider.", {
            logger: init.logger,
            tryNextLink: true,
        });
    }
    init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromEnv");
    return fromEnv(init)();
}, async () => {
    init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromSSO");
    const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init;
    if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
        throw new CredentialsProviderError("Skipping SSO provider in default chain (inputs do not include SSO fields).", { logger: init.logger });
    }
    const { fromSSO } = await Promise.resolve().then(function () { return require('./index-Dyw9pQk3.js'); });
    return fromSSO(init)();
}, async () => {
    init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromIni");
    const { fromIni } = await Promise.resolve().then(function () { return require('./index-Tiez_lA3.js'); });
    return fromIni(init)();
}, async () => {
    init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromProcess");
    const { fromProcess } = await Promise.resolve().then(function () { return require('./index-DPGBJJ7E.js'); });
    return fromProcess(init)();
}, async () => {
    init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile");
    const { fromTokenFile } = await Promise.resolve().then(function () { return require('./index-C1z1TjXm.js'); });
    return fromTokenFile(init)();
}, async () => {
    init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::remoteProvider");
    return (await remoteProvider(init))();
}, async () => {
    throw new CredentialsProviderError("Could not load credentials from any providers", {
        tryNextLink: false,
        logger: init.logger,
    });
}), credentialsTreatedAsExpired, credentialsWillNeedRefresh);
const credentialsWillNeedRefresh = (credentials) => credentials?.expiration !== undefined;
const credentialsTreatedAsExpired = (credentials) => credentials?.expiration !== undefined && credentials.expiration.getTime() - Date.now() < 300000;

const isCrtAvailable = () => {
    return null;
};

const createDefaultUserAgentProvider = ({ serviceId, clientVersion }) => {
    return async (config) => {
        const sections = [
            ["aws-sdk-js", clientVersion],
            ["ua", "2.1"],
            [`os/${os.platform()}`, os.release()],
            ["lang/js"],
            ["md/nodejs", `${process$1.versions.node}`],
        ];
        const crtAvailable = isCrtAvailable();
        if (crtAvailable) {
            sections.push(crtAvailable);
        }
        if (serviceId) {
            sections.push([`api/${serviceId}`, clientVersion]);
        }
        if (process$1.env.AWS_EXECUTION_ENV) {
            sections.push([`exec-env/${process$1.env.AWS_EXECUTION_ENV}`]);
        }
        const appId = await config?.userAgentAppId?.();
        const resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
        return resolvedUserAgent;
    };
};

const UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
const UA_APP_ID_INI_NAME = "sdk_ua_app_id";
const UA_APP_ID_INI_NAME_DEPRECATED = "sdk-ua-app-id";
const NODE_APP_ID_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[UA_APP_ID_ENV_NAME],
    configFileSelector: (profile) => profile[UA_APP_ID_INI_NAME] ?? profile[UA_APP_ID_INI_NAME_DEPRECATED],
    default: DEFAULT_UA_APP_ID,
};

class Hash {
    constructor(algorithmIdentifier, secret) {
        this.algorithmIdentifier = algorithmIdentifier;
        this.secret = secret;
        this.reset();
    }
    update(toHash, encoding) {
        this.hash.update(toUint8Array(castSourceData(toHash, encoding)));
    }
    digest() {
        return Promise.resolve(this.hash.digest());
    }
    reset() {
        this.hash = this.secret
            ? require$$0$c.createHmac(this.algorithmIdentifier, castSourceData(this.secret))
            : require$$0$c.createHash(this.algorithmIdentifier);
    }
}
function castSourceData(toCast, encoding) {
    if (require$$0$a.Buffer.isBuffer(toCast)) {
        return toCast;
    }
    if (typeof toCast === "string") {
        return fromString$1(toCast, encoding);
    }
    if (ArrayBuffer.isView(toCast)) {
        return fromArrayBuffer(toCast.buffer, toCast.byteOffset, toCast.byteLength);
    }
    return fromArrayBuffer(toCast);
}

const calculateBodyLength = (body) => {
    if (!body) {
        return 0;
    }
    if (typeof body === "string") {
        return Buffer.byteLength(body);
    }
    else if (typeof body.byteLength === "number") {
        return body.byteLength;
    }
    else if (typeof body.size === "number") {
        return body.size;
    }
    else if (typeof body.start === "number" && typeof body.end === "number") {
        return body.end + 1 - body.start;
    }
    else if (typeof body.path === "string" || Buffer.isBuffer(body.path)) {
        return fs.lstatSync(body.path).size;
    }
    else if (typeof body.fd === "number") {
        return fs.fstatSync(body.fd).size;
    }
    throw new Error(`Body Length computation failed for ${body}`);
};

const AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
const AWS_REGION_ENV = "AWS_REGION";
const AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
const ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
const DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
const IMDS_REGION_PATH = "/latest/meta-data/placement/region";

const AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE";
const AWS_DEFAULTS_MODE_CONFIG = "defaults_mode";
const NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => {
        return env[AWS_DEFAULTS_MODE_ENV];
    },
    configFileSelector: (profile) => {
        return profile[AWS_DEFAULTS_MODE_CONFIG];
    },
    default: "legacy",
};

const resolveDefaultsModeConfig = ({ region = loadConfig(NODE_REGION_CONFIG_OPTIONS), defaultsMode = loadConfig(NODE_DEFAULTS_MODE_CONFIG_OPTIONS), } = {}) => memoize(async () => {
    const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
    switch (mode?.toLowerCase()) {
        case "auto":
            return resolveNodeDefaultsModeAuto(region);
        case "in-region":
        case "cross-region":
        case "mobile":
        case "standard":
        case "legacy":
            return Promise.resolve(mode?.toLocaleLowerCase());
        case undefined:
            return Promise.resolve("legacy");
        default:
            throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
    }
});
const resolveNodeDefaultsModeAuto = async (clientRegion) => {
    if (clientRegion) {
        const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
        const inferredRegion = await inferPhysicalRegion();
        if (!inferredRegion) {
            return "standard";
        }
        if (resolvedRegion === inferredRegion) {
            return "in-region";
        }
        else {
            return "cross-region";
        }
    }
    return "standard";
};
const inferPhysicalRegion = async () => {
    if (process.env[AWS_EXECUTION_ENV] && (process.env[AWS_REGION_ENV] || process.env[AWS_DEFAULT_REGION_ENV])) {
        return process.env[AWS_REGION_ENV] ?? process.env[AWS_DEFAULT_REGION_ENV];
    }
    if (!process.env[ENV_IMDS_DISABLED]) {
        try {
            const { getInstanceMetadataEndpoint, httpRequest } = await Promise.resolve().then(function () { return require('./index-CtlNO4Zj.js'); });
            const endpoint = await getInstanceMetadataEndpoint();
            return (await httpRequest({ ...endpoint, path: IMDS_REGION_PATH })).toString();
        }
        catch (e) {
        }
    }
};

const getAwsRegionExtensionConfiguration = (runtimeConfig) => {
    let runtimeConfigRegion = async () => {
        if (runtimeConfig.region === undefined) {
            throw new Error("Region is missing from runtimeConfig");
        }
        const region = runtimeConfig.region;
        if (typeof region === "string") {
            return region;
        }
        return region();
    };
    return {
        setRegion(region) {
            runtimeConfigRegion = region;
        },
        region() {
            return runtimeConfigRegion;
        },
    };
};
const resolveAwsRegionExtensionConfiguration = (awsRegionExtensionConfiguration) => {
    return {
        region: awsRegionExtensionConfiguration.region(),
    };
};

const defaultEC2HttpAuthSchemeParametersProvider = async (config, context, input) => {
    return {
        operation: getSmithyContext(context).operation,
        region: (await normalizeProvider$1(config.region)()) ||
            (() => {
                throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
            })(),
    };
};
function createAwsAuthSigv4HttpAuthOption$3(authParameters) {
    return {
        schemeId: "aws.auth#sigv4",
        signingProperties: {
            name: "ec2",
            region: authParameters.region,
        },
        propertiesExtractor: (config, context) => ({
            signingProperties: {
                config,
                context,
            },
        }),
    };
}
const defaultEC2HttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
        default: {
            options.push(createAwsAuthSigv4HttpAuthOption$3(authParameters));
        }
    }
    return options;
};
const resolveHttpAuthSchemeConfig$3 = (config) => {
    const config_0 = resolveAwsSdkSigV4Config(config);
    return {
        ...config_0,
    };
};

const resolveClientEndpointParameters$3 = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "ec2",
    };
};

var name$4 = "@aws-sdk/client-ec2";
var description$4 = "AWS SDK for JavaScript Ec2 Client for Node.js, Browser and React Native";
var version$4 = "3.712.0";
var scripts$4 = {
	build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
	"build:cjs": "node ../../scripts/compilation/inline client-ec2",
	"build:es": "tsc -p tsconfig.es.json",
	"build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
	"build:types": "tsc -p tsconfig.types.json",
	"build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
	clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
	"extract:docs": "api-extractor run --local",
	"generate:client": "node ../../scripts/generate-clients/single-service --solo ec2"
};
var main$4 = "./dist-cjs/index.js";
var types$4 = "./dist-types/index.d.ts";
var module$4 = "./dist-es/index.js";
var sideEffects$3 = false;
var dependencies$4 = {
	"@aws-crypto/sha256-browser": "5.2.0",
	"@aws-crypto/sha256-js": "5.2.0",
	"@aws-sdk/client-sso-oidc": "3.712.0",
	"@aws-sdk/client-sts": "3.712.0",
	"@aws-sdk/core": "3.709.0",
	"@aws-sdk/credential-provider-node": "3.712.0",
	"@aws-sdk/middleware-host-header": "3.709.0",
	"@aws-sdk/middleware-logger": "3.709.0",
	"@aws-sdk/middleware-recursion-detection": "3.709.0",
	"@aws-sdk/middleware-sdk-ec2": "3.709.0",
	"@aws-sdk/middleware-user-agent": "3.709.0",
	"@aws-sdk/region-config-resolver": "3.709.0",
	"@aws-sdk/types": "3.709.0",
	"@aws-sdk/util-endpoints": "3.709.0",
	"@aws-sdk/util-user-agent-browser": "3.709.0",
	"@aws-sdk/util-user-agent-node": "3.712.0",
	"@smithy/config-resolver": "^3.0.13",
	"@smithy/core": "^2.5.5",
	"@smithy/fetch-http-handler": "^4.1.2",
	"@smithy/hash-node": "^3.0.11",
	"@smithy/invalid-dependency": "^3.0.11",
	"@smithy/middleware-content-length": "^3.0.13",
	"@smithy/middleware-endpoint": "^3.2.5",
	"@smithy/middleware-retry": "^3.0.30",
	"@smithy/middleware-serde": "^3.0.11",
	"@smithy/middleware-stack": "^3.0.11",
	"@smithy/node-config-provider": "^3.1.12",
	"@smithy/node-http-handler": "^3.3.2",
	"@smithy/protocol-http": "^4.1.8",
	"@smithy/smithy-client": "^3.5.0",
	"@smithy/types": "^3.7.2",
	"@smithy/url-parser": "^3.0.11",
	"@smithy/util-base64": "^3.0.0",
	"@smithy/util-body-length-browser": "^3.0.0",
	"@smithy/util-body-length-node": "^3.0.0",
	"@smithy/util-defaults-mode-browser": "^3.0.30",
	"@smithy/util-defaults-mode-node": "^3.0.30",
	"@smithy/util-endpoints": "^2.1.7",
	"@smithy/util-middleware": "^3.0.11",
	"@smithy/util-retry": "^3.0.11",
	"@smithy/util-utf8": "^3.0.0",
	"@smithy/util-waiter": "^3.2.0",
	"@types/uuid": "^9.0.1",
	tslib: "^2.6.2",
	uuid: "^9.0.1"
};
var devDependencies$4 = {
	"@tsconfig/node16": "16.1.3",
	"@types/node": "^16.18.96",
	concurrently: "7.0.0",
	"downlevel-dts": "0.10.1",
	rimraf: "3.0.2",
	typescript: "~4.9.5"
};
var engines$4 = {
	node: ">=16.0.0"
};
var typesVersions$3 = {
	"<4.0": {
		"dist-types/*": [
			"dist-types/ts3.4/*"
		]
	}
};
var files$4 = [
	"dist-*/**"
];
var author$4 = {
	name: "AWS SDK for JavaScript Team",
	url: "https://aws.amazon.com/javascript/"
};
var license$4 = "Apache-2.0";
var browser$3 = {
	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
};
var homepage$4 = "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-ec2";
var repository$4 = {
	type: "git",
	url: "https://github.com/aws/aws-sdk-js-v3.git",
	directory: "clients/client-ec2"
};
var packageInfo$3 = {
	name: name$4,
	description: description$4,
	version: version$4,
	scripts: scripts$4,
	main: main$4,
	types: types$4,
	module: module$4,
	sideEffects: sideEffects$3,
	dependencies: dependencies$4,
	devDependencies: devDependencies$4,
	engines: engines$4,
	typesVersions: typesVersions$3,
	files: files$4,
	author: author$4,
	license: license$4,
	browser: browser$3,
	"react-native": {
	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
},
	homepage: homepage$4,
	repository: repository$4
};

const u$3 = "required", v$3 = "fn", w$2 = "argv", x$2 = "ref";
const a$3 = true, b$3 = "isSet", c$3 = "booleanEquals", d$3 = "error", e$3 = "endpoint", f$3 = "tree", g$3 = "PartitionResult", h$3 = "getAttr", i$3 = { [u$3]: false, "type": "String" }, j$3 = { [u$3]: true, "default": false, "type": "Boolean" }, k$3 = { [x$2]: "Endpoint" }, l$3 = { [v$3]: c$3, [w$2]: [{ [x$2]: "UseFIPS" }, true] }, m$3 = { [v$3]: c$3, [w$2]: [{ [x$2]: "UseDualStack" }, true] }, n$3 = {}, o$3 = { [v$3]: h$3, [w$2]: [{ [x$2]: g$3 }, "supportsFIPS"] }, p$3 = { [x$2]: g$3 }, q$3 = { [v$3]: c$3, [w$2]: [true, { [v$3]: h$3, [w$2]: [p$3, "supportsDualStack"] }] }, r$3 = [l$3], s$3 = [m$3], t$3 = [{ [x$2]: "Region" }];
const _data$3 = { version: "1.0", parameters: { Region: i$3, UseDualStack: j$3, UseFIPS: j$3, Endpoint: i$3 }, rules: [{ conditions: [{ [v$3]: b$3, [w$2]: [k$3] }], rules: [{ conditions: r$3, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d$3 }, { conditions: s$3, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d$3 }, { endpoint: { url: k$3, properties: n$3, headers: n$3 }, type: e$3 }], type: f$3 }, { conditions: [{ [v$3]: b$3, [w$2]: t$3 }], rules: [{ conditions: [{ [v$3]: "aws.partition", [w$2]: t$3, assign: g$3 }], rules: [{ conditions: [l$3, m$3], rules: [{ conditions: [{ [v$3]: c$3, [w$2]: [a$3, o$3] }, q$3], rules: [{ endpoint: { url: "https://ec2-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n$3, headers: n$3 }, type: e$3 }], type: f$3 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d$3 }], type: f$3 }, { conditions: r$3, rules: [{ conditions: [{ [v$3]: c$3, [w$2]: [o$3, a$3] }], rules: [{ conditions: [{ [v$3]: "stringEquals", [w$2]: [{ [v$3]: h$3, [w$2]: [p$3, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://ec2.{Region}.amazonaws.com", properties: n$3, headers: n$3 }, type: e$3 }, { endpoint: { url: "https://ec2-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n$3, headers: n$3 }, type: e$3 }], type: f$3 }, { error: "FIPS is enabled but this partition does not support FIPS", type: d$3 }], type: f$3 }, { conditions: s$3, rules: [{ conditions: [q$3], rules: [{ endpoint: { url: "https://ec2.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n$3, headers: n$3 }, type: e$3 }], type: f$3 }, { error: "DualStack is enabled but this partition does not support DualStack", type: d$3 }], type: f$3 }, { endpoint: { url: "https://ec2.{Region}.{PartitionResult#dnsSuffix}", properties: n$3, headers: n$3 }, type: e$3 }], type: f$3 }], type: f$3 }, { error: "Invalid Configuration: Missing Region", type: d$3 }] };
const ruleSet$3 = _data$3;

const cache$3 = new EndpointCache({
    size: 50,
    params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"],
});
const defaultEndpointResolver$3 = (endpointParams, context = {}) => {
    return cache$3.get(endpointParams, () => resolveEndpoint(ruleSet$3, {
        endpointParams: endpointParams,
        logger: context.logger,
    }));
};
customEndpointFunctions.aws = awsEndpointFunctions;

const getRuntimeConfig$7 = (config) => {
    return {
        apiVersion: "2016-11-15",
        base64Decoder: config?.base64Decoder ?? fromBase64,
        base64Encoder: config?.base64Encoder ?? toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver$3,
        extensions: config?.extensions ?? [],
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultEC2HttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
            {
                schemeId: "aws.auth#sigv4",
                identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
                signer: new AwsSdkSigV4Signer(),
            },
        ],
        logger: config?.logger ?? new NoOpLogger(),
        serviceId: config?.serviceId ?? "EC2",
        urlParser: config?.urlParser ?? parseUrl,
        utf8Decoder: config?.utf8Decoder ?? fromUtf8$1,
        utf8Encoder: config?.utf8Encoder ?? toUtf8,
    };
};

const getRuntimeConfig$6 = (config) => {
    emitWarningIfUnsupportedVersion(process.version);
    const defaultsMode = resolveDefaultsModeConfig(config);
    const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
    const clientSharedValues = getRuntimeConfig$7(config);
    emitWarningIfUnsupportedVersion$1(process.version);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? defaultProvider,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: packageInfo$3.version }),
        maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ??
            loadConfig({
                ...NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? streamCollector$1,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
        userAgentAppId: config?.userAgentAppId ?? loadConfig(NODE_APP_ID_CONFIG_OPTIONS),
    };
};

const getHttpAuthExtensionConfiguration$3 = (runtimeConfig) => {
    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
    let _credentials = runtimeConfig.credentials;
    return {
        setHttpAuthScheme(httpAuthScheme) {
            const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
            if (index === -1) {
                _httpAuthSchemes.push(httpAuthScheme);
            }
            else {
                _httpAuthSchemes.splice(index, 1, httpAuthScheme);
            }
        },
        httpAuthSchemes() {
            return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
            _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
            return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
            _credentials = credentials;
        },
        credentials() {
            return _credentials;
        },
    };
};
const resolveHttpAuthRuntimeConfig$3 = (config) => {
    return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials(),
    };
};

const asPartial$3 = (t) => t;
const resolveRuntimeExtensions$3 = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
        ...asPartial$3(getAwsRegionExtensionConfiguration(runtimeConfig)),
        ...asPartial$3(getDefaultExtensionConfiguration(runtimeConfig)),
        ...asPartial$3(getHttpHandlerExtensionConfiguration(runtimeConfig)),
        ...asPartial$3(getHttpAuthExtensionConfiguration$3(runtimeConfig)),
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
        ...resolveDefaultRuntimeConfig(extensionConfiguration),
        ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
        ...resolveHttpAuthRuntimeConfig$3(extensionConfiguration),
    };
};

class EC2Client extends Client {
    constructor(...[configuration]) {
        const _config_0 = getRuntimeConfig$6(configuration || {});
        const _config_1 = resolveClientEndpointParameters$3(_config_0);
        const _config_2 = resolveUserAgentConfig(_config_1);
        const _config_3 = resolveRetryConfig(_config_2);
        const _config_4 = resolveRegionConfig(_config_3);
        const _config_5 = resolveHostHeaderConfig(_config_4);
        const _config_6 = resolveEndpointConfig(_config_5);
        const _config_7 = resolveHttpAuthSchemeConfig$3(_config_6);
        const _config_8 = resolveRuntimeExtensions$3(_config_7, configuration?.extensions || []);
        super(_config_8);
        this.config = _config_8;
        this.middlewareStack.use(getUserAgentPlugin(this.config));
        this.middlewareStack.use(getRetryPlugin(this.config));
        this.middlewareStack.use(getContentLengthPlugin(this.config));
        this.middlewareStack.use(getHostHeaderPlugin(this.config));
        this.middlewareStack.use(getLoggerPlugin(this.config));
        this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
        this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
            httpAuthSchemeParametersProvider: defaultEC2HttpAuthSchemeParametersProvider,
            identityProviderConfigProvider: async (config) => new DefaultIdentityProviderConfig({
                "aws.auth#sigv4": config.credentials,
            }),
        }));
        this.middlewareStack.use(getHttpSigningPlugin(this.config));
    }
    destroy() {
        super.destroy();
    }
}

const defaultECSHttpAuthSchemeParametersProvider = async (config, context, input) => {
    return {
        operation: getSmithyContext(context).operation,
        region: (await normalizeProvider$1(config.region)()) ||
            (() => {
                throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
            })(),
    };
};
function createAwsAuthSigv4HttpAuthOption$2(authParameters) {
    return {
        schemeId: "aws.auth#sigv4",
        signingProperties: {
            name: "ecs",
            region: authParameters.region,
        },
        propertiesExtractor: (config, context) => ({
            signingProperties: {
                config,
                context,
            },
        }),
    };
}
const defaultECSHttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
        default: {
            options.push(createAwsAuthSigv4HttpAuthOption$2(authParameters));
        }
    }
    return options;
};
const resolveHttpAuthSchemeConfig$2 = (config) => {
    const config_0 = resolveAwsSdkSigV4Config(config);
    return {
        ...config_0,
    };
};

const resolveClientEndpointParameters$2 = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "ecs",
    };
};

var name$3 = "@aws-sdk/client-ecs";
var description$3 = "AWS SDK for JavaScript Ecs Client for Node.js, Browser and React Native";
var version$3 = "3.712.0";
var scripts$3 = {
	build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
	"build:cjs": "node ../../scripts/compilation/inline client-ecs",
	"build:es": "tsc -p tsconfig.es.json",
	"build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
	"build:types": "tsc -p tsconfig.types.json",
	"build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
	clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
	"extract:docs": "api-extractor run --local",
	"generate:client": "node ../../scripts/generate-clients/single-service --solo ecs"
};
var main$3 = "./dist-cjs/index.js";
var types$3 = "./dist-types/index.d.ts";
var module$3 = "./dist-es/index.js";
var sideEffects$2 = false;
var dependencies$3 = {
	"@aws-crypto/sha256-browser": "5.2.0",
	"@aws-crypto/sha256-js": "5.2.0",
	"@aws-sdk/client-sso-oidc": "3.712.0",
	"@aws-sdk/client-sts": "3.712.0",
	"@aws-sdk/core": "3.709.0",
	"@aws-sdk/credential-provider-node": "3.712.0",
	"@aws-sdk/middleware-host-header": "3.709.0",
	"@aws-sdk/middleware-logger": "3.709.0",
	"@aws-sdk/middleware-recursion-detection": "3.709.0",
	"@aws-sdk/middleware-user-agent": "3.709.0",
	"@aws-sdk/region-config-resolver": "3.709.0",
	"@aws-sdk/types": "3.709.0",
	"@aws-sdk/util-endpoints": "3.709.0",
	"@aws-sdk/util-user-agent-browser": "3.709.0",
	"@aws-sdk/util-user-agent-node": "3.712.0",
	"@smithy/config-resolver": "^3.0.13",
	"@smithy/core": "^2.5.5",
	"@smithy/fetch-http-handler": "^4.1.2",
	"@smithy/hash-node": "^3.0.11",
	"@smithy/invalid-dependency": "^3.0.11",
	"@smithy/middleware-content-length": "^3.0.13",
	"@smithy/middleware-endpoint": "^3.2.5",
	"@smithy/middleware-retry": "^3.0.30",
	"@smithy/middleware-serde": "^3.0.11",
	"@smithy/middleware-stack": "^3.0.11",
	"@smithy/node-config-provider": "^3.1.12",
	"@smithy/node-http-handler": "^3.3.2",
	"@smithy/protocol-http": "^4.1.8",
	"@smithy/smithy-client": "^3.5.0",
	"@smithy/types": "^3.7.2",
	"@smithy/url-parser": "^3.0.11",
	"@smithy/util-base64": "^3.0.0",
	"@smithy/util-body-length-browser": "^3.0.0",
	"@smithy/util-body-length-node": "^3.0.0",
	"@smithy/util-defaults-mode-browser": "^3.0.30",
	"@smithy/util-defaults-mode-node": "^3.0.30",
	"@smithy/util-endpoints": "^2.1.7",
	"@smithy/util-middleware": "^3.0.11",
	"@smithy/util-retry": "^3.0.11",
	"@smithy/util-utf8": "^3.0.0",
	"@smithy/util-waiter": "^3.2.0",
	"@types/uuid": "^9.0.1",
	tslib: "^2.6.2",
	uuid: "^9.0.1"
};
var devDependencies$3 = {
	"@tsconfig/node16": "16.1.3",
	"@types/node": "^16.18.96",
	concurrently: "7.0.0",
	"downlevel-dts": "0.10.1",
	rimraf: "3.0.2",
	typescript: "~4.9.5"
};
var engines$3 = {
	node: ">=16.0.0"
};
var typesVersions$2 = {
	"<4.0": {
		"dist-types/*": [
			"dist-types/ts3.4/*"
		]
	}
};
var files$3 = [
	"dist-*/**"
];
var author$3 = {
	name: "AWS SDK for JavaScript Team",
	url: "https://aws.amazon.com/javascript/"
};
var license$3 = "Apache-2.0";
var browser$2 = {
	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
};
var homepage$3 = "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-ecs";
var repository$3 = {
	type: "git",
	url: "https://github.com/aws/aws-sdk-js-v3.git",
	directory: "clients/client-ecs"
};
var packageInfo$2 = {
	name: name$3,
	description: description$3,
	version: version$3,
	scripts: scripts$3,
	main: main$3,
	types: types$3,
	module: module$3,
	sideEffects: sideEffects$2,
	dependencies: dependencies$3,
	devDependencies: devDependencies$3,
	engines: engines$3,
	typesVersions: typesVersions$2,
	files: files$3,
	author: author$3,
	license: license$3,
	browser: browser$2,
	"react-native": {
	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
},
	homepage: homepage$3,
	repository: repository$3
};

const s$2 = "required", t$2 = "fn", u$2 = "argv", v$2 = "ref";
const a$2 = true, b$2 = "isSet", c$2 = "booleanEquals", d$2 = "error", e$2 = "endpoint", f$2 = "tree", g$2 = "PartitionResult", h$2 = { [s$2]: false, "type": "String" }, i$2 = { [s$2]: true, "default": false, "type": "Boolean" }, j$2 = { [v$2]: "Endpoint" }, k$2 = { [t$2]: c$2, [u$2]: [{ [v$2]: "UseFIPS" }, true] }, l$2 = { [t$2]: c$2, [u$2]: [{ [v$2]: "UseDualStack" }, true] }, m$2 = {}, n$2 = { [t$2]: "getAttr", [u$2]: [{ [v$2]: g$2 }, "supportsFIPS"] }, o$2 = { [t$2]: c$2, [u$2]: [true, { [t$2]: "getAttr", [u$2]: [{ [v$2]: g$2 }, "supportsDualStack"] }] }, p$2 = [k$2], q$2 = [l$2], r$2 = [{ [v$2]: "Region" }];
const _data$2 = { version: "1.0", parameters: { Region: h$2, UseDualStack: i$2, UseFIPS: i$2, Endpoint: h$2 }, rules: [{ conditions: [{ [t$2]: b$2, [u$2]: [j$2] }], rules: [{ conditions: p$2, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d$2 }, { conditions: q$2, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d$2 }, { endpoint: { url: j$2, properties: m$2, headers: m$2 }, type: e$2 }], type: f$2 }, { conditions: [{ [t$2]: b$2, [u$2]: r$2 }], rules: [{ conditions: [{ [t$2]: "aws.partition", [u$2]: r$2, assign: g$2 }], rules: [{ conditions: [k$2, l$2], rules: [{ conditions: [{ [t$2]: c$2, [u$2]: [a$2, n$2] }, o$2], rules: [{ endpoint: { url: "https://ecs-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m$2, headers: m$2 }, type: e$2 }], type: f$2 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d$2 }], type: f$2 }, { conditions: p$2, rules: [{ conditions: [{ [t$2]: c$2, [u$2]: [n$2, a$2] }], rules: [{ endpoint: { url: "https://ecs-fips.{Region}.{PartitionResult#dnsSuffix}", properties: m$2, headers: m$2 }, type: e$2 }], type: f$2 }, { error: "FIPS is enabled but this partition does not support FIPS", type: d$2 }], type: f$2 }, { conditions: q$2, rules: [{ conditions: [o$2], rules: [{ endpoint: { url: "https://ecs.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m$2, headers: m$2 }, type: e$2 }], type: f$2 }, { error: "DualStack is enabled but this partition does not support DualStack", type: d$2 }], type: f$2 }, { endpoint: { url: "https://ecs.{Region}.{PartitionResult#dnsSuffix}", properties: m$2, headers: m$2 }, type: e$2 }], type: f$2 }], type: f$2 }, { error: "Invalid Configuration: Missing Region", type: d$2 }] };
const ruleSet$2 = _data$2;

const cache$2 = new EndpointCache({
    size: 50,
    params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"],
});
const defaultEndpointResolver$2 = (endpointParams, context = {}) => {
    return cache$2.get(endpointParams, () => resolveEndpoint(ruleSet$2, {
        endpointParams: endpointParams,
        logger: context.logger,
    }));
};
customEndpointFunctions.aws = awsEndpointFunctions;

const getRuntimeConfig$5 = (config) => {
    return {
        apiVersion: "2014-11-13",
        base64Decoder: config?.base64Decoder ?? fromBase64,
        base64Encoder: config?.base64Encoder ?? toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver$2,
        extensions: config?.extensions ?? [],
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultECSHttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
            {
                schemeId: "aws.auth#sigv4",
                identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
                signer: new AwsSdkSigV4Signer(),
            },
        ],
        logger: config?.logger ?? new NoOpLogger(),
        serviceId: config?.serviceId ?? "ECS",
        urlParser: config?.urlParser ?? parseUrl,
        utf8Decoder: config?.utf8Decoder ?? fromUtf8$1,
        utf8Encoder: config?.utf8Encoder ?? toUtf8,
    };
};

const getRuntimeConfig$4 = (config) => {
    emitWarningIfUnsupportedVersion(process.version);
    const defaultsMode = resolveDefaultsModeConfig(config);
    const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
    const clientSharedValues = getRuntimeConfig$5(config);
    emitWarningIfUnsupportedVersion$1(process.version);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? defaultProvider,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: packageInfo$2.version }),
        maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ??
            loadConfig({
                ...NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? streamCollector$1,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
        userAgentAppId: config?.userAgentAppId ?? loadConfig(NODE_APP_ID_CONFIG_OPTIONS),
    };
};

const getHttpAuthExtensionConfiguration$2 = (runtimeConfig) => {
    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
    let _credentials = runtimeConfig.credentials;
    return {
        setHttpAuthScheme(httpAuthScheme) {
            const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
            if (index === -1) {
                _httpAuthSchemes.push(httpAuthScheme);
            }
            else {
                _httpAuthSchemes.splice(index, 1, httpAuthScheme);
            }
        },
        httpAuthSchemes() {
            return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
            _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
            return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
            _credentials = credentials;
        },
        credentials() {
            return _credentials;
        },
    };
};
const resolveHttpAuthRuntimeConfig$2 = (config) => {
    return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials(),
    };
};

const asPartial$2 = (t) => t;
const resolveRuntimeExtensions$2 = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
        ...asPartial$2(getAwsRegionExtensionConfiguration(runtimeConfig)),
        ...asPartial$2(getDefaultExtensionConfiguration(runtimeConfig)),
        ...asPartial$2(getHttpHandlerExtensionConfiguration(runtimeConfig)),
        ...asPartial$2(getHttpAuthExtensionConfiguration$2(runtimeConfig)),
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
        ...resolveDefaultRuntimeConfig(extensionConfiguration),
        ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
        ...resolveHttpAuthRuntimeConfig$2(extensionConfiguration),
    };
};

class ECSClient extends Client {
    constructor(...[configuration]) {
        const _config_0 = getRuntimeConfig$4(configuration || {});
        const _config_1 = resolveClientEndpointParameters$2(_config_0);
        const _config_2 = resolveUserAgentConfig(_config_1);
        const _config_3 = resolveRetryConfig(_config_2);
        const _config_4 = resolveRegionConfig(_config_3);
        const _config_5 = resolveHostHeaderConfig(_config_4);
        const _config_6 = resolveEndpointConfig(_config_5);
        const _config_7 = resolveHttpAuthSchemeConfig$2(_config_6);
        const _config_8 = resolveRuntimeExtensions$2(_config_7, configuration?.extensions || []);
        super(_config_8);
        this.config = _config_8;
        this.middlewareStack.use(getUserAgentPlugin(this.config));
        this.middlewareStack.use(getRetryPlugin(this.config));
        this.middlewareStack.use(getContentLengthPlugin(this.config));
        this.middlewareStack.use(getHostHeaderPlugin(this.config));
        this.middlewareStack.use(getLoggerPlugin(this.config));
        this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
        this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
            httpAuthSchemeParametersProvider: defaultECSHttpAuthSchemeParametersProvider,
            identityProviderConfigProvider: async (config) => new DefaultIdentityProviderConfig({
                "aws.auth#sigv4": config.credentials,
            }),
        }));
        this.middlewareStack.use(getHttpSigningPlugin(this.config));
    }
    destroy() {
        super.destroy();
    }
}

function addExpectContinueMiddleware(options) {
    return (next) => async (args) => {
        const { request } = args;
        if (HttpRequest.isInstance(request) && request.body && options.runtime === "node") {
            if (options.requestHandler?.constructor?.name !== "FetchHttpHandler") {
                request.headers = {
                    ...request.headers,
                    Expect: "100-continue",
                };
            }
        }
        return next({
            ...args,
            request,
        });
    };
}
const addExpectContinueMiddlewareOptions = {
    step: "build",
    tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
    name: "addExpectContinueMiddleware",
    override: true,
};
const getAddExpectContinuePlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(addExpectContinueMiddleware(options), addExpectContinueMiddlewareOptions);
    },
});

const RequestChecksumCalculation = {
    WHEN_SUPPORTED: "WHEN_SUPPORTED",
    WHEN_REQUIRED: "WHEN_REQUIRED",
};
const DEFAULT_REQUEST_CHECKSUM_CALCULATION = RequestChecksumCalculation.WHEN_SUPPORTED;
const ResponseChecksumValidation = {
    WHEN_SUPPORTED: "WHEN_SUPPORTED",
    WHEN_REQUIRED: "WHEN_REQUIRED",
};
const DEFAULT_RESPONSE_CHECKSUM_VALIDATION = RequestChecksumCalculation.WHEN_SUPPORTED;
var ChecksumAlgorithm;
(function (ChecksumAlgorithm) {
    ChecksumAlgorithm["MD5"] = "MD5";
    ChecksumAlgorithm["CRC32"] = "CRC32";
    ChecksumAlgorithm["CRC32C"] = "CRC32C";
    ChecksumAlgorithm["SHA1"] = "SHA1";
    ChecksumAlgorithm["SHA256"] = "SHA256";
})(ChecksumAlgorithm || (ChecksumAlgorithm = {}));
var ChecksumLocation;
(function (ChecksumLocation) {
    ChecksumLocation["HEADER"] = "header";
    ChecksumLocation["TRAILER"] = "trailer";
})(ChecksumLocation || (ChecksumLocation = {}));
ChecksumAlgorithm.MD5;
ChecksumAlgorithm.CRC32;

var SelectorType;
(function (SelectorType) {
    SelectorType["ENV"] = "env";
    SelectorType["CONFIG"] = "shared config entry";
})(SelectorType || (SelectorType = {}));
const stringUnionSelector = (obj, key, union, type) => {
    if (!(key in obj))
        return undefined;
    const value = obj[key].toUpperCase();
    if (!Object.values(union).includes(value)) {
        throw new TypeError(`Cannot load ${type} '${key}'. Expected one of ${Object.values(union)}, got '${obj[key]}'.`);
    }
    return value;
};

const ENV_REQUEST_CHECKSUM_CALCULATION = "AWS_REQUEST_CHECKSUM_CALCULATION";
const CONFIG_REQUEST_CHECKSUM_CALCULATION = "request_checksum_calculation";
const NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => stringUnionSelector(env, ENV_REQUEST_CHECKSUM_CALCULATION, RequestChecksumCalculation, SelectorType.ENV),
    configFileSelector: (profile) => stringUnionSelector(profile, CONFIG_REQUEST_CHECKSUM_CALCULATION, RequestChecksumCalculation, SelectorType.CONFIG),
    default: DEFAULT_REQUEST_CHECKSUM_CALCULATION,
};

const ENV_RESPONSE_CHECKSUM_VALIDATION = "AWS_RESPONSE_CHECKSUM_VALIDATION";
const CONFIG_RESPONSE_CHECKSUM_VALIDATION = "response_checksum_validation";
const NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => stringUnionSelector(env, ENV_RESPONSE_CHECKSUM_VALIDATION, ResponseChecksumValidation, SelectorType.ENV),
    configFileSelector: (profile) => stringUnionSelector(profile, CONFIG_RESPONSE_CHECKSUM_VALIDATION, ResponseChecksumValidation, SelectorType.CONFIG),
    default: DEFAULT_RESPONSE_CHECKSUM_VALIDATION,
};

[
    ChecksumAlgorithm.CRC32,
    ChecksumAlgorithm.CRC32C,
    ChecksumAlgorithm.SHA1,
    ChecksumAlgorithm.SHA256,
];
[
    ChecksumAlgorithm.SHA256,
    ChecksumAlgorithm.SHA1,
    ChecksumAlgorithm.CRC32,
    ChecksumAlgorithm.CRC32C,
];

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const fromString = (input, encoding) => {
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return require$$0$a.Buffer.from(input, encoding) ;
};

const fromUtf8 = (input) => {
    const buf = fromString(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
// Quick polyfill
typeof Buffer !== "undefined" && Buffer.from
    ? function (input) { return Buffer.from(input, "utf8"); }
    : fromUtf8;

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
// IE 11 does not support Array.from, so we do it manually
function uint32ArrayFrom(a_lookUpTable) {
    if (!Uint32Array.from) {
        var return_array = new Uint32Array(a_lookUpTable.length);
        var a_index = 0;
        while (a_index < a_lookUpTable.length) {
            return_array[a_index] = a_lookUpTable[a_index];
            a_index += 1;
        }
        return return_array;
    }
    return Uint32Array.from(a_lookUpTable);
}

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
// prettier-ignore
var a_lookupTable = [
    0x00000000, 0xF26B8303, 0xE13B70F7, 0x1350F3F4, 0xC79A971F, 0x35F1141C, 0x26A1E7E8, 0xD4CA64EB,
    0x8AD958CF, 0x78B2DBCC, 0x6BE22838, 0x9989AB3B, 0x4D43CFD0, 0xBF284CD3, 0xAC78BF27, 0x5E133C24,
    0x105EC76F, 0xE235446C, 0xF165B798, 0x030E349B, 0xD7C45070, 0x25AFD373, 0x36FF2087, 0xC494A384,
    0x9A879FA0, 0x68EC1CA3, 0x7BBCEF57, 0x89D76C54, 0x5D1D08BF, 0xAF768BBC, 0xBC267848, 0x4E4DFB4B,
    0x20BD8EDE, 0xD2D60DDD, 0xC186FE29, 0x33ED7D2A, 0xE72719C1, 0x154C9AC2, 0x061C6936, 0xF477EA35,
    0xAA64D611, 0x580F5512, 0x4B5FA6E6, 0xB93425E5, 0x6DFE410E, 0x9F95C20D, 0x8CC531F9, 0x7EAEB2FA,
    0x30E349B1, 0xC288CAB2, 0xD1D83946, 0x23B3BA45, 0xF779DEAE, 0x05125DAD, 0x1642AE59, 0xE4292D5A,
    0xBA3A117E, 0x4851927D, 0x5B016189, 0xA96AE28A, 0x7DA08661, 0x8FCB0562, 0x9C9BF696, 0x6EF07595,
    0x417B1DBC, 0xB3109EBF, 0xA0406D4B, 0x522BEE48, 0x86E18AA3, 0x748A09A0, 0x67DAFA54, 0x95B17957,
    0xCBA24573, 0x39C9C670, 0x2A993584, 0xD8F2B687, 0x0C38D26C, 0xFE53516F, 0xED03A29B, 0x1F682198,
    0x5125DAD3, 0xA34E59D0, 0xB01EAA24, 0x42752927, 0x96BF4DCC, 0x64D4CECF, 0x77843D3B, 0x85EFBE38,
    0xDBFC821C, 0x2997011F, 0x3AC7F2EB, 0xC8AC71E8, 0x1C661503, 0xEE0D9600, 0xFD5D65F4, 0x0F36E6F7,
    0x61C69362, 0x93AD1061, 0x80FDE395, 0x72966096, 0xA65C047D, 0x5437877E, 0x4767748A, 0xB50CF789,
    0xEB1FCBAD, 0x197448AE, 0x0A24BB5A, 0xF84F3859, 0x2C855CB2, 0xDEEEDFB1, 0xCDBE2C45, 0x3FD5AF46,
    0x7198540D, 0x83F3D70E, 0x90A324FA, 0x62C8A7F9, 0xB602C312, 0x44694011, 0x5739B3E5, 0xA55230E6,
    0xFB410CC2, 0x092A8FC1, 0x1A7A7C35, 0xE811FF36, 0x3CDB9BDD, 0xCEB018DE, 0xDDE0EB2A, 0x2F8B6829,
    0x82F63B78, 0x709DB87B, 0x63CD4B8F, 0x91A6C88C, 0x456CAC67, 0xB7072F64, 0xA457DC90, 0x563C5F93,
    0x082F63B7, 0xFA44E0B4, 0xE9141340, 0x1B7F9043, 0xCFB5F4A8, 0x3DDE77AB, 0x2E8E845F, 0xDCE5075C,
    0x92A8FC17, 0x60C37F14, 0x73938CE0, 0x81F80FE3, 0x55326B08, 0xA759E80B, 0xB4091BFF, 0x466298FC,
    0x1871A4D8, 0xEA1A27DB, 0xF94AD42F, 0x0B21572C, 0xDFEB33C7, 0x2D80B0C4, 0x3ED04330, 0xCCBBC033,
    0xA24BB5A6, 0x502036A5, 0x4370C551, 0xB11B4652, 0x65D122B9, 0x97BAA1BA, 0x84EA524E, 0x7681D14D,
    0x2892ED69, 0xDAF96E6A, 0xC9A99D9E, 0x3BC21E9D, 0xEF087A76, 0x1D63F975, 0x0E330A81, 0xFC588982,
    0xB21572C9, 0x407EF1CA, 0x532E023E, 0xA145813D, 0x758FE5D6, 0x87E466D5, 0x94B49521, 0x66DF1622,
    0x38CC2A06, 0xCAA7A905, 0xD9F75AF1, 0x2B9CD9F2, 0xFF56BD19, 0x0D3D3E1A, 0x1E6DCDEE, 0xEC064EED,
    0xC38D26C4, 0x31E6A5C7, 0x22B65633, 0xD0DDD530, 0x0417B1DB, 0xF67C32D8, 0xE52CC12C, 0x1747422F,
    0x49547E0B, 0xBB3FFD08, 0xA86F0EFC, 0x5A048DFF, 0x8ECEE914, 0x7CA56A17, 0x6FF599E3, 0x9D9E1AE0,
    0xD3D3E1AB, 0x21B862A8, 0x32E8915C, 0xC083125F, 0x144976B4, 0xE622F5B7, 0xF5720643, 0x07198540,
    0x590AB964, 0xAB613A67, 0xB831C993, 0x4A5A4A90, 0x9E902E7B, 0x6CFBAD78, 0x7FAB5E8C, 0x8DC0DD8F,
    0xE330A81A, 0x115B2B19, 0x020BD8ED, 0xF0605BEE, 0x24AA3F05, 0xD6C1BC06, 0xC5914FF2, 0x37FACCF1,
    0x69E9F0D5, 0x9B8273D6, 0x88D28022, 0x7AB90321, 0xAE7367CA, 0x5C18E4C9, 0x4F48173D, 0xBD23943E,
    0xF36E6F75, 0x0105EC76, 0x12551F82, 0xE03E9C81, 0x34F4F86A, 0xC69F7B69, 0xD5CF889D, 0x27A40B9E,
    0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351,
];
uint32ArrayFrom(a_lookupTable);

var Crc32 = /** @class */ (function () {
    function Crc32() {
        this.checksum = 0xffffffff;
    }
    Crc32.prototype.update = function (data) {
        var e_1, _a;
        try {
            for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                var byte = data_1_1.value;
                this.checksum =
                    (this.checksum >>> 8) ^ lookupTable[(this.checksum ^ byte) & 0xff];
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return this;
    };
    Crc32.prototype.digest = function () {
        return (this.checksum ^ 0xffffffff) >>> 0;
    };
    return Crc32;
}());
// prettier-ignore
var a_lookUpTable = [
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D,
];
var lookupTable = uint32ArrayFrom(a_lookUpTable);

const resolveFlexibleChecksumsConfig = (input) => ({
    ...input,
    requestChecksumCalculation: normalizeProvider$1(input.requestChecksumCalculation ?? DEFAULT_REQUEST_CHECKSUM_CALCULATION),
    responseChecksumValidation: normalizeProvider$1(input.responseChecksumValidation ?? DEFAULT_RESPONSE_CHECKSUM_VALIDATION),
});

const regionRedirectEndpointMiddleware = (config) => {
    return (next, context) => async (args) => {
        const originalRegion = await config.region();
        const regionProviderRef = config.region;
        let unlock = () => { };
        if (context.__s3RegionRedirect) {
            Object.defineProperty(config, "region", {
                writable: false,
                value: async () => {
                    return context.__s3RegionRedirect;
                },
            });
            unlock = () => Object.defineProperty(config, "region", {
                writable: true,
                value: regionProviderRef,
            });
        }
        try {
            const result = await next(args);
            if (context.__s3RegionRedirect) {
                unlock();
                const region = await config.region();
                if (originalRegion !== region) {
                    throw new Error("Region was not restored following S3 region redirect.");
                }
            }
            return result;
        }
        catch (e) {
            unlock();
            throw e;
        }
    };
};
const regionRedirectEndpointMiddlewareOptions = {
    tags: ["REGION_REDIRECT", "S3"],
    name: "regionRedirectEndpointMiddleware",
    override: true,
    relation: "before",
    toMiddleware: "endpointV2Middleware",
};

function regionRedirectMiddleware(clientConfig) {
    return (next, context) => async (args) => {
        try {
            return await next(args);
        }
        catch (err) {
            if (clientConfig.followRegionRedirects) {
                if (err?.$metadata?.httpStatusCode === 301 ||
                    (err?.$metadata?.httpStatusCode === 400 && err?.name === "IllegalLocationConstraintException")) {
                    try {
                        const actualRegion = err.$response.headers["x-amz-bucket-region"];
                        context.logger?.debug(`Redirecting from ${await clientConfig.region()} to ${actualRegion}`);
                        context.__s3RegionRedirect = actualRegion;
                    }
                    catch (e) {
                        throw new Error("Region redirect failed: " + e);
                    }
                    return next(args);
                }
            }
            throw err;
        }
    };
}
const regionRedirectMiddlewareOptions = {
    step: "initialize",
    tags: ["REGION_REDIRECT", "S3"],
    name: "regionRedirectMiddleware",
    override: true,
};
const getRegionRedirectMiddlewarePlugin = (clientConfig) => ({
    applyToStack: (clientStack) => {
        clientStack.add(regionRedirectMiddleware(clientConfig), regionRedirectMiddlewareOptions);
        clientStack.addRelativeTo(regionRedirectEndpointMiddleware(clientConfig), regionRedirectEndpointMiddlewareOptions);
    },
});

class S3ExpressIdentityCache {
    constructor(data = {}) {
        this.data = data;
        this.lastPurgeTime = Date.now();
    }
    get(key) {
        const entry = this.data[key];
        if (!entry) {
            return;
        }
        return entry;
    }
    set(key, entry) {
        this.data[key] = entry;
        return entry;
    }
    delete(key) {
        delete this.data[key];
    }
    async purgeExpired() {
        const now = Date.now();
        if (this.lastPurgeTime + S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > now) {
            return;
        }
        for (const key in this.data) {
            const entry = this.data[key];
            if (!entry.isRefreshing) {
                const credential = await entry.identity;
                if (credential.expiration) {
                    if (credential.expiration.getTime() < now) {
                        delete this.data[key];
                    }
                }
            }
        }
    }
}
S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 30000;

class S3ExpressIdentityCacheEntry {
    constructor(_identity, isRefreshing = false, accessed = Date.now()) {
        this._identity = _identity;
        this.isRefreshing = isRefreshing;
        this.accessed = accessed;
    }
    get identity() {
        this.accessed = Date.now();
        return this._identity;
    }
}

class S3ExpressIdentityProviderImpl {
    constructor(createSessionFn, cache = new S3ExpressIdentityCache()) {
        this.createSessionFn = createSessionFn;
        this.cache = cache;
    }
    async getS3ExpressIdentity(awsIdentity, identityProperties) {
        const key = identityProperties.Bucket;
        const { cache } = this;
        const entry = cache.get(key);
        if (entry) {
            return entry.identity.then((identity) => {
                const isExpired = (identity.expiration?.getTime() ?? 0) < Date.now();
                if (isExpired) {
                    return cache.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
                }
                const isExpiringSoon = (identity.expiration?.getTime() ?? 0) < Date.now() + S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS;
                if (isExpiringSoon && !entry.isRefreshing) {
                    entry.isRefreshing = true;
                    this.getIdentity(key).then((id) => {
                        cache.set(key, new S3ExpressIdentityCacheEntry(Promise.resolve(id)));
                    });
                }
                return identity;
            });
        }
        return cache.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
    }
    async getIdentity(key) {
        await this.cache.purgeExpired().catch((error) => {
            console.warn("Error while clearing expired entries in S3ExpressIdentityCache: \n" + error);
        });
        const session = await this.createSessionFn(key);
        if (!session.Credentials?.AccessKeyId || !session.Credentials?.SecretAccessKey) {
            throw new Error("s3#createSession response credential missing AccessKeyId or SecretAccessKey.");
        }
        const identity = {
            accessKeyId: session.Credentials.AccessKeyId,
            secretAccessKey: session.Credentials.SecretAccessKey,
            sessionToken: session.Credentials.SessionToken,
            expiration: session.Credentials.Expiration ? new Date(session.Credentials.Expiration) : undefined,
        };
        return identity;
    }
}
S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS = 60000;

const S3_EXPRESS_BUCKET_TYPE = "Directory";
const S3_EXPRESS_BACKEND = "S3Express";
const S3_EXPRESS_AUTH_SCHEME = "sigv4-s3express";
const SESSION_TOKEN_QUERY_PARAM = "X-Amz-S3session-Token";
const SESSION_TOKEN_HEADER = SESSION_TOKEN_QUERY_PARAM.toLowerCase();
const NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_ENV_NAME = "AWS_S3_DISABLE_EXPRESS_SESSION_AUTH";
const NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_INI_NAME = "s3_disable_express_session_auth";
const NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS = {
    environmentVariableSelector: (env) => booleanSelector(env, NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_ENV_NAME, SelectorType$1.ENV),
    configFileSelector: (profile) => booleanSelector(profile, NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_INI_NAME, SelectorType$1.CONFIG),
    default: false,
};

class SignatureV4S3Express extends SignatureV4 {
    async signWithCredentials(requestToSign, credentials, options) {
        const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
        requestToSign.headers[SESSION_TOKEN_HEADER] = credentials.sessionToken;
        const privateAccess = this;
        setSingleOverride(privateAccess, credentialsWithoutSessionToken);
        return privateAccess.signRequest(requestToSign, options ?? {});
    }
    async presignWithCredentials(requestToSign, credentials, options) {
        const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
        delete requestToSign.headers[SESSION_TOKEN_HEADER];
        requestToSign.headers[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
        requestToSign.query = requestToSign.query ?? {};
        requestToSign.query[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
        const privateAccess = this;
        setSingleOverride(privateAccess, credentialsWithoutSessionToken);
        return this.presign(requestToSign, options);
    }
}
function getCredentialsWithoutSessionToken(credentials) {
    const credentialsWithoutSessionToken = {
        accessKeyId: credentials.accessKeyId,
        secretAccessKey: credentials.secretAccessKey,
        expiration: credentials.expiration,
    };
    return credentialsWithoutSessionToken;
}
function setSingleOverride(privateAccess, credentialsWithoutSessionToken) {
    const id = setTimeout(() => {
        throw new Error("SignatureV4S3Express credential override was created but not called.");
    }, 10);
    const currentCredentialProvider = privateAccess.credentialProvider;
    const overrideCredentialsProviderOnce = () => {
        clearTimeout(id);
        privateAccess.credentialProvider = currentCredentialProvider;
        return Promise.resolve(credentialsWithoutSessionToken);
    };
    privateAccess.credentialProvider = overrideCredentialsProviderOnce;
}

const s3ExpressMiddleware = (options) => {
    return (next, context) => async (args) => {
        if (context.endpointV2) {
            const endpoint = context.endpointV2;
            const isS3ExpressAuth = endpoint.properties?.authSchemes?.[0]?.name === S3_EXPRESS_AUTH_SCHEME;
            const isS3ExpressBucket = endpoint.properties?.backend === S3_EXPRESS_BACKEND ||
                endpoint.properties?.bucketType === S3_EXPRESS_BUCKET_TYPE;
            if (isS3ExpressBucket) {
                setFeature(context, "S3_EXPRESS_BUCKET", "J");
                context.isS3ExpressBucket = true;
            }
            if (isS3ExpressAuth) {
                const requestBucket = args.input.Bucket;
                if (requestBucket) {
                    const s3ExpressIdentity = await options.s3ExpressIdentityProvider.getS3ExpressIdentity(await options.credentials(), {
                        Bucket: requestBucket,
                    });
                    context.s3ExpressIdentity = s3ExpressIdentity;
                    if (HttpRequest.isInstance(args.request) && s3ExpressIdentity.sessionToken) {
                        args.request.headers[SESSION_TOKEN_HEADER] = s3ExpressIdentity.sessionToken;
                    }
                }
            }
        }
        return next(args);
    };
};
const s3ExpressMiddlewareOptions = {
    name: "s3ExpressMiddleware",
    step: "build",
    tags: ["S3", "S3_EXPRESS"],
    override: true,
};
const getS3ExpressPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(s3ExpressMiddleware(options), s3ExpressMiddlewareOptions);
    },
});

const signS3Express = async (s3ExpressIdentity, signingOptions, request, sigV4MultiRegionSigner) => {
    const signedRequest = await sigV4MultiRegionSigner.signWithCredentials(request, s3ExpressIdentity, {});
    if (signedRequest.headers["X-Amz-Security-Token"] || signedRequest.headers["x-amz-security-token"]) {
        throw new Error("X-Amz-Security-Token must not be set for s3-express requests.");
    }
    return signedRequest;
};

const defaultErrorHandler = (signingProperties) => (error) => {
    throw error;
};
const defaultSuccessHandler = (httpResponse, signingProperties) => { };
const s3ExpressHttpSigningMiddleware = (config) => (next, context) => async (args) => {
    if (!HttpRequest.isInstance(args.request)) {
        return next(args);
    }
    const smithyContext = getSmithyContext(context);
    const scheme = smithyContext.selectedHttpAuthScheme;
    if (!scheme) {
        throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
    }
    const { httpAuthOption: { signingProperties = {} }, identity, signer, } = scheme;
    let request;
    if (context.s3ExpressIdentity) {
        request = await signS3Express(context.s3ExpressIdentity, signingProperties, args.request, await config.signer());
    }
    else {
        request = await signer.sign(args.request, identity, signingProperties);
    }
    const output = await next({
        ...args,
        request,
    }).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));
    (signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);
    return output;
};
const getS3ExpressHttpSigningPlugin = (config) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(s3ExpressHttpSigningMiddleware(config), httpSigningMiddlewareOptions);
    },
});

const resolveS3Config = (input, { session, }) => {
    const [s3ClientProvider, CreateSessionCommandCtor] = session;
    return {
        ...input,
        forcePathStyle: input.forcePathStyle ?? false,
        useAccelerateEndpoint: input.useAccelerateEndpoint ?? false,
        disableMultiregionAccessPoints: input.disableMultiregionAccessPoints ?? false,
        followRegionRedirects: input.followRegionRedirects ?? false,
        s3ExpressIdentityProvider: input.s3ExpressIdentityProvider ??
            new S3ExpressIdentityProviderImpl(async (key) => s3ClientProvider().send(new CreateSessionCommandCtor({
                Bucket: key,
                SessionMode: "ReadWrite",
            }))),
        bucketEndpoint: input.bucketEndpoint ?? false,
    };
};

const THROW_IF_EMPTY_BODY = {
    CopyObjectCommand: true,
    UploadPartCopyCommand: true,
    CompleteMultipartUploadCommand: true,
};
const MAX_BYTES_TO_INSPECT = 3000;
const throw200ExceptionsMiddleware = (config) => (next, context) => async (args) => {
    const result = await next(args);
    const { response } = result;
    if (!HttpResponse.isInstance(response)) {
        return result;
    }
    const { statusCode, body: sourceBody } = response;
    if (statusCode < 200 || statusCode >= 300) {
        return result;
    }
    const isSplittableStream = typeof sourceBody?.stream === "function" ||
        typeof sourceBody?.pipe === "function" ||
        typeof sourceBody?.tee === "function";
    if (!isSplittableStream) {
        return result;
    }
    let bodyCopy = sourceBody;
    let body = sourceBody;
    if (sourceBody && typeof sourceBody === "object" && !(sourceBody instanceof Uint8Array)) {
        [bodyCopy, body] = await splitStream(sourceBody);
    }
    response.body = body;
    const bodyBytes = await collectBody(bodyCopy, {
        streamCollector: async (stream) => {
            return headStream(stream, MAX_BYTES_TO_INSPECT);
        },
    });
    if (typeof bodyCopy?.destroy === "function") {
        bodyCopy.destroy();
    }
    const bodyStringTail = config.utf8Encoder(bodyBytes.subarray(bodyBytes.length - 16));
    if (bodyBytes.length === 0 && THROW_IF_EMPTY_BODY[context.commandName]) {
        const err = new Error("S3 aborted request");
        err.name = "InternalError";
        throw err;
    }
    if (bodyStringTail && bodyStringTail.endsWith("</Error>")) {
        response.statusCode = 400;
    }
    return result;
};
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const throw200ExceptionsMiddlewareOptions = {
    relation: "after",
    toMiddleware: "deserializerMiddleware",
    tags: ["THROW_200_EXCEPTIONS", "S3"],
    name: "throw200ExceptionsMiddleware",
    override: true,
};
const getThrow200ExceptionsPlugin = (config) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(throw200ExceptionsMiddleware(config), throw200ExceptionsMiddlewareOptions);
    },
});

const validate = (str) => typeof str === "string" && str.indexOf("arn:") === 0 && str.split(":").length >= 6;

function bucketEndpointMiddleware(options) {
    return (next, context) => async (args) => {
        if (options.bucketEndpoint) {
            const endpoint = context.endpointV2;
            if (endpoint) {
                const bucket = args.input.Bucket;
                if (typeof bucket === "string") {
                    try {
                        const bucketEndpointUrl = new URL(bucket);
                        context.endpointV2 = {
                            ...endpoint,
                            url: bucketEndpointUrl,
                        };
                    }
                    catch (e) {
                        const warning = `@aws-sdk/middleware-sdk-s3: bucketEndpoint=true was set but Bucket=${bucket} could not be parsed as URL.`;
                        if (context.logger?.constructor?.name === "NoOpLogger") {
                            console.warn(warning);
                        }
                        else {
                            context.logger?.warn?.(warning);
                        }
                        throw e;
                    }
                }
            }
        }
        return next(args);
    };
}
const bucketEndpointMiddlewareOptions = {
    name: "bucketEndpointMiddleware",
    override: true,
    relation: "after",
    toMiddleware: "endpointV2Middleware",
};

function validateBucketNameMiddleware({ bucketEndpoint }) {
    return (next) => async (args) => {
        const { input: { Bucket }, } = args;
        if (!bucketEndpoint && typeof Bucket === "string" && !validate(Bucket) && Bucket.indexOf("/") >= 0) {
            const err = new Error(`Bucket name shouldn't contain '/', received '${Bucket}'`);
            err.name = "InvalidBucketName";
            throw err;
        }
        return next({ ...args });
    };
}
const validateBucketNameMiddlewareOptions = {
    step: "initialize",
    tags: ["VALIDATE_BUCKET_NAME"],
    name: "validateBucketNameMiddleware",
    override: true,
};
const getValidateBucketNamePlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(validateBucketNameMiddleware(options), validateBucketNameMiddlewareOptions);
        clientStack.addRelativeTo(bucketEndpointMiddleware(options), bucketEndpointMiddlewareOptions);
    },
});

const resolveEventStreamSerdeConfig = (input) => ({
    ...input,
    eventStreamMarshaller: input.eventStreamSerdeProvider(input),
});

const signatureV4CrtContainer = {
    CrtSignerV4: null,
};

class SignatureV4MultiRegion {
    constructor(options) {
        this.sigv4Signer = new SignatureV4S3Express(options);
        this.signerOptions = options;
    }
    async sign(requestToSign, options = {}) {
        if (options.signingRegion === "*") {
            if (this.signerOptions.runtime !== "node")
                throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
            return this.getSigv4aSigner().sign(requestToSign, options);
        }
        return this.sigv4Signer.sign(requestToSign, options);
    }
    async signWithCredentials(requestToSign, credentials, options = {}) {
        if (options.signingRegion === "*") {
            if (this.signerOptions.runtime !== "node")
                throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
            return this.getSigv4aSigner().signWithCredentials(requestToSign, credentials, options);
        }
        return this.sigv4Signer.signWithCredentials(requestToSign, credentials, options);
    }
    async presign(originalRequest, options = {}) {
        if (options.signingRegion === "*") {
            if (this.signerOptions.runtime !== "node")
                throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
            return this.getSigv4aSigner().presign(originalRequest, options);
        }
        return this.sigv4Signer.presign(originalRequest, options);
    }
    async presignWithCredentials(originalRequest, credentials, options = {}) {
        if (options.signingRegion === "*") {
            throw new Error("Method presignWithCredentials is not supported for [signingRegion=*].");
        }
        return this.sigv4Signer.presignWithCredentials(originalRequest, credentials, options);
    }
    getSigv4aSigner() {
        if (!this.sigv4aSigner) {
            let CrtSignerV4 = null;
            try {
                CrtSignerV4 = signatureV4CrtContainer.CrtSignerV4;
                if (typeof CrtSignerV4 !== "function")
                    throw new Error();
            }
            catch (e) {
                e.message =
                    `${e.message}\n` +
                        `Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. \n` +
                        `You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] ` +
                        `or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. \n` +
                        "For more information please go to " +
                        "https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt";
                throw e;
            }
            this.sigv4aSigner = new CrtSignerV4({
                ...this.signerOptions,
                signingAlgorithm: 1,
            });
        }
        return this.sigv4aSigner;
    }
}

const ci = "required", cj = "type", ck = "conditions", cl = "fn", cm = "argv", cn = "ref", co = "assign", cp = "url", cq = "properties", cr = "backend", cs = "authSchemes", ct = "disableDoubleEncoding", cu = "signingName", cv = "signingRegion", cw = "headers", cx = "signingRegionSet";
const a$1 = 6, b$1 = false, c$1 = true, d$1 = "isSet", e$1 = "booleanEquals", f$1 = "error", g$1 = "aws.partition", h$1 = "stringEquals", i$1 = "getAttr", j$1 = "name", k$1 = "substring", l$1 = "bucketSuffix", m$1 = "parseURL", n$1 = "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}", o$1 = "endpoint", p$1 = "tree", q$1 = "aws.isVirtualHostableS3Bucket", r$1 = "{url#scheme}://{Bucket}.{url#authority}{url#path}", s$1 = "not", t$1 = "{url#scheme}://{url#authority}{url#path}", u$1 = "hardwareType", v$1 = "regionPrefix", w$1 = "bucketAliasSuffix", x$1 = "outpostId", y = "isValidHostLabel", z = "sigv4a", A = "s3-outposts", B = "s3", C = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}", D = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}", E = "https://{Bucket}.s3.{partitionResult#dnsSuffix}", F = "aws.parseArn", G = "bucketArn", H = "arnType", I = "", J = "s3-object-lambda", K = "accesspoint", L = "accessPointName", M = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}", N = "mrapPartition", O = "outpostType", P = "arnPrefix", Q = "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", R = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", S = "https://s3.{partitionResult#dnsSuffix}", T = { [ci]: false, [cj]: "String" }, U = { [ci]: true, "default": false, [cj]: "Boolean" }, V = { [ci]: false, [cj]: "Boolean" }, W = { [cl]: e$1, [cm]: [{ [cn]: "Accelerate" }, true] }, X = { [cl]: e$1, [cm]: [{ [cn]: "UseFIPS" }, true] }, Y = { [cl]: e$1, [cm]: [{ [cn]: "UseDualStack" }, true] }, Z = { [cl]: d$1, [cm]: [{ [cn]: "Endpoint" }] }, aa = { [cl]: g$1, [cm]: [{ [cn]: "Region" }], [co]: "partitionResult" }, ab = { [cl]: h$1, [cm]: [{ [cl]: i$1, [cm]: [{ [cn]: "partitionResult" }, j$1] }, "aws-cn"] }, ac = { [cl]: d$1, [cm]: [{ [cn]: "Bucket" }] }, ad = { [cn]: "Bucket" }, ae = { [cl]: m$1, [cm]: [{ [cn]: "Endpoint" }], [co]: "url" }, af = { [cl]: e$1, [cm]: [{ [cl]: i$1, [cm]: [{ [cn]: "url" }, "isIp"] }, true] }, ag = { [cn]: "url" }, ah = { [cl]: "uriEncode", [cm]: [ad], [co]: "uri_encoded_bucket" }, ai = { [cr]: "S3Express", [cs]: [{ [ct]: true, [j$1]: "sigv4", [cu]: "s3express", [cv]: "{Region}" }] }, aj = {}, ak = { [cl]: q$1, [cm]: [ad, false] }, al = { [f$1]: "S3Express bucket name is not a valid virtual hostable name.", [cj]: f$1 }, am = { [cr]: "S3Express", [cs]: [{ [ct]: true, [j$1]: "sigv4-s3express", [cu]: "s3express", [cv]: "{Region}" }] }, an = { [cl]: d$1, [cm]: [{ [cn]: "UseS3ExpressControlEndpoint" }] }, ao = { [cl]: e$1, [cm]: [{ [cn]: "UseS3ExpressControlEndpoint" }, true] }, ap = { [cl]: s$1, [cm]: [Z] }, aq = { [f$1]: "Unrecognized S3Express bucket name format.", [cj]: f$1 }, ar = { [cl]: s$1, [cm]: [ac] }, as = { [cn]: u$1 }, at = { [ck]: [ap], [f$1]: "Expected a endpoint to be specified but no endpoint was found", [cj]: f$1 }, au = { [cs]: [{ [ct]: true, [j$1]: z, [cu]: A, [cx]: ["*"] }, { [ct]: true, [j$1]: "sigv4", [cu]: A, [cv]: "{Region}" }] }, av = { [cl]: e$1, [cm]: [{ [cn]: "ForcePathStyle" }, false] }, aw = { [cn]: "ForcePathStyle" }, ax = { [cl]: e$1, [cm]: [{ [cn]: "Accelerate" }, false] }, ay = { [cl]: h$1, [cm]: [{ [cn]: "Region" }, "aws-global"] }, az = { [cs]: [{ [ct]: true, [j$1]: "sigv4", [cu]: B, [cv]: "us-east-1" }] }, aA = { [cl]: s$1, [cm]: [ay] }, aB = { [cl]: e$1, [cm]: [{ [cn]: "UseGlobalEndpoint" }, true] }, aC = { [cp]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cq]: { [cs]: [{ [ct]: true, [j$1]: "sigv4", [cu]: B, [cv]: "{Region}" }] }, [cw]: {} }, aD = { [cs]: [{ [ct]: true, [j$1]: "sigv4", [cu]: B, [cv]: "{Region}" }] }, aE = { [cl]: e$1, [cm]: [{ [cn]: "UseGlobalEndpoint" }, false] }, aF = { [cl]: e$1, [cm]: [{ [cn]: "UseDualStack" }, false] }, aG = { [cp]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [cq]: aD, [cw]: {} }, aH = { [cl]: e$1, [cm]: [{ [cn]: "UseFIPS" }, false] }, aI = { [cp]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [cq]: aD, [cw]: {} }, aJ = { [cp]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cq]: aD, [cw]: {} }, aK = { [cl]: e$1, [cm]: [{ [cl]: i$1, [cm]: [ag, "isIp"] }, false] }, aL = { [cp]: C, [cq]: aD, [cw]: {} }, aM = { [cp]: r$1, [cq]: aD, [cw]: {} }, aN = { [o$1]: aM, [cj]: o$1 }, aO = { [cp]: D, [cq]: aD, [cw]: {} }, aP = { [cp]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [cq]: aD, [cw]: {} }, aQ = { [f$1]: "Invalid region: region was not a valid DNS name.", [cj]: f$1 }, aR = { [cn]: G }, aS = { [cn]: H }, aT = { [cl]: i$1, [cm]: [aR, "service"] }, aU = { [cn]: L }, aV = { [ck]: [Y], [f$1]: "S3 Object Lambda does not support Dual-stack", [cj]: f$1 }, aW = { [ck]: [W], [f$1]: "S3 Object Lambda does not support S3 Accelerate", [cj]: f$1 }, aX = { [ck]: [{ [cl]: d$1, [cm]: [{ [cn]: "DisableAccessPoints" }] }, { [cl]: e$1, [cm]: [{ [cn]: "DisableAccessPoints" }, true] }], [f$1]: "Access points are not supported for this operation", [cj]: f$1 }, aY = { [ck]: [{ [cl]: d$1, [cm]: [{ [cn]: "UseArnRegion" }] }, { [cl]: e$1, [cm]: [{ [cn]: "UseArnRegion" }, false] }, { [cl]: s$1, [cm]: [{ [cl]: h$1, [cm]: [{ [cl]: i$1, [cm]: [aR, "region"] }, "{Region}"] }] }], [f$1]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [cj]: f$1 }, aZ = { [cl]: i$1, [cm]: [{ [cn]: "bucketPartition" }, j$1] }, ba = { [cl]: i$1, [cm]: [aR, "accountId"] }, bb = { [cs]: [{ [ct]: true, [j$1]: "sigv4", [cu]: J, [cv]: "{bucketArn#region}" }] }, bc = { [f$1]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [cj]: f$1 }, bd = { [f$1]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [cj]: f$1 }, be = { [f$1]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [cj]: f$1 }, bf = { [f$1]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [cj]: f$1 }, bg = { [f$1]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [cj]: f$1 }, bh = { [f$1]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [cj]: f$1 }, bi = { [cs]: [{ [ct]: true, [j$1]: "sigv4", [cu]: B, [cv]: "{bucketArn#region}" }] }, bj = { [cs]: [{ [ct]: true, [j$1]: z, [cu]: A, [cx]: ["*"] }, { [ct]: true, [j$1]: "sigv4", [cu]: A, [cv]: "{bucketArn#region}" }] }, bk = { [cl]: F, [cm]: [ad] }, bl = { [cp]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: aD, [cw]: {} }, bm = { [cp]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: aD, [cw]: {} }, bn = { [cp]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: aD, [cw]: {} }, bo = { [cp]: Q, [cq]: aD, [cw]: {} }, bp = { [cp]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: aD, [cw]: {} }, bq = { [cn]: "UseObjectLambdaEndpoint" }, br = { [cs]: [{ [ct]: true, [j$1]: "sigv4", [cu]: J, [cv]: "{Region}" }] }, bs = { [cp]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cq]: aD, [cw]: {} }, bt = { [cp]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [cq]: aD, [cw]: {} }, bu = { [cp]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cq]: aD, [cw]: {} }, bv = { [cp]: t$1, [cq]: aD, [cw]: {} }, bw = { [cp]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [cq]: aD, [cw]: {} }, bx = [{ [cn]: "Region" }], by = [{ [cn]: "Endpoint" }], bz = [ad], bA = [Y], bB = [W], bC = [Z, ae], bD = [{ [cl]: d$1, [cm]: [{ [cn]: "DisableS3ExpressSessionAuth" }] }, { [cl]: e$1, [cm]: [{ [cn]: "DisableS3ExpressSessionAuth" }, true] }], bE = [af], bF = [ah], bG = [ak], bH = [X], bI = [{ [cl]: k$1, [cm]: [ad, 6, 14, true], [co]: "s3expressAvailabilityZoneId" }, { [cl]: k$1, [cm]: [ad, 14, 16, true], [co]: "s3expressAvailabilityZoneDelim" }, { [cl]: h$1, [cm]: [{ [cn]: "s3expressAvailabilityZoneDelim" }, "--"] }], bJ = [{ [ck]: [X], [o$1]: { [cp]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cq]: ai, [cw]: {} }, [cj]: o$1 }, { [o$1]: { [cp]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cq]: ai, [cw]: {} }, [cj]: o$1 }], bK = [{ [cl]: k$1, [cm]: [ad, 6, 15, true], [co]: "s3expressAvailabilityZoneId" }, { [cl]: k$1, [cm]: [ad, 15, 17, true], [co]: "s3expressAvailabilityZoneDelim" }, { [cl]: h$1, [cm]: [{ [cn]: "s3expressAvailabilityZoneDelim" }, "--"] }], bL = [{ [cl]: k$1, [cm]: [ad, 6, 19, true], [co]: "s3expressAvailabilityZoneId" }, { [cl]: k$1, [cm]: [ad, 19, 21, true], [co]: "s3expressAvailabilityZoneDelim" }, { [cl]: h$1, [cm]: [{ [cn]: "s3expressAvailabilityZoneDelim" }, "--"] }], bM = [{ [cl]: k$1, [cm]: [ad, 6, 20, true], [co]: "s3expressAvailabilityZoneId" }, { [cl]: k$1, [cm]: [ad, 20, 22, true], [co]: "s3expressAvailabilityZoneDelim" }, { [cl]: h$1, [cm]: [{ [cn]: "s3expressAvailabilityZoneDelim" }, "--"] }], bN = [{ [cl]: k$1, [cm]: [ad, 6, 26, true], [co]: "s3expressAvailabilityZoneId" }, { [cl]: k$1, [cm]: [ad, 26, 28, true], [co]: "s3expressAvailabilityZoneDelim" }, { [cl]: h$1, [cm]: [{ [cn]: "s3expressAvailabilityZoneDelim" }, "--"] }], bO = [{ [ck]: [X], [o$1]: { [cp]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cq]: am, [cw]: {} }, [cj]: o$1 }, { [o$1]: { [cp]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cq]: am, [cw]: {} }, [cj]: o$1 }], bP = [ac], bQ = [{ [cl]: y, [cm]: [{ [cn]: x$1 }, false] }], bR = [{ [cl]: h$1, [cm]: [{ [cn]: v$1 }, "beta"] }], bS = ["*"], bT = [aa], bU = [{ [cl]: y, [cm]: [{ [cn]: "Region" }, false] }], bV = [{ [cl]: h$1, [cm]: [{ [cn]: "Region" }, "us-east-1"] }], bW = [{ [cl]: h$1, [cm]: [aS, K] }], bX = [{ [cl]: i$1, [cm]: [aR, "resourceId[1]"], [co]: L }, { [cl]: s$1, [cm]: [{ [cl]: h$1, [cm]: [aU, I] }] }], bY = [aR, "resourceId[1]"], bZ = [{ [cl]: s$1, [cm]: [{ [cl]: h$1, [cm]: [{ [cl]: i$1, [cm]: [aR, "region"] }, I] }] }], ca = [{ [cl]: s$1, [cm]: [{ [cl]: d$1, [cm]: [{ [cl]: i$1, [cm]: [aR, "resourceId[2]"] }] }] }], cb = [aR, "resourceId[2]"], cc = [{ [cl]: g$1, [cm]: [{ [cl]: i$1, [cm]: [aR, "region"] }], [co]: "bucketPartition" }], cd = [{ [cl]: h$1, [cm]: [aZ, { [cl]: i$1, [cm]: [{ [cn]: "partitionResult" }, j$1] }] }], ce = [{ [cl]: y, [cm]: [{ [cl]: i$1, [cm]: [aR, "region"] }, true] }], cf = [{ [cl]: y, [cm]: [ba, false] }], cg = [{ [cl]: y, [cm]: [aU, false] }], ch = [{ [cl]: y, [cm]: [{ [cn]: "Region" }, true] }];
const _data$1 = { version: "1.0", parameters: { Bucket: T, Region: T, UseFIPS: U, UseDualStack: U, Endpoint: T, ForcePathStyle: U, Accelerate: U, UseGlobalEndpoint: U, UseObjectLambdaEndpoint: V, Key: T, Prefix: T, CopySource: T, DisableAccessPoints: V, DisableMultiRegionAccessPoints: U, UseArnRegion: V, UseS3ExpressControlEndpoint: V, DisableS3ExpressSessionAuth: V }, rules: [{ [ck]: [{ [cl]: d$1, [cm]: bx }], rules: [{ [ck]: [W, X], error: "Accelerate cannot be used with FIPS", [cj]: f$1 }, { [ck]: [Y, Z], error: "Cannot set dual-stack in combination with a custom endpoint.", [cj]: f$1 }, { [ck]: [Z, X], error: "A custom endpoint cannot be combined with FIPS", [cj]: f$1 }, { [ck]: [Z, W], error: "A custom endpoint cannot be combined with S3 Accelerate", [cj]: f$1 }, { [ck]: [X, aa, ab], error: "Partition does not support FIPS", [cj]: f$1 }, { [ck]: [ac, { [cl]: k$1, [cm]: [ad, 0, a$1, c$1], [co]: l$1 }, { [cl]: h$1, [cm]: [{ [cn]: l$1 }, "--x-s3"] }], rules: [{ [ck]: bA, error: "S3Express does not support Dual-stack.", [cj]: f$1 }, { [ck]: bB, error: "S3Express does not support S3 Accelerate.", [cj]: f$1 }, { [ck]: bC, rules: [{ [ck]: bD, rules: [{ [ck]: bE, rules: [{ [ck]: bF, rules: [{ endpoint: { [cp]: n$1, [cq]: ai, [cw]: aj }, [cj]: o$1 }], [cj]: p$1 }], [cj]: p$1 }, { [ck]: bG, rules: [{ endpoint: { [cp]: r$1, [cq]: ai, [cw]: aj }, [cj]: o$1 }], [cj]: p$1 }, al], [cj]: p$1 }, { [ck]: bE, rules: [{ [ck]: bF, rules: [{ endpoint: { [cp]: n$1, [cq]: am, [cw]: aj }, [cj]: o$1 }], [cj]: p$1 }], [cj]: p$1 }, { [ck]: bG, rules: [{ endpoint: { [cp]: r$1, [cq]: am, [cw]: aj }, [cj]: o$1 }], [cj]: p$1 }, al], [cj]: p$1 }, { [ck]: [an, ao], rules: [{ [ck]: [ah, ap], rules: [{ [ck]: bH, endpoint: { [cp]: "https://s3express-control-fips.{Region}.amazonaws.com/{uri_encoded_bucket}", [cq]: ai, [cw]: aj }, [cj]: o$1 }, { endpoint: { [cp]: "https://s3express-control.{Region}.amazonaws.com/{uri_encoded_bucket}", [cq]: ai, [cw]: aj }, [cj]: o$1 }], [cj]: p$1 }], [cj]: p$1 }, { [ck]: bG, rules: [{ [ck]: bD, rules: [{ [ck]: bI, rules: bJ, [cj]: p$1 }, { [ck]: bK, rules: bJ, [cj]: p$1 }, { [ck]: bL, rules: bJ, [cj]: p$1 }, { [ck]: bM, rules: bJ, [cj]: p$1 }, { [ck]: bN, rules: bJ, [cj]: p$1 }, aq], [cj]: p$1 }, { [ck]: bI, rules: bO, [cj]: p$1 }, { [ck]: bK, rules: bO, [cj]: p$1 }, { [ck]: bL, rules: bO, [cj]: p$1 }, { [ck]: bM, rules: bO, [cj]: p$1 }, { [ck]: bN, rules: bO, [cj]: p$1 }, aq], [cj]: p$1 }, al], [cj]: p$1 }, { [ck]: [ar, an, ao], rules: [{ [ck]: bC, endpoint: { [cp]: t$1, [cq]: ai, [cw]: aj }, [cj]: o$1 }, { [ck]: bH, endpoint: { [cp]: "https://s3express-control-fips.{Region}.amazonaws.com", [cq]: ai, [cw]: aj }, [cj]: o$1 }, { endpoint: { [cp]: "https://s3express-control.{Region}.amazonaws.com", [cq]: ai, [cw]: aj }, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [ac, { [cl]: k$1, [cm]: [ad, 49, 50, c$1], [co]: u$1 }, { [cl]: k$1, [cm]: [ad, 8, 12, c$1], [co]: v$1 }, { [cl]: k$1, [cm]: [ad, 0, 7, c$1], [co]: w$1 }, { [cl]: k$1, [cm]: [ad, 32, 49, c$1], [co]: x$1 }, { [cl]: g$1, [cm]: bx, [co]: "regionPartition" }, { [cl]: h$1, [cm]: [{ [cn]: w$1 }, "--op-s3"] }], rules: [{ [ck]: bQ, rules: [{ [ck]: [{ [cl]: h$1, [cm]: [as, "e"] }], rules: [{ [ck]: bR, rules: [at, { [ck]: bC, endpoint: { [cp]: "https://{Bucket}.ec2.{url#authority}", [cq]: au, [cw]: aj }, [cj]: o$1 }], [cj]: p$1 }, { endpoint: { [cp]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cq]: au, [cw]: aj }, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [{ [cl]: h$1, [cm]: [as, "o"] }], rules: [{ [ck]: bR, rules: [at, { [ck]: bC, endpoint: { [cp]: "https://{Bucket}.op-{outpostId}.{url#authority}", [cq]: au, [cw]: aj }, [cj]: o$1 }], [cj]: p$1 }, { endpoint: { [cp]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cq]: au, [cw]: aj }, [cj]: o$1 }], [cj]: p$1 }, { error: "Unrecognized hardware type: \"Expected hardware type o or e but got {hardwareType}\"", [cj]: f$1 }], [cj]: p$1 }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [cj]: f$1 }], [cj]: p$1 }, { [ck]: bP, rules: [{ [ck]: [Z, { [cl]: s$1, [cm]: [{ [cl]: d$1, [cm]: [{ [cl]: m$1, [cm]: by }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [cj]: f$1 }, { [ck]: [av, ak], rules: [{ [ck]: bT, rules: [{ [ck]: bU, rules: [{ [ck]: [W, ab], error: "S3 Accelerate cannot be used in this region", [cj]: f$1 }, { [ck]: [Y, X, ax, ap, ay], endpoint: { [cp]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o$1 }, { [ck]: [Y, X, ax, ap, aA, aB], rules: [{ endpoint: aC, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [Y, X, ax, ap, aA, aE], endpoint: aC, [cj]: o$1 }, { [ck]: [aF, X, ax, ap, ay], endpoint: { [cp]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o$1 }, { [ck]: [aF, X, ax, ap, aA, aB], rules: [{ endpoint: aG, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [aF, X, ax, ap, aA, aE], endpoint: aG, [cj]: o$1 }, { [ck]: [Y, aH, W, ap, ay], endpoint: { [cp]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o$1 }, { [ck]: [Y, aH, W, ap, aA, aB], rules: [{ endpoint: aI, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [Y, aH, W, ap, aA, aE], endpoint: aI, [cj]: o$1 }, { [ck]: [Y, aH, ax, ap, ay], endpoint: { [cp]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o$1 }, { [ck]: [Y, aH, ax, ap, aA, aB], rules: [{ endpoint: aJ, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [Y, aH, ax, ap, aA, aE], endpoint: aJ, [cj]: o$1 }, { [ck]: [aF, aH, ax, Z, ae, af, ay], endpoint: { [cp]: C, [cq]: az, [cw]: aj }, [cj]: o$1 }, { [ck]: [aF, aH, ax, Z, ae, aK, ay], endpoint: { [cp]: r$1, [cq]: az, [cw]: aj }, [cj]: o$1 }, { [ck]: [aF, aH, ax, Z, ae, af, aA, aB], rules: [{ [ck]: bV, endpoint: aL, [cj]: o$1 }, { endpoint: aL, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [aF, aH, ax, Z, ae, aK, aA, aB], rules: [{ [ck]: bV, endpoint: aM, [cj]: o$1 }, aN], [cj]: p$1 }, { [ck]: [aF, aH, ax, Z, ae, af, aA, aE], endpoint: aL, [cj]: o$1 }, { [ck]: [aF, aH, ax, Z, ae, aK, aA, aE], endpoint: aM, [cj]: o$1 }, { [ck]: [aF, aH, W, ap, ay], endpoint: { [cp]: D, [cq]: az, [cw]: aj }, [cj]: o$1 }, { [ck]: [aF, aH, W, ap, aA, aB], rules: [{ [ck]: bV, endpoint: aO, [cj]: o$1 }, { endpoint: aO, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [aF, aH, W, ap, aA, aE], endpoint: aO, [cj]: o$1 }, { [ck]: [aF, aH, ax, ap, ay], endpoint: { [cp]: E, [cq]: az, [cw]: aj }, [cj]: o$1 }, { [ck]: [aF, aH, ax, ap, aA, aB], rules: [{ [ck]: bV, endpoint: { [cp]: E, [cq]: aD, [cw]: aj }, [cj]: o$1 }, { endpoint: aP, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [aF, aH, ax, ap, aA, aE], endpoint: aP, [cj]: o$1 }], [cj]: p$1 }, aQ], [cj]: p$1 }], [cj]: p$1 }, { [ck]: [Z, ae, { [cl]: h$1, [cm]: [{ [cl]: i$1, [cm]: [ag, "scheme"] }, "http"] }, { [cl]: q$1, [cm]: [ad, c$1] }, av, aH, aF, ax], rules: [{ [ck]: bT, rules: [{ [ck]: bU, rules: [aN], [cj]: p$1 }, aQ], [cj]: p$1 }], [cj]: p$1 }, { [ck]: [av, { [cl]: F, [cm]: bz, [co]: G }], rules: [{ [ck]: [{ [cl]: i$1, [cm]: [aR, "resourceId[0]"], [co]: H }, { [cl]: s$1, [cm]: [{ [cl]: h$1, [cm]: [aS, I] }] }], rules: [{ [ck]: [{ [cl]: h$1, [cm]: [aT, J] }], rules: [{ [ck]: bW, rules: [{ [ck]: bX, rules: [aV, aW, { [ck]: bZ, rules: [aX, { [ck]: ca, rules: [aY, { [ck]: cc, rules: [{ [ck]: bT, rules: [{ [ck]: cd, rules: [{ [ck]: ce, rules: [{ [ck]: [{ [cl]: h$1, [cm]: [ba, I] }], error: "Invalid ARN: Missing account id", [cj]: f$1 }, { [ck]: cf, rules: [{ [ck]: cg, rules: [{ [ck]: bC, endpoint: { [cp]: M, [cq]: bb, [cw]: aj }, [cj]: o$1 }, { [ck]: bH, endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bb, [cw]: aj }, [cj]: o$1 }, { endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bb, [cw]: aj }, [cj]: o$1 }], [cj]: p$1 }, bc], [cj]: p$1 }, bd], [cj]: p$1 }, be], [cj]: p$1 }, bf], [cj]: p$1 }], [cj]: p$1 }], [cj]: p$1 }, bg], [cj]: p$1 }, { error: "Invalid ARN: bucket ARN is missing a region", [cj]: f$1 }], [cj]: p$1 }, bh], [cj]: p$1 }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [cj]: f$1 }], [cj]: p$1 }, { [ck]: bW, rules: [{ [ck]: bX, rules: [{ [ck]: bZ, rules: [{ [ck]: bW, rules: [{ [ck]: bZ, rules: [aX, { [ck]: ca, rules: [aY, { [ck]: cc, rules: [{ [ck]: bT, rules: [{ [ck]: [{ [cl]: h$1, [cm]: [aZ, "{partitionResult#name}"] }], rules: [{ [ck]: ce, rules: [{ [ck]: [{ [cl]: h$1, [cm]: [aT, B] }], rules: [{ [ck]: cf, rules: [{ [ck]: cg, rules: [{ [ck]: bB, error: "Access Points do not support S3 Accelerate", [cj]: f$1 }, { [ck]: [X, Y], endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bi, [cw]: aj }, [cj]: o$1 }, { [ck]: [X, aF], endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bi, [cw]: aj }, [cj]: o$1 }, { [ck]: [aH, Y], endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bi, [cw]: aj }, [cj]: o$1 }, { [ck]: [aH, aF, Z, ae], endpoint: { [cp]: M, [cq]: bi, [cw]: aj }, [cj]: o$1 }, { [ck]: [aH, aF], endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bi, [cw]: aj }, [cj]: o$1 }], [cj]: p$1 }, bc], [cj]: p$1 }, bd], [cj]: p$1 }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [cj]: f$1 }], [cj]: p$1 }, be], [cj]: p$1 }, bf], [cj]: p$1 }], [cj]: p$1 }], [cj]: p$1 }, bg], [cj]: p$1 }], [cj]: p$1 }], [cj]: p$1 }, { [ck]: [{ [cl]: y, [cm]: [aU, c$1] }], rules: [{ [ck]: bA, error: "S3 MRAP does not support dual-stack", [cj]: f$1 }, { [ck]: bH, error: "S3 MRAP does not support FIPS", [cj]: f$1 }, { [ck]: bB, error: "S3 MRAP does not support S3 Accelerate", [cj]: f$1 }, { [ck]: [{ [cl]: e$1, [cm]: [{ [cn]: "DisableMultiRegionAccessPoints" }, c$1] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [cj]: f$1 }, { [ck]: [{ [cl]: g$1, [cm]: bx, [co]: N }], rules: [{ [ck]: [{ [cl]: h$1, [cm]: [{ [cl]: i$1, [cm]: [{ [cn]: N }, j$1] }, { [cl]: i$1, [cm]: [aR, "partition"] }] }], rules: [{ endpoint: { [cp]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [cq]: { [cs]: [{ [ct]: c$1, name: z, [cu]: B, [cx]: bS }] }, [cw]: aj }, [cj]: o$1 }], [cj]: p$1 }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [cj]: f$1 }], [cj]: p$1 }], [cj]: p$1 }, { error: "Invalid Access Point Name", [cj]: f$1 }], [cj]: p$1 }, bh], [cj]: p$1 }, { [ck]: [{ [cl]: h$1, [cm]: [aT, A] }], rules: [{ [ck]: bA, error: "S3 Outposts does not support Dual-stack", [cj]: f$1 }, { [ck]: bH, error: "S3 Outposts does not support FIPS", [cj]: f$1 }, { [ck]: bB, error: "S3 Outposts does not support S3 Accelerate", [cj]: f$1 }, { [ck]: [{ [cl]: d$1, [cm]: [{ [cl]: i$1, [cm]: [aR, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [cj]: f$1 }, { [ck]: [{ [cl]: i$1, [cm]: bY, [co]: x$1 }], rules: [{ [ck]: bQ, rules: [aY, { [ck]: cc, rules: [{ [ck]: bT, rules: [{ [ck]: cd, rules: [{ [ck]: ce, rules: [{ [ck]: cf, rules: [{ [ck]: [{ [cl]: i$1, [cm]: cb, [co]: O }], rules: [{ [ck]: [{ [cl]: i$1, [cm]: [aR, "resourceId[3]"], [co]: L }], rules: [{ [ck]: [{ [cl]: h$1, [cm]: [{ [cn]: O }, K] }], rules: [{ [ck]: bC, endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [cq]: bj, [cw]: aj }, [cj]: o$1 }, { endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bj, [cw]: aj }, [cj]: o$1 }], [cj]: p$1 }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [cj]: f$1 }], [cj]: p$1 }, { error: "Invalid ARN: expected an access point name", [cj]: f$1 }], [cj]: p$1 }, { error: "Invalid ARN: Expected a 4-component resource", [cj]: f$1 }], [cj]: p$1 }, bd], [cj]: p$1 }, be], [cj]: p$1 }, bf], [cj]: p$1 }], [cj]: p$1 }], [cj]: p$1 }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [cj]: f$1 }], [cj]: p$1 }, { error: "Invalid ARN: The Outpost Id was not set", [cj]: f$1 }], [cj]: p$1 }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [cj]: f$1 }], [cj]: p$1 }, { error: "Invalid ARN: No ARN type specified", [cj]: f$1 }], [cj]: p$1 }, { [ck]: [{ [cl]: k$1, [cm]: [ad, 0, 4, b$1], [co]: P }, { [cl]: h$1, [cm]: [{ [cn]: P }, "arn:"] }, { [cl]: s$1, [cm]: [{ [cl]: d$1, [cm]: [bk] }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [cj]: f$1 }, { [ck]: [{ [cl]: e$1, [cm]: [aw, c$1] }, bk], error: "Path-style addressing cannot be used with ARN buckets", [cj]: f$1 }, { [ck]: bF, rules: [{ [ck]: bT, rules: [{ [ck]: [ax], rules: [{ [ck]: [Y, ap, X, ay], endpoint: { [cp]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: az, [cw]: aj }, [cj]: o$1 }, { [ck]: [Y, ap, X, aA, aB], rules: [{ endpoint: bl, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [Y, ap, X, aA, aE], endpoint: bl, [cj]: o$1 }, { [ck]: [aF, ap, X, ay], endpoint: { [cp]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: az, [cw]: aj }, [cj]: o$1 }, { [ck]: [aF, ap, X, aA, aB], rules: [{ endpoint: bm, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [aF, ap, X, aA, aE], endpoint: bm, [cj]: o$1 }, { [ck]: [Y, ap, aH, ay], endpoint: { [cp]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: az, [cw]: aj }, [cj]: o$1 }, { [ck]: [Y, ap, aH, aA, aB], rules: [{ endpoint: bn, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [Y, ap, aH, aA, aE], endpoint: bn, [cj]: o$1 }, { [ck]: [aF, Z, ae, aH, ay], endpoint: { [cp]: Q, [cq]: az, [cw]: aj }, [cj]: o$1 }, { [ck]: [aF, Z, ae, aH, aA, aB], rules: [{ [ck]: bV, endpoint: bo, [cj]: o$1 }, { endpoint: bo, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [aF, Z, ae, aH, aA, aE], endpoint: bo, [cj]: o$1 }, { [ck]: [aF, ap, aH, ay], endpoint: { [cp]: R, [cq]: az, [cw]: aj }, [cj]: o$1 }, { [ck]: [aF, ap, aH, aA, aB], rules: [{ [ck]: bV, endpoint: { [cp]: R, [cq]: aD, [cw]: aj }, [cj]: o$1 }, { endpoint: bp, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [aF, ap, aH, aA, aE], endpoint: bp, [cj]: o$1 }], [cj]: p$1 }, { error: "Path-style addressing cannot be used with S3 Accelerate", [cj]: f$1 }], [cj]: p$1 }], [cj]: p$1 }], [cj]: p$1 }, { [ck]: [{ [cl]: d$1, [cm]: [bq] }, { [cl]: e$1, [cm]: [bq, c$1] }], rules: [{ [ck]: bT, rules: [{ [ck]: ch, rules: [aV, aW, { [ck]: bC, endpoint: { [cp]: t$1, [cq]: br, [cw]: aj }, [cj]: o$1 }, { [ck]: bH, endpoint: { [cp]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [cq]: br, [cw]: aj }, [cj]: o$1 }, { endpoint: { [cp]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [cq]: br, [cw]: aj }, [cj]: o$1 }], [cj]: p$1 }, aQ], [cj]: p$1 }], [cj]: p$1 }, { [ck]: [ar], rules: [{ [ck]: bT, rules: [{ [ck]: ch, rules: [{ [ck]: [X, Y, ap, ay], endpoint: { [cp]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o$1 }, { [ck]: [X, Y, ap, aA, aB], rules: [{ endpoint: bs, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [X, Y, ap, aA, aE], endpoint: bs, [cj]: o$1 }, { [ck]: [X, aF, ap, ay], endpoint: { [cp]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o$1 }, { [ck]: [X, aF, ap, aA, aB], rules: [{ endpoint: bt, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [X, aF, ap, aA, aE], endpoint: bt, [cj]: o$1 }, { [ck]: [aH, Y, ap, ay], endpoint: { [cp]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o$1 }, { [ck]: [aH, Y, ap, aA, aB], rules: [{ endpoint: bu, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [aH, Y, ap, aA, aE], endpoint: bu, [cj]: o$1 }, { [ck]: [aH, aF, Z, ae, ay], endpoint: { [cp]: t$1, [cq]: az, [cw]: aj }, [cj]: o$1 }, { [ck]: [aH, aF, Z, ae, aA, aB], rules: [{ [ck]: bV, endpoint: bv, [cj]: o$1 }, { endpoint: bv, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [aH, aF, Z, ae, aA, aE], endpoint: bv, [cj]: o$1 }, { [ck]: [aH, aF, ap, ay], endpoint: { [cp]: S, [cq]: az, [cw]: aj }, [cj]: o$1 }, { [ck]: [aH, aF, ap, aA, aB], rules: [{ [ck]: bV, endpoint: { [cp]: S, [cq]: aD, [cw]: aj }, [cj]: o$1 }, { endpoint: bw, [cj]: o$1 }], [cj]: p$1 }, { [ck]: [aH, aF, ap, aA, aE], endpoint: bw, [cj]: o$1 }], [cj]: p$1 }, aQ], [cj]: p$1 }], [cj]: p$1 }], [cj]: p$1 }, { error: "A region must be set when sending requests to S3.", [cj]: f$1 }] };
const ruleSet$1 = _data$1;

const cache$1 = new EndpointCache({
    size: 50,
    params: [
        "Accelerate",
        "Bucket",
        "DisableAccessPoints",
        "DisableMultiRegionAccessPoints",
        "DisableS3ExpressSessionAuth",
        "Endpoint",
        "ForcePathStyle",
        "Region",
        "UseArnRegion",
        "UseDualStack",
        "UseFIPS",
        "UseGlobalEndpoint",
        "UseObjectLambdaEndpoint",
        "UseS3ExpressControlEndpoint",
    ],
});
const defaultEndpointResolver$1 = (endpointParams, context = {}) => {
    return cache$1.get(endpointParams, () => resolveEndpoint(ruleSet$1, {
        endpointParams: endpointParams,
        logger: context.logger,
    }));
};
customEndpointFunctions.aws = awsEndpointFunctions;

const createEndpointRuleSetHttpAuthSchemeParametersProvider = (defaultHttpAuthSchemeParametersProvider) => async (config, context, input) => {
    if (!input) {
        throw new Error(`Could not find \`input\` for \`defaultEndpointRuleSetHttpAuthSchemeParametersProvider\``);
    }
    const defaultParameters = await defaultHttpAuthSchemeParametersProvider(config, context, input);
    const instructionsFn = getSmithyContext(context)?.commandInstance?.constructor
        ?.getEndpointParameterInstructions;
    if (!instructionsFn) {
        throw new Error(`getEndpointParameterInstructions() is not defined on \`${context.commandName}\``);
    }
    const endpointParameters = await resolveParams(input, { getEndpointParameterInstructions: instructionsFn }, config);
    return Object.assign(defaultParameters, endpointParameters);
};
const _defaultS3HttpAuthSchemeParametersProvider = async (config, context, input) => {
    return {
        operation: getSmithyContext(context).operation,
        region: (await normalizeProvider$1(config.region)()) ||
            (() => {
                throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
            })(),
    };
};
const defaultS3HttpAuthSchemeParametersProvider = createEndpointRuleSetHttpAuthSchemeParametersProvider(_defaultS3HttpAuthSchemeParametersProvider);
function createAwsAuthSigv4HttpAuthOption$1(authParameters) {
    return {
        schemeId: "aws.auth#sigv4",
        signingProperties: {
            name: "s3",
            region: authParameters.region,
        },
        propertiesExtractor: (config, context) => ({
            signingProperties: {
                config,
                context,
            },
        }),
    };
}
function createAwsAuthSigv4aHttpAuthOption(authParameters) {
    return {
        schemeId: "aws.auth#sigv4a",
        signingProperties: {
            name: "s3",
            region: authParameters.region,
        },
        propertiesExtractor: (config, context) => ({
            signingProperties: {
                config,
                context,
            },
        }),
    };
}
const createEndpointRuleSetHttpAuthSchemeProvider = (defaultEndpointResolver, defaultHttpAuthSchemeResolver, createHttpAuthOptionFunctions) => {
    const endpointRuleSetHttpAuthSchemeProvider = (authParameters) => {
        const endpoint = defaultEndpointResolver(authParameters);
        const authSchemes = endpoint.properties?.authSchemes;
        if (!authSchemes) {
            return defaultHttpAuthSchemeResolver(authParameters);
        }
        const options = [];
        for (const scheme of authSchemes) {
            const { name: resolvedName, properties = {}, ...rest } = scheme;
            const name = resolvedName.toLowerCase();
            if (resolvedName !== name) {
                console.warn(`HttpAuthScheme has been normalized with lowercasing: \`${resolvedName}\` to \`${name}\``);
            }
            let schemeId;
            if (name === "sigv4a") {
                schemeId = "aws.auth#sigv4a";
                const sigv4Present = authSchemes.find((s) => {
                    const name = s.name.toLowerCase();
                    return name !== "sigv4a" && name.startsWith("sigv4");
                });
                if (sigv4Present) {
                    continue;
                }
            }
            else if (name.startsWith("sigv4")) {
                schemeId = "aws.auth#sigv4";
            }
            else {
                throw new Error(`Unknown HttpAuthScheme found in \`@smithy.rules#endpointRuleSet\`: \`${name}\``);
            }
            const createOption = createHttpAuthOptionFunctions[schemeId];
            if (!createOption) {
                throw new Error(`Could not find HttpAuthOption create function for \`${schemeId}\``);
            }
            const option = createOption(authParameters);
            option.schemeId = schemeId;
            option.signingProperties = { ...(option.signingProperties || {}), ...rest, ...properties };
            options.push(option);
        }
        return options;
    };
    return endpointRuleSetHttpAuthSchemeProvider;
};
const _defaultS3HttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
        default: {
            options.push(createAwsAuthSigv4HttpAuthOption$1(authParameters));
            options.push(createAwsAuthSigv4aHttpAuthOption(authParameters));
        }
    }
    return options;
};
const defaultS3HttpAuthSchemeProvider = createEndpointRuleSetHttpAuthSchemeProvider(defaultEndpointResolver$1, _defaultS3HttpAuthSchemeProvider, {
    "aws.auth#sigv4": createAwsAuthSigv4HttpAuthOption$1,
    "aws.auth#sigv4a": createAwsAuthSigv4aHttpAuthOption,
});
const resolveHttpAuthSchemeConfig$1 = (config) => {
    const config_0 = resolveAwsSdkSigV4Config(config);
    const config_1 = resolveAwsSdkSigV4AConfig(config_0);
    return {
        ...config_1,
    };
};

const resolveClientEndpointParameters$1 = (options) => {
    return {
        ...options,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        forcePathStyle: options.forcePathStyle ?? false,
        useAccelerateEndpoint: options.useAccelerateEndpoint ?? false,
        useGlobalEndpoint: options.useGlobalEndpoint ?? false,
        disableMultiregionAccessPoints: options.disableMultiregionAccessPoints ?? false,
        defaultSigningName: "s3",
    };
};
const commonParams = {
    ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
    UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
    DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
    Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
    DisableS3ExpressSessionAuth: { type: "clientContextParams", name: "disableS3ExpressSessionAuth" },
    UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
};

class S3ServiceException extends ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, S3ServiceException.prototype);
    }
}

class NoSuchUpload extends S3ServiceException {
    constructor(opts) {
        super({
            name: "NoSuchUpload",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchUpload";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchUpload.prototype);
    }
}
class ObjectNotInActiveTierError extends S3ServiceException {
    constructor(opts) {
        super({
            name: "ObjectNotInActiveTierError",
            $fault: "client",
            ...opts,
        });
        this.name = "ObjectNotInActiveTierError";
        this.$fault = "client";
        Object.setPrototypeOf(this, ObjectNotInActiveTierError.prototype);
    }
}
class BucketAlreadyExists extends S3ServiceException {
    constructor(opts) {
        super({
            name: "BucketAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "BucketAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, BucketAlreadyExists.prototype);
    }
}
class BucketAlreadyOwnedByYou extends S3ServiceException {
    constructor(opts) {
        super({
            name: "BucketAlreadyOwnedByYou",
            $fault: "client",
            ...opts,
        });
        this.name = "BucketAlreadyOwnedByYou";
        this.$fault = "client";
        Object.setPrototypeOf(this, BucketAlreadyOwnedByYou.prototype);
    }
}
class NoSuchBucket extends S3ServiceException {
    constructor(opts) {
        super({
            name: "NoSuchBucket",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchBucket";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchBucket.prototype);
    }
}
var AnalyticsFilter;
(function (AnalyticsFilter) {
    AnalyticsFilter.visit = (value, visitor) => {
        if (value.Prefix !== undefined)
            return visitor.Prefix(value.Prefix);
        if (value.Tag !== undefined)
            return visitor.Tag(value.Tag);
        if (value.And !== undefined)
            return visitor.And(value.And);
        return visitor._(value.$unknown[0], value.$unknown[1]);
    };
})(AnalyticsFilter || (AnalyticsFilter = {}));
var MetricsFilter;
(function (MetricsFilter) {
    MetricsFilter.visit = (value, visitor) => {
        if (value.Prefix !== undefined)
            return visitor.Prefix(value.Prefix);
        if (value.Tag !== undefined)
            return visitor.Tag(value.Tag);
        if (value.AccessPointArn !== undefined)
            return visitor.AccessPointArn(value.AccessPointArn);
        if (value.And !== undefined)
            return visitor.And(value.And);
        return visitor._(value.$unknown[0], value.$unknown[1]);
    };
})(MetricsFilter || (MetricsFilter = {}));
class InvalidObjectState extends S3ServiceException {
    constructor(opts) {
        super({
            name: "InvalidObjectState",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidObjectState";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidObjectState.prototype);
        this.StorageClass = opts.StorageClass;
        this.AccessTier = opts.AccessTier;
    }
}
class NoSuchKey extends S3ServiceException {
    constructor(opts) {
        super({
            name: "NoSuchKey",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchKey";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchKey.prototype);
    }
}
class NotFound extends S3ServiceException {
    constructor(opts) {
        super({
            name: "NotFound",
            $fault: "client",
            ...opts,
        });
        this.name = "NotFound";
        this.$fault = "client";
        Object.setPrototypeOf(this, NotFound.prototype);
    }
}
const SessionCredentialsFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SecretAccessKey && { SecretAccessKey: SENSITIVE_STRING }),
    ...(obj.SessionToken && { SessionToken: SENSITIVE_STRING }),
});
const CreateSessionOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING }),
    ...(obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }),
    ...(obj.Credentials && { Credentials: SessionCredentialsFilterSensitiveLog(obj.Credentials) }),
});
const CreateSessionRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING }),
    ...(obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }),
});

class EncryptionTypeMismatch extends S3ServiceException {
    constructor(opts) {
        super({
            name: "EncryptionTypeMismatch",
            $fault: "client",
            ...opts,
        });
        this.name = "EncryptionTypeMismatch";
        this.$fault = "client";
        Object.setPrototypeOf(this, EncryptionTypeMismatch.prototype);
    }
}
class InvalidRequest extends S3ServiceException {
    constructor(opts) {
        super({
            name: "InvalidRequest",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRequest";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRequest.prototype);
    }
}
class InvalidWriteOffset extends S3ServiceException {
    constructor(opts) {
        super({
            name: "InvalidWriteOffset",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidWriteOffset";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidWriteOffset.prototype);
    }
}
class TooManyParts extends S3ServiceException {
    constructor(opts) {
        super({
            name: "TooManyParts",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyParts";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyParts.prototype);
    }
}
class ObjectAlreadyInActiveTierError extends S3ServiceException {
    constructor(opts) {
        super({
            name: "ObjectAlreadyInActiveTierError",
            $fault: "client",
            ...opts,
        });
        this.name = "ObjectAlreadyInActiveTierError";
        this.$fault = "client";
        Object.setPrototypeOf(this, ObjectAlreadyInActiveTierError.prototype);
    }
}
var SelectObjectContentEventStream;
(function (SelectObjectContentEventStream) {
    SelectObjectContentEventStream.visit = (value, visitor) => {
        if (value.Records !== undefined)
            return visitor.Records(value.Records);
        if (value.Stats !== undefined)
            return visitor.Stats(value.Stats);
        if (value.Progress !== undefined)
            return visitor.Progress(value.Progress);
        if (value.Cont !== undefined)
            return visitor.Cont(value.Cont);
        if (value.End !== undefined)
            return visitor.End(value.End);
        return visitor._(value.$unknown[0], value.$unknown[1]);
    };
})(SelectObjectContentEventStream || (SelectObjectContentEventStream = {}));

const se_CreateSessionCommand = async (input, context) => {
    const b = requestBuilder(input, context);
    const headers = map$1({}, isSerializableHeaderValue, {
        [_xacsm]: input[_SM],
        [_xasse]: input[_SSE],
        [_xasseakki]: input[_SSEKMSKI],
        [_xassec]: input[_SSEKMSEC],
        [_xassebke]: [() => isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = map$1({
        [_s]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
const de_CreateSessionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map$1({
        $metadata: deserializeMetadata(output),
        [_SSE]: [, output.headers[_xasse]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_SSEKMSEC]: [, output.headers[_xassec]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
    });
    const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
    if (data[_C] != null) {
        contents[_C] = de_SessionCredentials(data[_C]);
    }
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseXmlErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchUpload":
        case "com.amazonaws.s3#NoSuchUpload":
            throw await de_NoSuchUploadRes(parsedOutput);
        case "ObjectNotInActiveTierError":
        case "com.amazonaws.s3#ObjectNotInActiveTierError":
            throw await de_ObjectNotInActiveTierErrorRes(parsedOutput);
        case "BucketAlreadyExists":
        case "com.amazonaws.s3#BucketAlreadyExists":
            throw await de_BucketAlreadyExistsRes(parsedOutput);
        case "BucketAlreadyOwnedByYou":
        case "com.amazonaws.s3#BucketAlreadyOwnedByYou":
            throw await de_BucketAlreadyOwnedByYouRes(parsedOutput);
        case "NoSuchBucket":
        case "com.amazonaws.s3#NoSuchBucket":
            throw await de_NoSuchBucketRes(parsedOutput);
        case "InvalidObjectState":
        case "com.amazonaws.s3#InvalidObjectState":
            throw await de_InvalidObjectStateRes(parsedOutput);
        case "NoSuchKey":
        case "com.amazonaws.s3#NoSuchKey":
            throw await de_NoSuchKeyRes(parsedOutput);
        case "NotFound":
        case "com.amazonaws.s3#NotFound":
            throw await de_NotFoundRes(parsedOutput);
        case "EncryptionTypeMismatch":
        case "com.amazonaws.s3#EncryptionTypeMismatch":
            throw await de_EncryptionTypeMismatchRes(parsedOutput);
        case "InvalidRequest":
        case "com.amazonaws.s3#InvalidRequest":
            throw await de_InvalidRequestRes(parsedOutput);
        case "InvalidWriteOffset":
        case "com.amazonaws.s3#InvalidWriteOffset":
            throw await de_InvalidWriteOffsetRes(parsedOutput);
        case "TooManyParts":
        case "com.amazonaws.s3#TooManyParts":
            throw await de_TooManyPartsRes(parsedOutput);
        case "ObjectAlreadyInActiveTierError":
        case "com.amazonaws.s3#ObjectAlreadyInActiveTierError":
            throw await de_ObjectAlreadyInActiveTierErrorRes(parsedOutput);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(S3ServiceException);
const de_BucketAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = map$1({});
    parsedOutput.body;
    const exception = new BucketAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_BucketAlreadyOwnedByYouRes = async (parsedOutput, context) => {
    const contents = map$1({});
    parsedOutput.body;
    const exception = new BucketAlreadyOwnedByYou({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_EncryptionTypeMismatchRes = async (parsedOutput, context) => {
    const contents = map$1({});
    parsedOutput.body;
    const exception = new EncryptionTypeMismatch({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidObjectStateRes = async (parsedOutput, context) => {
    const contents = map$1({});
    const data = parsedOutput.body;
    if (data[_AT] != null) {
        contents[_AT] = expectString(data[_AT]);
    }
    if (data[_SC] != null) {
        contents[_SC] = expectString(data[_SC]);
    }
    const exception = new InvalidObjectState({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidRequestRes = async (parsedOutput, context) => {
    const contents = map$1({});
    parsedOutput.body;
    const exception = new InvalidRequest({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidWriteOffsetRes = async (parsedOutput, context) => {
    const contents = map$1({});
    parsedOutput.body;
    const exception = new InvalidWriteOffset({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_NoSuchBucketRes = async (parsedOutput, context) => {
    const contents = map$1({});
    parsedOutput.body;
    const exception = new NoSuchBucket({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_NoSuchKeyRes = async (parsedOutput, context) => {
    const contents = map$1({});
    parsedOutput.body;
    const exception = new NoSuchKey({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_NoSuchUploadRes = async (parsedOutput, context) => {
    const contents = map$1({});
    parsedOutput.body;
    const exception = new NoSuchUpload({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_NotFoundRes = async (parsedOutput, context) => {
    const contents = map$1({});
    parsedOutput.body;
    const exception = new NotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_ObjectAlreadyInActiveTierErrorRes = async (parsedOutput, context) => {
    const contents = map$1({});
    parsedOutput.body;
    const exception = new ObjectAlreadyInActiveTierError({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_ObjectNotInActiveTierErrorRes = async (parsedOutput, context) => {
    const contents = map$1({});
    parsedOutput.body;
    const exception = new ObjectNotInActiveTierError({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_TooManyPartsRes = async (parsedOutput, context) => {
    const contents = map$1({});
    parsedOutput.body;
    const exception = new TooManyParts({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return decorateServiceException(exception, parsedOutput.body);
};
const de_SessionCredentials = (output, context) => {
    const contents = {};
    if (output[_AKI] != null) {
        contents[_AKI] = expectString(output[_AKI]);
    }
    if (output[_SAK] != null) {
        contents[_SAK] = expectString(output[_SAK]);
    }
    if (output[_ST] != null) {
        contents[_ST] = expectString(output[_ST]);
    }
    if (output[_Exp] != null) {
        contents[_Exp] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_Exp]));
    }
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const _AKI = "AccessKeyId";
const _AT = "AccessTier";
const _BKE = "BucketKeyEnabled";
const _C = "Credentials";
const _Exp = "Expiration";
const _SAK = "SecretAccessKey";
const _SC = "StorageClass";
const _SM = "SessionMode";
const _SSE = "ServerSideEncryption";
const _SSEKMSEC = "SSEKMSEncryptionContext";
const _SSEKMSKI = "SSEKMSKeyId";
const _ST = "SessionToken";
const _s = "session";
const _xacsm = "x-amz-create-session-mode";
const _xasse = "x-amz-server-side-encryption";
const _xasseakki = "x-amz-server-side-encryption-aws-kms-key-id";
const _xassebke = "x-amz-server-side-encryption-bucket-key-enabled";
const _xassec = "x-amz-server-side-encryption-context";

class CreateSessionCommand extends Command
    .classBuilder()
    .ep({
    ...commonParams,
    DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config),
    ];
})
    .s("AmazonS3", "CreateSession", {})
    .n("S3Client", "CreateSessionCommand")
    .f(CreateSessionRequestFilterSensitiveLog, CreateSessionOutputFilterSensitiveLog)
    .ser(se_CreateSessionCommand)
    .de(de_CreateSessionCommand)
    .build() {
}

var name$2 = "@aws-sdk/client-s3";
var description$2 = "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native";
var version$2 = "3.712.0";
var scripts$2 = {
	build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
	"build:cjs": "node ../../scripts/compilation/inline client-s3",
	"build:es": "tsc -p tsconfig.es.json",
	"build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
	"build:types": "tsc -p tsconfig.types.json",
	"build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
	clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
	"extract:docs": "api-extractor run --local",
	"generate:client": "node ../../scripts/generate-clients/single-service --solo s3",
	test: "yarn g:vitest run",
	"test:browser": "node ./test/browser-build/esbuild && vitest run -c vitest.config.browser.ts --mode development",
	"test:browser:watch": "node ./test/browser-build/esbuild && yarn g:vitest watch -c vitest.config.browser.ts",
	"test:e2e": "yarn g:vitest run -c vitest.config.e2e.ts --mode development && yarn test:browser",
	"test:e2e:watch": "yarn g:vitest watch -c vitest.config.e2e.ts",
	"test:watch": "yarn g:vitest watch"
};
var main$2 = "./dist-cjs/index.js";
var types$2 = "./dist-types/index.d.ts";
var module$2 = "./dist-es/index.js";
var sideEffects$1 = false;
var dependencies$2 = {
	"@aws-crypto/sha1-browser": "5.2.0",
	"@aws-crypto/sha256-browser": "5.2.0",
	"@aws-crypto/sha256-js": "5.2.0",
	"@aws-sdk/client-sso-oidc": "3.712.0",
	"@aws-sdk/client-sts": "3.712.0",
	"@aws-sdk/core": "3.709.0",
	"@aws-sdk/credential-provider-node": "3.712.0",
	"@aws-sdk/middleware-bucket-endpoint": "3.709.0",
	"@aws-sdk/middleware-expect-continue": "3.709.0",
	"@aws-sdk/middleware-flexible-checksums": "3.709.0",
	"@aws-sdk/middleware-host-header": "3.709.0",
	"@aws-sdk/middleware-location-constraint": "3.709.0",
	"@aws-sdk/middleware-logger": "3.709.0",
	"@aws-sdk/middleware-recursion-detection": "3.709.0",
	"@aws-sdk/middleware-sdk-s3": "3.709.0",
	"@aws-sdk/middleware-ssec": "3.709.0",
	"@aws-sdk/middleware-user-agent": "3.709.0",
	"@aws-sdk/region-config-resolver": "3.709.0",
	"@aws-sdk/signature-v4-multi-region": "3.709.0",
	"@aws-sdk/types": "3.709.0",
	"@aws-sdk/util-endpoints": "3.709.0",
	"@aws-sdk/util-user-agent-browser": "3.709.0",
	"@aws-sdk/util-user-agent-node": "3.712.0",
	"@aws-sdk/xml-builder": "3.709.0",
	"@smithy/config-resolver": "^3.0.13",
	"@smithy/core": "^2.5.5",
	"@smithy/eventstream-serde-browser": "^3.0.14",
	"@smithy/eventstream-serde-config-resolver": "^3.0.11",
	"@smithy/eventstream-serde-node": "^3.0.13",
	"@smithy/fetch-http-handler": "^4.1.2",
	"@smithy/hash-blob-browser": "^3.1.10",
	"@smithy/hash-node": "^3.0.11",
	"@smithy/hash-stream-node": "^3.1.10",
	"@smithy/invalid-dependency": "^3.0.11",
	"@smithy/md5-js": "^3.0.11",
	"@smithy/middleware-content-length": "^3.0.13",
	"@smithy/middleware-endpoint": "^3.2.5",
	"@smithy/middleware-retry": "^3.0.30",
	"@smithy/middleware-serde": "^3.0.11",
	"@smithy/middleware-stack": "^3.0.11",
	"@smithy/node-config-provider": "^3.1.12",
	"@smithy/node-http-handler": "^3.3.2",
	"@smithy/protocol-http": "^4.1.8",
	"@smithy/smithy-client": "^3.5.0",
	"@smithy/types": "^3.7.2",
	"@smithy/url-parser": "^3.0.11",
	"@smithy/util-base64": "^3.0.0",
	"@smithy/util-body-length-browser": "^3.0.0",
	"@smithy/util-body-length-node": "^3.0.0",
	"@smithy/util-defaults-mode-browser": "^3.0.30",
	"@smithy/util-defaults-mode-node": "^3.0.30",
	"@smithy/util-endpoints": "^2.1.7",
	"@smithy/util-middleware": "^3.0.11",
	"@smithy/util-retry": "^3.0.11",
	"@smithy/util-stream": "^3.3.2",
	"@smithy/util-utf8": "^3.0.0",
	"@smithy/util-waiter": "^3.2.0",
	tslib: "^2.6.2"
};
var devDependencies$2 = {
	"@aws-sdk/signature-v4-crt": "3.712.0",
	"@tsconfig/node16": "16.1.3",
	"@types/node": "^16.18.96",
	concurrently: "7.0.0",
	"downlevel-dts": "0.10.1",
	rimraf: "3.0.2",
	typescript: "~4.9.5"
};
var engines$2 = {
	node: ">=16.0.0"
};
var typesVersions$1 = {
	"<4.0": {
		"dist-types/*": [
			"dist-types/ts3.4/*"
		]
	}
};
var files$2 = [
	"dist-*/**"
];
var author$2 = {
	name: "AWS SDK for JavaScript Team",
	url: "https://aws.amazon.com/javascript/"
};
var license$2 = "Apache-2.0";
var browser$1 = {
	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
};
var homepage$2 = "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3";
var repository$2 = {
	type: "git",
	url: "https://github.com/aws/aws-sdk-js-v3.git",
	directory: "clients/client-s3"
};
var packageInfo$1 = {
	name: name$2,
	description: description$2,
	version: version$2,
	scripts: scripts$2,
	main: main$2,
	types: types$2,
	module: module$2,
	sideEffects: sideEffects$1,
	dependencies: dependencies$2,
	devDependencies: devDependencies$2,
	engines: engines$2,
	typesVersions: typesVersions$1,
	files: files$2,
	author: author$2,
	license: license$2,
	browser: browser$1,
	"react-native": {
	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
},
	homepage: homepage$2,
	repository: repository$2
};

const NODE_USE_ARN_REGION_ENV_NAME = "AWS_S3_USE_ARN_REGION";
const NODE_USE_ARN_REGION_INI_NAME = "s3_use_arn_region";
const NODE_USE_ARN_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => booleanSelector(env, NODE_USE_ARN_REGION_ENV_NAME, SelectorType$1.ENV),
    configFileSelector: (profile) => booleanSelector(profile, NODE_USE_ARN_REGION_INI_NAME, SelectorType$1.CONFIG),
    default: false,
};

class Int64 {
    constructor(bytes) {
        this.bytes = bytes;
        if (bytes.byteLength !== 8) {
            throw new Error("Int64 buffers must be exactly 8 bytes");
        }
    }
    static fromNumber(number) {
        if (number > 9223372036854776000 || number < -9223372036854776000) {
            throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
        }
        const bytes = new Uint8Array(8);
        for (let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {
            bytes[i] = remaining;
        }
        if (number < 0) {
            negate(bytes);
        }
        return new Int64(bytes);
    }
    valueOf() {
        const bytes = this.bytes.slice(0);
        const negative = bytes[0] & 0b10000000;
        if (negative) {
            negate(bytes);
        }
        return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);
    }
    toString() {
        return String(this.valueOf());
    }
}
function negate(bytes) {
    for (let i = 0; i < 8; i++) {
        bytes[i] ^= 0xff;
    }
    for (let i = 7; i > -1; i--) {
        bytes[i]++;
        if (bytes[i] !== 0)
            break;
    }
}

class HeaderMarshaller {
    constructor(toUtf8, fromUtf8) {
        this.toUtf8 = toUtf8;
        this.fromUtf8 = fromUtf8;
    }
    format(headers) {
        const chunks = [];
        for (const headerName of Object.keys(headers)) {
            const bytes = this.fromUtf8(headerName);
            chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
        }
        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
        let position = 0;
        for (const chunk of chunks) {
            out.set(chunk, position);
            position += chunk.byteLength;
        }
        return out;
    }
    formatHeaderValue(header) {
        switch (header.type) {
            case "boolean":
                return Uint8Array.from([header.value ? 0 : 1]);
            case "byte":
                return Uint8Array.from([2, header.value]);
            case "short":
                const shortView = new DataView(new ArrayBuffer(3));
                shortView.setUint8(0, 3);
                shortView.setInt16(1, header.value, false);
                return new Uint8Array(shortView.buffer);
            case "integer":
                const intView = new DataView(new ArrayBuffer(5));
                intView.setUint8(0, 4);
                intView.setInt32(1, header.value, false);
                return new Uint8Array(intView.buffer);
            case "long":
                const longBytes = new Uint8Array(9);
                longBytes[0] = 5;
                longBytes.set(header.value.bytes, 1);
                return longBytes;
            case "binary":
                const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
                binView.setUint8(0, 6);
                binView.setUint16(1, header.value.byteLength, false);
                const binBytes = new Uint8Array(binView.buffer);
                binBytes.set(header.value, 3);
                return binBytes;
            case "string":
                const utf8Bytes = this.fromUtf8(header.value);
                const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
                strView.setUint8(0, 7);
                strView.setUint16(1, utf8Bytes.byteLength, false);
                const strBytes = new Uint8Array(strView.buffer);
                strBytes.set(utf8Bytes, 3);
                return strBytes;
            case "timestamp":
                const tsBytes = new Uint8Array(9);
                tsBytes[0] = 8;
                tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
                return tsBytes;
            case "uuid":
                if (!UUID_PATTERN.test(header.value)) {
                    throw new Error(`Invalid UUID received: ${header.value}`);
                }
                const uuidBytes = new Uint8Array(17);
                uuidBytes[0] = 9;
                uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
                return uuidBytes;
        }
    }
    parse(headers) {
        const out = {};
        let position = 0;
        while (position < headers.byteLength) {
            const nameLength = headers.getUint8(position++);
            const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
            position += nameLength;
            switch (headers.getUint8(position++)) {
                case 0:
                    out[name] = {
                        type: BOOLEAN_TAG,
                        value: true,
                    };
                    break;
                case 1:
                    out[name] = {
                        type: BOOLEAN_TAG,
                        value: false,
                    };
                    break;
                case 2:
                    out[name] = {
                        type: BYTE_TAG,
                        value: headers.getInt8(position++),
                    };
                    break;
                case 3:
                    out[name] = {
                        type: SHORT_TAG,
                        value: headers.getInt16(position, false),
                    };
                    position += 2;
                    break;
                case 4:
                    out[name] = {
                        type: INT_TAG,
                        value: headers.getInt32(position, false),
                    };
                    position += 4;
                    break;
                case 5:
                    out[name] = {
                        type: LONG_TAG,
                        value: new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)),
                    };
                    position += 8;
                    break;
                case 6:
                    const binaryLength = headers.getUint16(position, false);
                    position += 2;
                    out[name] = {
                        type: BINARY_TAG,
                        value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength),
                    };
                    position += binaryLength;
                    break;
                case 7:
                    const stringLength = headers.getUint16(position, false);
                    position += 2;
                    out[name] = {
                        type: STRING_TAG,
                        value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength)),
                    };
                    position += stringLength;
                    break;
                case 8:
                    out[name] = {
                        type: TIMESTAMP_TAG,
                        value: new Date(new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf()),
                    };
                    position += 8;
                    break;
                case 9:
                    const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
                    position += 16;
                    out[name] = {
                        type: UUID_TAG,
                        value: `${toHex(uuidBytes.subarray(0, 4))}-${toHex(uuidBytes.subarray(4, 6))}-${toHex(uuidBytes.subarray(6, 8))}-${toHex(uuidBytes.subarray(8, 10))}-${toHex(uuidBytes.subarray(10))}`,
                    };
                    break;
                default:
                    throw new Error(`Unrecognized header type tag`);
            }
        }
        return out;
    }
}
var HEADER_VALUE_TYPE;
(function (HEADER_VALUE_TYPE) {
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolTrue"] = 0] = "boolTrue";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolFalse"] = 1] = "boolFalse";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byte"] = 2] = "byte";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["short"] = 3] = "short";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["integer"] = 4] = "integer";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["long"] = 5] = "long";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byteArray"] = 6] = "byteArray";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["string"] = 7] = "string";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["timestamp"] = 8] = "timestamp";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
const BOOLEAN_TAG = "boolean";
const BYTE_TAG = "byte";
const SHORT_TAG = "short";
const INT_TAG = "integer";
const LONG_TAG = "long";
const BINARY_TAG = "binary";
const STRING_TAG = "string";
const TIMESTAMP_TAG = "timestamp";
const UUID_TAG = "uuid";
const UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;

const PRELUDE_MEMBER_LENGTH = 4;
const PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
const CHECKSUM_LENGTH = 4;
const MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
function splitMessage({ byteLength, byteOffset, buffer }) {
    if (byteLength < MINIMUM_MESSAGE_LENGTH) {
        throw new Error("Provided message too short to accommodate event stream message overhead");
    }
    const view = new DataView(buffer, byteOffset, byteLength);
    const messageLength = view.getUint32(0, false);
    if (byteLength !== messageLength) {
        throw new Error("Reported message length does not match received message length");
    }
    const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
    const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
    const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);
    const checksummer = new Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
    if (expectedPreludeChecksum !== checksummer.digest()) {
        throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
    }
    checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
    if (expectedMessageChecksum !== checksummer.digest()) {
        throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
    }
    return {
        headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
        body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH)),
    };
}

class EventStreamCodec {
    constructor(toUtf8, fromUtf8) {
        this.headerMarshaller = new HeaderMarshaller(toUtf8, fromUtf8);
        this.messageBuffer = [];
        this.isEndOfStream = false;
    }
    feed(message) {
        this.messageBuffer.push(this.decode(message));
    }
    endOfStream() {
        this.isEndOfStream = true;
    }
    getMessage() {
        const message = this.messageBuffer.pop();
        const isEndOfStream = this.isEndOfStream;
        return {
            getMessage() {
                return message;
            },
            isEndOfStream() {
                return isEndOfStream;
            },
        };
    }
    getAvailableMessages() {
        const messages = this.messageBuffer;
        this.messageBuffer = [];
        const isEndOfStream = this.isEndOfStream;
        return {
            getMessages() {
                return messages;
            },
            isEndOfStream() {
                return isEndOfStream;
            },
        };
    }
    encode({ headers: rawHeaders, body }) {
        const headers = this.headerMarshaller.format(rawHeaders);
        const length = headers.byteLength + body.byteLength + 16;
        const out = new Uint8Array(length);
        const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        const checksum = new Crc32();
        view.setUint32(0, length, false);
        view.setUint32(4, headers.byteLength, false);
        view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
        out.set(headers, 12);
        out.set(body, headers.byteLength + 12);
        view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);
        return out;
    }
    decode(message) {
        const { headers, body } = splitMessage(message);
        return { headers: this.headerMarshaller.parse(headers), body };
    }
    formatHeaders(rawHeaders) {
        return this.headerMarshaller.format(rawHeaders);
    }
}

class MessageDecoderStream {
    constructor(options) {
        this.options = options;
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }
    async *asyncIterator() {
        for await (const bytes of this.options.inputStream) {
            const decoded = this.options.decoder.decode(bytes);
            yield decoded;
        }
    }
}

class MessageEncoderStream {
    constructor(options) {
        this.options = options;
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }
    async *asyncIterator() {
        for await (const msg of this.options.messageStream) {
            const encoded = this.options.encoder.encode(msg);
            yield encoded;
        }
        if (this.options.includeEndFrame) {
            yield new Uint8Array(0);
        }
    }
}

class SmithyMessageDecoderStream {
    constructor(options) {
        this.options = options;
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }
    async *asyncIterator() {
        for await (const message of this.options.messageStream) {
            const deserialized = await this.options.deserializer(message);
            if (deserialized === undefined)
                continue;
            yield deserialized;
        }
    }
}

class SmithyMessageEncoderStream {
    constructor(options) {
        this.options = options;
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }
    async *asyncIterator() {
        for await (const chunk of this.options.inputStream) {
            const payloadBuf = this.options.serializer(chunk);
            yield payloadBuf;
        }
    }
}

function getChunkedStream(source) {
    let currentMessageTotalLength = 0;
    let currentMessagePendingLength = 0;
    let currentMessage = null;
    let messageLengthBuffer = null;
    const allocateMessage = (size) => {
        if (typeof size !== "number") {
            throw new Error("Attempted to allocate an event message where size was not a number: " + size);
        }
        currentMessageTotalLength = size;
        currentMessagePendingLength = 4;
        currentMessage = new Uint8Array(size);
        const currentMessageView = new DataView(currentMessage.buffer);
        currentMessageView.setUint32(0, size, false);
    };
    const iterator = async function* () {
        const sourceIterator = source[Symbol.asyncIterator]();
        while (true) {
            const { value, done } = await sourceIterator.next();
            if (done) {
                if (!currentMessageTotalLength) {
                    return;
                }
                else if (currentMessageTotalLength === currentMessagePendingLength) {
                    yield currentMessage;
                }
                else {
                    throw new Error("Truncated event message received.");
                }
                return;
            }
            const chunkLength = value.length;
            let currentOffset = 0;
            while (currentOffset < chunkLength) {
                if (!currentMessage) {
                    const bytesRemaining = chunkLength - currentOffset;
                    if (!messageLengthBuffer) {
                        messageLengthBuffer = new Uint8Array(4);
                    }
                    const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);
                    messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);
                    currentMessagePendingLength += numBytesForTotal;
                    currentOffset += numBytesForTotal;
                    if (currentMessagePendingLength < 4) {
                        break;
                    }
                    allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));
                    messageLengthBuffer = null;
                }
                const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);
                currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);
                currentMessagePendingLength += numBytesToWrite;
                currentOffset += numBytesToWrite;
                if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {
                    yield currentMessage;
                    currentMessage = null;
                    currentMessageTotalLength = 0;
                    currentMessagePendingLength = 0;
                }
            }
        }
    };
    return {
        [Symbol.asyncIterator]: iterator,
    };
}

function getMessageUnmarshaller(deserializer, toUtf8) {
    return async function (message) {
        const { value: messageType } = message.headers[":message-type"];
        if (messageType === "error") {
            const unmodeledError = new Error(message.headers[":error-message"].value || "UnknownError");
            unmodeledError.name = message.headers[":error-code"].value;
            throw unmodeledError;
        }
        else if (messageType === "exception") {
            const code = message.headers[":exception-type"].value;
            const exception = { [code]: message };
            const deserializedException = await deserializer(exception);
            if (deserializedException.$unknown) {
                const error = new Error(toUtf8(message.body));
                error.name = code;
                throw error;
            }
            throw deserializedException[code];
        }
        else if (messageType === "event") {
            const event = {
                [message.headers[":event-type"].value]: message,
            };
            const deserialized = await deserializer(event);
            if (deserialized.$unknown)
                return;
            return deserialized;
        }
        else {
            throw Error(`Unrecognizable event type: ${message.headers[":event-type"].value}`);
        }
    };
}

let EventStreamMarshaller$1 = class EventStreamMarshaller {
    constructor({ utf8Encoder, utf8Decoder }) {
        this.eventStreamCodec = new EventStreamCodec(utf8Encoder, utf8Decoder);
        this.utfEncoder = utf8Encoder;
    }
    deserialize(body, deserializer) {
        const inputStream = getChunkedStream(body);
        return new SmithyMessageDecoderStream({
            messageStream: new MessageDecoderStream({ inputStream, decoder: this.eventStreamCodec }),
            deserializer: getMessageUnmarshaller(deserializer, this.utfEncoder),
        });
    }
    serialize(inputStream, serializer) {
        return new MessageEncoderStream({
            messageStream: new SmithyMessageEncoderStream({ inputStream, serializer }),
            encoder: this.eventStreamCodec,
            includeEndFrame: true,
        });
    }
};

async function* readabletoIterable(readStream) {
    let streamEnded = false;
    let generationEnded = false;
    const records = new Array();
    readStream.on("error", (err) => {
        if (!streamEnded) {
            streamEnded = true;
        }
        if (err) {
            throw err;
        }
    });
    readStream.on("data", (data) => {
        records.push(data);
    });
    readStream.on("end", () => {
        streamEnded = true;
    });
    while (!generationEnded) {
        const value = await new Promise((resolve) => setTimeout(() => resolve(records.shift()), 0));
        if (value) {
            yield value;
        }
        generationEnded = streamEnded && records.length === 0;
    }
}

class EventStreamMarshaller {
    constructor({ utf8Encoder, utf8Decoder }) {
        this.universalMarshaller = new EventStreamMarshaller$1({
            utf8Decoder,
            utf8Encoder,
        });
    }
    deserialize(body, deserializer) {
        const bodyIterable = typeof body[Symbol.asyncIterator] === "function" ? body : readabletoIterable(body);
        return this.universalMarshaller.deserialize(bodyIterable, deserializer);
    }
    serialize(input, serializer) {
        return require$$0$9.Readable.from(this.universalMarshaller.serialize(input, serializer));
    }
}

const eventStreamSerdeProvider = (options) => new EventStreamMarshaller(options);

class HashCalculator extends require$$0$9.Writable {
    constructor(hash, options) {
        super(options);
        this.hash = hash;
    }
    _write(chunk, encoding, callback) {
        try {
            this.hash.update(toUint8Array(chunk));
        }
        catch (err) {
            return callback(err);
        }
        callback();
    }
}

const readableStreamHasher = (hashCtor, readableStream) => {
    if (readableStream.readableFlowing !== null) {
        throw new Error("Unable to calculate hash for flowing readable stream");
    }
    const hash = new hashCtor();
    const hashCalculator = new HashCalculator(hash);
    readableStream.pipe(hashCalculator);
    return new Promise((resolve, reject) => {
        readableStream.on("error", (err) => {
            hashCalculator.end();
            reject(err);
        });
        hashCalculator.on("error", reject);
        hashCalculator.on("finish", () => {
            hash.digest().then(resolve).catch(reject);
        });
    });
};

const getRuntimeConfig$3 = (config) => {
    return {
        apiVersion: "2006-03-01",
        base64Decoder: config?.base64Decoder ?? fromBase64,
        base64Encoder: config?.base64Encoder ?? toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver$1,
        extensions: config?.extensions ?? [],
        getAwsChunkedEncodingStream: config?.getAwsChunkedEncodingStream ?? getAwsChunkedEncodingStream,
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultS3HttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
            {
                schemeId: "aws.auth#sigv4",
                identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
                signer: new AwsSdkSigV4Signer(),
            },
            {
                schemeId: "aws.auth#sigv4a",
                identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4a"),
                signer: new AwsSdkSigV4ASigner(),
            },
        ],
        logger: config?.logger ?? new NoOpLogger(),
        sdkStreamMixin: config?.sdkStreamMixin ?? sdkStreamMixin,
        serviceId: config?.serviceId ?? "S3",
        signerConstructor: config?.signerConstructor ?? SignatureV4MultiRegion,
        signingEscapePath: config?.signingEscapePath ?? false,
        urlParser: config?.urlParser ?? parseUrl,
        useArnRegion: config?.useArnRegion ?? false,
        utf8Decoder: config?.utf8Decoder ?? fromUtf8$1,
        utf8Encoder: config?.utf8Encoder ?? toUtf8,
    };
};

const getRuntimeConfig$2 = (config) => {
    emitWarningIfUnsupportedVersion(process.version);
    const defaultsMode = resolveDefaultsModeConfig(config);
    const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
    const clientSharedValues = getRuntimeConfig$3(config);
    emitWarningIfUnsupportedVersion$1(process.version);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? defaultProvider,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: packageInfo$1.version }),
        disableS3ExpressSessionAuth: config?.disableS3ExpressSessionAuth ?? loadConfig(NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS),
        eventStreamSerdeProvider: config?.eventStreamSerdeProvider ?? eventStreamSerdeProvider,
        maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        md5: config?.md5 ?? Hash.bind(null, "md5"),
        region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
        requestChecksumCalculation: config?.requestChecksumCalculation ?? loadConfig(NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS),
        requestHandler: NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        responseChecksumValidation: config?.responseChecksumValidation ?? loadConfig(NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS),
        retryMode: config?.retryMode ??
            loadConfig({
                ...NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE,
            }),
        sha1: config?.sha1 ?? Hash.bind(null, "sha1"),
        sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
        sigv4aSigningRegionSet: config?.sigv4aSigningRegionSet ?? loadConfig(NODE_SIGV4A_CONFIG_OPTIONS),
        streamCollector: config?.streamCollector ?? streamCollector$1,
        streamHasher: config?.streamHasher ?? readableStreamHasher,
        useArnRegion: config?.useArnRegion ?? loadConfig(NODE_USE_ARN_REGION_CONFIG_OPTIONS),
        useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
        userAgentAppId: config?.userAgentAppId ?? loadConfig(NODE_APP_ID_CONFIG_OPTIONS),
    };
};

const getHttpAuthExtensionConfiguration$1 = (runtimeConfig) => {
    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
    let _credentials = runtimeConfig.credentials;
    return {
        setHttpAuthScheme(httpAuthScheme) {
            const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
            if (index === -1) {
                _httpAuthSchemes.push(httpAuthScheme);
            }
            else {
                _httpAuthSchemes.splice(index, 1, httpAuthScheme);
            }
        },
        httpAuthSchemes() {
            return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
            _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
            return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
            _credentials = credentials;
        },
        credentials() {
            return _credentials;
        },
    };
};
const resolveHttpAuthRuntimeConfig$1 = (config) => {
    return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials(),
    };
};

const asPartial$1 = (t) => t;
const resolveRuntimeExtensions$1 = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
        ...asPartial$1(getAwsRegionExtensionConfiguration(runtimeConfig)),
        ...asPartial$1(getDefaultExtensionConfiguration(runtimeConfig)),
        ...asPartial$1(getHttpHandlerExtensionConfiguration(runtimeConfig)),
        ...asPartial$1(getHttpAuthExtensionConfiguration$1(runtimeConfig)),
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
        ...resolveDefaultRuntimeConfig(extensionConfiguration),
        ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
        ...resolveHttpAuthRuntimeConfig$1(extensionConfiguration),
    };
};

class S3Client extends Client {
    constructor(...[configuration]) {
        const _config_0 = getRuntimeConfig$2(configuration || {});
        const _config_1 = resolveClientEndpointParameters$1(_config_0);
        const _config_2 = resolveUserAgentConfig(_config_1);
        const _config_3 = resolveFlexibleChecksumsConfig(_config_2);
        const _config_4 = resolveRetryConfig(_config_3);
        const _config_5 = resolveRegionConfig(_config_4);
        const _config_6 = resolveHostHeaderConfig(_config_5);
        const _config_7 = resolveEndpointConfig(_config_6);
        const _config_8 = resolveEventStreamSerdeConfig(_config_7);
        const _config_9 = resolveHttpAuthSchemeConfig$1(_config_8);
        const _config_10 = resolveS3Config(_config_9, { session: [() => this, CreateSessionCommand] });
        const _config_11 = resolveRuntimeExtensions$1(_config_10, configuration?.extensions || []);
        super(_config_11);
        this.config = _config_11;
        this.middlewareStack.use(getUserAgentPlugin(this.config));
        this.middlewareStack.use(getRetryPlugin(this.config));
        this.middlewareStack.use(getContentLengthPlugin(this.config));
        this.middlewareStack.use(getHostHeaderPlugin(this.config));
        this.middlewareStack.use(getLoggerPlugin(this.config));
        this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
        this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
            httpAuthSchemeParametersProvider: defaultS3HttpAuthSchemeParametersProvider,
            identityProviderConfigProvider: async (config) => new DefaultIdentityProviderConfig({
                "aws.auth#sigv4": config.credentials,
                "aws.auth#sigv4a": config.credentials,
            }),
        }));
        this.middlewareStack.use(getHttpSigningPlugin(this.config));
        this.middlewareStack.use(getValidateBucketNamePlugin(this.config));
        this.middlewareStack.use(getAddExpectContinuePlugin(this.config));
        this.middlewareStack.use(getRegionRedirectMiddlewarePlugin(this.config));
        this.middlewareStack.use(getS3ExpressPlugin(this.config));
        this.middlewareStack.use(getS3ExpressHttpSigningPlugin(this.config));
    }
    destroy() {
        super.destroy();
    }
}

requireMimeTypes();

const resolveQueueUrlConfig = (config) => {
    return {
        ...config,
        useQueueUrlAsEndpoint: config.useQueueUrlAsEndpoint ?? true,
    };
};
function queueUrlMiddleware({ useQueueUrlAsEndpoint, endpoint }) {
    return (next, context) => {
        return async (args) => {
            const { input } = args;
            const resolvedEndpoint = context.endpointV2;
            if (!endpoint && input.QueueUrl && resolvedEndpoint && useQueueUrlAsEndpoint) {
                const logger = context.logger instanceof NoOpLogger || !context.logger?.warn ? console : context.logger;
                try {
                    const queueUrl = new URL(input.QueueUrl);
                    const queueUrlOrigin = new URL(queueUrl.origin);
                    if (resolvedEndpoint.url.origin !== queueUrlOrigin.origin) {
                        logger.warn(`QueueUrl=${input.QueueUrl} differs from SQSClient resolved endpoint=${resolvedEndpoint.url.toString()}, using QueueUrl host as endpoint.
Set [endpoint=string] or [useQueueUrlAsEndpoint=false] on the SQSClient.`);
                        context.endpointV2 = {
                            ...resolvedEndpoint,
                            url: queueUrlOrigin,
                        };
                    }
                }
                catch (e) {
                    logger.warn(e);
                }
            }
            return next(args);
        };
    };
}
const queueUrlMiddlewareOptions = {
    name: "queueUrlMiddleware",
    relation: "after",
    toMiddleware: "endpointV2Middleware",
    override: true,
};
const getQueueUrlPlugin = (config) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(queueUrlMiddleware(config), queueUrlMiddlewareOptions);
    },
});

const defaultSQSHttpAuthSchemeParametersProvider = async (config, context, input) => {
    return {
        operation: getSmithyContext(context).operation,
        region: (await normalizeProvider$1(config.region)()) ||
            (() => {
                throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
            })(),
    };
};
function createAwsAuthSigv4HttpAuthOption(authParameters) {
    return {
        schemeId: "aws.auth#sigv4",
        signingProperties: {
            name: "sqs",
            region: authParameters.region,
        },
        propertiesExtractor: (config, context) => ({
            signingProperties: {
                config,
                context,
            },
        }),
    };
}
const defaultSQSHttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
        default: {
            options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
        }
    }
    return options;
};
const resolveHttpAuthSchemeConfig = (config) => {
    const config_0 = resolveAwsSdkSigV4Config(config);
    return {
        ...config_0,
    };
};

const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "sqs",
    };
};

var name$1 = "@aws-sdk/client-sqs";
var description$1 = "AWS SDK for JavaScript Sqs Client for Node.js, Browser and React Native";
var version$1 = "3.712.0";
var scripts$1 = {
	build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
	"build:cjs": "node ../../scripts/compilation/inline client-sqs",
	"build:es": "tsc -p tsconfig.es.json",
	"build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
	"build:types": "tsc -p tsconfig.types.json",
	"build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
	clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
	"extract:docs": "api-extractor run --local",
	"generate:client": "node ../../scripts/generate-clients/single-service --solo sqs"
};
var main$1 = "./dist-cjs/index.js";
var types$1 = "./dist-types/index.d.ts";
var module$1 = "./dist-es/index.js";
var sideEffects = false;
var dependencies$1 = {
	"@aws-crypto/sha256-browser": "5.2.0",
	"@aws-crypto/sha256-js": "5.2.0",
	"@aws-sdk/client-sso-oidc": "3.712.0",
	"@aws-sdk/client-sts": "3.712.0",
	"@aws-sdk/core": "3.709.0",
	"@aws-sdk/credential-provider-node": "3.712.0",
	"@aws-sdk/middleware-host-header": "3.709.0",
	"@aws-sdk/middleware-logger": "3.709.0",
	"@aws-sdk/middleware-recursion-detection": "3.709.0",
	"@aws-sdk/middleware-sdk-sqs": "3.709.0",
	"@aws-sdk/middleware-user-agent": "3.709.0",
	"@aws-sdk/region-config-resolver": "3.709.0",
	"@aws-sdk/types": "3.709.0",
	"@aws-sdk/util-endpoints": "3.709.0",
	"@aws-sdk/util-user-agent-browser": "3.709.0",
	"@aws-sdk/util-user-agent-node": "3.712.0",
	"@smithy/config-resolver": "^3.0.13",
	"@smithy/core": "^2.5.5",
	"@smithy/fetch-http-handler": "^4.1.2",
	"@smithy/hash-node": "^3.0.11",
	"@smithy/invalid-dependency": "^3.0.11",
	"@smithy/md5-js": "^3.0.11",
	"@smithy/middleware-content-length": "^3.0.13",
	"@smithy/middleware-endpoint": "^3.2.5",
	"@smithy/middleware-retry": "^3.0.30",
	"@smithy/middleware-serde": "^3.0.11",
	"@smithy/middleware-stack": "^3.0.11",
	"@smithy/node-config-provider": "^3.1.12",
	"@smithy/node-http-handler": "^3.3.2",
	"@smithy/protocol-http": "^4.1.8",
	"@smithy/smithy-client": "^3.5.0",
	"@smithy/types": "^3.7.2",
	"@smithy/url-parser": "^3.0.11",
	"@smithy/util-base64": "^3.0.0",
	"@smithy/util-body-length-browser": "^3.0.0",
	"@smithy/util-body-length-node": "^3.0.0",
	"@smithy/util-defaults-mode-browser": "^3.0.30",
	"@smithy/util-defaults-mode-node": "^3.0.30",
	"@smithy/util-endpoints": "^2.1.7",
	"@smithy/util-middleware": "^3.0.11",
	"@smithy/util-retry": "^3.0.11",
	"@smithy/util-utf8": "^3.0.0",
	tslib: "^2.6.2"
};
var devDependencies$1 = {
	"@tsconfig/node16": "16.1.3",
	"@types/node": "^16.18.96",
	concurrently: "7.0.0",
	"downlevel-dts": "0.10.1",
	rimraf: "3.0.2",
	typescript: "~4.9.5"
};
var engines$1 = {
	node: ">=16.0.0"
};
var typesVersions = {
	"<4.0": {
		"dist-types/*": [
			"dist-types/ts3.4/*"
		]
	}
};
var files$1 = [
	"dist-*/**"
];
var author$1 = {
	name: "AWS SDK for JavaScript Team",
	url: "https://aws.amazon.com/javascript/"
};
var license$1 = "Apache-2.0";
var browser = {
	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
};
var homepage$1 = "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sqs";
var repository$1 = {
	type: "git",
	url: "https://github.com/aws/aws-sdk-js-v3.git",
	directory: "clients/client-sqs"
};
var packageInfo = {
	name: name$1,
	description: description$1,
	version: version$1,
	scripts: scripts$1,
	main: main$1,
	types: types$1,
	module: module$1,
	sideEffects: sideEffects,
	dependencies: dependencies$1,
	devDependencies: devDependencies$1,
	engines: engines$1,
	typesVersions: typesVersions,
	files: files$1,
	author: author$1,
	license: license$1,
	browser: browser,
	"react-native": {
	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
},
	homepage: homepage$1,
	repository: repository$1
};

const u = "required", v = "fn", w = "argv", x = "ref";
const a = true, b = "isSet", c = "booleanEquals", d = "error", e = "endpoint", f = "tree", g = "PartitionResult", h = "getAttr", i = { [u]: false, "type": "String" }, j = { [u]: true, "default": false, "type": "Boolean" }, k = { [x]: "Endpoint" }, l = { [v]: c, [w]: [{ [x]: "UseFIPS" }, true] }, m = { [v]: c, [w]: [{ [x]: "UseDualStack" }, true] }, n = {}, o = { [v]: h, [w]: [{ [x]: g }, "supportsFIPS"] }, p = { [x]: g }, q = { [v]: c, [w]: [true, { [v]: h, [w]: [p, "supportsDualStack"] }] }, r = [l], s = [m], t = [{ [x]: "Region" }];
const _data = { version: "1.0", parameters: { Region: i, UseDualStack: j, UseFIPS: j, Endpoint: i }, rules: [{ conditions: [{ [v]: b, [w]: [k] }], rules: [{ conditions: r, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: s, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: k, properties: n, headers: n }, type: e }], type: f }, { conditions: [{ [v]: b, [w]: t }], rules: [{ conditions: [{ [v]: "aws.partition", [w]: t, assign: g }], rules: [{ conditions: [l, m], rules: [{ conditions: [{ [v]: c, [w]: [a, o] }, q], rules: [{ endpoint: { url: "https://sqs-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: r, rules: [{ conditions: [{ [v]: c, [w]: [o, a] }], rules: [{ conditions: [{ [v]: "stringEquals", [w]: [{ [v]: h, [w]: [p, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://sqs.{Region}.amazonaws.com", properties: n, headers: n }, type: e }, { endpoint: { url: "https://sqs-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: s, rules: [{ conditions: [q], rules: [{ endpoint: { url: "https://sqs.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://sqs.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
const ruleSet = _data;

const cache = new EndpointCache({
    size: 50,
    params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"],
});
const defaultEndpointResolver = (endpointParams, context = {}) => {
    return cache.get(endpointParams, () => resolveEndpoint(ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    }));
};
customEndpointFunctions.aws = awsEndpointFunctions;

const getRuntimeConfig$1 = (config) => {
    return {
        apiVersion: "2012-11-05",
        base64Decoder: config?.base64Decoder ?? fromBase64,
        base64Encoder: config?.base64Encoder ?? toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultSQSHttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
            {
                schemeId: "aws.auth#sigv4",
                identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
                signer: new AwsSdkSigV4Signer(),
            },
        ],
        logger: config?.logger ?? new NoOpLogger(),
        serviceId: config?.serviceId ?? "SQS",
        urlParser: config?.urlParser ?? parseUrl,
        utf8Decoder: config?.utf8Decoder ?? fromUtf8$1,
        utf8Encoder: config?.utf8Encoder ?? toUtf8,
    };
};

const getRuntimeConfig = (config) => {
    emitWarningIfUnsupportedVersion(process.version);
    const defaultsMode = resolveDefaultsModeConfig(config);
    const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
    const clientSharedValues = getRuntimeConfig$1(config);
    emitWarningIfUnsupportedVersion$1(process.version);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? defaultProvider,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: packageInfo.version }),
        maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        md5: config?.md5 ?? Hash.bind(null, "md5"),
        region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ??
            loadConfig({
                ...NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? streamCollector$1,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
        userAgentAppId: config?.userAgentAppId ?? loadConfig(NODE_APP_ID_CONFIG_OPTIONS),
    };
};

const getHttpAuthExtensionConfiguration = (runtimeConfig) => {
    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
    let _credentials = runtimeConfig.credentials;
    return {
        setHttpAuthScheme(httpAuthScheme) {
            const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
            if (index === -1) {
                _httpAuthSchemes.push(httpAuthScheme);
            }
            else {
                _httpAuthSchemes.splice(index, 1, httpAuthScheme);
            }
        },
        httpAuthSchemes() {
            return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
            _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
            return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
            _credentials = credentials;
        },
        credentials() {
            return _credentials;
        },
    };
};
const resolveHttpAuthRuntimeConfig = (config) => {
    return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials(),
    };
};

const asPartial = (t) => t;
const resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
        ...asPartial(getAwsRegionExtensionConfiguration(runtimeConfig)),
        ...asPartial(getDefaultExtensionConfiguration(runtimeConfig)),
        ...asPartial(getHttpHandlerExtensionConfiguration(runtimeConfig)),
        ...asPartial(getHttpAuthExtensionConfiguration(runtimeConfig)),
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
        ...resolveDefaultRuntimeConfig(extensionConfiguration),
        ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
        ...resolveHttpAuthRuntimeConfig(extensionConfiguration),
    };
};

class SQSClient extends Client {
    constructor(...[configuration]) {
        const _config_0 = getRuntimeConfig(configuration || {});
        const _config_1 = resolveClientEndpointParameters(_config_0);
        const _config_2 = resolveUserAgentConfig(_config_1);
        const _config_3 = resolveRetryConfig(_config_2);
        const _config_4 = resolveRegionConfig(_config_3);
        const _config_5 = resolveHostHeaderConfig(_config_4);
        const _config_6 = resolveEndpointConfig(_config_5);
        const _config_7 = resolveQueueUrlConfig(_config_6);
        const _config_8 = resolveHttpAuthSchemeConfig(_config_7);
        const _config_9 = resolveRuntimeExtensions(_config_8, configuration?.extensions || []);
        super(_config_9);
        this.config = _config_9;
        this.middlewareStack.use(getUserAgentPlugin(this.config));
        this.middlewareStack.use(getRetryPlugin(this.config));
        this.middlewareStack.use(getContentLengthPlugin(this.config));
        this.middlewareStack.use(getHostHeaderPlugin(this.config));
        this.middlewareStack.use(getLoggerPlugin(this.config));
        this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
        this.middlewareStack.use(getQueueUrlPlugin(this.config));
        this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
            httpAuthSchemeParametersProvider: defaultSQSHttpAuthSchemeParametersProvider,
            identityProviderConfigProvider: async (config) => new DefaultIdentityProviderConfig({
                "aws.auth#sigv4": config.credentials,
            }),
        }));
        this.middlewareStack.use(getHttpSigningPlugin(this.config));
    }
    destroy() {
        super.destroy();
    }
}

const NODE_ENV = process.env.NODE_ENV || 'development';
const VERSION = process.env.VERSION || '0.0.0';
const ORIGINS = [
    ...(process.env.ORIGINS || '').split(','),
    /^((https:\/\/juki\.app)|(https:\/\/[a-zA-Z0-9\-_]+\.juki\.app))$/,
    /^((https:\/\/juk\.app)|(https:\/\/[a-zA-Z0-9\-_]+\.juk\.app))$/,
    /^((https:\/\/juki\.team)|(https:\/\/[a-zA-Z0-9\-_]+\.juki\.team))$/,
    /^((https:\/\/jukijudge\.com)|(https:\/\/[a-zA-Z0-9\-_]+\.jukijudge\.com))$/,
    /^((https:\/\/juki-ui\.com)|(https:\/\/[a-zA-Z0-9\-_]+\.juki-ui\.com))$/,
    /^((https:\/\/oscargauss\.com)|(https:\/\/[a-zA-Z0-9\-_]+\.oscargauss\.com))$/,
];
const LOG_LEVEL = process.env.LOG_LEVEL || LogLevel.INFO;
const PORT = process.env.PORT || 4000;
const TELEGRAM_JUKI_LOGS_BOT_TOKEN = process.env.TELEGRAM_JUKI_LOGS_BOT_TOKEN || '';
const TELEGRAM_JUKI_INFO_LOGS_CHAT_ID = process.env.TELEGRAM_JUKI_INFO_LOGS_CHAT_ID || '';
const TELEGRAM_JUKI_ERROR_LOGS_CHAT_ID = process.env.TELEGRAM_JUKI_ERROR_LOGS_CHAT_ID || '';
const JUKI_SECRET_TOKEN = process.env.JUKI_SECRET_TOKEN || '';
process.env.SHARED_TASK_STATUSES_FOLDER || '';

function routerGetPing(request, response) {
    try {
        response.sendContent('pong');
    }
    catch (error) {
        response.sendError(toJkError(error), { message: 'Error handling "routerGetPing"', notify: true });
    }
}
function routerGetVersion(request, response) {
    try {
        response.sendContent(VERSION);
    }
    catch (error) {
        response.sendError(toJkError(error), { message: 'Error handling "routerGetVersion"', notify: true });
    }
}
function routerGetNodeEnv(request, response) {
    try {
        response.sendContent(NODE_ENV);
    }
    catch (error) {
        response.sendError(toJkError(error), { message: 'Error handling "routerGetEnv"', notify: true });
    }
}
function routerGetStatus(request, response) {
    try {
        response.sendContent({
            time: new Date(),
            cpus: os.cpus(),
            totalmem: os.totalmem(),
            freemem: os.freemem(),
        });
    }
    catch (error) {
        response.sendError(toJkError(error), { message: 'Error handling "routerGetStatus"', notify: true });
    }
}
function routerGetEnvs(request, response) {
    try {
        if (request.query.secretToken !== JUKI_SECRET_TOKEN) {
            return response.sendError(new JkError(ErrorCode.ERR401), {
                message: 'Unauthorized "routerGetEnvs"',
                notify: true,
            });
        }
        response.sendContent({
            ...process.env,
        });
    }
    catch (error) {
        response.sendError(toJkError(error), {
            message: 'Error handling "routerGetEnvs"',
            notify: true,
        });
    }
}

class TelegramBotService {
    constructor(fetcher) {
        this._JUKI_LOGS_BOT_TOKEN = '';
        this._JUKI_INFO_LOGS_CHAT_ID = '';
        this._JUKI_ERROR_LOGS_CHAT_ID = '';
        // The maximum length of a Telegram message is 4096 characters and it must be UTF-8 encoded.
        this.maxSizeText = 2048;
        // this._JUKI_LOGS_BOT_TOKEN = jukiLogsBotToken;
        // this._JUKI_LOGS_CHAT_ID = jukiLogsChatId;
        // this._HEADER = header;
        this._fetcher = fetcher;
    }
    config(jukiLogsBotToken, jukiInfoLogsChatId, jukiErrorLogsChatId, fetcher) {
        this._JUKI_LOGS_BOT_TOKEN = jukiLogsBotToken;
        this._JUKI_INFO_LOGS_CHAT_ID = jukiInfoLogsChatId;
        this._JUKI_ERROR_LOGS_CHAT_ID = jukiErrorLogsChatId;
        if (fetcher) {
            this._fetcher = fetcher;
        }
    }
    setHeader(header) {
        this._HEADER = header;
    }
    // https://core.telegram.org/bots/api#markdownv2-style
    escape(text) {
        if (typeof text !== 'string') {
            return '__NO_STRING__';
        }
        return text
            .split('_').join('\\_')
            .split('*').join('\\*')
            .split('[').join('\\[')
            .split(']').join('\\]')
            .split('(').join('\\(')
            .split(')').join('\\)')
            .split('~').join('\\~')
            .split('`').join('\\`')
            .split('>').join('\\>')
            .split('#').join('\\#')
            .split('+').join('\\+')
            .split('-').join('\\-')
            .split('=').join('\\=')
            .split('|').join('\\|')
            .split('{').join('\\{')
            .split('}').join('\\}')
            .split('.').join('\\.')
            .split('!').join('\\!');
    }
    send(partialUrl, formData) {
        if (!this._JUKI_LOGS_BOT_TOKEN || !this._JUKI_ERROR_LOGS_CHAT_ID || !this._JUKI_LOGS_BOT_TOKEN || !this._HEADER) {
            return log(LogLevel.ERROR)('PLEASE SET UP THE \'TelegramBotService\'');
        }
        log(LogLevel.TRACE)('sending Telegram log');
        const url = `https://api.telegram.org/bot${this._JUKI_LOGS_BOT_TOKEN}/${partialUrl}`;
        return this._fetcher(url, formData ? { body: formData, method: 'POST' } : {})
            .then(response => response.json())
            .then(response => {
            if (response.ok) {
                log(LogLevel.TRACE)('telegram message sent ' + url);
                return;
            }
            throw response;
        })
            .catch(error => {
            if (error.response) {
                log(LogLevel.WARN)('error on sending telegram message', {
                    data: error.response.data,
                    status: error.response.status,
                    headers: error.response.headers,
                    partialUrl,
                    url,
                    possibleError: 'The request was made and the server responded with a status code, that falls out of the range of 2xx',
                });
            }
            else if (error.request) {
                log(LogLevel.WARN)('error on sending telegram message', {
                    request: error.request,
                    partialUrl, url,
                    possibleError: 'The request was made but no response was received `error.request` is an instance of XMLHttpRequest in the browser and an instance of http.ClientRequest in node.js',
                });
            }
            else {
                log(LogLevel.WARN)('error on sending telegram message', {
                    message: error?.message,
                    partialUrl, url,
                    possibleError: 'Something happened in setting up the request that triggered an Error',
                });
            }
        });
    }
    sendErrorDocument(document) {
        const formData = new FormData();
        formData.append('chat_id', this._JUKI_ERROR_LOGS_CHAT_ID);
        formData.append('document', document);
        return this.send('sendDocument', formData);
    }
    sendMessage(markdownV2Text, chatId) {
        return this.send(`sendMessage?chat_id=${chatId}&text=${encodeURIComponent(markdownV2Text)}&parse_mode=MarkdownV2`);
    }
    getTitle(title) {
        return `${this.escape(this._HEADER + ':')} *${this.escape(title)}*`;
    }
    async sendMessages(messages, chatId) {
        const results = [];
        for (let i = 0; i < messages.length; i++) {
            results.push(await this.sendMessage(messages[i]
                + (messages.length > 1
                    ? this.escape(`\n${i + 1}/${messages.length} [${messages[i].length}/${this.maxSizeText}]`)
                    : ''), chatId));
        }
        return results;
    }
    async sendErrorMessage(title, error, requestData) {
        log(LogLevel.INFO)(`ERROR: sending error message "${title}"`, error);
        const errorText = stringifyObject(error, 5);
        const requestText = stringifyObject(requestData, 5);
        const errorTextChunked = chunkString(errorText, this.maxSizeText);
        const messages = errorTextChunked.map(errorText => ([
            this.getTitle(title),
            '```',
            this.escape(errorText),
            '```',
            ...(requestData !== undefined
                ? [
                    '*REQUEST*',
                    '```',
                    this.escape(requestText),
                    '```',
                ]
                : []),
        ].join('\n')));
        return await this.sendMessages(messages, this._JUKI_ERROR_LOGS_CHAT_ID);
    }
    toText(content) {
        let contentText = '';
        if (typeof content === 'object' && content !== null) {
            Object.entries(content).forEach(([key, value]) => {
                contentText += `\n*${this.escape(key + ':')}* `
                    + `${(Array.isArray(value) ? value : [value]).map(v => '`' + this.escape(v instanceof RegExp ? v.toString() : JSON.stringify(v)) + '`').join(', ')}`;
            });
        }
        else {
            contentText = `${content}`;
        }
        return contentText;
    }
    async sendInfoMessage(title, content, text) {
        log(LogLevel.INFO)(`INFO: sending info message "${title}"`, content);
        let contentText = stringifyObject(content, 5);
        if (text) {
            contentText = this.toText(content);
        }
        const contentTextChunked = chunkString(contentText, this.maxSizeText);
        const messages = contentTextChunked.map(contentText => ([
            this.getTitle(title),
            ...(text
                ? [contentText]
                : ['\n```', this.escape(contentText), '```']),
        ].join('\n')));
        return await this.sendMessages(messages, this._JUKI_INFO_LOGS_CHAT_ID);
    }
}

const getFetcher = (url, options) => fetch(url, { body: options?.body, method: options?.method });
const jkLogTelegramBot = new TelegramBotService(getFetcher);
jkLogTelegramBot.config(TELEGRAM_JUKI_LOGS_BOT_TOKEN, TELEGRAM_JUKI_INFO_LOGS_CHAT_ID, TELEGRAM_JUKI_ERROR_LOGS_CHAT_ID);

/*
 https://github.com/visionmedia/supertest/issues/416
 
 Error-handling middleware always takes four arguments.
 You must provide four arguments to identify it as an error-handling middleware function.
 Even if you dont need to use the next object, you must specify it to maintain the signature.
 Otherwise, the next object will be interpreted as regular middleware and will fail to handle errors.
 */
function errorLoggerHandler(err, request, response, next) {
    const { headers, method, url, body, params } = request;
    const error = {
        headers,
        method,
        url,
        body,
        params,
        error: err.stack,
    };
    void jkLogTelegramBot.sendErrorMessage(`Logging error [[${url}]]`, error, getRequestData(request));
    next(err);
}
function errorResponderHandler(err, request, response, next) {
    if (request.xhr) {
        response
            .status(500)
            .send(errorsResponse(err?.message || ERROR[ErrorCode.ERR500].message, new JkError(ErrorCode.ERR500, { message: err?.message, stack: err?.stack })));
    }
    else {
        next(err);
    }
}
function failSafeHandler(err, request, response, next) {
    response
        .status(500)
        .send(errorsResponse(err?.message || ERROR[ErrorCode.ERR500].message, new JkError(ErrorCode.ERR500, { message: err?.message, stack: err?.stack })));
}
function notFoundResponse(req, res, next) {
    res.sendError(new JkError(ErrorCode.ERR404));
}

const SHOULD_DISPLAY_LOG = {
    [LogLevel.FATAL]: {
        FATAL: true,
        ERROR: false,
        WARN: false,
        INFO: false,
        DEBUG: false,
        TRACE: false,
    },
    [LogLevel.ERROR]: {
        FATAL: true,
        ERROR: true,
        WARN: false,
        INFO: false,
        DEBUG: false,
        TRACE: false,
    },
    [LogLevel.WARN]: {
        FATAL: true,
        ERROR: true,
        WARN: true,
        INFO: false,
        DEBUG: false,
        TRACE: false,
    },
    [LogLevel.INFO]: {
        FATAL: true,
        ERROR: true,
        WARN: true,
        INFO: true,
        DEBUG: false,
        TRACE: false,
    },
    [LogLevel.DEBUG]: {
        FATAL: true,
        ERROR: true,
        WARN: true,
        INFO: true,
        DEBUG: true,
        TRACE: false,
    },
    [LogLevel.TRACE]: {
        FATAL: true,
        ERROR: true,
        WARN: true,
        INFO: true,
        DEBUG: true,
        TRACE: true,
    },
};
const shouldDisplayLog = (logLevel) => {
    return SHOULD_DISPLAY_LOG[LOG_LEVEL]?.[logLevel] ?? false;
};
const log = (logLevel) => (message, content) => {
    if (shouldDisplayLog(logLevel)) {
        console.log(`[${logLevel}] ${new Date().toISOString()}, ${message}${content ? ': ' + stringifyObject(content, 5) : ''} `);
    }
};

function loggerAllRequestHandler(request, response, next) {
    const { rawHeaders, httpVersion, method, socket, url, body, params } = request;
    const { remoteAddress, remoteFamily } = socket;
    const data = {
        timestamp: Date.now(),
        rawHeaders,
        httpVersion,
        method,
        remoteAddress,
        remoteFamily,
        url,
        body,
        params,
    };
    const requestStart = Date.now();
    const no = nextNRequest().padStart(5);
    log(LogLevel.DEBUG)(`[request: ${no}] ${url}`, data);
    response.on('finish', () => log(LogLevel.DEBUG)(`[request: ${no}] ${url} [${Date.now() - requestStart}]`));
    next();
}
let nRequest = 0;
const nextNRequest = () => {
    nRequest++;
    return nRequest;
};
function loggerRequestTimeHandler(request, response, next) {
    const { url } = request;
    const requestStart = Date.now();
    const no = nextNRequest().padStart(5);
    log(LogLevel.INFO)(`[request: ${no}] ${url}`);
    response.on('finish', () => log(LogLevel.INFO)(`[request: ${no}] ${url} [${Date.now() - requestStart}]`));
    next();
}

const WITHOUT_AWS_KEYS = !!process.env.WITHOUT_AWS_KEYS;
const AWS_REGION = process.env.AWS_REGION || '';
const AWS_ACCESS_KEY_ID = process.env.AWS_ACCESS_KEY_ID || '';
const AWS_SECRET_ACCESS_KEY = process.env.AWS_SECRET_ACCESS_KEY || '';
const AWS_ECS_SECURITY_GROUPS = process.env.AWS_ECS_SECURITY_GROUPS || '';
const AWS_ECS_SUBNETS = process.env.AWS_ECS_SUBNETS || '';

new EC2Client({
    region: AWS_REGION,
    credentials: WITHOUT_AWS_KEYS
        ? undefined
        : { accessKeyId: AWS_ACCESS_KEY_ID, secretAccessKey: AWS_SECRET_ACCESS_KEY },
});

new ECSClient({
    region: AWS_REGION,
    credentials: WITHOUT_AWS_KEYS
        ? undefined
        : { accessKeyId: AWS_ACCESS_KEY_ID, secretAccessKey: AWS_SECRET_ACCESS_KEY },
});
AWS_ECS_SUBNETS.split(',');
AWS_ECS_SECURITY_GROUPS.split(',');

new S3Client({
    credentials: WITHOUT_AWS_KEYS
        ? undefined
        : { accessKeyId: AWS_ACCESS_KEY_ID, secretAccessKey: AWS_SECRET_ACCESS_KEY },
});

new SQSClient({
    region: AWS_REGION,
    apiVersion: '2012-11-05',
    credentials: WITHOUT_AWS_KEYS
        ? undefined
        : { accessKeyId: AWS_ACCESS_KEY_ID, secretAccessKey: AWS_SECRET_ACCESS_KEY },
});

const getRequestData = (request) => {
    return {
        method: request.method,
        originalUrl: request.originalUrl,
        baseUrl: request.baseUrl,
        path: request.path,
        query: request.query,
        headers: request.headers,
        body: request.body,
    };
};
const responseError = (request, response) => (error, options, ...restErrors) => {
    const { message: _message, status: _status } = options || {};
    let { notify } = options || {};
    const errors = [error, ...restErrors];
    if (errors.some(error => error.code === ErrorCode.ERR500 || !ERROR[error.code] || ERROR[error.code]?.status >= 500 || ERROR[error.code]?.status < 400)) {
        notify = true;
    }
    const message = _message || error.message;
    const status = _status || ERROR[error.code].status;
    if (notify) {
        void jkLogTelegramBot.sendErrorMessage(`${status}: ${message}`, errors, getRequestData(request));
    }
    if (!response.headersSent) {
        return response.status(status).send(errorsResponse(message, ...errors));
    }
};
const responseContents = (request, response) => (contents, meta, options) => {
    const { message: _message, status: _status, notify } = options || {};
    const message = _message || 'OK';
    const status = _status || 200;
    if (notify) {
        void jkLogTelegramBot.sendInfoMessage(`${status}: ${message}`, { contents, meta, request: getRequestData(request) });
    }
    return response.status(status).send(contentsResponse(message, contents, meta));
};
const responseContent = (request, response) => (content, options) => {
    const { message: _message, status: _status, notify } = options || {};
    const message = _message || 'OK';
    const status = _status || 200;
    if (notify) {
        void jkLogTelegramBot.sendInfoMessage(`${status}: ${message}`, { content, request: getRequestData(request) });
    }
    return response.status(status).send(contentResponse(message, content));
};

const responsesMiddleware = (req, res, next) => {
    res.sendError = responseError(req, res);
    res.sendContents = responseContents(req, res);
    res.sendContent = responseContent(req, res);
    next();
};

const initialSetupApp = () => {
    log(LogLevel.INFO)('starting initial express set up', { NODE_ENV, VERSION, PORT, ORIGINS });
    const app = express();
    app.disable('x-powered-by');
    app.use(express.json({ limit: '10mb' }));
    app.use(express.urlencoded({ extended: true }));
    if (shouldDisplayLog(LogLevel.DEBUG)) {
        app.use(loggerAllRequestHandler);
    }
    else if (shouldDisplayLog(LogLevel.INFO)) {
        app.use(loggerRequestTimeHandler);
    }
    app.use(responsesMiddleware);
    app.use(cors({ origin: ORIGINS, credentials: true }));
    app.use(cookieParser());
    log(LogLevel.INFO)('completed express set up');
    return app;
};
const finishSetupApp = (app) => {
    log(LogLevel.INFO)('starting finish express set up');
    app.use(errorLoggerHandler);
    app.use(errorResponderHandler);
    app.use(failSafeHandler);
    log(LogLevel.INFO)('completed finish express set up');
    return app.listen(PORT, () => log(LogLevel.INFO)(`listening on port ${PORT}`));
};

const stringifyObject = function (obj, depth, indent = 0) {
    if (depth < 0) {
        return '';
    }
    if (typeof obj === 'function') {
        return obj.toString();
    }
    else if (typeof obj === 'object' && obj !== null) {
        const indentStr = ' '.repeat(indent);
        const entries = Object.entries(obj).map(([key, value]) => {
            if (typeof value === 'function') {
                return `${indentStr}    ${key}: ${value.toString()},`;
            }
            else if (typeof value === 'object' && value !== null) {
                return `${indentStr}    ${key}: ${stringifyObject(value, depth - 1, indent + 4)},`;
            }
            return `${indentStr}    ${key}: ${JSON.stringify(value)},`;
        }).join('\n');
        return `{\n${entries}\n${indentStr}}`;
    }
    return JSON.stringify(obj);
};

var ImagesJukiPub;
(function (ImagesJukiPub) {
    ImagesJukiPub["O"] = "o";
    ImagesJukiPub["T"] = "t";
    ImagesJukiPub["U"] = "u";
    ImagesJukiPub["C"] = "c";
})(ImagesJukiPub || (ImagesJukiPub = {}));
var FilesJukiPub;
(function (FilesJukiPub) {
    FilesJukiPub["SHARED"] = "shared";
    FilesJukiPub["TEMP"] = "temp";
    FilesJukiPub["PROBLEMS"] = "problems";
    FilesJukiPub["CONTESTS"] = "contents";
})(FilesJukiPub || (FilesJukiPub = {}));
var FilesJukiPrivate;
(function (FilesJukiPrivate) {
    FilesJukiPrivate["TEST_CASES"] = "test-cases";
})(FilesJukiPrivate || (FilesJukiPrivate = {}));
var LinkFilesJukiLy;
(function (LinkFilesJukiLy) {
    LinkFilesJukiLy["PUBLIC"] = "p";
    LinkFilesJukiLy["CUSTOM"] = "c";
})(LinkFilesJukiLy || (LinkFilesJukiLy = {}));

var GroupStatus;
(function (GroupStatus) {
    GroupStatus["PENDING"] = "pending";
    GroupStatus["ACTIVE"] = "active";
    GroupStatus["CONCLUDED"] = "concluded";
    GroupStatus["ABANDONED"] = "abandoned";
})(GroupStatus || (GroupStatus = {}));
var GroupCrypto;
(function (GroupCrypto) {
    GroupCrypto["USDC"] = "USDC";
    GroupCrypto["SOL"] = "SOL";
})(GroupCrypto || (GroupCrypto = {}));
var GroupPeriod;
(function (GroupPeriod) {
    GroupPeriod["MONTHLY"] = "monthly";
    GroupPeriod["WEEKLY"] = "weekly";
    GroupPeriod["ALL"] = "all";
})(GroupPeriod || (GroupPeriod = {}));
var GroupWithdrawalType;
(function (GroupWithdrawalType) {
    GroupWithdrawalType["COLLATERAL"] = "collateral";
    GroupWithdrawalType["INTEREST"] = "interest";
    GroupWithdrawalType["ROUND"] = "round";
})(GroupWithdrawalType || (GroupWithdrawalType = {}));

({
    [GroupWithdrawalType.COLLATERAL]: {
        amount: 0,
        type: GroupWithdrawalType.COLLATERAL,
        timestamp: 0,
        transactionSignature: '',
    },
    [GroupWithdrawalType.ROUND]: {
        amount: 0,
        type: GroupWithdrawalType.ROUND,
        timestamp: 0,
        transactionSignature: '',
    },
    [GroupWithdrawalType.INTEREST]: {
        amount: 0,
        type: GroupWithdrawalType.INTEREST,
        timestamp: 0,
        transactionSignature: '',
    },
});

var lib$2 = {};

var admin = {};

var bson$1 = {};

var bson = {};

var hasRequiredBson$1;

function requireBson$1 () {
	if (hasRequiredBson$1) return bson;
	hasRequiredBson$1 = 1;

	function isAnyArrayBuffer(value) {
	    return ['[object ArrayBuffer]', '[object SharedArrayBuffer]'].includes(Object.prototype.toString.call(value));
	}
	function isUint8Array(value) {
	    return Object.prototype.toString.call(value) === '[object Uint8Array]';
	}
	function isRegExp(d) {
	    return Object.prototype.toString.call(d) === '[object RegExp]';
	}
	function isMap(d) {
	    return Object.prototype.toString.call(d) === '[object Map]';
	}
	function isDate(d) {
	    return Object.prototype.toString.call(d) === '[object Date]';
	}
	function defaultInspect(x, _options) {
	    return JSON.stringify(x, (k, v) => {
	        if (typeof v === 'bigint') {
	            return { $numberLong: `${v}` };
	        }
	        else if (isMap(v)) {
	            return Object.fromEntries(v);
	        }
	        return v;
	    });
	}
	function getStylizeFunction(options) {
	    const stylizeExists = options != null &&
	        typeof options === 'object' &&
	        'stylize' in options &&
	        typeof options.stylize === 'function';
	    if (stylizeExists) {
	        return options.stylize;
	    }
	}

	const BSON_MAJOR_VERSION = 6;
	const BSON_INT32_MAX = 0x7fffffff;
	const BSON_INT32_MIN = -0x80000000;
	const BSON_INT64_MAX = Math.pow(2, 63) - 1;
	const BSON_INT64_MIN = -Math.pow(2, 63);
	const JS_INT_MAX = Math.pow(2, 53);
	const JS_INT_MIN = -Math.pow(2, 53);
	const BSON_DATA_NUMBER = 1;
	const BSON_DATA_STRING = 2;
	const BSON_DATA_OBJECT = 3;
	const BSON_DATA_ARRAY = 4;
	const BSON_DATA_BINARY = 5;
	const BSON_DATA_UNDEFINED = 6;
	const BSON_DATA_OID = 7;
	const BSON_DATA_BOOLEAN = 8;
	const BSON_DATA_DATE = 9;
	const BSON_DATA_NULL = 10;
	const BSON_DATA_REGEXP = 11;
	const BSON_DATA_DBPOINTER = 12;
	const BSON_DATA_CODE = 13;
	const BSON_DATA_SYMBOL = 14;
	const BSON_DATA_CODE_W_SCOPE = 15;
	const BSON_DATA_INT = 16;
	const BSON_DATA_TIMESTAMP = 17;
	const BSON_DATA_LONG = 18;
	const BSON_DATA_DECIMAL128 = 19;
	const BSON_DATA_MIN_KEY = 0xff;
	const BSON_DATA_MAX_KEY = 0x7f;
	const BSON_BINARY_SUBTYPE_DEFAULT = 0;
	const BSON_BINARY_SUBTYPE_UUID_NEW = 4;
	const BSONType = Object.freeze({
	    double: 1,
	    string: 2,
	    object: 3,
	    array: 4,
	    binData: 5,
	    undefined: 6,
	    objectId: 7,
	    bool: 8,
	    date: 9,
	    null: 10,
	    regex: 11,
	    dbPointer: 12,
	    javascript: 13,
	    symbol: 14,
	    javascriptWithScope: 15,
	    int: 16,
	    timestamp: 17,
	    long: 18,
	    decimal: 19,
	    minKey: -1,
	    maxKey: 127
	});

	class BSONError extends Error {
	    get bsonError() {
	        return true;
	    }
	    get name() {
	        return 'BSONError';
	    }
	    constructor(message, options) {
	        super(message, options);
	    }
	    static isBSONError(value) {
	        return (value != null &&
	            typeof value === 'object' &&
	            'bsonError' in value &&
	            value.bsonError === true &&
	            'name' in value &&
	            'message' in value &&
	            'stack' in value);
	    }
	}
	class BSONVersionError extends BSONError {
	    get name() {
	        return 'BSONVersionError';
	    }
	    constructor() {
	        super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.x.x`);
	    }
	}
	class BSONRuntimeError extends BSONError {
	    get name() {
	        return 'BSONRuntimeError';
	    }
	    constructor(message) {
	        super(message);
	    }
	}
	class BSONOffsetError extends BSONError {
	    get name() {
	        return 'BSONOffsetError';
	    }
	    constructor(message, offset, options) {
	        super(`${message}. offset: ${offset}`, options);
	        this.offset = offset;
	    }
	}

	let TextDecoderFatal;
	let TextDecoderNonFatal;
	function parseUtf8(buffer, start, end, fatal) {
	    if (fatal) {
	        TextDecoderFatal ??= new TextDecoder('utf8', { fatal: true });
	        try {
	            return TextDecoderFatal.decode(buffer.subarray(start, end));
	        }
	        catch (cause) {
	            throw new BSONError('Invalid UTF-8 string in BSON document', { cause });
	        }
	    }
	    TextDecoderNonFatal ??= new TextDecoder('utf8', { fatal: false });
	    return TextDecoderNonFatal.decode(buffer.subarray(start, end));
	}

	function tryReadBasicLatin(uint8array, start, end) {
	    if (uint8array.length === 0) {
	        return '';
	    }
	    const stringByteLength = end - start;
	    if (stringByteLength === 0) {
	        return '';
	    }
	    if (stringByteLength > 20) {
	        return null;
	    }
	    if (stringByteLength === 1 && uint8array[start] < 128) {
	        return String.fromCharCode(uint8array[start]);
	    }
	    if (stringByteLength === 2 && uint8array[start] < 128 && uint8array[start + 1] < 128) {
	        return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]);
	    }
	    if (stringByteLength === 3 &&
	        uint8array[start] < 128 &&
	        uint8array[start + 1] < 128 &&
	        uint8array[start + 2] < 128) {
	        return (String.fromCharCode(uint8array[start]) +
	            String.fromCharCode(uint8array[start + 1]) +
	            String.fromCharCode(uint8array[start + 2]));
	    }
	    const latinBytes = [];
	    for (let i = start; i < end; i++) {
	        const byte = uint8array[i];
	        if (byte > 127) {
	            return null;
	        }
	        latinBytes.push(byte);
	    }
	    return String.fromCharCode(...latinBytes);
	}
	function tryWriteBasicLatin(destination, source, offset) {
	    if (source.length === 0)
	        return 0;
	    if (source.length > 25)
	        return null;
	    if (destination.length - offset < source.length)
	        return null;
	    for (let charOffset = 0, destinationOffset = offset; charOffset < source.length; charOffset++, destinationOffset++) {
	        const char = source.charCodeAt(charOffset);
	        if (char > 127)
	            return null;
	        destination[destinationOffset] = char;
	    }
	    return source.length;
	}

	function nodejsMathRandomBytes(byteLength) {
	    return nodeJsByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
	}
	const nodejsRandomBytes = (() => {
	    try {
	        return require('crypto').randomBytes;
	    }
	    catch {
	        return nodejsMathRandomBytes;
	    }
	})();
	const nodeJsByteUtils = {
	    toLocalBufferType(potentialBuffer) {
	        if (Buffer.isBuffer(potentialBuffer)) {
	            return potentialBuffer;
	        }
	        if (ArrayBuffer.isView(potentialBuffer)) {
	            return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);
	        }
	        const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);
	        if (stringTag === 'ArrayBuffer' ||
	            stringTag === 'SharedArrayBuffer' ||
	            stringTag === '[object ArrayBuffer]' ||
	            stringTag === '[object SharedArrayBuffer]') {
	            return Buffer.from(potentialBuffer);
	        }
	        throw new BSONError(`Cannot create Buffer from ${String(potentialBuffer)}`);
	    },
	    allocate(size) {
	        return Buffer.alloc(size);
	    },
	    allocateUnsafe(size) {
	        return Buffer.allocUnsafe(size);
	    },
	    equals(a, b) {
	        return nodeJsByteUtils.toLocalBufferType(a).equals(b);
	    },
	    fromNumberArray(array) {
	        return Buffer.from(array);
	    },
	    fromBase64(base64) {
	        return Buffer.from(base64, 'base64');
	    },
	    toBase64(buffer) {
	        return nodeJsByteUtils.toLocalBufferType(buffer).toString('base64');
	    },
	    fromISO88591(codePoints) {
	        return Buffer.from(codePoints, 'binary');
	    },
	    toISO88591(buffer) {
	        return nodeJsByteUtils.toLocalBufferType(buffer).toString('binary');
	    },
	    fromHex(hex) {
	        return Buffer.from(hex, 'hex');
	    },
	    toHex(buffer) {
	        return nodeJsByteUtils.toLocalBufferType(buffer).toString('hex');
	    },
	    toUTF8(buffer, start, end, fatal) {
	        const basicLatin = end - start <= 20 ? tryReadBasicLatin(buffer, start, end) : null;
	        if (basicLatin != null) {
	            return basicLatin;
	        }
	        const string = nodeJsByteUtils.toLocalBufferType(buffer).toString('utf8', start, end);
	        if (fatal) {
	            for (let i = 0; i < string.length; i++) {
	                if (string.charCodeAt(i) === 0xfffd) {
	                    parseUtf8(buffer, start, end, true);
	                    break;
	                }
	            }
	        }
	        return string;
	    },
	    utf8ByteLength(input) {
	        return Buffer.byteLength(input, 'utf8');
	    },
	    encodeUTF8Into(buffer, source, byteOffset) {
	        const latinBytesWritten = tryWriteBasicLatin(buffer, source, byteOffset);
	        if (latinBytesWritten != null) {
	            return latinBytesWritten;
	        }
	        return nodeJsByteUtils.toLocalBufferType(buffer).write(source, byteOffset, undefined, 'utf8');
	    },
	    randomBytes: nodejsRandomBytes
	};

	function isReactNative() {
	    const { navigator } = globalThis;
	    return typeof navigator === 'object' && navigator.product === 'ReactNative';
	}
	function webMathRandomBytes(byteLength) {
	    if (byteLength < 0) {
	        throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);
	    }
	    return webByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
	}
	const webRandomBytes = (() => {
	    const { crypto } = globalThis;
	    if (crypto != null && typeof crypto.getRandomValues === 'function') {
	        return (byteLength) => {
	            return crypto.getRandomValues(webByteUtils.allocate(byteLength));
	        };
	    }
	    else {
	        if (isReactNative()) {
	            const { console } = globalThis;
	            console?.warn?.('BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.');
	        }
	        return webMathRandomBytes;
	    }
	})();
	const HEX_DIGIT = /(\d|[a-f])/i;
	const webByteUtils = {
	    toLocalBufferType(potentialUint8array) {
	        const stringTag = potentialUint8array?.[Symbol.toStringTag] ??
	            Object.prototype.toString.call(potentialUint8array);
	        if (stringTag === 'Uint8Array') {
	            return potentialUint8array;
	        }
	        if (ArrayBuffer.isView(potentialUint8array)) {
	            return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));
	        }
	        if (stringTag === 'ArrayBuffer' ||
	            stringTag === 'SharedArrayBuffer' ||
	            stringTag === '[object ArrayBuffer]' ||
	            stringTag === '[object SharedArrayBuffer]') {
	            return new Uint8Array(potentialUint8array);
	        }
	        throw new BSONError(`Cannot make a Uint8Array from ${String(potentialUint8array)}`);
	    },
	    allocate(size) {
	        if (typeof size !== 'number') {
	            throw new TypeError(`The "size" argument must be of type number. Received ${String(size)}`);
	        }
	        return new Uint8Array(size);
	    },
	    allocateUnsafe(size) {
	        return webByteUtils.allocate(size);
	    },
	    equals(a, b) {
	        if (a.byteLength !== b.byteLength) {
	            return false;
	        }
	        for (let i = 0; i < a.byteLength; i++) {
	            if (a[i] !== b[i]) {
	                return false;
	            }
	        }
	        return true;
	    },
	    fromNumberArray(array) {
	        return Uint8Array.from(array);
	    },
	    fromBase64(base64) {
	        return Uint8Array.from(atob(base64), c => c.charCodeAt(0));
	    },
	    toBase64(uint8array) {
	        return btoa(webByteUtils.toISO88591(uint8array));
	    },
	    fromISO88591(codePoints) {
	        return Uint8Array.from(codePoints, c => c.charCodeAt(0) & 0xff);
	    },
	    toISO88591(uint8array) {
	        return Array.from(Uint16Array.from(uint8array), b => String.fromCharCode(b)).join('');
	    },
	    fromHex(hex) {
	        const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);
	        const buffer = [];
	        for (let i = 0; i < evenLengthHex.length; i += 2) {
	            const firstDigit = evenLengthHex[i];
	            const secondDigit = evenLengthHex[i + 1];
	            if (!HEX_DIGIT.test(firstDigit)) {
	                break;
	            }
	            if (!HEX_DIGIT.test(secondDigit)) {
	                break;
	            }
	            const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);
	            buffer.push(hexDigit);
	        }
	        return Uint8Array.from(buffer);
	    },
	    toHex(uint8array) {
	        return Array.from(uint8array, byte => byte.toString(16).padStart(2, '0')).join('');
	    },
	    toUTF8(uint8array, start, end, fatal) {
	        const basicLatin = end - start <= 20 ? tryReadBasicLatin(uint8array, start, end) : null;
	        if (basicLatin != null) {
	            return basicLatin;
	        }
	        return parseUtf8(uint8array, start, end, fatal);
	    },
	    utf8ByteLength(input) {
	        return new TextEncoder().encode(input).byteLength;
	    },
	    encodeUTF8Into(uint8array, source, byteOffset) {
	        const bytes = new TextEncoder().encode(source);
	        uint8array.set(bytes, byteOffset);
	        return bytes.byteLength;
	    },
	    randomBytes: webRandomBytes
	};

	const hasGlobalBuffer = typeof Buffer === 'function' && Buffer.prototype?._isBuffer !== true;
	const ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;

	class BSONValue {
	    get [Symbol.for('@@mdb.bson.version')]() {
	        return BSON_MAJOR_VERSION;
	    }
	    [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {
	        return this.inspect(depth, options, inspect);
	    }
	}

	class Binary extends BSONValue {
	    get _bsontype() {
	        return 'Binary';
	    }
	    constructor(buffer, subType) {
	        super();
	        if (!(buffer == null) &&
	            typeof buffer === 'string' &&
	            !ArrayBuffer.isView(buffer) &&
	            !isAnyArrayBuffer(buffer) &&
	            !Array.isArray(buffer)) {
	            throw new BSONError('Binary can only be constructed from Uint8Array or number[]');
	        }
	        this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT;
	        if (buffer == null) {
	            this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);
	            this.position = 0;
	        }
	        else {
	            this.buffer = Array.isArray(buffer)
	                ? ByteUtils.fromNumberArray(buffer)
	                : ByteUtils.toLocalBufferType(buffer);
	            this.position = this.buffer.byteLength;
	        }
	    }
	    put(byteValue) {
	        if (typeof byteValue === 'string' && byteValue.length !== 1) {
	            throw new BSONError('only accepts single character String');
	        }
	        else if (typeof byteValue !== 'number' && byteValue.length !== 1)
	            throw new BSONError('only accepts single character Uint8Array or Array');
	        let decodedByte;
	        if (typeof byteValue === 'string') {
	            decodedByte = byteValue.charCodeAt(0);
	        }
	        else if (typeof byteValue === 'number') {
	            decodedByte = byteValue;
	        }
	        else {
	            decodedByte = byteValue[0];
	        }
	        if (decodedByte < 0 || decodedByte > 255) {
	            throw new BSONError('only accepts number in a valid unsigned byte range 0-255');
	        }
	        if (this.buffer.byteLength > this.position) {
	            this.buffer[this.position++] = decodedByte;
	        }
	        else {
	            const newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);
	            newSpace.set(this.buffer, 0);
	            this.buffer = newSpace;
	            this.buffer[this.position++] = decodedByte;
	        }
	    }
	    write(sequence, offset) {
	        offset = typeof offset === 'number' ? offset : this.position;
	        if (this.buffer.byteLength < offset + sequence.length) {
	            const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);
	            newSpace.set(this.buffer, 0);
	            this.buffer = newSpace;
	        }
	        if (ArrayBuffer.isView(sequence)) {
	            this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);
	            this.position =
	                offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;
	        }
	        else if (typeof sequence === 'string') {
	            throw new BSONError('input cannot be string');
	        }
	    }
	    read(position, length) {
	        length = length && length > 0 ? length : this.position;
	        return this.buffer.slice(position, position + length);
	    }
	    value() {
	        return this.buffer.length === this.position
	            ? this.buffer
	            : this.buffer.subarray(0, this.position);
	    }
	    length() {
	        return this.position;
	    }
	    toJSON() {
	        return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
	    }
	    toString(encoding) {
	        if (encoding === 'hex')
	            return ByteUtils.toHex(this.buffer.subarray(0, this.position));
	        if (encoding === 'base64')
	            return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
	        if (encoding === 'utf8' || encoding === 'utf-8')
	            return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
	        return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
	    }
	    toExtendedJSON(options) {
	        options = options || {};
	        const base64String = ByteUtils.toBase64(this.buffer);
	        const subType = Number(this.sub_type).toString(16);
	        if (options.legacy) {
	            return {
	                $binary: base64String,
	                $type: subType.length === 1 ? '0' + subType : subType
	            };
	        }
	        return {
	            $binary: {
	                base64: base64String,
	                subType: subType.length === 1 ? '0' + subType : subType
	            }
	        };
	    }
	    toUUID() {
	        if (this.sub_type === Binary.SUBTYPE_UUID) {
	            return new UUID(this.buffer.slice(0, this.position));
	        }
	        throw new BSONError(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${Binary.SUBTYPE_UUID}" is currently supported.`);
	    }
	    static createFromHexString(hex, subType) {
	        return new Binary(ByteUtils.fromHex(hex), subType);
	    }
	    static createFromBase64(base64, subType) {
	        return new Binary(ByteUtils.fromBase64(base64), subType);
	    }
	    static fromExtendedJSON(doc, options) {
	        options = options || {};
	        let data;
	        let type;
	        if ('$binary' in doc) {
	            if (options.legacy && typeof doc.$binary === 'string' && '$type' in doc) {
	                type = doc.$type ? parseInt(doc.$type, 16) : 0;
	                data = ByteUtils.fromBase64(doc.$binary);
	            }
	            else {
	                if (typeof doc.$binary !== 'string') {
	                    type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
	                    data = ByteUtils.fromBase64(doc.$binary.base64);
	                }
	            }
	        }
	        else if ('$uuid' in doc) {
	            type = 4;
	            data = UUID.bytesFromString(doc.$uuid);
	        }
	        if (!data) {
	            throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);
	        }
	        return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);
	    }
	    inspect(depth, options, inspect) {
	        inspect ??= defaultInspect;
	        const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));
	        const base64Arg = inspect(base64, options);
	        const subTypeArg = inspect(this.sub_type, options);
	        return `Binary.createFromBase64(${base64Arg}, ${subTypeArg})`;
	    }
	}
	Binary.BSON_BINARY_SUBTYPE_DEFAULT = 0;
	Binary.BUFFER_SIZE = 256;
	Binary.SUBTYPE_DEFAULT = 0;
	Binary.SUBTYPE_FUNCTION = 1;
	Binary.SUBTYPE_BYTE_ARRAY = 2;
	Binary.SUBTYPE_UUID_OLD = 3;
	Binary.SUBTYPE_UUID = 4;
	Binary.SUBTYPE_MD5 = 5;
	Binary.SUBTYPE_ENCRYPTED = 6;
	Binary.SUBTYPE_COLUMN = 7;
	Binary.SUBTYPE_SENSITIVE = 8;
	Binary.SUBTYPE_USER_DEFINED = 128;
	const UUID_BYTE_LENGTH = 16;
	const UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;
	const UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;
	class UUID extends Binary {
	    constructor(input) {
	        let bytes;
	        if (input == null) {
	            bytes = UUID.generate();
	        }
	        else if (input instanceof UUID) {
	            bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));
	        }
	        else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {
	            bytes = ByteUtils.toLocalBufferType(input);
	        }
	        else if (typeof input === 'string') {
	            bytes = UUID.bytesFromString(input);
	        }
	        else {
	            throw new BSONError('Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).');
	        }
	        super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);
	    }
	    get id() {
	        return this.buffer;
	    }
	    set id(value) {
	        this.buffer = value;
	    }
	    toHexString(includeDashes = true) {
	        if (includeDashes) {
	            return [
	                ByteUtils.toHex(this.buffer.subarray(0, 4)),
	                ByteUtils.toHex(this.buffer.subarray(4, 6)),
	                ByteUtils.toHex(this.buffer.subarray(6, 8)),
	                ByteUtils.toHex(this.buffer.subarray(8, 10)),
	                ByteUtils.toHex(this.buffer.subarray(10, 16))
	            ].join('-');
	        }
	        return ByteUtils.toHex(this.buffer);
	    }
	    toString(encoding) {
	        if (encoding === 'hex')
	            return ByteUtils.toHex(this.id);
	        if (encoding === 'base64')
	            return ByteUtils.toBase64(this.id);
	        return this.toHexString();
	    }
	    toJSON() {
	        return this.toHexString();
	    }
	    equals(otherId) {
	        if (!otherId) {
	            return false;
	        }
	        if (otherId instanceof UUID) {
	            return ByteUtils.equals(otherId.id, this.id);
	        }
	        try {
	            return ByteUtils.equals(new UUID(otherId).id, this.id);
	        }
	        catch {
	            return false;
	        }
	    }
	    toBinary() {
	        return new Binary(this.id, Binary.SUBTYPE_UUID);
	    }
	    static generate() {
	        const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);
	        bytes[6] = (bytes[6] & 0x0f) | 0x40;
	        bytes[8] = (bytes[8] & 0x3f) | 0x80;
	        return bytes;
	    }
	    static isValid(input) {
	        if (!input) {
	            return false;
	        }
	        if (typeof input === 'string') {
	            return UUID.isValidUUIDString(input);
	        }
	        if (isUint8Array(input)) {
	            return input.byteLength === UUID_BYTE_LENGTH;
	        }
	        return (input._bsontype === 'Binary' &&
	            input.sub_type === this.SUBTYPE_UUID &&
	            input.buffer.byteLength === 16);
	    }
	    static createFromHexString(hexString) {
	        const buffer = UUID.bytesFromString(hexString);
	        return new UUID(buffer);
	    }
	    static createFromBase64(base64) {
	        return new UUID(ByteUtils.fromBase64(base64));
	    }
	    static bytesFromString(representation) {
	        if (!UUID.isValidUUIDString(representation)) {
	            throw new BSONError('UUID string representation must be 32 hex digits or canonical hyphenated representation');
	        }
	        return ByteUtils.fromHex(representation.replace(/-/g, ''));
	    }
	    static isValidUUIDString(representation) {
	        return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);
	    }
	    inspect(depth, options, inspect) {
	        inspect ??= defaultInspect;
	        return `new UUID(${inspect(this.toHexString(), options)})`;
	    }
	}

	class Code extends BSONValue {
	    get _bsontype() {
	        return 'Code';
	    }
	    constructor(code, scope) {
	        super();
	        this.code = code.toString();
	        this.scope = scope ?? null;
	    }
	    toJSON() {
	        if (this.scope != null) {
	            return { code: this.code, scope: this.scope };
	        }
	        return { code: this.code };
	    }
	    toExtendedJSON() {
	        if (this.scope) {
	            return { $code: this.code, $scope: this.scope };
	        }
	        return { $code: this.code };
	    }
	    static fromExtendedJSON(doc) {
	        return new Code(doc.$code, doc.$scope);
	    }
	    inspect(depth, options, inspect) {
	        inspect ??= defaultInspect;
	        let parametersString = inspect(this.code, options);
	        const multiLineFn = parametersString.includes('\n');
	        if (this.scope != null) {
	            parametersString += `,${multiLineFn ? '\n' : ' '}${inspect(this.scope, options)}`;
	        }
	        const endingNewline = multiLineFn && this.scope === null;
	        return `new Code(${multiLineFn ? '\n' : ''}${parametersString}${endingNewline ? '\n' : ''})`;
	    }
	}

	function isDBRefLike(value) {
	    return (value != null &&
	        typeof value === 'object' &&
	        '$id' in value &&
	        value.$id != null &&
	        '$ref' in value &&
	        typeof value.$ref === 'string' &&
	        (!('$db' in value) || ('$db' in value && typeof value.$db === 'string')));
	}
	class DBRef extends BSONValue {
	    get _bsontype() {
	        return 'DBRef';
	    }
	    constructor(collection, oid, db, fields) {
	        super();
	        const parts = collection.split('.');
	        if (parts.length === 2) {
	            db = parts.shift();
	            collection = parts.shift();
	        }
	        this.collection = collection;
	        this.oid = oid;
	        this.db = db;
	        this.fields = fields || {};
	    }
	    get namespace() {
	        return this.collection;
	    }
	    set namespace(value) {
	        this.collection = value;
	    }
	    toJSON() {
	        const o = Object.assign({
	            $ref: this.collection,
	            $id: this.oid
	        }, this.fields);
	        if (this.db != null)
	            o.$db = this.db;
	        return o;
	    }
	    toExtendedJSON(options) {
	        options = options || {};
	        let o = {
	            $ref: this.collection,
	            $id: this.oid
	        };
	        if (options.legacy) {
	            return o;
	        }
	        if (this.db)
	            o.$db = this.db;
	        o = Object.assign(o, this.fields);
	        return o;
	    }
	    static fromExtendedJSON(doc) {
	        const copy = Object.assign({}, doc);
	        delete copy.$ref;
	        delete copy.$id;
	        delete copy.$db;
	        return new DBRef(doc.$ref, doc.$id, doc.$db, copy);
	    }
	    inspect(depth, options, inspect) {
	        inspect ??= defaultInspect;
	        const args = [
	            inspect(this.namespace, options),
	            inspect(this.oid, options),
	            ...(this.db ? [inspect(this.db, options)] : []),
	            ...(Object.keys(this.fields).length > 0 ? [inspect(this.fields, options)] : [])
	        ];
	        args[1] = inspect === defaultInspect ? `new ObjectId(${args[1]})` : args[1];
	        return `new DBRef(${args.join(', ')})`;
	    }
	}

	function removeLeadingZerosAndExplicitPlus(str) {
	    if (str === '') {
	        return str;
	    }
	    let startIndex = 0;
	    const isNegative = str[startIndex] === '-';
	    const isExplicitlyPositive = str[startIndex] === '+';
	    if (isExplicitlyPositive || isNegative) {
	        startIndex += 1;
	    }
	    let foundInsignificantZero = false;
	    for (; startIndex < str.length && str[startIndex] === '0'; ++startIndex) {
	        foundInsignificantZero = true;
	    }
	    if (!foundInsignificantZero) {
	        return isExplicitlyPositive ? str.slice(1) : str;
	    }
	    return `${isNegative ? '-' : ''}${str.length === startIndex ? '0' : str.slice(startIndex)}`;
	}
	function validateStringCharacters(str, radix) {
	    radix = radix ?? 10;
	    const validCharacters = '0123456789abcdefghijklmnopqrstuvwxyz'.slice(0, radix);
	    const regex = new RegExp(`[^-+${validCharacters}]`, 'i');
	    return regex.test(str) ? false : str;
	}

	let wasm = undefined;
	try {
	    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
	}
	catch {
	}
	const TWO_PWR_16_DBL = 1 << 16;
	const TWO_PWR_24_DBL = 1 << 24;
	const TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
	const TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
	const TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
	const INT_CACHE = {};
	const UINT_CACHE = {};
	const MAX_INT64_STRING_LENGTH = 20;
	const DECIMAL_REG_EX = /^(\+?0|(\+|-)?[1-9][0-9]*)$/;
	class Long extends BSONValue {
	    get _bsontype() {
	        return 'Long';
	    }
	    get __isLong__() {
	        return true;
	    }
	    constructor(lowOrValue = 0, highOrUnsigned, unsigned) {
	        super();
	        const unsignedBool = typeof highOrUnsigned === 'boolean' ? highOrUnsigned : Boolean(unsigned);
	        const high = typeof highOrUnsigned === 'number' ? highOrUnsigned : 0;
	        const res = typeof lowOrValue === 'string'
	            ? Long.fromString(lowOrValue, unsignedBool)
	            : typeof lowOrValue === 'bigint'
	                ? Long.fromBigInt(lowOrValue, unsignedBool)
	                : { low: lowOrValue | 0, high: high | 0, unsigned: unsignedBool };
	        this.low = res.low;
	        this.high = res.high;
	        this.unsigned = res.unsigned;
	    }
	    static fromBits(lowBits, highBits, unsigned) {
	        return new Long(lowBits, highBits, unsigned);
	    }
	    static fromInt(value, unsigned) {
	        let obj, cachedObj, cache;
	        if (unsigned) {
	            value >>>= 0;
	            if ((cache = 0 <= value && value < 256)) {
	                cachedObj = UINT_CACHE[value];
	                if (cachedObj)
	                    return cachedObj;
	            }
	            obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);
	            if (cache)
	                UINT_CACHE[value] = obj;
	            return obj;
	        }
	        else {
	            value |= 0;
	            if ((cache = -128 <= value && value < 128)) {
	                cachedObj = INT_CACHE[value];
	                if (cachedObj)
	                    return cachedObj;
	            }
	            obj = Long.fromBits(value, value < 0 ? -1 : 0, false);
	            if (cache)
	                INT_CACHE[value] = obj;
	            return obj;
	        }
	    }
	    static fromNumber(value, unsigned) {
	        if (isNaN(value))
	            return unsigned ? Long.UZERO : Long.ZERO;
	        if (unsigned) {
	            if (value < 0)
	                return Long.UZERO;
	            if (value >= TWO_PWR_64_DBL)
	                return Long.MAX_UNSIGNED_VALUE;
	        }
	        else {
	            if (value <= -TWO_PWR_63_DBL)
	                return Long.MIN_VALUE;
	            if (value + 1 >= TWO_PWR_63_DBL)
	                return Long.MAX_VALUE;
	        }
	        if (value < 0)
	            return Long.fromNumber(-value, unsigned).neg();
	        return Long.fromBits(value % TWO_PWR_32_DBL | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
	    }
	    static fromBigInt(value, unsigned) {
	        const FROM_BIGINT_BIT_MASK = BigInt(0xffffffff);
	        const FROM_BIGINT_BIT_SHIFT = BigInt(32);
	        return new Long(Number(value & FROM_BIGINT_BIT_MASK), Number((value >> FROM_BIGINT_BIT_SHIFT) & FROM_BIGINT_BIT_MASK), unsigned);
	    }
	    static _fromString(str, unsigned, radix) {
	        if (str.length === 0)
	            throw new BSONError('empty string');
	        if (radix < 2 || 36 < radix)
	            throw new BSONError('radix');
	        let p;
	        if ((p = str.indexOf('-')) > 0)
	            throw new BSONError('interior hyphen');
	        else if (p === 0) {
	            return Long._fromString(str.substring(1), unsigned, radix).neg();
	        }
	        const radixToPower = Long.fromNumber(Math.pow(radix, 8));
	        let result = Long.ZERO;
	        for (let i = 0; i < str.length; i += 8) {
	            const size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
	            if (size < 8) {
	                const power = Long.fromNumber(Math.pow(radix, size));
	                result = result.mul(power).add(Long.fromNumber(value));
	            }
	            else {
	                result = result.mul(radixToPower);
	                result = result.add(Long.fromNumber(value));
	            }
	        }
	        result.unsigned = unsigned;
	        return result;
	    }
	    static fromStringStrict(str, unsignedOrRadix, radix) {
	        let unsigned = false;
	        if (typeof unsignedOrRadix === 'number') {
	            (radix = unsignedOrRadix), (unsignedOrRadix = false);
	        }
	        else {
	            unsigned = !!unsignedOrRadix;
	        }
	        radix ??= 10;
	        if (str.trim() !== str) {
	            throw new BSONError(`Input: '${str}' contains leading and/or trailing whitespace`);
	        }
	        if (!validateStringCharacters(str, radix)) {
	            throw new BSONError(`Input: '${str}' contains invalid characters for radix: ${radix}`);
	        }
	        const cleanedStr = removeLeadingZerosAndExplicitPlus(str);
	        const result = Long._fromString(cleanedStr, unsigned, radix);
	        if (result.toString(radix).toLowerCase() !== cleanedStr.toLowerCase()) {
	            throw new BSONError(`Input: ${str} is not representable as ${result.unsigned ? 'an unsigned' : 'a signed'} 64-bit Long ${radix != null ? `with radix: ${radix}` : ''}`);
	        }
	        return result;
	    }
	    static fromString(str, unsignedOrRadix, radix) {
	        let unsigned = false;
	        if (typeof unsignedOrRadix === 'number') {
	            (radix = unsignedOrRadix), (unsignedOrRadix = false);
	        }
	        else {
	            unsigned = !!unsignedOrRadix;
	        }
	        radix ??= 10;
	        if (str === 'NaN' && radix < 24) {
	            return Long.ZERO;
	        }
	        else if ((str === 'Infinity' || str === '+Infinity' || str === '-Infinity') && radix < 35) {
	            return Long.ZERO;
	        }
	        return Long._fromString(str, unsigned, radix);
	    }
	    static fromBytes(bytes, unsigned, le) {
	        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
	    }
	    static fromBytesLE(bytes, unsigned) {
	        return new Long(bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24), bytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24), unsigned);
	    }
	    static fromBytesBE(bytes, unsigned) {
	        return new Long((bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7], (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3], unsigned);
	    }
	    static isLong(value) {
	        return (value != null &&
	            typeof value === 'object' &&
	            '__isLong__' in value &&
	            value.__isLong__ === true);
	    }
	    static fromValue(val, unsigned) {
	        if (typeof val === 'number')
	            return Long.fromNumber(val, unsigned);
	        if (typeof val === 'string')
	            return Long.fromString(val, unsigned);
	        return Long.fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
	    }
	    add(addend) {
	        if (!Long.isLong(addend))
	            addend = Long.fromValue(addend);
	        const a48 = this.high >>> 16;
	        const a32 = this.high & 0xffff;
	        const a16 = this.low >>> 16;
	        const a00 = this.low & 0xffff;
	        const b48 = addend.high >>> 16;
	        const b32 = addend.high & 0xffff;
	        const b16 = addend.low >>> 16;
	        const b00 = addend.low & 0xffff;
	        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
	        c00 += a00 + b00;
	        c16 += c00 >>> 16;
	        c00 &= 0xffff;
	        c16 += a16 + b16;
	        c32 += c16 >>> 16;
	        c16 &= 0xffff;
	        c32 += a32 + b32;
	        c48 += c32 >>> 16;
	        c32 &= 0xffff;
	        c48 += a48 + b48;
	        c48 &= 0xffff;
	        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
	    }
	    and(other) {
	        if (!Long.isLong(other))
	            other = Long.fromValue(other);
	        return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
	    }
	    compare(other) {
	        if (!Long.isLong(other))
	            other = Long.fromValue(other);
	        if (this.eq(other))
	            return 0;
	        const thisNeg = this.isNegative(), otherNeg = other.isNegative();
	        if (thisNeg && !otherNeg)
	            return -1;
	        if (!thisNeg && otherNeg)
	            return 1;
	        if (!this.unsigned)
	            return this.sub(other).isNegative() ? -1 : 1;
	        return other.high >>> 0 > this.high >>> 0 ||
	            (other.high === this.high && other.low >>> 0 > this.low >>> 0)
	            ? -1
	            : 1;
	    }
	    comp(other) {
	        return this.compare(other);
	    }
	    divide(divisor) {
	        if (!Long.isLong(divisor))
	            divisor = Long.fromValue(divisor);
	        if (divisor.isZero())
	            throw new BSONError('division by zero');
	        if (wasm) {
	            if (!this.unsigned &&
	                this.high === -0x80000000 &&
	                divisor.low === -1 &&
	                divisor.high === -1) {
	                return this;
	            }
	            const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
	            return Long.fromBits(low, wasm.get_high(), this.unsigned);
	        }
	        if (this.isZero())
	            return this.unsigned ? Long.UZERO : Long.ZERO;
	        let approx, rem, res;
	        if (!this.unsigned) {
	            if (this.eq(Long.MIN_VALUE)) {
	                if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE))
	                    return Long.MIN_VALUE;
	                else if (divisor.eq(Long.MIN_VALUE))
	                    return Long.ONE;
	                else {
	                    const halfThis = this.shr(1);
	                    approx = halfThis.div(divisor).shl(1);
	                    if (approx.eq(Long.ZERO)) {
	                        return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;
	                    }
	                    else {
	                        rem = this.sub(divisor.mul(approx));
	                        res = approx.add(rem.div(divisor));
	                        return res;
	                    }
	                }
	            }
	            else if (divisor.eq(Long.MIN_VALUE))
	                return this.unsigned ? Long.UZERO : Long.ZERO;
	            if (this.isNegative()) {
	                if (divisor.isNegative())
	                    return this.neg().div(divisor.neg());
	                return this.neg().div(divisor).neg();
	            }
	            else if (divisor.isNegative())
	                return this.div(divisor.neg()).neg();
	            res = Long.ZERO;
	        }
	        else {
	            if (!divisor.unsigned)
	                divisor = divisor.toUnsigned();
	            if (divisor.gt(this))
	                return Long.UZERO;
	            if (divisor.gt(this.shru(1)))
	                return Long.UONE;
	            res = Long.UZERO;
	        }
	        rem = this;
	        while (rem.gte(divisor)) {
	            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
	            const log2 = Math.ceil(Math.log(approx) / Math.LN2);
	            const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
	            let approxRes = Long.fromNumber(approx);
	            let approxRem = approxRes.mul(divisor);
	            while (approxRem.isNegative() || approxRem.gt(rem)) {
	                approx -= delta;
	                approxRes = Long.fromNumber(approx, this.unsigned);
	                approxRem = approxRes.mul(divisor);
	            }
	            if (approxRes.isZero())
	                approxRes = Long.ONE;
	            res = res.add(approxRes);
	            rem = rem.sub(approxRem);
	        }
	        return res;
	    }
	    div(divisor) {
	        return this.divide(divisor);
	    }
	    equals(other) {
	        if (!Long.isLong(other))
	            other = Long.fromValue(other);
	        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
	            return false;
	        return this.high === other.high && this.low === other.low;
	    }
	    eq(other) {
	        return this.equals(other);
	    }
	    getHighBits() {
	        return this.high;
	    }
	    getHighBitsUnsigned() {
	        return this.high >>> 0;
	    }
	    getLowBits() {
	        return this.low;
	    }
	    getLowBitsUnsigned() {
	        return this.low >>> 0;
	    }
	    getNumBitsAbs() {
	        if (this.isNegative()) {
	            return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
	        }
	        const val = this.high !== 0 ? this.high : this.low;
	        let bit;
	        for (bit = 31; bit > 0; bit--)
	            if ((val & (1 << bit)) !== 0)
	                break;
	        return this.high !== 0 ? bit + 33 : bit + 1;
	    }
	    greaterThan(other) {
	        return this.comp(other) > 0;
	    }
	    gt(other) {
	        return this.greaterThan(other);
	    }
	    greaterThanOrEqual(other) {
	        return this.comp(other) >= 0;
	    }
	    gte(other) {
	        return this.greaterThanOrEqual(other);
	    }
	    ge(other) {
	        return this.greaterThanOrEqual(other);
	    }
	    isEven() {
	        return (this.low & 1) === 0;
	    }
	    isNegative() {
	        return !this.unsigned && this.high < 0;
	    }
	    isOdd() {
	        return (this.low & 1) === 1;
	    }
	    isPositive() {
	        return this.unsigned || this.high >= 0;
	    }
	    isZero() {
	        return this.high === 0 && this.low === 0;
	    }
	    lessThan(other) {
	        return this.comp(other) < 0;
	    }
	    lt(other) {
	        return this.lessThan(other);
	    }
	    lessThanOrEqual(other) {
	        return this.comp(other) <= 0;
	    }
	    lte(other) {
	        return this.lessThanOrEqual(other);
	    }
	    modulo(divisor) {
	        if (!Long.isLong(divisor))
	            divisor = Long.fromValue(divisor);
	        if (wasm) {
	            const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
	            return Long.fromBits(low, wasm.get_high(), this.unsigned);
	        }
	        return this.sub(this.div(divisor).mul(divisor));
	    }
	    mod(divisor) {
	        return this.modulo(divisor);
	    }
	    rem(divisor) {
	        return this.modulo(divisor);
	    }
	    multiply(multiplier) {
	        if (this.isZero())
	            return Long.ZERO;
	        if (!Long.isLong(multiplier))
	            multiplier = Long.fromValue(multiplier);
	        if (wasm) {
	            const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
	            return Long.fromBits(low, wasm.get_high(), this.unsigned);
	        }
	        if (multiplier.isZero())
	            return Long.ZERO;
	        if (this.eq(Long.MIN_VALUE))
	            return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;
	        if (multiplier.eq(Long.MIN_VALUE))
	            return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
	        if (this.isNegative()) {
	            if (multiplier.isNegative())
	                return this.neg().mul(multiplier.neg());
	            else
	                return this.neg().mul(multiplier).neg();
	        }
	        else if (multiplier.isNegative())
	            return this.mul(multiplier.neg()).neg();
	        if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24))
	            return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
	        const a48 = this.high >>> 16;
	        const a32 = this.high & 0xffff;
	        const a16 = this.low >>> 16;
	        const a00 = this.low & 0xffff;
	        const b48 = multiplier.high >>> 16;
	        const b32 = multiplier.high & 0xffff;
	        const b16 = multiplier.low >>> 16;
	        const b00 = multiplier.low & 0xffff;
	        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
	        c00 += a00 * b00;
	        c16 += c00 >>> 16;
	        c00 &= 0xffff;
	        c16 += a16 * b00;
	        c32 += c16 >>> 16;
	        c16 &= 0xffff;
	        c16 += a00 * b16;
	        c32 += c16 >>> 16;
	        c16 &= 0xffff;
	        c32 += a32 * b00;
	        c48 += c32 >>> 16;
	        c32 &= 0xffff;
	        c32 += a16 * b16;
	        c48 += c32 >>> 16;
	        c32 &= 0xffff;
	        c32 += a00 * b32;
	        c48 += c32 >>> 16;
	        c32 &= 0xffff;
	        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
	        c48 &= 0xffff;
	        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
	    }
	    mul(multiplier) {
	        return this.multiply(multiplier);
	    }
	    negate() {
	        if (!this.unsigned && this.eq(Long.MIN_VALUE))
	            return Long.MIN_VALUE;
	        return this.not().add(Long.ONE);
	    }
	    neg() {
	        return this.negate();
	    }
	    not() {
	        return Long.fromBits(~this.low, ~this.high, this.unsigned);
	    }
	    notEquals(other) {
	        return !this.equals(other);
	    }
	    neq(other) {
	        return this.notEquals(other);
	    }
	    ne(other) {
	        return this.notEquals(other);
	    }
	    or(other) {
	        if (!Long.isLong(other))
	            other = Long.fromValue(other);
	        return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
	    }
	    shiftLeft(numBits) {
	        if (Long.isLong(numBits))
	            numBits = numBits.toInt();
	        if ((numBits &= 63) === 0)
	            return this;
	        else if (numBits < 32)
	            return Long.fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
	        else
	            return Long.fromBits(0, this.low << (numBits - 32), this.unsigned);
	    }
	    shl(numBits) {
	        return this.shiftLeft(numBits);
	    }
	    shiftRight(numBits) {
	        if (Long.isLong(numBits))
	            numBits = numBits.toInt();
	        if ((numBits &= 63) === 0)
	            return this;
	        else if (numBits < 32)
	            return Long.fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
	        else
	            return Long.fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
	    }
	    shr(numBits) {
	        return this.shiftRight(numBits);
	    }
	    shiftRightUnsigned(numBits) {
	        if (Long.isLong(numBits))
	            numBits = numBits.toInt();
	        numBits &= 63;
	        if (numBits === 0)
	            return this;
	        else {
	            const high = this.high;
	            if (numBits < 32) {
	                const low = this.low;
	                return Long.fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
	            }
	            else if (numBits === 32)
	                return Long.fromBits(high, 0, this.unsigned);
	            else
	                return Long.fromBits(high >>> (numBits - 32), 0, this.unsigned);
	        }
	    }
	    shr_u(numBits) {
	        return this.shiftRightUnsigned(numBits);
	    }
	    shru(numBits) {
	        return this.shiftRightUnsigned(numBits);
	    }
	    subtract(subtrahend) {
	        if (!Long.isLong(subtrahend))
	            subtrahend = Long.fromValue(subtrahend);
	        return this.add(subtrahend.neg());
	    }
	    sub(subtrahend) {
	        return this.subtract(subtrahend);
	    }
	    toInt() {
	        return this.unsigned ? this.low >>> 0 : this.low;
	    }
	    toNumber() {
	        if (this.unsigned)
	            return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
	        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
	    }
	    toBigInt() {
	        return BigInt(this.toString());
	    }
	    toBytes(le) {
	        return le ? this.toBytesLE() : this.toBytesBE();
	    }
	    toBytesLE() {
	        const hi = this.high, lo = this.low;
	        return [
	            lo & 0xff,
	            (lo >>> 8) & 0xff,
	            (lo >>> 16) & 0xff,
	            lo >>> 24,
	            hi & 0xff,
	            (hi >>> 8) & 0xff,
	            (hi >>> 16) & 0xff,
	            hi >>> 24
	        ];
	    }
	    toBytesBE() {
	        const hi = this.high, lo = this.low;
	        return [
	            hi >>> 24,
	            (hi >>> 16) & 0xff,
	            (hi >>> 8) & 0xff,
	            hi & 0xff,
	            lo >>> 24,
	            (lo >>> 16) & 0xff,
	            (lo >>> 8) & 0xff,
	            lo & 0xff
	        ];
	    }
	    toSigned() {
	        if (!this.unsigned)
	            return this;
	        return Long.fromBits(this.low, this.high, false);
	    }
	    toString(radix) {
	        radix = radix || 10;
	        if (radix < 2 || 36 < radix)
	            throw new BSONError('radix');
	        if (this.isZero())
	            return '0';
	        if (this.isNegative()) {
	            if (this.eq(Long.MIN_VALUE)) {
	                const radixLong = Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
	                return div.toString(radix) + rem1.toInt().toString(radix);
	            }
	            else
	                return '-' + this.neg().toString(radix);
	        }
	        const radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);
	        let rem = this;
	        let result = '';
	        while (true) {
	            const remDiv = rem.div(radixToPower);
	            const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;
	            let digits = intval.toString(radix);
	            rem = remDiv;
	            if (rem.isZero()) {
	                return digits + result;
	            }
	            else {
	                while (digits.length < 6)
	                    digits = '0' + digits;
	                result = '' + digits + result;
	            }
	        }
	    }
	    toUnsigned() {
	        if (this.unsigned)
	            return this;
	        return Long.fromBits(this.low, this.high, true);
	    }
	    xor(other) {
	        if (!Long.isLong(other))
	            other = Long.fromValue(other);
	        return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
	    }
	    eqz() {
	        return this.isZero();
	    }
	    le(other) {
	        return this.lessThanOrEqual(other);
	    }
	    toExtendedJSON(options) {
	        if (options && options.relaxed)
	            return this.toNumber();
	        return { $numberLong: this.toString() };
	    }
	    static fromExtendedJSON(doc, options) {
	        const { useBigInt64 = false, relaxed = true } = { ...options };
	        if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {
	            throw new BSONError('$numberLong string is too long');
	        }
	        if (!DECIMAL_REG_EX.test(doc.$numberLong)) {
	            throw new BSONError(`$numberLong string "${doc.$numberLong}" is in an invalid format`);
	        }
	        if (useBigInt64) {
	            const bigIntResult = BigInt(doc.$numberLong);
	            return BigInt.asIntN(64, bigIntResult);
	        }
	        const longResult = Long.fromString(doc.$numberLong);
	        if (relaxed) {
	            return longResult.toNumber();
	        }
	        return longResult;
	    }
	    inspect(depth, options, inspect) {
	        inspect ??= defaultInspect;
	        const longVal = inspect(this.toString(), options);
	        const unsignedVal = this.unsigned ? `, ${inspect(this.unsigned, options)}` : '';
	        return `new Long(${longVal}${unsignedVal})`;
	    }
	}
	Long.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);
	Long.MAX_UNSIGNED_VALUE = Long.fromBits(0xffffffff | 0, 0xffffffff | 0, true);
	Long.ZERO = Long.fromInt(0);
	Long.UZERO = Long.fromInt(0, true);
	Long.ONE = Long.fromInt(1);
	Long.UONE = Long.fromInt(1, true);
	Long.NEG_ONE = Long.fromInt(-1);
	Long.MAX_VALUE = Long.fromBits(0xffffffff | 0, 0x7fffffff | 0, false);
	Long.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0, false);

	const PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
	const PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
	const PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
	const EXPONENT_MAX = 6111;
	const EXPONENT_MIN = -6176;
	const EXPONENT_BIAS = 6176;
	const MAX_DIGITS = 34;
	const NAN_BUFFER = ByteUtils.fromNumberArray([
	    0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	].reverse());
	const INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([
	    0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	].reverse());
	const INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([
	    0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	].reverse());
	const EXPONENT_REGEX = /^([-+])?(\d+)?$/;
	const COMBINATION_MASK = 0x1f;
	const EXPONENT_MASK = 0x3fff;
	const COMBINATION_INFINITY = 30;
	const COMBINATION_NAN = 31;
	function isDigit(value) {
	    return !isNaN(parseInt(value, 10));
	}
	function divideu128(value) {
	    const DIVISOR = Long.fromNumber(1000 * 1000 * 1000);
	    let _rem = Long.fromNumber(0);
	    if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
	        return { quotient: value, rem: _rem };
	    }
	    for (let i = 0; i <= 3; i++) {
	        _rem = _rem.shiftLeft(32);
	        _rem = _rem.add(new Long(value.parts[i], 0));
	        value.parts[i] = _rem.div(DIVISOR).low;
	        _rem = _rem.modulo(DIVISOR);
	    }
	    return { quotient: value, rem: _rem };
	}
	function multiply64x2(left, right) {
	    if (!left && !right) {
	        return { high: Long.fromNumber(0), low: Long.fromNumber(0) };
	    }
	    const leftHigh = left.shiftRightUnsigned(32);
	    const leftLow = new Long(left.getLowBits(), 0);
	    const rightHigh = right.shiftRightUnsigned(32);
	    const rightLow = new Long(right.getLowBits(), 0);
	    let productHigh = leftHigh.multiply(rightHigh);
	    let productMid = leftHigh.multiply(rightLow);
	    const productMid2 = leftLow.multiply(rightHigh);
	    let productLow = leftLow.multiply(rightLow);
	    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
	    productMid = new Long(productMid.getLowBits(), 0)
	        .add(productMid2)
	        .add(productLow.shiftRightUnsigned(32));
	    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
	    productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));
	    return { high: productHigh, low: productLow };
	}
	function lessThan(left, right) {
	    const uhleft = left.high >>> 0;
	    const uhright = right.high >>> 0;
	    if (uhleft < uhright) {
	        return true;
	    }
	    else if (uhleft === uhright) {
	        const ulleft = left.low >>> 0;
	        const ulright = right.low >>> 0;
	        if (ulleft < ulright)
	            return true;
	    }
	    return false;
	}
	function invalidErr(string, message) {
	    throw new BSONError(`"${string}" is not a valid Decimal128 string - ${message}`);
	}
	class Decimal128 extends BSONValue {
	    get _bsontype() {
	        return 'Decimal128';
	    }
	    constructor(bytes) {
	        super();
	        if (typeof bytes === 'string') {
	            this.bytes = Decimal128.fromString(bytes).bytes;
	        }
	        else if (isUint8Array(bytes)) {
	            if (bytes.byteLength !== 16) {
	                throw new BSONError('Decimal128 must take a Buffer of 16 bytes');
	            }
	            this.bytes = bytes;
	        }
	        else {
	            throw new BSONError('Decimal128 must take a Buffer or string');
	        }
	    }
	    static fromString(representation) {
	        return Decimal128._fromString(representation, { allowRounding: false });
	    }
	    static fromStringWithRounding(representation) {
	        return Decimal128._fromString(representation, { allowRounding: true });
	    }
	    static _fromString(representation, options) {
	        let isNegative = false;
	        let sawSign = false;
	        let sawRadix = false;
	        let foundNonZero = false;
	        let significantDigits = 0;
	        let nDigitsRead = 0;
	        let nDigits = 0;
	        let radixPosition = 0;
	        let firstNonZero = 0;
	        const digits = [0];
	        let nDigitsStored = 0;
	        let digitsInsert = 0;
	        let lastDigit = 0;
	        let exponent = 0;
	        let significandHigh = new Long(0, 0);
	        let significandLow = new Long(0, 0);
	        let biasedExponent = 0;
	        let index = 0;
	        if (representation.length >= 7000) {
	            throw new BSONError('' + representation + ' not a valid Decimal128 string');
	        }
	        const stringMatch = representation.match(PARSE_STRING_REGEXP);
	        const infMatch = representation.match(PARSE_INF_REGEXP);
	        const nanMatch = representation.match(PARSE_NAN_REGEXP);
	        if ((!stringMatch && !infMatch && !nanMatch) || representation.length === 0) {
	            throw new BSONError('' + representation + ' not a valid Decimal128 string');
	        }
	        if (stringMatch) {
	            const unsignedNumber = stringMatch[2];
	            const e = stringMatch[4];
	            const expSign = stringMatch[5];
	            const expNumber = stringMatch[6];
	            if (e && expNumber === undefined)
	                invalidErr(representation, 'missing exponent power');
	            if (e && unsignedNumber === undefined)
	                invalidErr(representation, 'missing exponent base');
	            if (e === undefined && (expSign || expNumber)) {
	                invalidErr(representation, 'missing e before exponent');
	            }
	        }
	        if (representation[index] === '+' || representation[index] === '-') {
	            sawSign = true;
	            isNegative = representation[index++] === '-';
	        }
	        if (!isDigit(representation[index]) && representation[index] !== '.') {
	            if (representation[index] === 'i' || representation[index] === 'I') {
	                return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
	            }
	            else if (representation[index] === 'N') {
	                return new Decimal128(NAN_BUFFER);
	            }
	        }
	        while (isDigit(representation[index]) || representation[index] === '.') {
	            if (representation[index] === '.') {
	                if (sawRadix)
	                    invalidErr(representation, 'contains multiple periods');
	                sawRadix = true;
	                index = index + 1;
	                continue;
	            }
	            if (nDigitsStored < MAX_DIGITS) {
	                if (representation[index] !== '0' || foundNonZero) {
	                    if (!foundNonZero) {
	                        firstNonZero = nDigitsRead;
	                    }
	                    foundNonZero = true;
	                    digits[digitsInsert++] = parseInt(representation[index], 10);
	                    nDigitsStored = nDigitsStored + 1;
	                }
	            }
	            if (foundNonZero)
	                nDigits = nDigits + 1;
	            if (sawRadix)
	                radixPosition = radixPosition + 1;
	            nDigitsRead = nDigitsRead + 1;
	            index = index + 1;
	        }
	        if (sawRadix && !nDigitsRead)
	            throw new BSONError('' + representation + ' not a valid Decimal128 string');
	        if (representation[index] === 'e' || representation[index] === 'E') {
	            const match = representation.substr(++index).match(EXPONENT_REGEX);
	            if (!match || !match[2])
	                return new Decimal128(NAN_BUFFER);
	            exponent = parseInt(match[0], 10);
	            index = index + match[0].length;
	        }
	        if (representation[index])
	            return new Decimal128(NAN_BUFFER);
	        if (!nDigitsStored) {
	            digits[0] = 0;
	            nDigits = 1;
	            nDigitsStored = 1;
	            significantDigits = 0;
	        }
	        else {
	            lastDigit = nDigitsStored - 1;
	            significantDigits = nDigits;
	            if (significantDigits !== 1) {
	                while (representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === '0') {
	                    significantDigits = significantDigits - 1;
	                }
	            }
	        }
	        if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) {
	            exponent = EXPONENT_MIN;
	        }
	        else {
	            exponent = exponent - radixPosition;
	        }
	        while (exponent > EXPONENT_MAX) {
	            lastDigit = lastDigit + 1;
	            if (lastDigit >= MAX_DIGITS) {
	                if (significantDigits === 0) {
	                    exponent = EXPONENT_MAX;
	                    break;
	                }
	                invalidErr(representation, 'overflow');
	            }
	            exponent = exponent - 1;
	        }
	        if (options.allowRounding) {
	            while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
	                if (lastDigit === 0 && significantDigits < nDigitsStored) {
	                    exponent = EXPONENT_MIN;
	                    significantDigits = 0;
	                    break;
	                }
	                if (nDigitsStored < nDigits) {
	                    nDigits = nDigits - 1;
	                }
	                else {
	                    lastDigit = lastDigit - 1;
	                }
	                if (exponent < EXPONENT_MAX) {
	                    exponent = exponent + 1;
	                }
	                else {
	                    const digitsString = digits.join('');
	                    if (digitsString.match(/^0+$/)) {
	                        exponent = EXPONENT_MAX;
	                        break;
	                    }
	                    invalidErr(representation, 'overflow');
	                }
	            }
	            if (lastDigit + 1 < significantDigits) {
	                let endOfString = nDigitsRead;
	                if (sawRadix) {
	                    firstNonZero = firstNonZero + 1;
	                    endOfString = endOfString + 1;
	                }
	                if (sawSign) {
	                    firstNonZero = firstNonZero + 1;
	                    endOfString = endOfString + 1;
	                }
	                const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
	                let roundBit = 0;
	                if (roundDigit >= 5) {
	                    roundBit = 1;
	                    if (roundDigit === 5) {
	                        roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;
	                        for (let i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
	                            if (parseInt(representation[i], 10)) {
	                                roundBit = 1;
	                                break;
	                            }
	                        }
	                    }
	                }
	                if (roundBit) {
	                    let dIdx = lastDigit;
	                    for (; dIdx >= 0; dIdx--) {
	                        if (++digits[dIdx] > 9) {
	                            digits[dIdx] = 0;
	                            if (dIdx === 0) {
	                                if (exponent < EXPONENT_MAX) {
	                                    exponent = exponent + 1;
	                                    digits[dIdx] = 1;
	                                }
	                                else {
	                                    return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
	                                }
	                            }
	                        }
	                        else {
	                            break;
	                        }
	                    }
	                }
	            }
	        }
	        else {
	            while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
	                if (lastDigit === 0) {
	                    if (significantDigits === 0) {
	                        exponent = EXPONENT_MIN;
	                        break;
	                    }
	                    invalidErr(representation, 'exponent underflow');
	                }
	                if (nDigitsStored < nDigits) {
	                    if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== '0' &&
	                        significantDigits !== 0) {
	                        invalidErr(representation, 'inexact rounding');
	                    }
	                    nDigits = nDigits - 1;
	                }
	                else {
	                    if (digits[lastDigit] !== 0) {
	                        invalidErr(representation, 'inexact rounding');
	                    }
	                    lastDigit = lastDigit - 1;
	                }
	                if (exponent < EXPONENT_MAX) {
	                    exponent = exponent + 1;
	                }
	                else {
	                    invalidErr(representation, 'overflow');
	                }
	            }
	            if (lastDigit + 1 < significantDigits) {
	                if (sawRadix) {
	                    firstNonZero = firstNonZero + 1;
	                }
	                if (sawSign) {
	                    firstNonZero = firstNonZero + 1;
	                }
	                const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
	                if (roundDigit !== 0) {
	                    invalidErr(representation, 'inexact rounding');
	                }
	            }
	        }
	        significandHigh = Long.fromNumber(0);
	        significandLow = Long.fromNumber(0);
	        if (significantDigits === 0) {
	            significandHigh = Long.fromNumber(0);
	            significandLow = Long.fromNumber(0);
	        }
	        else if (lastDigit < 17) {
	            let dIdx = 0;
	            significandLow = Long.fromNumber(digits[dIdx++]);
	            significandHigh = new Long(0, 0);
	            for (; dIdx <= lastDigit; dIdx++) {
	                significandLow = significandLow.multiply(Long.fromNumber(10));
	                significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
	            }
	        }
	        else {
	            let dIdx = 0;
	            significandHigh = Long.fromNumber(digits[dIdx++]);
	            for (; dIdx <= lastDigit - 17; dIdx++) {
	                significandHigh = significandHigh.multiply(Long.fromNumber(10));
	                significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));
	            }
	            significandLow = Long.fromNumber(digits[dIdx++]);
	            for (; dIdx <= lastDigit; dIdx++) {
	                significandLow = significandLow.multiply(Long.fromNumber(10));
	                significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
	            }
	        }
	        const significand = multiply64x2(significandHigh, Long.fromString('100000000000000000'));
	        significand.low = significand.low.add(significandLow);
	        if (lessThan(significand.low, significandLow)) {
	            significand.high = significand.high.add(Long.fromNumber(1));
	        }
	        biasedExponent = exponent + EXPONENT_BIAS;
	        const dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };
	        if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {
	            dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61));
	            dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));
	            dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));
	        }
	        else {
	            dec.high = dec.high.or(Long.fromNumber(biasedExponent & 0x3fff).shiftLeft(49));
	            dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));
	        }
	        dec.low = significand.low;
	        if (isNegative) {
	            dec.high = dec.high.or(Long.fromString('9223372036854775808'));
	        }
	        const buffer = ByteUtils.allocateUnsafe(16);
	        index = 0;
	        buffer[index++] = dec.low.low & 0xff;
	        buffer[index++] = (dec.low.low >> 8) & 0xff;
	        buffer[index++] = (dec.low.low >> 16) & 0xff;
	        buffer[index++] = (dec.low.low >> 24) & 0xff;
	        buffer[index++] = dec.low.high & 0xff;
	        buffer[index++] = (dec.low.high >> 8) & 0xff;
	        buffer[index++] = (dec.low.high >> 16) & 0xff;
	        buffer[index++] = (dec.low.high >> 24) & 0xff;
	        buffer[index++] = dec.high.low & 0xff;
	        buffer[index++] = (dec.high.low >> 8) & 0xff;
	        buffer[index++] = (dec.high.low >> 16) & 0xff;
	        buffer[index++] = (dec.high.low >> 24) & 0xff;
	        buffer[index++] = dec.high.high & 0xff;
	        buffer[index++] = (dec.high.high >> 8) & 0xff;
	        buffer[index++] = (dec.high.high >> 16) & 0xff;
	        buffer[index++] = (dec.high.high >> 24) & 0xff;
	        return new Decimal128(buffer);
	    }
	    toString() {
	        let biased_exponent;
	        let significand_digits = 0;
	        const significand = new Array(36);
	        for (let i = 0; i < significand.length; i++)
	            significand[i] = 0;
	        let index = 0;
	        let is_zero = false;
	        let significand_msb;
	        let significand128 = { parts: [0, 0, 0, 0] };
	        let j, k;
	        const string = [];
	        index = 0;
	        const buffer = this.bytes;
	        const low = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);
	        const midl = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);
	        const midh = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);
	        const high = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);
	        index = 0;
	        const dec = {
	            low: new Long(low, midl),
	            high: new Long(midh, high)
	        };
	        if (dec.high.lessThan(Long.ZERO)) {
	            string.push('-');
	        }
	        const combination = (high >> 26) & COMBINATION_MASK;
	        if (combination >> 3 === 3) {
	            if (combination === COMBINATION_INFINITY) {
	                return string.join('') + 'Infinity';
	            }
	            else if (combination === COMBINATION_NAN) {
	                return 'NaN';
	            }
	            else {
	                biased_exponent = (high >> 15) & EXPONENT_MASK;
	                significand_msb = 0x08 + ((high >> 14) & 0x01);
	            }
	        }
	        else {
	            significand_msb = (high >> 14) & 0x07;
	            biased_exponent = (high >> 17) & EXPONENT_MASK;
	        }
	        const exponent = biased_exponent - EXPONENT_BIAS;
	        significand128.parts[0] = (high & 0x3fff) + ((significand_msb & 0xf) << 14);
	        significand128.parts[1] = midh;
	        significand128.parts[2] = midl;
	        significand128.parts[3] = low;
	        if (significand128.parts[0] === 0 &&
	            significand128.parts[1] === 0 &&
	            significand128.parts[2] === 0 &&
	            significand128.parts[3] === 0) {
	            is_zero = true;
	        }
	        else {
	            for (k = 3; k >= 0; k--) {
	                let least_digits = 0;
	                const result = divideu128(significand128);
	                significand128 = result.quotient;
	                least_digits = result.rem.low;
	                if (!least_digits)
	                    continue;
	                for (j = 8; j >= 0; j--) {
	                    significand[k * 9 + j] = least_digits % 10;
	                    least_digits = Math.floor(least_digits / 10);
	                }
	            }
	        }
	        if (is_zero) {
	            significand_digits = 1;
	            significand[index] = 0;
	        }
	        else {
	            significand_digits = 36;
	            while (!significand[index]) {
	                significand_digits = significand_digits - 1;
	                index = index + 1;
	            }
	        }
	        const scientific_exponent = significand_digits - 1 + exponent;
	        if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
	            if (significand_digits > 34) {
	                string.push(`${0}`);
	                if (exponent > 0)
	                    string.push(`E+${exponent}`);
	                else if (exponent < 0)
	                    string.push(`E${exponent}`);
	                return string.join('');
	            }
	            string.push(`${significand[index++]}`);
	            significand_digits = significand_digits - 1;
	            if (significand_digits) {
	                string.push('.');
	            }
	            for (let i = 0; i < significand_digits; i++) {
	                string.push(`${significand[index++]}`);
	            }
	            string.push('E');
	            if (scientific_exponent > 0) {
	                string.push(`+${scientific_exponent}`);
	            }
	            else {
	                string.push(`${scientific_exponent}`);
	            }
	        }
	        else {
	            if (exponent >= 0) {
	                for (let i = 0; i < significand_digits; i++) {
	                    string.push(`${significand[index++]}`);
	                }
	            }
	            else {
	                let radix_position = significand_digits + exponent;
	                if (radix_position > 0) {
	                    for (let i = 0; i < radix_position; i++) {
	                        string.push(`${significand[index++]}`);
	                    }
	                }
	                else {
	                    string.push('0');
	                }
	                string.push('.');
	                while (radix_position++ < 0) {
	                    string.push('0');
	                }
	                for (let i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {
	                    string.push(`${significand[index++]}`);
	                }
	            }
	        }
	        return string.join('');
	    }
	    toJSON() {
	        return { $numberDecimal: this.toString() };
	    }
	    toExtendedJSON() {
	        return { $numberDecimal: this.toString() };
	    }
	    static fromExtendedJSON(doc) {
	        return Decimal128.fromString(doc.$numberDecimal);
	    }
	    inspect(depth, options, inspect) {
	        inspect ??= defaultInspect;
	        const d128string = inspect(this.toString(), options);
	        return `new Decimal128(${d128string})`;
	    }
	}

	class Double extends BSONValue {
	    get _bsontype() {
	        return 'Double';
	    }
	    constructor(value) {
	        super();
	        if (value instanceof Number) {
	            value = value.valueOf();
	        }
	        this.value = +value;
	    }
	    static fromString(value) {
	        const coercedValue = Number(value);
	        if (value === 'NaN')
	            return new Double(NaN);
	        if (value === 'Infinity')
	            return new Double(Infinity);
	        if (value === '-Infinity')
	            return new Double(-Infinity);
	        if (!Number.isFinite(coercedValue)) {
	            throw new BSONError(`Input: ${value} is not representable as a Double`);
	        }
	        if (value.trim() !== value) {
	            throw new BSONError(`Input: '${value}' contains whitespace`);
	        }
	        if (value === '') {
	            throw new BSONError(`Input is an empty string`);
	        }
	        if (/[^-0-9.+eE]/.test(value)) {
	            throw new BSONError(`Input: '${value}' is not in decimal or exponential notation`);
	        }
	        return new Double(coercedValue);
	    }
	    valueOf() {
	        return this.value;
	    }
	    toJSON() {
	        return this.value;
	    }
	    toString(radix) {
	        return this.value.toString(radix);
	    }
	    toExtendedJSON(options) {
	        if (options && (options.legacy || (options.relaxed && isFinite(this.value)))) {
	            return this.value;
	        }
	        if (Object.is(Math.sign(this.value), -0)) {
	            return { $numberDouble: '-0.0' };
	        }
	        return {
	            $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()
	        };
	    }
	    static fromExtendedJSON(doc, options) {
	        const doubleValue = parseFloat(doc.$numberDouble);
	        return options && options.relaxed ? doubleValue : new Double(doubleValue);
	    }
	    inspect(depth, options, inspect) {
	        inspect ??= defaultInspect;
	        return `new Double(${inspect(this.value, options)})`;
	    }
	}

	class Int32 extends BSONValue {
	    get _bsontype() {
	        return 'Int32';
	    }
	    constructor(value) {
	        super();
	        if (value instanceof Number) {
	            value = value.valueOf();
	        }
	        this.value = +value | 0;
	    }
	    static fromString(value) {
	        const cleanedValue = removeLeadingZerosAndExplicitPlus(value);
	        const coercedValue = Number(value);
	        if (BSON_INT32_MAX < coercedValue) {
	            throw new BSONError(`Input: '${value}' is larger than the maximum value for Int32`);
	        }
	        else if (BSON_INT32_MIN > coercedValue) {
	            throw new BSONError(`Input: '${value}' is smaller than the minimum value for Int32`);
	        }
	        else if (!Number.isSafeInteger(coercedValue)) {
	            throw new BSONError(`Input: '${value}' is not a safe integer`);
	        }
	        else if (coercedValue.toString() !== cleanedValue) {
	            throw new BSONError(`Input: '${value}' is not a valid Int32 string`);
	        }
	        return new Int32(coercedValue);
	    }
	    valueOf() {
	        return this.value;
	    }
	    toString(radix) {
	        return this.value.toString(radix);
	    }
	    toJSON() {
	        return this.value;
	    }
	    toExtendedJSON(options) {
	        if (options && (options.relaxed || options.legacy))
	            return this.value;
	        return { $numberInt: this.value.toString() };
	    }
	    static fromExtendedJSON(doc, options) {
	        return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);
	    }
	    inspect(depth, options, inspect) {
	        inspect ??= defaultInspect;
	        return `new Int32(${inspect(this.value, options)})`;
	    }
	}

	class MaxKey extends BSONValue {
	    get _bsontype() {
	        return 'MaxKey';
	    }
	    toExtendedJSON() {
	        return { $maxKey: 1 };
	    }
	    static fromExtendedJSON() {
	        return new MaxKey();
	    }
	    inspect() {
	        return 'new MaxKey()';
	    }
	}

	class MinKey extends BSONValue {
	    get _bsontype() {
	        return 'MinKey';
	    }
	    toExtendedJSON() {
	        return { $minKey: 1 };
	    }
	    static fromExtendedJSON() {
	        return new MinKey();
	    }
	    inspect() {
	        return 'new MinKey()';
	    }
	}

	const FLOAT = new Float64Array(1);
	const FLOAT_BYTES = new Uint8Array(FLOAT.buffer, 0, 8);
	FLOAT[0] = -1;
	const isBigEndian = FLOAT_BYTES[7] === 0;
	const NumberUtils = {
	    getNonnegativeInt32LE(source, offset) {
	        if (source[offset + 3] > 127) {
	            throw new RangeError(`Size cannot be negative at offset: ${offset}`);
	        }
	        return (source[offset] |
	            (source[offset + 1] << 8) |
	            (source[offset + 2] << 16) |
	            (source[offset + 3] << 24));
	    },
	    getInt32LE(source, offset) {
	        return (source[offset] |
	            (source[offset + 1] << 8) |
	            (source[offset + 2] << 16) |
	            (source[offset + 3] << 24));
	    },
	    getUint32LE(source, offset) {
	        return (source[offset] +
	            source[offset + 1] * 256 +
	            source[offset + 2] * 65536 +
	            source[offset + 3] * 16777216);
	    },
	    getUint32BE(source, offset) {
	        return (source[offset + 3] +
	            source[offset + 2] * 256 +
	            source[offset + 1] * 65536 +
	            source[offset] * 16777216);
	    },
	    getBigInt64LE(source, offset) {
	        const lo = NumberUtils.getUint32LE(source, offset);
	        const hi = NumberUtils.getUint32LE(source, offset + 4);
	        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
	    },
	    getFloat64LE: isBigEndian
	        ? (source, offset) => {
	            FLOAT_BYTES[7] = source[offset];
	            FLOAT_BYTES[6] = source[offset + 1];
	            FLOAT_BYTES[5] = source[offset + 2];
	            FLOAT_BYTES[4] = source[offset + 3];
	            FLOAT_BYTES[3] = source[offset + 4];
	            FLOAT_BYTES[2] = source[offset + 5];
	            FLOAT_BYTES[1] = source[offset + 6];
	            FLOAT_BYTES[0] = source[offset + 7];
	            return FLOAT[0];
	        }
	        : (source, offset) => {
	            FLOAT_BYTES[0] = source[offset];
	            FLOAT_BYTES[1] = source[offset + 1];
	            FLOAT_BYTES[2] = source[offset + 2];
	            FLOAT_BYTES[3] = source[offset + 3];
	            FLOAT_BYTES[4] = source[offset + 4];
	            FLOAT_BYTES[5] = source[offset + 5];
	            FLOAT_BYTES[6] = source[offset + 6];
	            FLOAT_BYTES[7] = source[offset + 7];
	            return FLOAT[0];
	        },
	    setInt32BE(destination, offset, value) {
	        destination[offset + 3] = value;
	        value >>>= 8;
	        destination[offset + 2] = value;
	        value >>>= 8;
	        destination[offset + 1] = value;
	        value >>>= 8;
	        destination[offset] = value;
	        return 4;
	    },
	    setInt32LE(destination, offset, value) {
	        destination[offset] = value;
	        value >>>= 8;
	        destination[offset + 1] = value;
	        value >>>= 8;
	        destination[offset + 2] = value;
	        value >>>= 8;
	        destination[offset + 3] = value;
	        return 4;
	    },
	    setBigInt64LE(destination, offset, value) {
	        const mask32bits = BigInt(4294967295);
	        let lo = Number(value & mask32bits);
	        destination[offset] = lo;
	        lo >>= 8;
	        destination[offset + 1] = lo;
	        lo >>= 8;
	        destination[offset + 2] = lo;
	        lo >>= 8;
	        destination[offset + 3] = lo;
	        let hi = Number((value >> BigInt(32)) & mask32bits);
	        destination[offset + 4] = hi;
	        hi >>= 8;
	        destination[offset + 5] = hi;
	        hi >>= 8;
	        destination[offset + 6] = hi;
	        hi >>= 8;
	        destination[offset + 7] = hi;
	        return 8;
	    },
	    setFloat64LE: isBigEndian
	        ? (destination, offset, value) => {
	            FLOAT[0] = value;
	            destination[offset] = FLOAT_BYTES[7];
	            destination[offset + 1] = FLOAT_BYTES[6];
	            destination[offset + 2] = FLOAT_BYTES[5];
	            destination[offset + 3] = FLOAT_BYTES[4];
	            destination[offset + 4] = FLOAT_BYTES[3];
	            destination[offset + 5] = FLOAT_BYTES[2];
	            destination[offset + 6] = FLOAT_BYTES[1];
	            destination[offset + 7] = FLOAT_BYTES[0];
	            return 8;
	        }
	        : (destination, offset, value) => {
	            FLOAT[0] = value;
	            destination[offset] = FLOAT_BYTES[0];
	            destination[offset + 1] = FLOAT_BYTES[1];
	            destination[offset + 2] = FLOAT_BYTES[2];
	            destination[offset + 3] = FLOAT_BYTES[3];
	            destination[offset + 4] = FLOAT_BYTES[4];
	            destination[offset + 5] = FLOAT_BYTES[5];
	            destination[offset + 6] = FLOAT_BYTES[6];
	            destination[offset + 7] = FLOAT_BYTES[7];
	            return 8;
	        }
	};

	const checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$');
	let PROCESS_UNIQUE = null;
	class ObjectId extends BSONValue {
	    get _bsontype() {
	        return 'ObjectId';
	    }
	    constructor(inputId) {
	        super();
	        let workingId;
	        if (typeof inputId === 'object' && inputId && 'id' in inputId) {
	            if (typeof inputId.id !== 'string' && !ArrayBuffer.isView(inputId.id)) {
	                throw new BSONError('Argument passed in must have an id that is of type string or Buffer');
	            }
	            if ('toHexString' in inputId && typeof inputId.toHexString === 'function') {
	                workingId = ByteUtils.fromHex(inputId.toHexString());
	            }
	            else {
	                workingId = inputId.id;
	            }
	        }
	        else {
	            workingId = inputId;
	        }
	        if (workingId == null || typeof workingId === 'number') {
	            this.buffer = ObjectId.generate(typeof workingId === 'number' ? workingId : undefined);
	        }
	        else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {
	            this.buffer = ByteUtils.toLocalBufferType(workingId);
	        }
	        else if (typeof workingId === 'string') {
	            if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {
	                this.buffer = ByteUtils.fromHex(workingId);
	            }
	            else {
	                throw new BSONError('input must be a 24 character hex string, 12 byte Uint8Array, or an integer');
	            }
	        }
	        else {
	            throw new BSONError('Argument passed in does not match the accepted types');
	        }
	        if (ObjectId.cacheHexString) {
	            this.__id = ByteUtils.toHex(this.id);
	        }
	    }
	    get id() {
	        return this.buffer;
	    }
	    set id(value) {
	        this.buffer = value;
	        if (ObjectId.cacheHexString) {
	            this.__id = ByteUtils.toHex(value);
	        }
	    }
	    toHexString() {
	        if (ObjectId.cacheHexString && this.__id) {
	            return this.__id;
	        }
	        const hexString = ByteUtils.toHex(this.id);
	        if (ObjectId.cacheHexString && !this.__id) {
	            this.__id = hexString;
	        }
	        return hexString;
	    }
	    static getInc() {
	        return (ObjectId.index = (ObjectId.index + 1) % 0xffffff);
	    }
	    static generate(time) {
	        if ('number' !== typeof time) {
	            time = Math.floor(Date.now() / 1000);
	        }
	        const inc = ObjectId.getInc();
	        const buffer = ByteUtils.allocateUnsafe(12);
	        NumberUtils.setInt32BE(buffer, 0, time);
	        if (PROCESS_UNIQUE === null) {
	            PROCESS_UNIQUE = ByteUtils.randomBytes(5);
	        }
	        buffer[4] = PROCESS_UNIQUE[0];
	        buffer[5] = PROCESS_UNIQUE[1];
	        buffer[6] = PROCESS_UNIQUE[2];
	        buffer[7] = PROCESS_UNIQUE[3];
	        buffer[8] = PROCESS_UNIQUE[4];
	        buffer[11] = inc & 0xff;
	        buffer[10] = (inc >> 8) & 0xff;
	        buffer[9] = (inc >> 16) & 0xff;
	        return buffer;
	    }
	    toString(encoding) {
	        if (encoding === 'base64')
	            return ByteUtils.toBase64(this.id);
	        if (encoding === 'hex')
	            return this.toHexString();
	        return this.toHexString();
	    }
	    toJSON() {
	        return this.toHexString();
	    }
	    static is(variable) {
	        return (variable != null &&
	            typeof variable === 'object' &&
	            '_bsontype' in variable &&
	            variable._bsontype === 'ObjectId');
	    }
	    equals(otherId) {
	        if (otherId === undefined || otherId === null) {
	            return false;
	        }
	        if (ObjectId.is(otherId)) {
	            return (this.buffer[11] === otherId.buffer[11] && ByteUtils.equals(this.buffer, otherId.buffer));
	        }
	        if (typeof otherId === 'string') {
	            return otherId.toLowerCase() === this.toHexString();
	        }
	        if (typeof otherId === 'object' && typeof otherId.toHexString === 'function') {
	            const otherIdString = otherId.toHexString();
	            const thisIdString = this.toHexString();
	            return typeof otherIdString === 'string' && otherIdString.toLowerCase() === thisIdString;
	        }
	        return false;
	    }
	    getTimestamp() {
	        const timestamp = new Date();
	        const time = NumberUtils.getUint32BE(this.buffer, 0);
	        timestamp.setTime(Math.floor(time) * 1000);
	        return timestamp;
	    }
	    static createPk() {
	        return new ObjectId();
	    }
	    serializeInto(uint8array, index) {
	        uint8array[index] = this.buffer[0];
	        uint8array[index + 1] = this.buffer[1];
	        uint8array[index + 2] = this.buffer[2];
	        uint8array[index + 3] = this.buffer[3];
	        uint8array[index + 4] = this.buffer[4];
	        uint8array[index + 5] = this.buffer[5];
	        uint8array[index + 6] = this.buffer[6];
	        uint8array[index + 7] = this.buffer[7];
	        uint8array[index + 8] = this.buffer[8];
	        uint8array[index + 9] = this.buffer[9];
	        uint8array[index + 10] = this.buffer[10];
	        uint8array[index + 11] = this.buffer[11];
	        return 12;
	    }
	    static createFromTime(time) {
	        const buffer = ByteUtils.allocate(12);
	        for (let i = 11; i >= 4; i--)
	            buffer[i] = 0;
	        NumberUtils.setInt32BE(buffer, 0, time);
	        return new ObjectId(buffer);
	    }
	    static createFromHexString(hexString) {
	        if (hexString?.length !== 24) {
	            throw new BSONError('hex string must be 24 characters');
	        }
	        return new ObjectId(ByteUtils.fromHex(hexString));
	    }
	    static createFromBase64(base64) {
	        if (base64?.length !== 16) {
	            throw new BSONError('base64 string must be 16 characters');
	        }
	        return new ObjectId(ByteUtils.fromBase64(base64));
	    }
	    static isValid(id) {
	        if (id == null)
	            return false;
	        try {
	            new ObjectId(id);
	            return true;
	        }
	        catch {
	            return false;
	        }
	    }
	    toExtendedJSON() {
	        if (this.toHexString)
	            return { $oid: this.toHexString() };
	        return { $oid: this.toString('hex') };
	    }
	    static fromExtendedJSON(doc) {
	        return new ObjectId(doc.$oid);
	    }
	    inspect(depth, options, inspect) {
	        inspect ??= defaultInspect;
	        return `new ObjectId(${inspect(this.toHexString(), options)})`;
	    }
	}
	ObjectId.index = Math.floor(Math.random() * 0xffffff);

	function internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {
	    let totalLength = 4 + 1;
	    if (Array.isArray(object)) {
	        for (let i = 0; i < object.length; i++) {
	            totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
	        }
	    }
	    else {
	        if (typeof object?.toBSON === 'function') {
	            object = object.toBSON();
	        }
	        for (const key of Object.keys(object)) {
	            totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
	        }
	    }
	    return totalLength;
	}
	function calculateElement(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) {
	    if (typeof value?.toBSON === 'function') {
	        value = value.toBSON();
	    }
	    switch (typeof value) {
	        case 'string':
	            return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;
	        case 'number':
	            if (Math.floor(value) === value &&
	                value >= JS_INT_MIN &&
	                value <= JS_INT_MAX) {
	                if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
	                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);
	                }
	                else {
	                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
	                }
	            }
	            else {
	                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
	            }
	        case 'undefined':
	            if (isArray || !ignoreUndefined)
	                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
	            return 0;
	        case 'boolean':
	            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);
	        case 'object':
	            if (value != null &&
	                typeof value._bsontype === 'string' &&
	                value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {
	                throw new BSONVersionError();
	            }
	            else if (value == null || value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {
	                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
	            }
	            else if (value._bsontype === 'ObjectId') {
	                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);
	            }
	            else if (value instanceof Date || isDate(value)) {
	                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
	            }
	            else if (ArrayBuffer.isView(value) ||
	                value instanceof ArrayBuffer ||
	                isAnyArrayBuffer(value)) {
	                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength);
	            }
	            else if (value._bsontype === 'Long' ||
	                value._bsontype === 'Double' ||
	                value._bsontype === 'Timestamp') {
	                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
	            }
	            else if (value._bsontype === 'Decimal128') {
	                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);
	            }
	            else if (value._bsontype === 'Code') {
	                if (value.scope != null && Object.keys(value.scope).length > 0) {
	                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +
	                        1 +
	                        4 +
	                        4 +
	                        ByteUtils.utf8ByteLength(value.code.toString()) +
	                        1 +
	                        internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined));
	                }
	                else {
	                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +
	                        1 +
	                        4 +
	                        ByteUtils.utf8ByteLength(value.code.toString()) +
	                        1);
	                }
	            }
	            else if (value._bsontype === 'Binary') {
	                const binary = value;
	                if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
	                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +
	                        (binary.position + 1 + 4 + 1 + 4));
	                }
	                else {
	                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1));
	                }
	            }
	            else if (value._bsontype === 'Symbol') {
	                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +
	                    ByteUtils.utf8ByteLength(value.value) +
	                    4 +
	                    1 +
	                    1);
	            }
	            else if (value._bsontype === 'DBRef') {
	                const ordered_values = Object.assign({
	                    $ref: value.collection,
	                    $id: value.oid
	                }, value.fields);
	                if (value.db != null) {
	                    ordered_values['$db'] = value.db;
	                }
	                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +
	                    1 +
	                    internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined));
	            }
	            else if (value instanceof RegExp || isRegExp(value)) {
	                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +
	                    1 +
	                    ByteUtils.utf8ByteLength(value.source) +
	                    1 +
	                    (value.global ? 1 : 0) +
	                    (value.ignoreCase ? 1 : 0) +
	                    (value.multiline ? 1 : 0) +
	                    1);
	            }
	            else if (value._bsontype === 'BSONRegExp') {
	                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +
	                    1 +
	                    ByteUtils.utf8ByteLength(value.pattern) +
	                    1 +
	                    ByteUtils.utf8ByteLength(value.options) +
	                    1);
	            }
	            else {
	                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +
	                    internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) +
	                    1);
	            }
	        case 'function':
	            if (serializeFunctions) {
	                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +
	                    1 +
	                    4 +
	                    ByteUtils.utf8ByteLength(value.toString()) +
	                    1);
	            }
	    }
	    return 0;
	}

	function alphabetize(str) {
	    return str.split('').sort().join('');
	}
	class BSONRegExp extends BSONValue {
	    get _bsontype() {
	        return 'BSONRegExp';
	    }
	    constructor(pattern, options) {
	        super();
	        this.pattern = pattern;
	        this.options = alphabetize(options ?? '');
	        if (this.pattern.indexOf('\x00') !== -1) {
	            throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);
	        }
	        if (this.options.indexOf('\x00') !== -1) {
	            throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);
	        }
	        for (let i = 0; i < this.options.length; i++) {
	            if (!(this.options[i] === 'i' ||
	                this.options[i] === 'm' ||
	                this.options[i] === 'x' ||
	                this.options[i] === 'l' ||
	                this.options[i] === 's' ||
	                this.options[i] === 'u')) {
	                throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);
	            }
	        }
	    }
	    static parseOptions(options) {
	        return options ? options.split('').sort().join('') : '';
	    }
	    toExtendedJSON(options) {
	        options = options || {};
	        if (options.legacy) {
	            return { $regex: this.pattern, $options: this.options };
	        }
	        return { $regularExpression: { pattern: this.pattern, options: this.options } };
	    }
	    static fromExtendedJSON(doc) {
	        if ('$regex' in doc) {
	            if (typeof doc.$regex !== 'string') {
	                if (doc.$regex._bsontype === 'BSONRegExp') {
	                    return doc;
	                }
	            }
	            else {
	                return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));
	            }
	        }
	        if ('$regularExpression' in doc) {
	            return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));
	        }
	        throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);
	    }
	    inspect(depth, options, inspect) {
	        const stylize = getStylizeFunction(options) ?? (v => v);
	        inspect ??= defaultInspect;
	        const pattern = stylize(inspect(this.pattern), 'regexp');
	        const flags = stylize(inspect(this.options), 'regexp');
	        return `new BSONRegExp(${pattern}, ${flags})`;
	    }
	}

	class BSONSymbol extends BSONValue {
	    get _bsontype() {
	        return 'BSONSymbol';
	    }
	    constructor(value) {
	        super();
	        this.value = value;
	    }
	    valueOf() {
	        return this.value;
	    }
	    toString() {
	        return this.value;
	    }
	    toJSON() {
	        return this.value;
	    }
	    toExtendedJSON() {
	        return { $symbol: this.value };
	    }
	    static fromExtendedJSON(doc) {
	        return new BSONSymbol(doc.$symbol);
	    }
	    inspect(depth, options, inspect) {
	        inspect ??= defaultInspect;
	        return `new BSONSymbol(${inspect(this.value, options)})`;
	    }
	}

	const LongWithoutOverridesClass = Long;
	class Timestamp extends LongWithoutOverridesClass {
	    get _bsontype() {
	        return 'Timestamp';
	    }
	    constructor(low) {
	        if (low == null) {
	            super(0, 0, true);
	        }
	        else if (typeof low === 'bigint') {
	            super(low, true);
	        }
	        else if (Long.isLong(low)) {
	            super(low.low, low.high, true);
	        }
	        else if (typeof low === 'object' && 't' in low && 'i' in low) {
	            if (typeof low.t !== 'number' && (typeof low.t !== 'object' || low.t._bsontype !== 'Int32')) {
	                throw new BSONError('Timestamp constructed from { t, i } must provide t as a number');
	            }
	            if (typeof low.i !== 'number' && (typeof low.i !== 'object' || low.i._bsontype !== 'Int32')) {
	                throw new BSONError('Timestamp constructed from { t, i } must provide i as a number');
	            }
	            const t = Number(low.t);
	            const i = Number(low.i);
	            if (t < 0 || Number.isNaN(t)) {
	                throw new BSONError('Timestamp constructed from { t, i } must provide a positive t');
	            }
	            if (i < 0 || Number.isNaN(i)) {
	                throw new BSONError('Timestamp constructed from { t, i } must provide a positive i');
	            }
	            if (t > 4294967295) {
	                throw new BSONError('Timestamp constructed from { t, i } must provide t equal or less than uint32 max');
	            }
	            if (i > 4294967295) {
	                throw new BSONError('Timestamp constructed from { t, i } must provide i equal or less than uint32 max');
	            }
	            super(i, t, true);
	        }
	        else {
	            throw new BSONError('A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }');
	        }
	    }
	    toJSON() {
	        return {
	            $timestamp: this.toString()
	        };
	    }
	    static fromInt(value) {
	        return new Timestamp(Long.fromInt(value, true));
	    }
	    static fromNumber(value) {
	        return new Timestamp(Long.fromNumber(value, true));
	    }
	    static fromBits(lowBits, highBits) {
	        return new Timestamp({ i: lowBits, t: highBits });
	    }
	    static fromString(str, optRadix) {
	        return new Timestamp(Long.fromString(str, true, optRadix));
	    }
	    toExtendedJSON() {
	        return { $timestamp: { t: this.high >>> 0, i: this.low >>> 0 } };
	    }
	    static fromExtendedJSON(doc) {
	        const i = Long.isLong(doc.$timestamp.i)
	            ? doc.$timestamp.i.getLowBitsUnsigned()
	            : doc.$timestamp.i;
	        const t = Long.isLong(doc.$timestamp.t)
	            ? doc.$timestamp.t.getLowBitsUnsigned()
	            : doc.$timestamp.t;
	        return new Timestamp({ t, i });
	    }
	    inspect(depth, options, inspect) {
	        inspect ??= defaultInspect;
	        const t = inspect(this.high >>> 0, options);
	        const i = inspect(this.low >>> 0, options);
	        return `new Timestamp({ t: ${t}, i: ${i} })`;
	    }
	}
	Timestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;

	const JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);
	const JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);
	function internalDeserialize(buffer, options, isArray) {
	    options = options == null ? {} : options;
	    const index = options && options.index ? options.index : 0;
	    const size = NumberUtils.getInt32LE(buffer, index);
	    if (size < 5) {
	        throw new BSONError(`bson size must be >= 5, is ${size}`);
	    }
	    if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {
	        throw new BSONError(`buffer length ${buffer.length} must be >= bson size ${size}`);
	    }
	    if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {
	        throw new BSONError(`buffer length ${buffer.length} must === bson size ${size}`);
	    }
	    if (size + index > buffer.byteLength) {
	        throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer.byteLength})`);
	    }
	    if (buffer[index + size - 1] !== 0) {
	        throw new BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
	    }
	    return deserializeObject(buffer, index, options, isArray);
	}
	const allowedDBRefKeys = /^\$ref$|^\$id$|^\$db$/;
	function deserializeObject(buffer, index, options, isArray = false) {
	    const fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];
	    const raw = options['raw'] == null ? false : options['raw'];
	    const bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false;
	    const promoteBuffers = options.promoteBuffers ?? false;
	    const promoteLongs = options.promoteLongs ?? true;
	    const promoteValues = options.promoteValues ?? true;
	    const useBigInt64 = options.useBigInt64 ?? false;
	    if (useBigInt64 && !promoteValues) {
	        throw new BSONError('Must either request bigint or Long for int64 deserialization');
	    }
	    if (useBigInt64 && !promoteLongs) {
	        throw new BSONError('Must either request bigint or Long for int64 deserialization');
	    }
	    const validation = options.validation == null ? { utf8: true } : options.validation;
	    let globalUTFValidation = true;
	    let validationSetting;
	    let utf8KeysSet;
	    const utf8ValidatedKeys = validation.utf8;
	    if (typeof utf8ValidatedKeys === 'boolean') {
	        validationSetting = utf8ValidatedKeys;
	    }
	    else {
	        globalUTFValidation = false;
	        const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function (key) {
	            return utf8ValidatedKeys[key];
	        });
	        if (utf8ValidationValues.length === 0) {
	            throw new BSONError('UTF-8 validation setting cannot be empty');
	        }
	        if (typeof utf8ValidationValues[0] !== 'boolean') {
	            throw new BSONError('Invalid UTF-8 validation option, must specify boolean values');
	        }
	        validationSetting = utf8ValidationValues[0];
	        if (!utf8ValidationValues.every(item => item === validationSetting)) {
	            throw new BSONError('Invalid UTF-8 validation option - keys must be all true or all false');
	        }
	    }
	    if (!globalUTFValidation) {
	        utf8KeysSet = new Set();
	        for (const key of Object.keys(utf8ValidatedKeys)) {
	            utf8KeysSet.add(key);
	        }
	    }
	    const startIndex = index;
	    if (buffer.length < 5)
	        throw new BSONError('corrupt bson message < 5 bytes long');
	    const size = NumberUtils.getInt32LE(buffer, index);
	    index += 4;
	    if (size < 5 || size > buffer.length)
	        throw new BSONError('corrupt bson message');
	    const object = isArray ? [] : {};
	    let arrayIndex = 0;
	    const done = false;
	    let isPossibleDBRef = isArray ? false : null;
	    while (!done) {
	        const elementType = buffer[index++];
	        if (elementType === 0)
	            break;
	        let i = index;
	        while (buffer[i] !== 0x00 && i < buffer.length) {
	            i++;
	        }
	        if (i >= buffer.byteLength)
	            throw new BSONError('Bad BSON Document: illegal CString');
	        const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer, index, i, false);
	        let shouldValidateKey = true;
	        if (globalUTFValidation || utf8KeysSet?.has(name)) {
	            shouldValidateKey = validationSetting;
	        }
	        else {
	            shouldValidateKey = !validationSetting;
	        }
	        if (isPossibleDBRef !== false && name[0] === '$') {
	            isPossibleDBRef = allowedDBRefKeys.test(name);
	        }
	        let value;
	        index = i + 1;
	        if (elementType === BSON_DATA_STRING) {
	            const stringSize = NumberUtils.getInt32LE(buffer, index);
	            index += 4;
	            if (stringSize <= 0 ||
	                stringSize > buffer.length - index ||
	                buffer[index + stringSize - 1] !== 0) {
	                throw new BSONError('bad string length in bson');
	            }
	            value = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);
	            index = index + stringSize;
	        }
	        else if (elementType === BSON_DATA_OID) {
	            const oid = ByteUtils.allocateUnsafe(12);
	            for (let i = 0; i < 12; i++)
	                oid[i] = buffer[index + i];
	            value = new ObjectId(oid);
	            index = index + 12;
	        }
	        else if (elementType === BSON_DATA_INT && promoteValues === false) {
	            value = new Int32(NumberUtils.getInt32LE(buffer, index));
	            index += 4;
	        }
	        else if (elementType === BSON_DATA_INT) {
	            value = NumberUtils.getInt32LE(buffer, index);
	            index += 4;
	        }
	        else if (elementType === BSON_DATA_NUMBER) {
	            value = NumberUtils.getFloat64LE(buffer, index);
	            index += 8;
	            if (promoteValues === false)
	                value = new Double(value);
	        }
	        else if (elementType === BSON_DATA_DATE) {
	            const lowBits = NumberUtils.getInt32LE(buffer, index);
	            const highBits = NumberUtils.getInt32LE(buffer, index + 4);
	            index += 8;
	            value = new Date(new Long(lowBits, highBits).toNumber());
	        }
	        else if (elementType === BSON_DATA_BOOLEAN) {
	            if (buffer[index] !== 0 && buffer[index] !== 1)
	                throw new BSONError('illegal boolean type value');
	            value = buffer[index++] === 1;
	        }
	        else if (elementType === BSON_DATA_OBJECT) {
	            const _index = index;
	            const objectSize = NumberUtils.getInt32LE(buffer, index);
	            if (objectSize <= 0 || objectSize > buffer.length - index)
	                throw new BSONError('bad embedded document length in bson');
	            if (raw) {
	                value = buffer.slice(index, index + objectSize);
	            }
	            else {
	                let objectOptions = options;
	                if (!globalUTFValidation) {
	                    objectOptions = { ...options, validation: { utf8: shouldValidateKey } };
	                }
	                value = deserializeObject(buffer, _index, objectOptions, false);
	            }
	            index = index + objectSize;
	        }
	        else if (elementType === BSON_DATA_ARRAY) {
	            const _index = index;
	            const objectSize = NumberUtils.getInt32LE(buffer, index);
	            let arrayOptions = options;
	            const stopIndex = index + objectSize;
	            if (fieldsAsRaw && fieldsAsRaw[name]) {
	                arrayOptions = { ...options, raw: true };
	            }
	            if (!globalUTFValidation) {
	                arrayOptions = { ...arrayOptions, validation: { utf8: shouldValidateKey } };
	            }
	            value = deserializeObject(buffer, _index, arrayOptions, true);
	            index = index + objectSize;
	            if (buffer[index - 1] !== 0)
	                throw new BSONError('invalid array terminator byte');
	            if (index !== stopIndex)
	                throw new BSONError('corrupted array bson');
	        }
	        else if (elementType === BSON_DATA_UNDEFINED) {
	            value = undefined;
	        }
	        else if (elementType === BSON_DATA_NULL) {
	            value = null;
	        }
	        else if (elementType === BSON_DATA_LONG) {
	            if (useBigInt64) {
	                value = NumberUtils.getBigInt64LE(buffer, index);
	                index += 8;
	            }
	            else {
	                const lowBits = NumberUtils.getInt32LE(buffer, index);
	                const highBits = NumberUtils.getInt32LE(buffer, index + 4);
	                index += 8;
	                const long = new Long(lowBits, highBits);
	                if (promoteLongs && promoteValues === true) {
	                    value =
	                        long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG)
	                            ? long.toNumber()
	                            : long;
	                }
	                else {
	                    value = long;
	                }
	            }
	        }
	        else if (elementType === BSON_DATA_DECIMAL128) {
	            const bytes = ByteUtils.allocateUnsafe(16);
	            for (let i = 0; i < 16; i++)
	                bytes[i] = buffer[index + i];
	            index = index + 16;
	            value = new Decimal128(bytes);
	        }
	        else if (elementType === BSON_DATA_BINARY) {
	            let binarySize = NumberUtils.getInt32LE(buffer, index);
	            index += 4;
	            const totalBinarySize = binarySize;
	            const subType = buffer[index++];
	            if (binarySize < 0)
	                throw new BSONError('Negative binary type element size found');
	            if (binarySize > buffer.byteLength)
	                throw new BSONError('Binary type size larger than document size');
	            if (buffer['slice'] != null) {
	                if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
	                    binarySize = NumberUtils.getInt32LE(buffer, index);
	                    index += 4;
	                    if (binarySize < 0)
	                        throw new BSONError('Negative binary type element size found for subtype 0x02');
	                    if (binarySize > totalBinarySize - 4)
	                        throw new BSONError('Binary type with subtype 0x02 contains too long binary size');
	                    if (binarySize < totalBinarySize - 4)
	                        throw new BSONError('Binary type with subtype 0x02 contains too short binary size');
	                }
	                if (promoteBuffers && promoteValues) {
	                    value = ByteUtils.toLocalBufferType(buffer.slice(index, index + binarySize));
	                }
	                else {
	                    value = new Binary(buffer.slice(index, index + binarySize), subType);
	                    if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {
	                        value = value.toUUID();
	                    }
	                }
	            }
	            else {
	                if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
	                    binarySize = NumberUtils.getInt32LE(buffer, index);
	                    index += 4;
	                    if (binarySize < 0)
	                        throw new BSONError('Negative binary type element size found for subtype 0x02');
	                    if (binarySize > totalBinarySize - 4)
	                        throw new BSONError('Binary type with subtype 0x02 contains too long binary size');
	                    if (binarySize < totalBinarySize - 4)
	                        throw new BSONError('Binary type with subtype 0x02 contains too short binary size');
	                }
	                if (promoteBuffers && promoteValues) {
	                    value = ByteUtils.allocateUnsafe(binarySize);
	                    for (i = 0; i < binarySize; i++) {
	                        value[i] = buffer[index + i];
	                    }
	                }
	                else {
	                    value = new Binary(buffer.slice(index, index + binarySize), subType);
	                    if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {
	                        value = value.toUUID();
	                    }
	                }
	            }
	            index = index + binarySize;
	        }
	        else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {
	            i = index;
	            while (buffer[i] !== 0x00 && i < buffer.length) {
	                i++;
	            }
	            if (i >= buffer.length)
	                throw new BSONError('Bad BSON Document: illegal CString');
	            const source = ByteUtils.toUTF8(buffer, index, i, false);
	            index = i + 1;
	            i = index;
	            while (buffer[i] !== 0x00 && i < buffer.length) {
	                i++;
	            }
	            if (i >= buffer.length)
	                throw new BSONError('Bad BSON Document: illegal CString');
	            const regExpOptions = ByteUtils.toUTF8(buffer, index, i, false);
	            index = i + 1;
	            const optionsArray = new Array(regExpOptions.length);
	            for (i = 0; i < regExpOptions.length; i++) {
	                switch (regExpOptions[i]) {
	                    case 'm':
	                        optionsArray[i] = 'm';
	                        break;
	                    case 's':
	                        optionsArray[i] = 'g';
	                        break;
	                    case 'i':
	                        optionsArray[i] = 'i';
	                        break;
	                }
	            }
	            value = new RegExp(source, optionsArray.join(''));
	        }
	        else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {
	            i = index;
	            while (buffer[i] !== 0x00 && i < buffer.length) {
	                i++;
	            }
	            if (i >= buffer.length)
	                throw new BSONError('Bad BSON Document: illegal CString');
	            const source = ByteUtils.toUTF8(buffer, index, i, false);
	            index = i + 1;
	            i = index;
	            while (buffer[i] !== 0x00 && i < buffer.length) {
	                i++;
	            }
	            if (i >= buffer.length)
	                throw new BSONError('Bad BSON Document: illegal CString');
	            const regExpOptions = ByteUtils.toUTF8(buffer, index, i, false);
	            index = i + 1;
	            value = new BSONRegExp(source, regExpOptions);
	        }
	        else if (elementType === BSON_DATA_SYMBOL) {
	            const stringSize = NumberUtils.getInt32LE(buffer, index);
	            index += 4;
	            if (stringSize <= 0 ||
	                stringSize > buffer.length - index ||
	                buffer[index + stringSize - 1] !== 0) {
	                throw new BSONError('bad string length in bson');
	            }
	            const symbol = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);
	            value = promoteValues ? symbol : new BSONSymbol(symbol);
	            index = index + stringSize;
	        }
	        else if (elementType === BSON_DATA_TIMESTAMP) {
	            value = new Timestamp({
	                i: NumberUtils.getUint32LE(buffer, index),
	                t: NumberUtils.getUint32LE(buffer, index + 4)
	            });
	            index += 8;
	        }
	        else if (elementType === BSON_DATA_MIN_KEY) {
	            value = new MinKey();
	        }
	        else if (elementType === BSON_DATA_MAX_KEY) {
	            value = new MaxKey();
	        }
	        else if (elementType === BSON_DATA_CODE) {
	            const stringSize = NumberUtils.getInt32LE(buffer, index);
	            index += 4;
	            if (stringSize <= 0 ||
	                stringSize > buffer.length - index ||
	                buffer[index + stringSize - 1] !== 0) {
	                throw new BSONError('bad string length in bson');
	            }
	            const functionString = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);
	            value = new Code(functionString);
	            index = index + stringSize;
	        }
	        else if (elementType === BSON_DATA_CODE_W_SCOPE) {
	            const totalSize = NumberUtils.getInt32LE(buffer, index);
	            index += 4;
	            if (totalSize < 4 + 4 + 4 + 1) {
	                throw new BSONError('code_w_scope total size shorter minimum expected length');
	            }
	            const stringSize = NumberUtils.getInt32LE(buffer, index);
	            index += 4;
	            if (stringSize <= 0 ||
	                stringSize > buffer.length - index ||
	                buffer[index + stringSize - 1] !== 0) {
	                throw new BSONError('bad string length in bson');
	            }
	            const functionString = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);
	            index = index + stringSize;
	            const _index = index;
	            const objectSize = NumberUtils.getInt32LE(buffer, index);
	            const scopeObject = deserializeObject(buffer, _index, options, false);
	            index = index + objectSize;
	            if (totalSize < 4 + 4 + objectSize + stringSize) {
	                throw new BSONError('code_w_scope total size is too short, truncating scope');
	            }
	            if (totalSize > 4 + 4 + objectSize + stringSize) {
	                throw new BSONError('code_w_scope total size is too long, clips outer document');
	            }
	            value = new Code(functionString, scopeObject);
	        }
	        else if (elementType === BSON_DATA_DBPOINTER) {
	            const stringSize = NumberUtils.getInt32LE(buffer, index);
	            index += 4;
	            if (stringSize <= 0 ||
	                stringSize > buffer.length - index ||
	                buffer[index + stringSize - 1] !== 0)
	                throw new BSONError('bad string length in bson');
	            const namespace = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);
	            index = index + stringSize;
	            const oidBuffer = ByteUtils.allocateUnsafe(12);
	            for (let i = 0; i < 12; i++)
	                oidBuffer[i] = buffer[index + i];
	            const oid = new ObjectId(oidBuffer);
	            index = index + 12;
	            value = new DBRef(namespace, oid);
	        }
	        else {
	            throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname "${name}"`);
	        }
	        if (name === '__proto__') {
	            Object.defineProperty(object, name, {
	                value,
	                writable: true,
	                enumerable: true,
	                configurable: true
	            });
	        }
	        else {
	            object[name] = value;
	        }
	    }
	    if (size !== index - startIndex) {
	        if (isArray)
	            throw new BSONError('corrupt array bson');
	        throw new BSONError('corrupt object bson');
	    }
	    if (!isPossibleDBRef)
	        return object;
	    if (isDBRefLike(object)) {
	        const copy = Object.assign({}, object);
	        delete copy.$ref;
	        delete copy.$id;
	        delete copy.$db;
	        return new DBRef(object.$ref, object.$id, object.$db, copy);
	    }
	    return object;
	}

	const regexp = /\x00/;
	const ignoreKeys = new Set(['$db', '$ref', '$id', '$clusterTime']);
	function serializeString(buffer, key, value, index) {
	    buffer[index++] = BSON_DATA_STRING;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes + 1;
	    buffer[index - 1] = 0;
	    const size = ByteUtils.encodeUTF8Into(buffer, value, index + 4);
	    NumberUtils.setInt32LE(buffer, index, size + 1);
	    index = index + 4 + size;
	    buffer[index++] = 0;
	    return index;
	}
	function serializeNumber(buffer, key, value, index) {
	    const isNegativeZero = Object.is(value, -0);
	    const type = !isNegativeZero &&
	        Number.isSafeInteger(value) &&
	        value <= BSON_INT32_MAX &&
	        value >= BSON_INT32_MIN
	        ? BSON_DATA_INT
	        : BSON_DATA_NUMBER;
	    buffer[index++] = type;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0x00;
	    if (type === BSON_DATA_INT) {
	        index += NumberUtils.setInt32LE(buffer, index, value);
	    }
	    else {
	        index += NumberUtils.setFloat64LE(buffer, index, value);
	    }
	    return index;
	}
	function serializeBigInt(buffer, key, value, index) {
	    buffer[index++] = BSON_DATA_LONG;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index += numberOfWrittenBytes;
	    buffer[index++] = 0;
	    index += NumberUtils.setBigInt64LE(buffer, index, value);
	    return index;
	}
	function serializeNull(buffer, key, _, index) {
	    buffer[index++] = BSON_DATA_NULL;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    return index;
	}
	function serializeBoolean(buffer, key, value, index) {
	    buffer[index++] = BSON_DATA_BOOLEAN;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    buffer[index++] = value ? 1 : 0;
	    return index;
	}
	function serializeDate(buffer, key, value, index) {
	    buffer[index++] = BSON_DATA_DATE;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    const dateInMilis = Long.fromNumber(value.getTime());
	    const lowBits = dateInMilis.getLowBits();
	    const highBits = dateInMilis.getHighBits();
	    index += NumberUtils.setInt32LE(buffer, index, lowBits);
	    index += NumberUtils.setInt32LE(buffer, index, highBits);
	    return index;
	}
	function serializeRegExp(buffer, key, value, index) {
	    buffer[index++] = BSON_DATA_REGEXP;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    if (value.source && value.source.match(regexp) != null) {
	        throw new BSONError('value ' + value.source + ' must not contain null bytes');
	    }
	    index = index + ByteUtils.encodeUTF8Into(buffer, value.source, index);
	    buffer[index++] = 0x00;
	    if (value.ignoreCase)
	        buffer[index++] = 0x69;
	    if (value.global)
	        buffer[index++] = 0x73;
	    if (value.multiline)
	        buffer[index++] = 0x6d;
	    buffer[index++] = 0x00;
	    return index;
	}
	function serializeBSONRegExp(buffer, key, value, index) {
	    buffer[index++] = BSON_DATA_REGEXP;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    if (value.pattern.match(regexp) != null) {
	        throw new BSONError('pattern ' + value.pattern + ' must not contain null bytes');
	    }
	    index = index + ByteUtils.encodeUTF8Into(buffer, value.pattern, index);
	    buffer[index++] = 0x00;
	    const sortedOptions = value.options.split('').sort().join('');
	    index = index + ByteUtils.encodeUTF8Into(buffer, sortedOptions, index);
	    buffer[index++] = 0x00;
	    return index;
	}
	function serializeMinMax(buffer, key, value, index) {
	    if (value === null) {
	        buffer[index++] = BSON_DATA_NULL;
	    }
	    else if (value._bsontype === 'MinKey') {
	        buffer[index++] = BSON_DATA_MIN_KEY;
	    }
	    else {
	        buffer[index++] = BSON_DATA_MAX_KEY;
	    }
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    return index;
	}
	function serializeObjectId(buffer, key, value, index) {
	    buffer[index++] = BSON_DATA_OID;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    index += value.serializeInto(buffer, index);
	    return index;
	}
	function serializeBuffer(buffer, key, value, index) {
	    buffer[index++] = BSON_DATA_BINARY;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    const size = value.length;
	    index += NumberUtils.setInt32LE(buffer, index, size);
	    buffer[index++] = BSON_BINARY_SUBTYPE_DEFAULT;
	    if (size <= 16) {
	        for (let i = 0; i < size; i++)
	            buffer[index + i] = value[i];
	    }
	    else {
	        buffer.set(value, index);
	    }
	    index = index + size;
	    return index;
	}
	function serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {
	    if (path.has(value)) {
	        throw new BSONError('Cannot convert circular structure to BSON');
	    }
	    path.add(value);
	    buffer[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    const endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
	    path.delete(value);
	    return endIndex;
	}
	function serializeDecimal128(buffer, key, value, index) {
	    buffer[index++] = BSON_DATA_DECIMAL128;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    for (let i = 0; i < 16; i++)
	        buffer[index + i] = value.bytes[i];
	    return index + 16;
	}
	function serializeLong(buffer, key, value, index) {
	    buffer[index++] =
	        value._bsontype === 'Long' ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    const lowBits = value.getLowBits();
	    const highBits = value.getHighBits();
	    index += NumberUtils.setInt32LE(buffer, index, lowBits);
	    index += NumberUtils.setInt32LE(buffer, index, highBits);
	    return index;
	}
	function serializeInt32(buffer, key, value, index) {
	    value = value.valueOf();
	    buffer[index++] = BSON_DATA_INT;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    index += NumberUtils.setInt32LE(buffer, index, value);
	    return index;
	}
	function serializeDouble(buffer, key, value, index) {
	    buffer[index++] = BSON_DATA_NUMBER;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    index += NumberUtils.setFloat64LE(buffer, index, value.value);
	    return index;
	}
	function serializeFunction(buffer, key, value, index) {
	    buffer[index++] = BSON_DATA_CODE;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    const functionString = value.toString();
	    const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;
	    NumberUtils.setInt32LE(buffer, index, size);
	    index = index + 4 + size - 1;
	    buffer[index++] = 0;
	    return index;
	}
	function serializeCode(buffer, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) {
	    if (value.scope && typeof value.scope === 'object') {
	        buffer[index++] = BSON_DATA_CODE_W_SCOPE;
	        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	        index = index + numberOfWrittenBytes;
	        buffer[index++] = 0;
	        let startIndex = index;
	        const functionString = value.code;
	        index = index + 4;
	        const codeSize = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;
	        NumberUtils.setInt32LE(buffer, index, codeSize);
	        buffer[index + 4 + codeSize - 1] = 0;
	        index = index + codeSize + 4;
	        const endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
	        index = endIndex - 1;
	        const totalSize = endIndex - startIndex;
	        startIndex += NumberUtils.setInt32LE(buffer, startIndex, totalSize);
	        buffer[index++] = 0;
	    }
	    else {
	        buffer[index++] = BSON_DATA_CODE;
	        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	        index = index + numberOfWrittenBytes;
	        buffer[index++] = 0;
	        const functionString = value.code.toString();
	        const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;
	        NumberUtils.setInt32LE(buffer, index, size);
	        index = index + 4 + size - 1;
	        buffer[index++] = 0;
	    }
	    return index;
	}
	function serializeBinary(buffer, key, value, index) {
	    buffer[index++] = BSON_DATA_BINARY;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    const data = value.buffer;
	    let size = value.position;
	    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY)
	        size = size + 4;
	    index += NumberUtils.setInt32LE(buffer, index, size);
	    buffer[index++] = value.sub_type;
	    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
	        size = size - 4;
	        index += NumberUtils.setInt32LE(buffer, index, size);
	    }
	    if (size <= 16) {
	        for (let i = 0; i < size; i++)
	            buffer[index + i] = data[i];
	    }
	    else {
	        buffer.set(data, index);
	    }
	    index = index + value.position;
	    return index;
	}
	function serializeSymbol(buffer, key, value, index) {
	    buffer[index++] = BSON_DATA_SYMBOL;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    const size = ByteUtils.encodeUTF8Into(buffer, value.value, index + 4) + 1;
	    NumberUtils.setInt32LE(buffer, index, size);
	    index = index + 4 + size - 1;
	    buffer[index++] = 0;
	    return index;
	}
	function serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path) {
	    buffer[index++] = BSON_DATA_OBJECT;
	    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    let startIndex = index;
	    let output = {
	        $ref: value.collection || value.namespace,
	        $id: value.oid
	    };
	    if (value.db != null) {
	        output.$db = value.db;
	    }
	    output = Object.assign(output, value.fields);
	    const endIndex = serializeInto(buffer, output, false, index, depth + 1, serializeFunctions, true, path);
	    const size = endIndex - startIndex;
	    startIndex += NumberUtils.setInt32LE(buffer, index, size);
	    return endIndex;
	}
	function serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
	    if (path == null) {
	        if (object == null) {
	            buffer[0] = 0x05;
	            buffer[1] = 0x00;
	            buffer[2] = 0x00;
	            buffer[3] = 0x00;
	            buffer[4] = 0x00;
	            return 5;
	        }
	        if (Array.isArray(object)) {
	            throw new BSONError('serialize does not support an array as the root input');
	        }
	        if (typeof object !== 'object') {
	            throw new BSONError('serialize does not support non-object as the root input');
	        }
	        else if ('_bsontype' in object && typeof object._bsontype === 'string') {
	            throw new BSONError(`BSON types cannot be serialized as a document`);
	        }
	        else if (isDate(object) ||
	            isRegExp(object) ||
	            isUint8Array(object) ||
	            isAnyArrayBuffer(object)) {
	            throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);
	        }
	        path = new Set();
	    }
	    path.add(object);
	    let index = startingIndex + 4;
	    if (Array.isArray(object)) {
	        for (let i = 0; i < object.length; i++) {
	            const key = `${i}`;
	            let value = object[i];
	            if (typeof value?.toBSON === 'function') {
	                value = value.toBSON();
	            }
	            if (typeof value === 'string') {
	                index = serializeString(buffer, key, value, index);
	            }
	            else if (typeof value === 'number') {
	                index = serializeNumber(buffer, key, value, index);
	            }
	            else if (typeof value === 'bigint') {
	                index = serializeBigInt(buffer, key, value, index);
	            }
	            else if (typeof value === 'boolean') {
	                index = serializeBoolean(buffer, key, value, index);
	            }
	            else if (value instanceof Date || isDate(value)) {
	                index = serializeDate(buffer, key, value, index);
	            }
	            else if (value === undefined) {
	                index = serializeNull(buffer, key, value, index);
	            }
	            else if (value === null) {
	                index = serializeNull(buffer, key, value, index);
	            }
	            else if (isUint8Array(value)) {
	                index = serializeBuffer(buffer, key, value, index);
	            }
	            else if (value instanceof RegExp || isRegExp(value)) {
	                index = serializeRegExp(buffer, key, value, index);
	            }
	            else if (typeof value === 'object' && value._bsontype == null) {
	                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
	            }
	            else if (typeof value === 'object' &&
	                value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {
	                throw new BSONVersionError();
	            }
	            else if (value._bsontype === 'ObjectId') {
	                index = serializeObjectId(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'Decimal128') {
	                index = serializeDecimal128(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {
	                index = serializeLong(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'Double') {
	                index = serializeDouble(buffer, key, value, index);
	            }
	            else if (typeof value === 'function' && serializeFunctions) {
	                index = serializeFunction(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'Code') {
	                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
	            }
	            else if (value._bsontype === 'Binary') {
	                index = serializeBinary(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'BSONSymbol') {
	                index = serializeSymbol(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'DBRef') {
	                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);
	            }
	            else if (value._bsontype === 'BSONRegExp') {
	                index = serializeBSONRegExp(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'Int32') {
	                index = serializeInt32(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {
	                index = serializeMinMax(buffer, key, value, index);
	            }
	            else if (typeof value._bsontype !== 'undefined') {
	                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
	            }
	        }
	    }
	    else if (object instanceof Map || isMap(object)) {
	        const iterator = object.entries();
	        let done = false;
	        while (!done) {
	            const entry = iterator.next();
	            done = !!entry.done;
	            if (done)
	                continue;
	            const key = entry.value[0];
	            let value = entry.value[1];
	            if (typeof value?.toBSON === 'function') {
	                value = value.toBSON();
	            }
	            const type = typeof value;
	            if (typeof key === 'string' && !ignoreKeys.has(key)) {
	                if (key.match(regexp) != null) {
	                    throw new BSONError('key ' + key + ' must not contain null bytes');
	                }
	                if (checkKeys) {
	                    if ('$' === key[0]) {
	                        throw new BSONError('key ' + key + " must not start with '$'");
	                    }
	                    else if (key.includes('.')) {
	                        throw new BSONError('key ' + key + " must not contain '.'");
	                    }
	                }
	            }
	            if (type === 'string') {
	                index = serializeString(buffer, key, value, index);
	            }
	            else if (type === 'number') {
	                index = serializeNumber(buffer, key, value, index);
	            }
	            else if (type === 'bigint') {
	                index = serializeBigInt(buffer, key, value, index);
	            }
	            else if (type === 'boolean') {
	                index = serializeBoolean(buffer, key, value, index);
	            }
	            else if (value instanceof Date || isDate(value)) {
	                index = serializeDate(buffer, key, value, index);
	            }
	            else if (value === null || (value === undefined && ignoreUndefined === false)) {
	                index = serializeNull(buffer, key, value, index);
	            }
	            else if (isUint8Array(value)) {
	                index = serializeBuffer(buffer, key, value, index);
	            }
	            else if (value instanceof RegExp || isRegExp(value)) {
	                index = serializeRegExp(buffer, key, value, index);
	            }
	            else if (type === 'object' && value._bsontype == null) {
	                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
	            }
	            else if (typeof value === 'object' &&
	                value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {
	                throw new BSONVersionError();
	            }
	            else if (value._bsontype === 'ObjectId') {
	                index = serializeObjectId(buffer, key, value, index);
	            }
	            else if (type === 'object' && value._bsontype === 'Decimal128') {
	                index = serializeDecimal128(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {
	                index = serializeLong(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'Double') {
	                index = serializeDouble(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'Code') {
	                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
	            }
	            else if (typeof value === 'function' && serializeFunctions) {
	                index = serializeFunction(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'Binary') {
	                index = serializeBinary(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'BSONSymbol') {
	                index = serializeSymbol(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'DBRef') {
	                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);
	            }
	            else if (value._bsontype === 'BSONRegExp') {
	                index = serializeBSONRegExp(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'Int32') {
	                index = serializeInt32(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {
	                index = serializeMinMax(buffer, key, value, index);
	            }
	            else if (typeof value._bsontype !== 'undefined') {
	                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
	            }
	        }
	    }
	    else {
	        if (typeof object?.toBSON === 'function') {
	            object = object.toBSON();
	            if (object != null && typeof object !== 'object') {
	                throw new BSONError('toBSON function did not return an object');
	            }
	        }
	        for (const key of Object.keys(object)) {
	            let value = object[key];
	            if (typeof value?.toBSON === 'function') {
	                value = value.toBSON();
	            }
	            const type = typeof value;
	            if (typeof key === 'string' && !ignoreKeys.has(key)) {
	                if (key.match(regexp) != null) {
	                    throw new BSONError('key ' + key + ' must not contain null bytes');
	                }
	                if (checkKeys) {
	                    if ('$' === key[0]) {
	                        throw new BSONError('key ' + key + " must not start with '$'");
	                    }
	                    else if (key.includes('.')) {
	                        throw new BSONError('key ' + key + " must not contain '.'");
	                    }
	                }
	            }
	            if (type === 'string') {
	                index = serializeString(buffer, key, value, index);
	            }
	            else if (type === 'number') {
	                index = serializeNumber(buffer, key, value, index);
	            }
	            else if (type === 'bigint') {
	                index = serializeBigInt(buffer, key, value, index);
	            }
	            else if (type === 'boolean') {
	                index = serializeBoolean(buffer, key, value, index);
	            }
	            else if (value instanceof Date || isDate(value)) {
	                index = serializeDate(buffer, key, value, index);
	            }
	            else if (value === undefined) {
	                if (ignoreUndefined === false)
	                    index = serializeNull(buffer, key, value, index);
	            }
	            else if (value === null) {
	                index = serializeNull(buffer, key, value, index);
	            }
	            else if (isUint8Array(value)) {
	                index = serializeBuffer(buffer, key, value, index);
	            }
	            else if (value instanceof RegExp || isRegExp(value)) {
	                index = serializeRegExp(buffer, key, value, index);
	            }
	            else if (type === 'object' && value._bsontype == null) {
	                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
	            }
	            else if (typeof value === 'object' &&
	                value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {
	                throw new BSONVersionError();
	            }
	            else if (value._bsontype === 'ObjectId') {
	                index = serializeObjectId(buffer, key, value, index);
	            }
	            else if (type === 'object' && value._bsontype === 'Decimal128') {
	                index = serializeDecimal128(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {
	                index = serializeLong(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'Double') {
	                index = serializeDouble(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'Code') {
	                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
	            }
	            else if (typeof value === 'function' && serializeFunctions) {
	                index = serializeFunction(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'Binary') {
	                index = serializeBinary(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'BSONSymbol') {
	                index = serializeSymbol(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'DBRef') {
	                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);
	            }
	            else if (value._bsontype === 'BSONRegExp') {
	                index = serializeBSONRegExp(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'Int32') {
	                index = serializeInt32(buffer, key, value, index);
	            }
	            else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {
	                index = serializeMinMax(buffer, key, value, index);
	            }
	            else if (typeof value._bsontype !== 'undefined') {
	                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
	            }
	        }
	    }
	    path.delete(object);
	    buffer[index++] = 0x00;
	    const size = index - startingIndex;
	    startingIndex += NumberUtils.setInt32LE(buffer, startingIndex, size);
	    return index;
	}

	function isBSONType(value) {
	    return (value != null &&
	        typeof value === 'object' &&
	        '_bsontype' in value &&
	        typeof value._bsontype === 'string');
	}
	const keysToCodecs = {
	    $oid: ObjectId,
	    $binary: Binary,
	    $uuid: Binary,
	    $symbol: BSONSymbol,
	    $numberInt: Int32,
	    $numberDecimal: Decimal128,
	    $numberDouble: Double,
	    $numberLong: Long,
	    $minKey: MinKey,
	    $maxKey: MaxKey,
	    $regex: BSONRegExp,
	    $regularExpression: BSONRegExp,
	    $timestamp: Timestamp
	};
	function deserializeValue(value, options = {}) {
	    if (typeof value === 'number') {
	        const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;
	        const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;
	        if (options.relaxed || options.legacy) {
	            return value;
	        }
	        if (Number.isInteger(value) && !Object.is(value, -0)) {
	            if (in32BitRange) {
	                return new Int32(value);
	            }
	            if (in64BitRange) {
	                if (options.useBigInt64) {
	                    return BigInt(value);
	                }
	                return Long.fromNumber(value);
	            }
	        }
	        return new Double(value);
	    }
	    if (value == null || typeof value !== 'object')
	        return value;
	    if (value.$undefined)
	        return null;
	    const keys = Object.keys(value).filter(k => k.startsWith('$') && value[k] != null);
	    for (let i = 0; i < keys.length; i++) {
	        const c = keysToCodecs[keys[i]];
	        if (c)
	            return c.fromExtendedJSON(value, options);
	    }
	    if (value.$date != null) {
	        const d = value.$date;
	        const date = new Date();
	        if (options.legacy) {
	            if (typeof d === 'number')
	                date.setTime(d);
	            else if (typeof d === 'string')
	                date.setTime(Date.parse(d));
	            else if (typeof d === 'bigint')
	                date.setTime(Number(d));
	            else
	                throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);
	        }
	        else {
	            if (typeof d === 'string')
	                date.setTime(Date.parse(d));
	            else if (Long.isLong(d))
	                date.setTime(d.toNumber());
	            else if (typeof d === 'number' && options.relaxed)
	                date.setTime(d);
	            else if (typeof d === 'bigint')
	                date.setTime(Number(d));
	            else
	                throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);
	        }
	        return date;
	    }
	    if (value.$code != null) {
	        const copy = Object.assign({}, value);
	        if (value.$scope) {
	            copy.$scope = deserializeValue(value.$scope);
	        }
	        return Code.fromExtendedJSON(value);
	    }
	    if (isDBRefLike(value) || value.$dbPointer) {
	        const v = value.$ref ? value : value.$dbPointer;
	        if (v instanceof DBRef)
	            return v;
	        const dollarKeys = Object.keys(v).filter(k => k.startsWith('$'));
	        let valid = true;
	        dollarKeys.forEach(k => {
	            if (['$ref', '$id', '$db'].indexOf(k) === -1)
	                valid = false;
	        });
	        if (valid)
	            return DBRef.fromExtendedJSON(v);
	    }
	    return value;
	}
	function serializeArray(array, options) {
	    return array.map((v, index) => {
	        options.seenObjects.push({ propertyName: `index ${index}`, obj: null });
	        try {
	            return serializeValue(v, options);
	        }
	        finally {
	            options.seenObjects.pop();
	        }
	    });
	}
	function getISOString(date) {
	    const isoStr = date.toISOString();
	    return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + 'Z';
	}
	function serializeValue(value, options) {
	    if (value instanceof Map || isMap(value)) {
	        const obj = Object.create(null);
	        for (const [k, v] of value) {
	            if (typeof k !== 'string') {
	                throw new BSONError('Can only serialize maps with string keys');
	            }
	            obj[k] = v;
	        }
	        return serializeValue(obj, options);
	    }
	    if ((typeof value === 'object' || typeof value === 'function') && value !== null) {
	        const index = options.seenObjects.findIndex(entry => entry.obj === value);
	        if (index !== -1) {
	            const props = options.seenObjects.map(entry => entry.propertyName);
	            const leadingPart = props
	                .slice(0, index)
	                .map(prop => `${prop} -> `)
	                .join('');
	            const alreadySeen = props[index];
	            const circularPart = ' -> ' +
	                props
	                    .slice(index + 1, props.length - 1)
	                    .map(prop => `${prop} -> `)
	                    .join('');
	            const current = props[props.length - 1];
	            const leadingSpace = ' '.repeat(leadingPart.length + alreadySeen.length / 2);
	            const dashes = '-'.repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);
	            throw new BSONError('Converting circular structure to EJSON:\n' +
	                `    ${leadingPart}${alreadySeen}${circularPart}${current}\n` +
	                `    ${leadingSpace}\\${dashes}/`);
	        }
	        options.seenObjects[options.seenObjects.length - 1].obj = value;
	    }
	    if (Array.isArray(value))
	        return serializeArray(value, options);
	    if (value === undefined)
	        return null;
	    if (value instanceof Date || isDate(value)) {
	        const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 253402318800000;
	        if (options.legacy) {
	            return options.relaxed && inRange
	                ? { $date: value.getTime() }
	                : { $date: getISOString(value) };
	        }
	        return options.relaxed && inRange
	            ? { $date: getISOString(value) }
	            : { $date: { $numberLong: value.getTime().toString() } };
	    }
	    if (typeof value === 'number' && (!options.relaxed || !isFinite(value))) {
	        if (Number.isInteger(value) && !Object.is(value, -0)) {
	            if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
	                return { $numberInt: value.toString() };
	            }
	            if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {
	                return { $numberLong: value.toString() };
	            }
	        }
	        return { $numberDouble: Object.is(value, -0) ? '-0.0' : value.toString() };
	    }
	    if (typeof value === 'bigint') {
	        if (!options.relaxed) {
	            return { $numberLong: BigInt.asIntN(64, value).toString() };
	        }
	        return Number(BigInt.asIntN(64, value));
	    }
	    if (value instanceof RegExp || isRegExp(value)) {
	        let flags = value.flags;
	        if (flags === undefined) {
	            const match = value.toString().match(/[gimuy]*$/);
	            if (match) {
	                flags = match[0];
	            }
	        }
	        const rx = new BSONRegExp(value.source, flags);
	        return rx.toExtendedJSON(options);
	    }
	    if (value != null && typeof value === 'object')
	        return serializeDocument(value, options);
	    return value;
	}
	const BSON_TYPE_MAPPINGS = {
	    Binary: (o) => new Binary(o.value(), o.sub_type),
	    Code: (o) => new Code(o.code, o.scope),
	    DBRef: (o) => new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields),
	    Decimal128: (o) => new Decimal128(o.bytes),
	    Double: (o) => new Double(o.value),
	    Int32: (o) => new Int32(o.value),
	    Long: (o) => Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_),
	    MaxKey: () => new MaxKey(),
	    MinKey: () => new MinKey(),
	    ObjectId: (o) => new ObjectId(o),
	    BSONRegExp: (o) => new BSONRegExp(o.pattern, o.options),
	    BSONSymbol: (o) => new BSONSymbol(o.value),
	    Timestamp: (o) => Timestamp.fromBits(o.low, o.high)
	};
	function serializeDocument(doc, options) {
	    if (doc == null || typeof doc !== 'object')
	        throw new BSONError('not an object instance');
	    const bsontype = doc._bsontype;
	    if (typeof bsontype === 'undefined') {
	        const _doc = {};
	        for (const name of Object.keys(doc)) {
	            options.seenObjects.push({ propertyName: name, obj: null });
	            try {
	                const value = serializeValue(doc[name], options);
	                if (name === '__proto__') {
	                    Object.defineProperty(_doc, name, {
	                        value,
	                        writable: true,
	                        enumerable: true,
	                        configurable: true
	                    });
	                }
	                else {
	                    _doc[name] = value;
	                }
	            }
	            finally {
	                options.seenObjects.pop();
	            }
	        }
	        return _doc;
	    }
	    else if (doc != null &&
	        typeof doc === 'object' &&
	        typeof doc._bsontype === 'string' &&
	        doc[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {
	        throw new BSONVersionError();
	    }
	    else if (isBSONType(doc)) {
	        let outDoc = doc;
	        if (typeof outDoc.toExtendedJSON !== 'function') {
	            const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
	            if (!mapper) {
	                throw new BSONError('Unrecognized or invalid _bsontype: ' + doc._bsontype);
	            }
	            outDoc = mapper(outDoc);
	        }
	        if (bsontype === 'Code' && outDoc.scope) {
	            outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));
	        }
	        else if (bsontype === 'DBRef' && outDoc.oid) {
	            outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));
	        }
	        return outDoc.toExtendedJSON(options);
	    }
	    else {
	        throw new BSONError('_bsontype must be a string, but was: ' + typeof bsontype);
	    }
	}
	function parse(text, options) {
	    const ejsonOptions = {
	        useBigInt64: options?.useBigInt64 ?? false,
	        relaxed: options?.relaxed ?? true,
	        legacy: options?.legacy ?? false
	    };
	    return JSON.parse(text, (key, value) => {
	        if (key.indexOf('\x00') !== -1) {
	            throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);
	        }
	        return deserializeValue(value, ejsonOptions);
	    });
	}
	function stringify(value, replacer, space, options) {
	    if (space != null && typeof space === 'object') {
	        options = space;
	        space = 0;
	    }
	    if (replacer != null && typeof replacer === 'object' && !Array.isArray(replacer)) {
	        options = replacer;
	        replacer = undefined;
	        space = 0;
	    }
	    const serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {
	        seenObjects: [{ propertyName: '(root)', obj: null }]
	    });
	    const doc = serializeValue(value, serializeOptions);
	    return JSON.stringify(doc, replacer, space);
	}
	function EJSONserialize(value, options) {
	    options = options || {};
	    return JSON.parse(stringify(value, options));
	}
	function EJSONdeserialize(ejson, options) {
	    options = options || {};
	    return parse(JSON.stringify(ejson), options);
	}
	const EJSON = Object.create(null);
	EJSON.parse = parse;
	EJSON.stringify = stringify;
	EJSON.serialize = EJSONserialize;
	EJSON.deserialize = EJSONdeserialize;
	Object.freeze(EJSON);

	function getSize(source, offset) {
	    try {
	        return NumberUtils.getNonnegativeInt32LE(source, offset);
	    }
	    catch (cause) {
	        throw new BSONOffsetError('BSON size cannot be negative', offset, { cause });
	    }
	}
	function findNull(bytes, offset) {
	    let nullTerminatorOffset = offset;
	    for (; bytes[nullTerminatorOffset] !== 0x00; nullTerminatorOffset++)
	        ;
	    if (nullTerminatorOffset === bytes.length - 1) {
	        throw new BSONOffsetError('Null terminator not found', offset);
	    }
	    return nullTerminatorOffset;
	}
	function parseToElements(bytes, startOffset = 0) {
	    startOffset ??= 0;
	    if (bytes.length < 5) {
	        throw new BSONOffsetError(`Input must be at least 5 bytes, got ${bytes.length} bytes`, startOffset);
	    }
	    const documentSize = getSize(bytes, startOffset);
	    if (documentSize > bytes.length - startOffset) {
	        throw new BSONOffsetError(`Parsed documentSize (${documentSize} bytes) does not match input length (${bytes.length} bytes)`, startOffset);
	    }
	    if (bytes[startOffset + documentSize - 1] !== 0x00) {
	        throw new BSONOffsetError('BSON documents must end in 0x00', startOffset + documentSize);
	    }
	    const elements = [];
	    let offset = startOffset + 4;
	    while (offset <= documentSize + startOffset) {
	        const type = bytes[offset];
	        offset += 1;
	        if (type === 0) {
	            if (offset - startOffset !== documentSize) {
	                throw new BSONOffsetError(`Invalid 0x00 type byte`, offset);
	            }
	            break;
	        }
	        const nameOffset = offset;
	        const nameLength = findNull(bytes, offset) - nameOffset;
	        offset += nameLength + 1;
	        let length;
	        if (type === 1 ||
	            type === 18 ||
	            type === 9 ||
	            type === 17) {
	            length = 8;
	        }
	        else if (type === 16) {
	            length = 4;
	        }
	        else if (type === 7) {
	            length = 12;
	        }
	        else if (type === 19) {
	            length = 16;
	        }
	        else if (type === 8) {
	            length = 1;
	        }
	        else if (type === 10 ||
	            type === 6 ||
	            type === 127 ||
	            type === 255) {
	            length = 0;
	        }
	        else if (type === 11) {
	            length = findNull(bytes, findNull(bytes, offset) + 1) + 1 - offset;
	        }
	        else if (type === 3 ||
	            type === 4 ||
	            type === 15) {
	            length = getSize(bytes, offset);
	        }
	        else if (type === 2 ||
	            type === 5 ||
	            type === 12 ||
	            type === 13 ||
	            type === 14) {
	            length = getSize(bytes, offset) + 4;
	            if (type === 5) {
	                length += 1;
	            }
	            if (type === 12) {
	                length += 12;
	            }
	        }
	        else {
	            throw new BSONOffsetError(`Invalid 0x${type.toString(16).padStart(2, '0')} type byte`, offset);
	        }
	        if (length > documentSize) {
	            throw new BSONOffsetError('value reports length larger than document', offset);
	        }
	        elements.push([type, nameOffset, nameLength, offset, length]);
	        offset += length;
	    }
	    return elements;
	}

	const onDemand = Object.create(null);
	onDemand.parseToElements = parseToElements;
	onDemand.ByteUtils = ByteUtils;
	onDemand.NumberUtils = NumberUtils;
	Object.freeze(onDemand);

	const MAXSIZE = 1024 * 1024 * 17;
	let buffer = ByteUtils.allocate(MAXSIZE);
	function setInternalBufferSize(size) {
	    if (buffer.length < size) {
	        buffer = ByteUtils.allocate(size);
	    }
	}
	function serialize(object, options = {}) {
	    const checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
	    const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
	    const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
	    const minInternalBufferSize = typeof options.minInternalBufferSize === 'number' ? options.minInternalBufferSize : MAXSIZE;
	    if (buffer.length < minInternalBufferSize) {
	        buffer = ByteUtils.allocate(minInternalBufferSize);
	    }
	    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
	    const finishedBuffer = ByteUtils.allocateUnsafe(serializationIndex);
	    finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);
	    return finishedBuffer;
	}
	function serializeWithBufferAndIndex(object, finalBuffer, options = {}) {
	    const checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
	    const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
	    const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
	    const startIndex = typeof options.index === 'number' ? options.index : 0;
	    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
	    finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);
	    return startIndex + serializationIndex - 1;
	}
	function deserialize(buffer, options = {}) {
	    return internalDeserialize(ByteUtils.toLocalBufferType(buffer), options);
	}
	function calculateObjectSize(object, options = {}) {
	    options = options || {};
	    const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
	    const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
	    return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);
	}
	function deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
	    const internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);
	    const bufferData = ByteUtils.toLocalBufferType(data);
	    let index = startIndex;
	    for (let i = 0; i < numberOfDocuments; i++) {
	        const size = NumberUtils.getInt32LE(bufferData, index);
	        internalOptions.index = index;
	        documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);
	        index = index + size;
	    }
	    return index;
	}

	var bson$1 = /*#__PURE__*/Object.freeze({
	    __proto__: null,
	    BSONError: BSONError,
	    BSONOffsetError: BSONOffsetError,
	    BSONRegExp: BSONRegExp,
	    BSONRuntimeError: BSONRuntimeError,
	    BSONSymbol: BSONSymbol,
	    BSONType: BSONType,
	    BSONValue: BSONValue,
	    BSONVersionError: BSONVersionError,
	    Binary: Binary,
	    Code: Code,
	    DBRef: DBRef,
	    Decimal128: Decimal128,
	    Double: Double,
	    EJSON: EJSON,
	    Int32: Int32,
	    Long: Long,
	    MaxKey: MaxKey,
	    MinKey: MinKey,
	    ObjectId: ObjectId,
	    Timestamp: Timestamp,
	    UUID: UUID,
	    calculateObjectSize: calculateObjectSize,
	    deserialize: deserialize,
	    deserializeStream: deserializeStream,
	    onDemand: onDemand,
	    serialize: serialize,
	    serializeWithBufferAndIndex: serializeWithBufferAndIndex,
	    setInternalBufferSize: setInternalBufferSize
	});

	bson.BSON = bson$1;
	bson.BSONError = BSONError;
	bson.BSONOffsetError = BSONOffsetError;
	bson.BSONRegExp = BSONRegExp;
	bson.BSONRuntimeError = BSONRuntimeError;
	bson.BSONSymbol = BSONSymbol;
	bson.BSONType = BSONType;
	bson.BSONValue = BSONValue;
	bson.BSONVersionError = BSONVersionError;
	bson.Binary = Binary;
	bson.Code = Code;
	bson.DBRef = DBRef;
	bson.Decimal128 = Decimal128;
	bson.Double = Double;
	bson.EJSON = EJSON;
	bson.Int32 = Int32;
	bson.Long = Long;
	bson.MaxKey = MaxKey;
	bson.MinKey = MinKey;
	bson.ObjectId = ObjectId;
	bson.Timestamp = Timestamp;
	bson.UUID = UUID;
	bson.calculateObjectSize = calculateObjectSize;
	bson.deserialize = deserialize;
	bson.deserializeStream = deserializeStream;
	bson.onDemand = onDemand;
	bson.serialize = serialize;
	bson.serializeWithBufferAndIndex = serializeWithBufferAndIndex;
	bson.setInternalBufferSize = setInternalBufferSize;
	
	return bson;
}

var hasRequiredBson;

function requireBson () {
	if (hasRequiredBson) return bson$1;
	hasRequiredBson = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.toUTF8 = exports.getBigInt64LE = exports.getFloat64LE = exports.getInt32LE = exports.UUID = exports.Timestamp = exports.serialize = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Long = exports.Int32 = exports.EJSON = exports.Double = exports.deserialize = exports.Decimal128 = exports.DBRef = exports.Code = exports.calculateObjectSize = exports.BSONType = exports.BSONSymbol = exports.BSONRegExp = exports.BSONError = exports.BSON = exports.Binary = void 0;
		exports.parseToElementsToArray = parseToElementsToArray;
		exports.pluckBSONSerializeOptions = pluckBSONSerializeOptions;
		exports.resolveBSONOptions = resolveBSONOptions;
		exports.parseUtf8ValidationOption = parseUtf8ValidationOption;
		const bson_1 = requireBson$1();
		var bson_2 = requireBson$1();
		Object.defineProperty(exports, "Binary", { enumerable: true, get: function () { return bson_2.Binary; } });
		Object.defineProperty(exports, "BSON", { enumerable: true, get: function () { return bson_2.BSON; } });
		Object.defineProperty(exports, "BSONError", { enumerable: true, get: function () { return bson_2.BSONError; } });
		Object.defineProperty(exports, "BSONRegExp", { enumerable: true, get: function () { return bson_2.BSONRegExp; } });
		Object.defineProperty(exports, "BSONSymbol", { enumerable: true, get: function () { return bson_2.BSONSymbol; } });
		Object.defineProperty(exports, "BSONType", { enumerable: true, get: function () { return bson_2.BSONType; } });
		Object.defineProperty(exports, "calculateObjectSize", { enumerable: true, get: function () { return bson_2.calculateObjectSize; } });
		Object.defineProperty(exports, "Code", { enumerable: true, get: function () { return bson_2.Code; } });
		Object.defineProperty(exports, "DBRef", { enumerable: true, get: function () { return bson_2.DBRef; } });
		Object.defineProperty(exports, "Decimal128", { enumerable: true, get: function () { return bson_2.Decimal128; } });
		Object.defineProperty(exports, "deserialize", { enumerable: true, get: function () { return bson_2.deserialize; } });
		Object.defineProperty(exports, "Double", { enumerable: true, get: function () { return bson_2.Double; } });
		Object.defineProperty(exports, "EJSON", { enumerable: true, get: function () { return bson_2.EJSON; } });
		Object.defineProperty(exports, "Int32", { enumerable: true, get: function () { return bson_2.Int32; } });
		Object.defineProperty(exports, "Long", { enumerable: true, get: function () { return bson_2.Long; } });
		Object.defineProperty(exports, "MaxKey", { enumerable: true, get: function () { return bson_2.MaxKey; } });
		Object.defineProperty(exports, "MinKey", { enumerable: true, get: function () { return bson_2.MinKey; } });
		Object.defineProperty(exports, "ObjectId", { enumerable: true, get: function () { return bson_2.ObjectId; } });
		Object.defineProperty(exports, "serialize", { enumerable: true, get: function () { return bson_2.serialize; } });
		Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function () { return bson_2.Timestamp; } });
		Object.defineProperty(exports, "UUID", { enumerable: true, get: function () { return bson_2.UUID; } });
		function parseToElementsToArray(bytes, offset) {
		    const res = bson_1.BSON.onDemand.parseToElements(bytes, offset);
		    return Array.isArray(res) ? res : [...res];
		}
		exports.getInt32LE = bson_1.BSON.onDemand.NumberUtils.getInt32LE;
		exports.getFloat64LE = bson_1.BSON.onDemand.NumberUtils.getFloat64LE;
		exports.getBigInt64LE = bson_1.BSON.onDemand.NumberUtils.getBigInt64LE;
		exports.toUTF8 = bson_1.BSON.onDemand.ByteUtils.toUTF8;
		function pluckBSONSerializeOptions(options) {
		    const { fieldsAsRaw, useBigInt64, promoteValues, promoteBuffers, promoteLongs, serializeFunctions, ignoreUndefined, bsonRegExp, raw, enableUtf8Validation } = options;
		    return {
		        fieldsAsRaw,
		        useBigInt64,
		        promoteValues,
		        promoteBuffers,
		        promoteLongs,
		        serializeFunctions,
		        ignoreUndefined,
		        bsonRegExp,
		        raw,
		        enableUtf8Validation
		    };
		}
		/**
		 * Merge the given BSONSerializeOptions, preferring options over the parent's options, and
		 * substituting defaults for values not set.
		 *
		 * @internal
		 */
		function resolveBSONOptions(options, parent) {
		    const parentOptions = parent?.bsonOptions;
		    return {
		        raw: options?.raw ?? parentOptions?.raw ?? false,
		        useBigInt64: options?.useBigInt64 ?? parentOptions?.useBigInt64 ?? false,
		        promoteLongs: options?.promoteLongs ?? parentOptions?.promoteLongs ?? true,
		        promoteValues: options?.promoteValues ?? parentOptions?.promoteValues ?? true,
		        promoteBuffers: options?.promoteBuffers ?? parentOptions?.promoteBuffers ?? false,
		        ignoreUndefined: options?.ignoreUndefined ?? parentOptions?.ignoreUndefined ?? false,
		        bsonRegExp: options?.bsonRegExp ?? parentOptions?.bsonRegExp ?? false,
		        serializeFunctions: options?.serializeFunctions ?? parentOptions?.serializeFunctions ?? false,
		        fieldsAsRaw: options?.fieldsAsRaw ?? parentOptions?.fieldsAsRaw ?? {},
		        enableUtf8Validation: options?.enableUtf8Validation ?? parentOptions?.enableUtf8Validation ?? true
		    };
		}
		/** @internal */
		function parseUtf8ValidationOption(options) {
		    const enableUtf8Validation = options?.enableUtf8Validation;
		    if (enableUtf8Validation === false) {
		        return { utf8: false };
		    }
		    return { utf8: { writeErrors: false } };
		}
		
	} (bson$1));
	return bson$1;
}

var execute_operation = {};

var error$1 = {};

var hasRequiredError;

function requireError () {
	if (hasRequiredError) return error$1;
	hasRequiredError = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.MongoWriteConcernError = exports.MongoServerSelectionError = exports.MongoSystemError = exports.MongoMissingDependencyError = exports.MongoMissingCredentialsError = exports.MongoCompatibilityError = exports.MongoInvalidArgumentError = exports.MongoParseError = exports.MongoNetworkTimeoutError = exports.MongoNetworkError = exports.MongoTopologyClosedError = exports.MongoCursorExhaustedError = exports.MongoServerClosedError = exports.MongoCursorInUseError = exports.MongoUnexpectedServerResponseError = exports.MongoGridFSChunkError = exports.MongoGridFSStreamError = exports.MongoTailableCursorError = exports.MongoChangeStreamError = exports.MongoGCPError = exports.MongoAzureError = exports.MongoOIDCError = exports.MongoAWSError = exports.MongoKerberosError = exports.MongoExpiredSessionError = exports.MongoTransactionError = exports.MongoNotConnectedError = exports.MongoDecompressionError = exports.MongoBatchReExecutionError = exports.MongoRuntimeError = exports.MongoAPIError = exports.MongoDriverError = exports.MongoServerError = exports.MongoError = exports.MongoErrorLabel = exports.GET_MORE_RESUMABLE_CODES = exports.MONGODB_ERROR_CODES = exports.NODE_IS_RECOVERING_ERROR_MESSAGE = exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = void 0;
		exports.isNetworkErrorBeforeHandshake = isNetworkErrorBeforeHandshake;
		exports.needsRetryableWriteLabel = needsRetryableWriteLabel;
		exports.isRetryableWriteError = isRetryableWriteError;
		exports.isRetryableReadError = isRetryableReadError;
		exports.isNodeShuttingDownError = isNodeShuttingDownError;
		exports.isSDAMUnrecoverableError = isSDAMUnrecoverableError;
		exports.isNetworkTimeoutError = isNetworkTimeoutError;
		exports.isResumableError = isResumableError;
		/** @internal */
		const kErrorLabels = Symbol('errorLabels');
		/**
		 * @internal
		 * The legacy error message from the server that indicates the node is not a writable primary
		 * https://github.com/mongodb/specifications/blob/b07c26dc40d04ac20349f989db531c9845fdd755/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-writable-primary-and-node-is-recovering
		 */
		exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = new RegExp('not master', 'i');
		/**
		 * @internal
		 * The legacy error message from the server that indicates the node is not a primary or secondary
		 * https://github.com/mongodb/specifications/blob/b07c26dc40d04ac20349f989db531c9845fdd755/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-writable-primary-and-node-is-recovering
		 */
		exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = new RegExp('not master or secondary', 'i');
		/**
		 * @internal
		 * The error message from the server that indicates the node is recovering
		 * https://github.com/mongodb/specifications/blob/b07c26dc40d04ac20349f989db531c9845fdd755/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-writable-primary-and-node-is-recovering
		 */
		exports.NODE_IS_RECOVERING_ERROR_MESSAGE = new RegExp('node is recovering', 'i');
		/** @internal MongoDB Error Codes */
		exports.MONGODB_ERROR_CODES = Object.freeze({
		    HostUnreachable: 6,
		    HostNotFound: 7,
		    AuthenticationFailed: 18,
		    NetworkTimeout: 89,
		    ShutdownInProgress: 91,
		    PrimarySteppedDown: 189,
		    ExceededTimeLimit: 262,
		    SocketException: 9001,
		    NotWritablePrimary: 10107,
		    InterruptedAtShutdown: 11600,
		    InterruptedDueToReplStateChange: 11602,
		    NotPrimaryNoSecondaryOk: 13435,
		    NotPrimaryOrSecondary: 13436,
		    StaleShardVersion: 63,
		    StaleEpoch: 150,
		    StaleConfig: 13388,
		    RetryChangeStream: 234,
		    FailedToSatisfyReadPreference: 133,
		    CursorNotFound: 43,
		    LegacyNotPrimary: 10058,
		    WriteConcernFailed: 64,
		    NamespaceNotFound: 26,
		    IllegalOperation: 20,
		    MaxTimeMSExpired: 50,
		    UnknownReplWriteConcern: 79,
		    UnsatisfiableWriteConcern: 100,
		    Reauthenticate: 391,
		    ReadConcernMajorityNotAvailableYet: 134
		});
		// From spec@https://github.com/mongodb/specifications/blob/f93d78191f3db2898a59013a7ed5650352ef6da8/source/change-streams/change-streams.rst#resumable-error
		exports.GET_MORE_RESUMABLE_CODES = new Set([
		    exports.MONGODB_ERROR_CODES.HostUnreachable,
		    exports.MONGODB_ERROR_CODES.HostNotFound,
		    exports.MONGODB_ERROR_CODES.NetworkTimeout,
		    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
		    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
		    exports.MONGODB_ERROR_CODES.ExceededTimeLimit,
		    exports.MONGODB_ERROR_CODES.SocketException,
		    exports.MONGODB_ERROR_CODES.NotWritablePrimary,
		    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
		    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
		    exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
		    exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary,
		    exports.MONGODB_ERROR_CODES.StaleShardVersion,
		    exports.MONGODB_ERROR_CODES.StaleEpoch,
		    exports.MONGODB_ERROR_CODES.StaleConfig,
		    exports.MONGODB_ERROR_CODES.RetryChangeStream,
		    exports.MONGODB_ERROR_CODES.FailedToSatisfyReadPreference,
		    exports.MONGODB_ERROR_CODES.CursorNotFound
		]);
		/** @public */
		exports.MongoErrorLabel = Object.freeze({
		    RetryableWriteError: 'RetryableWriteError',
		    TransientTransactionError: 'TransientTransactionError',
		    UnknownTransactionCommitResult: 'UnknownTransactionCommitResult',
		    ResumableChangeStreamError: 'ResumableChangeStreamError',
		    HandshakeError: 'HandshakeError',
		    ResetPool: 'ResetPool',
		    PoolRequstedRetry: 'PoolRequstedRetry',
		    InterruptInUseConnections: 'InterruptInUseConnections',
		    NoWritesPerformed: 'NoWritesPerformed'
		});
		function isAggregateError(e) {
		    return e != null && typeof e === 'object' && 'errors' in e && Array.isArray(e.errors);
		}
		/**
		 * @public
		 * @category Error
		 *
		 * @privateRemarks
		 * mongodb-client-encryption has a dependency on this error, it uses the constructor with a string argument
		 */
		class MongoError extends Error {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message, options) {
		        super(message, options);
		        this[kErrorLabels] = new Set();
		    }
		    /** @internal */
		    static buildErrorMessage(e) {
		        if (typeof e === 'string') {
		            return e;
		        }
		        if (isAggregateError(e) && e.message.length === 0) {
		            return e.errors.length === 0
		                ? 'AggregateError has an empty errors array. Please check the `cause` property for more information.'
		                : e.errors.map(({ message }) => message).join(', ');
		        }
		        return e != null && typeof e === 'object' && 'message' in e && typeof e.message === 'string'
		            ? e.message
		            : 'empty error message';
		    }
		    get name() {
		        return 'MongoError';
		    }
		    /** Legacy name for server error responses */
		    get errmsg() {
		        return this.message;
		    }
		    /**
		     * Checks the error to see if it has an error label
		     *
		     * @param label - The error label to check for
		     * @returns returns true if the error has the provided error label
		     */
		    hasErrorLabel(label) {
		        return this[kErrorLabels].has(label);
		    }
		    addErrorLabel(label) {
		        this[kErrorLabels].add(label);
		    }
		    get errorLabels() {
		        return Array.from(this[kErrorLabels]);
		    }
		}
		exports.MongoError = MongoError;
		/**
		 * An error coming from the mongo server
		 *
		 * @public
		 * @category Error
		 */
		class MongoServerError extends MongoError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message) {
		        super(message.message || message.errmsg || message.$err || 'n/a');
		        if (message.errorLabels) {
		            this[kErrorLabels] = new Set(message.errorLabels);
		        }
		        this.errorResponse = message;
		        for (const name in message) {
		            if (name !== 'errorLabels' &&
		                name !== 'errmsg' &&
		                name !== 'message' &&
		                name !== 'errorResponse') {
		                this[name] = message[name];
		            }
		        }
		    }
		    get name() {
		        return 'MongoServerError';
		    }
		}
		exports.MongoServerError = MongoServerError;
		/**
		 * An error generated by the driver
		 *
		 * @public
		 * @category Error
		 */
		class MongoDriverError extends MongoError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message, options) {
		        super(message, options);
		    }
		    get name() {
		        return 'MongoDriverError';
		    }
		}
		exports.MongoDriverError = MongoDriverError;
		/**
		 * An error generated when the driver API is used incorrectly
		 *
		 * @privateRemarks
		 * Should **never** be directly instantiated
		 *
		 * @public
		 * @category Error
		 */
		class MongoAPIError extends MongoDriverError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message, options) {
		        super(message, options);
		    }
		    get name() {
		        return 'MongoAPIError';
		    }
		}
		exports.MongoAPIError = MongoAPIError;
		/**
		 * An error generated when the driver encounters unexpected input
		 * or reaches an unexpected/invalid internal state
		 *
		 * @privateRemarks
		 * Should **never** be directly instantiated.
		 *
		 * @public
		 * @category Error
		 */
		class MongoRuntimeError extends MongoDriverError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message, options) {
		        super(message, options);
		    }
		    get name() {
		        return 'MongoRuntimeError';
		    }
		}
		exports.MongoRuntimeError = MongoRuntimeError;
		/**
		 * An error generated when a batch command is re-executed after one of the commands in the batch
		 * has failed
		 *
		 * @public
		 * @category Error
		 */
		class MongoBatchReExecutionError extends MongoAPIError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message = 'This batch has already been executed, create new batch to execute') {
		        super(message);
		    }
		    get name() {
		        return 'MongoBatchReExecutionError';
		    }
		}
		exports.MongoBatchReExecutionError = MongoBatchReExecutionError;
		/**
		 * An error generated when the driver fails to decompress
		 * data received from the server.
		 *
		 * @public
		 * @category Error
		 */
		class MongoDecompressionError extends MongoRuntimeError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message) {
		        super(message);
		    }
		    get name() {
		        return 'MongoDecompressionError';
		    }
		}
		exports.MongoDecompressionError = MongoDecompressionError;
		/**
		 * An error thrown when the user attempts to operate on a database or collection through a MongoClient
		 * that has not yet successfully called the "connect" method
		 *
		 * @public
		 * @category Error
		 */
		class MongoNotConnectedError extends MongoAPIError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message) {
		        super(message);
		    }
		    get name() {
		        return 'MongoNotConnectedError';
		    }
		}
		exports.MongoNotConnectedError = MongoNotConnectedError;
		/**
		 * An error generated when the user makes a mistake in the usage of transactions.
		 * (e.g. attempting to commit a transaction with a readPreference other than primary)
		 *
		 * @public
		 * @category Error
		 */
		class MongoTransactionError extends MongoAPIError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message) {
		        super(message);
		    }
		    get name() {
		        return 'MongoTransactionError';
		    }
		}
		exports.MongoTransactionError = MongoTransactionError;
		/**
		 * An error generated when the user attempts to operate
		 * on a session that has expired or has been closed.
		 *
		 * @public
		 * @category Error
		 */
		class MongoExpiredSessionError extends MongoAPIError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message = 'Cannot use a session that has ended') {
		        super(message);
		    }
		    get name() {
		        return 'MongoExpiredSessionError';
		    }
		}
		exports.MongoExpiredSessionError = MongoExpiredSessionError;
		/**
		 * A error generated when the user attempts to authenticate
		 * via Kerberos, but fails to connect to the Kerberos client.
		 *
		 * @public
		 * @category Error
		 */
		class MongoKerberosError extends MongoRuntimeError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message) {
		        super(message);
		    }
		    get name() {
		        return 'MongoKerberosError';
		    }
		}
		exports.MongoKerberosError = MongoKerberosError;
		/**
		 * A error generated when the user attempts to authenticate
		 * via AWS, but fails
		 *
		 * @public
		 * @category Error
		 */
		class MongoAWSError extends MongoRuntimeError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message, options) {
		        super(message, options);
		    }
		    get name() {
		        return 'MongoAWSError';
		    }
		}
		exports.MongoAWSError = MongoAWSError;
		/**
		 * A error generated when the user attempts to authenticate
		 * via OIDC callbacks, but fails.
		 *
		 * @public
		 * @category Error
		 */
		class MongoOIDCError extends MongoRuntimeError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message) {
		        super(message);
		    }
		    get name() {
		        return 'MongoOIDCError';
		    }
		}
		exports.MongoOIDCError = MongoOIDCError;
		/**
		 * A error generated when the user attempts to authenticate
		 * via Azure, but fails.
		 *
		 * @public
		 * @category Error
		 */
		class MongoAzureError extends MongoOIDCError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message) {
		        super(message);
		    }
		    get name() {
		        return 'MongoAzureError';
		    }
		}
		exports.MongoAzureError = MongoAzureError;
		/**
		 * A error generated when the user attempts to authenticate
		 * via GCP, but fails.
		 *
		 * @public
		 * @category Error
		 */
		class MongoGCPError extends MongoOIDCError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message) {
		        super(message);
		    }
		    get name() {
		        return 'MongoGCPError';
		    }
		}
		exports.MongoGCPError = MongoGCPError;
		/**
		 * An error generated when a ChangeStream operation fails to execute.
		 *
		 * @public
		 * @category Error
		 */
		class MongoChangeStreamError extends MongoRuntimeError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message) {
		        super(message);
		    }
		    get name() {
		        return 'MongoChangeStreamError';
		    }
		}
		exports.MongoChangeStreamError = MongoChangeStreamError;
		/**
		 * An error thrown when the user calls a function or method not supported on a tailable cursor
		 *
		 * @public
		 * @category Error
		 */
		class MongoTailableCursorError extends MongoAPIError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message = 'Tailable cursor does not support this operation') {
		        super(message);
		    }
		    get name() {
		        return 'MongoTailableCursorError';
		    }
		}
		exports.MongoTailableCursorError = MongoTailableCursorError;
		/** An error generated when a GridFSStream operation fails to execute.
		 *
		 * @public
		 * @category Error
		 */
		class MongoGridFSStreamError extends MongoRuntimeError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message) {
		        super(message);
		    }
		    get name() {
		        return 'MongoGridFSStreamError';
		    }
		}
		exports.MongoGridFSStreamError = MongoGridFSStreamError;
		/**
		 * An error generated when a malformed or invalid chunk is
		 * encountered when reading from a GridFSStream.
		 *
		 * @public
		 * @category Error
		 */
		class MongoGridFSChunkError extends MongoRuntimeError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message) {
		        super(message);
		    }
		    get name() {
		        return 'MongoGridFSChunkError';
		    }
		}
		exports.MongoGridFSChunkError = MongoGridFSChunkError;
		/**
		 * An error generated when a **parsable** unexpected response comes from the server.
		 * This is generally an error where the driver in a state expecting a certain behavior to occur in
		 * the next message from MongoDB but it receives something else.
		 * This error **does not** represent an issue with wire message formatting.
		 *
		 * #### Example
		 * When an operation fails, it is the driver's job to retry it. It must perform serverSelection
		 * again to make sure that it attempts the operation against a server in a good state. If server
		 * selection returns a server that does not support retryable operations, this error is used.
		 * This scenario is unlikely as retryable support would also have been determined on the first attempt
		 * but it is possible the state change could report a selectable server that does not support retries.
		 *
		 * @public
		 * @category Error
		 */
		class MongoUnexpectedServerResponseError extends MongoRuntimeError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message, options) {
		        super(message, options);
		    }
		    get name() {
		        return 'MongoUnexpectedServerResponseError';
		    }
		}
		exports.MongoUnexpectedServerResponseError = MongoUnexpectedServerResponseError;
		/**
		 * An error thrown when the user attempts to add options to a cursor that has already been
		 * initialized
		 *
		 * @public
		 * @category Error
		 */
		class MongoCursorInUseError extends MongoAPIError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message = 'Cursor is already initialized') {
		        super(message);
		    }
		    get name() {
		        return 'MongoCursorInUseError';
		    }
		}
		exports.MongoCursorInUseError = MongoCursorInUseError;
		/**
		 * An error generated when an attempt is made to operate
		 * on a closed/closing server.
		 *
		 * @public
		 * @category Error
		 */
		class MongoServerClosedError extends MongoAPIError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message = 'Server is closed') {
		        super(message);
		    }
		    get name() {
		        return 'MongoServerClosedError';
		    }
		}
		exports.MongoServerClosedError = MongoServerClosedError;
		/**
		 * An error thrown when an attempt is made to read from a cursor that has been exhausted
		 *
		 * @public
		 * @category Error
		 */
		class MongoCursorExhaustedError extends MongoAPIError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message) {
		        super(message || 'Cursor is exhausted');
		    }
		    get name() {
		        return 'MongoCursorExhaustedError';
		    }
		}
		exports.MongoCursorExhaustedError = MongoCursorExhaustedError;
		/**
		 * An error generated when an attempt is made to operate on a
		 * dropped, or otherwise unavailable, database.
		 *
		 * @public
		 * @category Error
		 */
		class MongoTopologyClosedError extends MongoAPIError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message = 'Topology is closed') {
		        super(message);
		    }
		    get name() {
		        return 'MongoTopologyClosedError';
		    }
		}
		exports.MongoTopologyClosedError = MongoTopologyClosedError;
		/** @internal */
		const kBeforeHandshake = Symbol('beforeHandshake');
		function isNetworkErrorBeforeHandshake(err) {
		    return err[kBeforeHandshake] === true;
		}
		/**
		 * An error indicating an issue with the network, including TCP errors and timeouts.
		 * @public
		 * @category Error
		 */
		class MongoNetworkError extends MongoError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message, options) {
		        super(message, { cause: options?.cause });
		        if (options && typeof options.beforeHandshake === 'boolean') {
		            this[kBeforeHandshake] = options.beforeHandshake;
		        }
		    }
		    get name() {
		        return 'MongoNetworkError';
		    }
		}
		exports.MongoNetworkError = MongoNetworkError;
		/**
		 * An error indicating a network timeout occurred
		 * @public
		 * @category Error
		 *
		 * @privateRemarks
		 * mongodb-client-encryption has a dependency on this error with an instanceof check
		 */
		class MongoNetworkTimeoutError extends MongoNetworkError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message, options) {
		        super(message, options);
		    }
		    get name() {
		        return 'MongoNetworkTimeoutError';
		    }
		}
		exports.MongoNetworkTimeoutError = MongoNetworkTimeoutError;
		/**
		 * An error used when attempting to parse a value (like a connection string)
		 * @public
		 * @category Error
		 */
		class MongoParseError extends MongoDriverError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message) {
		        super(message);
		    }
		    get name() {
		        return 'MongoParseError';
		    }
		}
		exports.MongoParseError = MongoParseError;
		/**
		 * An error generated when the user supplies malformed or unexpected arguments
		 * or when a required argument or field is not provided.
		 *
		 *
		 * @public
		 * @category Error
		 */
		class MongoInvalidArgumentError extends MongoAPIError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message) {
		        super(message);
		    }
		    get name() {
		        return 'MongoInvalidArgumentError';
		    }
		}
		exports.MongoInvalidArgumentError = MongoInvalidArgumentError;
		/**
		 * An error generated when a feature that is not enabled or allowed for the current server
		 * configuration is used
		 *
		 *
		 * @public
		 * @category Error
		 */
		class MongoCompatibilityError extends MongoAPIError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message) {
		        super(message);
		    }
		    get name() {
		        return 'MongoCompatibilityError';
		    }
		}
		exports.MongoCompatibilityError = MongoCompatibilityError;
		/**
		 * An error generated when the user fails to provide authentication credentials before attempting
		 * to connect to a mongo server instance.
		 *
		 *
		 * @public
		 * @category Error
		 */
		class MongoMissingCredentialsError extends MongoAPIError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message) {
		        super(message);
		    }
		    get name() {
		        return 'MongoMissingCredentialsError';
		    }
		}
		exports.MongoMissingCredentialsError = MongoMissingCredentialsError;
		/**
		 * An error generated when a required module or dependency is not present in the local environment
		 *
		 * @public
		 * @category Error
		 */
		class MongoMissingDependencyError extends MongoAPIError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message, options) {
		        super(message, options);
		        this.dependencyName = options.dependencyName;
		    }
		    get name() {
		        return 'MongoMissingDependencyError';
		    }
		}
		exports.MongoMissingDependencyError = MongoMissingDependencyError;
		/**
		 * An error signifying a general system issue
		 * @public
		 * @category Error
		 */
		class MongoSystemError extends MongoError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message, reason) {
		        if (reason && reason.error) {
		            super(MongoError.buildErrorMessage(reason.error.message || reason.error), {
		                cause: reason.error
		            });
		        }
		        else {
		            super(message);
		        }
		        if (reason) {
		            this.reason = reason;
		        }
		        this.code = reason.error?.code;
		    }
		    get name() {
		        return 'MongoSystemError';
		    }
		}
		exports.MongoSystemError = MongoSystemError;
		/**
		 * An error signifying a client-side server selection error
		 * @public
		 * @category Error
		 */
		class MongoServerSelectionError extends MongoSystemError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(message, reason) {
		        super(message, reason);
		    }
		    get name() {
		        return 'MongoServerSelectionError';
		    }
		}
		exports.MongoServerSelectionError = MongoServerSelectionError;
		/**
		 * An error thrown when the server reports a writeConcernError
		 * @public
		 * @category Error
		 */
		class MongoWriteConcernError extends MongoServerError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(result) {
		        super({ ...result.writeConcernError, ...result });
		        this.errInfo = result.writeConcernError.errInfo;
		        this.result = result;
		    }
		    get name() {
		        return 'MongoWriteConcernError';
		    }
		}
		exports.MongoWriteConcernError = MongoWriteConcernError;
		// https://github.com/mongodb/specifications/blob/master/source/retryable-reads/retryable-reads.rst#retryable-error
		const RETRYABLE_READ_ERROR_CODES = new Set([
		    exports.MONGODB_ERROR_CODES.HostUnreachable,
		    exports.MONGODB_ERROR_CODES.HostNotFound,
		    exports.MONGODB_ERROR_CODES.NetworkTimeout,
		    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
		    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
		    exports.MONGODB_ERROR_CODES.SocketException,
		    exports.MONGODB_ERROR_CODES.NotWritablePrimary,
		    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
		    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
		    exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
		    exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary,
		    exports.MONGODB_ERROR_CODES.ExceededTimeLimit,
		    exports.MONGODB_ERROR_CODES.ReadConcernMajorityNotAvailableYet
		]);
		// see: https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.rst#terms
		const RETRYABLE_WRITE_ERROR_CODES = RETRYABLE_READ_ERROR_CODES;
		function needsRetryableWriteLabel(error, maxWireVersion, serverType) {
		    // pre-4.4 server, then the driver adds an error label for every valid case
		    // execute operation will only inspect the label, code/message logic is handled here
		    if (error instanceof MongoNetworkError) {
		        return true;
		    }
		    if (error instanceof MongoError) {
		        if ((maxWireVersion >= 9 || isRetryableWriteError(error)) &&
		            !error.hasErrorLabel(exports.MongoErrorLabel.HandshakeError)) {
		            // If we already have the error label no need to add it again. 4.4+ servers add the label.
		            // In the case where we have a handshake error, need to fall down to the logic checking
		            // the codes.
		            return false;
		        }
		    }
		    if (error instanceof MongoWriteConcernError) {
		        if (serverType === 'Mongos' && maxWireVersion < 9) {
		            // use original top-level code from server response
		            return RETRYABLE_WRITE_ERROR_CODES.has(error.result.code ?? 0);
		        }
		        const code = error.result.writeConcernError.code ?? Number(error.code);
		        return RETRYABLE_WRITE_ERROR_CODES.has(Number.isNaN(code) ? 0 : code);
		    }
		    if (error instanceof MongoError) {
		        return RETRYABLE_WRITE_ERROR_CODES.has(Number(error.code));
		    }
		    const isNotWritablePrimaryError = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error.message);
		    if (isNotWritablePrimaryError) {
		        return true;
		    }
		    const isNodeIsRecoveringError = exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error.message);
		    if (isNodeIsRecoveringError) {
		        return true;
		    }
		    return false;
		}
		function isRetryableWriteError(error) {
		    return (error.hasErrorLabel(exports.MongoErrorLabel.RetryableWriteError) ||
		        error.hasErrorLabel(exports.MongoErrorLabel.PoolRequstedRetry));
		}
		/** Determines whether an error is something the driver should attempt to retry */
		function isRetryableReadError(error) {
		    const hasRetryableErrorCode = typeof error.code === 'number' ? RETRYABLE_READ_ERROR_CODES.has(error.code) : false;
		    if (hasRetryableErrorCode) {
		        return true;
		    }
		    if (error instanceof MongoNetworkError) {
		        return true;
		    }
		    const isNotWritablePrimaryError = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error.message);
		    if (isNotWritablePrimaryError) {
		        return true;
		    }
		    const isNodeIsRecoveringError = exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error.message);
		    if (isNodeIsRecoveringError) {
		        return true;
		    }
		    return false;
		}
		const SDAM_RECOVERING_CODES = new Set([
		    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
		    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
		    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
		    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
		    exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary
		]);
		const SDAM_NOT_PRIMARY_CODES = new Set([
		    exports.MONGODB_ERROR_CODES.NotWritablePrimary,
		    exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
		    exports.MONGODB_ERROR_CODES.LegacyNotPrimary
		]);
		const SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = new Set([
		    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
		    exports.MONGODB_ERROR_CODES.ShutdownInProgress
		]);
		function isRecoveringError(err) {
		    if (typeof err.code === 'number') {
		        // If any error code exists, we ignore the error.message
		        return SDAM_RECOVERING_CODES.has(err.code);
		    }
		    return (exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE.test(err.message) ||
		        exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(err.message));
		}
		function isNotWritablePrimaryError(err) {
		    if (typeof err.code === 'number') {
		        // If any error code exists, we ignore the error.message
		        return SDAM_NOT_PRIMARY_CODES.has(err.code);
		    }
		    if (isRecoveringError(err)) {
		        return false;
		    }
		    return exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(err.message);
		}
		function isNodeShuttingDownError(err) {
		    return !!(typeof err.code === 'number' && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code));
		}
		/**
		 * Determines whether SDAM can recover from a given error. If it cannot
		 * then the pool will be cleared, and server state will completely reset
		 * locally.
		 *
		 * @see https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-master-and-node-is-recovering
		 */
		function isSDAMUnrecoverableError(error) {
		    // NOTE: null check is here for a strictly pre-CMAP world, a timeout or
		    //       close event are considered unrecoverable
		    if (error instanceof MongoParseError || error == null) {
		        return true;
		    }
		    return isRecoveringError(error) || isNotWritablePrimaryError(error);
		}
		function isNetworkTimeoutError(err) {
		    return !!(err instanceof MongoNetworkError && err.message.match(/timed out/));
		}
		function isResumableError(error, wireVersion) {
		    if (error == null || !(error instanceof MongoError)) {
		        return false;
		    }
		    if (error instanceof MongoNetworkError) {
		        return true;
		    }
		    if (wireVersion != null && wireVersion >= 9) {
		        // DRIVERS-1308: For 4.4 drivers running against 4.4 servers, drivers will add a special case to treat the CursorNotFound error code as resumable
		        if (error.code === exports.MONGODB_ERROR_CODES.CursorNotFound) {
		            return true;
		        }
		        return error.hasErrorLabel(exports.MongoErrorLabel.ResumableChangeStreamError);
		    }
		    if (typeof error.code === 'number') {
		        return exports.GET_MORE_RESUMABLE_CODES.has(error.code);
		    }
		    return false;
		}
		
	} (error$1));
	return error$1;
}

var read_preference = {};

var hasRequiredRead_preference;

function requireRead_preference () {
	if (hasRequiredRead_preference) return read_preference;
	hasRequiredRead_preference = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ReadPreference = exports.ReadPreferenceMode = void 0;
		const error_1 = requireError();
		/** @public */
		exports.ReadPreferenceMode = Object.freeze({
		    primary: 'primary',
		    primaryPreferred: 'primaryPreferred',
		    secondary: 'secondary',
		    secondaryPreferred: 'secondaryPreferred',
		    nearest: 'nearest'
		});
		/**
		 * The **ReadPreference** class is a class that represents a MongoDB ReadPreference and is
		 * used to construct connections.
		 * @public
		 *
		 * @see https://www.mongodb.com/docs/manual/core/read-preference/
		 */
		class ReadPreference {
		    /**
		     * @param mode - A string describing the read preference mode (primary|primaryPreferred|secondary|secondaryPreferred|nearest)
		     * @param tags - A tag set used to target reads to members with the specified tag(s). tagSet is not available if using read preference mode primary.
		     * @param options - Additional read preference options
		     */
		    constructor(mode, tags, options) {
		        if (!ReadPreference.isValid(mode)) {
		            throw new error_1.MongoInvalidArgumentError(`Invalid read preference mode ${JSON.stringify(mode)}`);
		        }
		        if (options == null && typeof tags === 'object' && !Array.isArray(tags)) {
		            options = tags;
		            tags = undefined;
		        }
		        else if (tags && !Array.isArray(tags)) {
		            throw new error_1.MongoInvalidArgumentError('ReadPreference tags must be an array');
		        }
		        this.mode = mode;
		        this.tags = tags;
		        this.hedge = options?.hedge;
		        this.maxStalenessSeconds = undefined;
		        this.minWireVersion = undefined;
		        options = options ?? {};
		        if (options.maxStalenessSeconds != null) {
		            if (options.maxStalenessSeconds <= 0) {
		                throw new error_1.MongoInvalidArgumentError('maxStalenessSeconds must be a positive integer');
		            }
		            this.maxStalenessSeconds = options.maxStalenessSeconds;
		            // NOTE: The minimum required wire version is 5 for this read preference. If the existing
		            //       topology has a lower value then a MongoError will be thrown during server selection.
		            this.minWireVersion = 5;
		        }
		        if (this.mode === ReadPreference.PRIMARY) {
		            if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {
		                throw new error_1.MongoInvalidArgumentError('Primary read preference cannot be combined with tags');
		            }
		            if (this.maxStalenessSeconds) {
		                throw new error_1.MongoInvalidArgumentError('Primary read preference cannot be combined with maxStalenessSeconds');
		            }
		            if (this.hedge) {
		                throw new error_1.MongoInvalidArgumentError('Primary read preference cannot be combined with hedge');
		            }
		        }
		    }
		    // Support the deprecated `preference` property introduced in the porcelain layer
		    get preference() {
		        return this.mode;
		    }
		    static fromString(mode) {
		        return new ReadPreference(mode);
		    }
		    /**
		     * Construct a ReadPreference given an options object.
		     *
		     * @param options - The options object from which to extract the read preference.
		     */
		    static fromOptions(options) {
		        if (!options)
		            return;
		        const readPreference = options.readPreference ?? options.session?.transaction.options.readPreference;
		        const readPreferenceTags = options.readPreferenceTags;
		        if (readPreference == null) {
		            return;
		        }
		        if (typeof readPreference === 'string') {
		            return new ReadPreference(readPreference, readPreferenceTags, {
		                maxStalenessSeconds: options.maxStalenessSeconds,
		                hedge: options.hedge
		            });
		        }
		        else if (!(readPreference instanceof ReadPreference) && typeof readPreference === 'object') {
		            const mode = readPreference.mode || readPreference.preference;
		            if (mode && typeof mode === 'string') {
		                return new ReadPreference(mode, readPreference.tags ?? readPreferenceTags, {
		                    maxStalenessSeconds: readPreference.maxStalenessSeconds,
		                    hedge: options.hedge
		                });
		            }
		        }
		        if (readPreferenceTags) {
		            readPreference.tags = readPreferenceTags;
		        }
		        return readPreference;
		    }
		    /**
		     * Replaces options.readPreference with a ReadPreference instance
		     */
		    static translate(options) {
		        if (options.readPreference == null)
		            return options;
		        const r = options.readPreference;
		        if (typeof r === 'string') {
		            options.readPreference = new ReadPreference(r);
		        }
		        else if (r && !(r instanceof ReadPreference) && typeof r === 'object') {
		            const mode = r.mode || r.preference;
		            if (mode && typeof mode === 'string') {
		                options.readPreference = new ReadPreference(mode, r.tags, {
		                    maxStalenessSeconds: r.maxStalenessSeconds
		                });
		            }
		        }
		        else if (!(r instanceof ReadPreference)) {
		            throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${r}`);
		        }
		        return options;
		    }
		    /**
		     * Validate if a mode is legal
		     *
		     * @param mode - The string representing the read preference mode.
		     */
		    static isValid(mode) {
		        const VALID_MODES = new Set([
		            ReadPreference.PRIMARY,
		            ReadPreference.PRIMARY_PREFERRED,
		            ReadPreference.SECONDARY,
		            ReadPreference.SECONDARY_PREFERRED,
		            ReadPreference.NEAREST,
		            null
		        ]);
		        return VALID_MODES.has(mode);
		    }
		    /**
		     * Validate if a mode is legal
		     *
		     * @param mode - The string representing the read preference mode.
		     */
		    isValid(mode) {
		        return ReadPreference.isValid(typeof mode === 'string' ? mode : this.mode);
		    }
		    /**
		     * Indicates that this readPreference needs the "SecondaryOk" bit when sent over the wire
		     * @see https://www.mongodb.com/docs/manual/reference/mongodb-wire-protocol/#op-query
		     */
		    secondaryOk() {
		        const NEEDS_SECONDARYOK = new Set([
		            ReadPreference.PRIMARY_PREFERRED,
		            ReadPreference.SECONDARY,
		            ReadPreference.SECONDARY_PREFERRED,
		            ReadPreference.NEAREST
		        ]);
		        return NEEDS_SECONDARYOK.has(this.mode);
		    }
		    /**
		     * Check if the two ReadPreferences are equivalent
		     *
		     * @param readPreference - The read preference with which to check equality
		     */
		    equals(readPreference) {
		        return readPreference.mode === this.mode;
		    }
		    /** Return JSON representation */
		    toJSON() {
		        const readPreference = { mode: this.mode };
		        if (Array.isArray(this.tags))
		            readPreference.tags = this.tags;
		        if (this.maxStalenessSeconds)
		            readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
		        if (this.hedge)
		            readPreference.hedge = this.hedge;
		        return readPreference;
		    }
		}
		exports.ReadPreference = ReadPreference;
		ReadPreference.PRIMARY = exports.ReadPreferenceMode.primary;
		ReadPreference.PRIMARY_PREFERRED = exports.ReadPreferenceMode.primaryPreferred;
		ReadPreference.SECONDARY = exports.ReadPreferenceMode.secondary;
		ReadPreference.SECONDARY_PREFERRED = exports.ReadPreferenceMode.secondaryPreferred;
		ReadPreference.NEAREST = exports.ReadPreferenceMode.nearest;
		ReadPreference.primary = new ReadPreference(exports.ReadPreferenceMode.primary);
		ReadPreference.primaryPreferred = new ReadPreference(exports.ReadPreferenceMode.primaryPreferred);
		ReadPreference.secondary = new ReadPreference(exports.ReadPreferenceMode.secondary);
		ReadPreference.secondaryPreferred = new ReadPreference(exports.ReadPreferenceMode.secondaryPreferred);
		ReadPreference.nearest = new ReadPreference(exports.ReadPreferenceMode.nearest);
		
	} (read_preference));
	return read_preference;
}

var server_selection = {};

var common$1 = {};

var hasRequiredCommon$1;

function requireCommon$1 () {
	if (hasRequiredCommon$1) return common$1;
	hasRequiredCommon$1 = 1;
	Object.defineProperty(common$1, "__esModule", { value: true });
	common$1.ServerType = common$1.TopologyType = common$1.STATE_CONNECTED = common$1.STATE_CONNECTING = common$1.STATE_CLOSED = common$1.STATE_CLOSING = void 0;
	common$1.drainTimerQueue = drainTimerQueue;
	common$1._advanceClusterTime = _advanceClusterTime;
	const timers_1 = require$$0$d;
	// shared state names
	common$1.STATE_CLOSING = 'closing';
	common$1.STATE_CLOSED = 'closed';
	common$1.STATE_CONNECTING = 'connecting';
	common$1.STATE_CONNECTED = 'connected';
	/**
	 * An enumeration of topology types we know about
	 * @public
	 */
	common$1.TopologyType = Object.freeze({
	    Single: 'Single',
	    ReplicaSetNoPrimary: 'ReplicaSetNoPrimary',
	    ReplicaSetWithPrimary: 'ReplicaSetWithPrimary',
	    Sharded: 'Sharded',
	    Unknown: 'Unknown',
	    LoadBalanced: 'LoadBalanced'
	});
	/**
	 * An enumeration of server types we know about
	 * @public
	 */
	common$1.ServerType = Object.freeze({
	    Standalone: 'Standalone',
	    Mongos: 'Mongos',
	    PossiblePrimary: 'PossiblePrimary',
	    RSPrimary: 'RSPrimary',
	    RSSecondary: 'RSSecondary',
	    RSArbiter: 'RSArbiter',
	    RSOther: 'RSOther',
	    RSGhost: 'RSGhost',
	    Unknown: 'Unknown',
	    LoadBalancer: 'LoadBalancer'
	});
	/** @internal */
	function drainTimerQueue(queue) {
	    queue.forEach(timers_1.clearTimeout);
	    queue.clear();
	}
	/** Shared function to determine clusterTime for a given topology or session */
	function _advanceClusterTime(entity, $clusterTime) {
	    if (entity.clusterTime == null) {
	        entity.clusterTime = $clusterTime;
	    }
	    else {
	        if ($clusterTime.clusterTime.greaterThan(entity.clusterTime.clusterTime)) {
	            entity.clusterTime = $clusterTime;
	        }
	    }
	}
	
	return common$1;
}

var hasRequiredServer_selection;

function requireServer_selection () {
	if (hasRequiredServer_selection) return server_selection;
	hasRequiredServer_selection = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.MIN_SECONDARY_WRITE_WIRE_VERSION = void 0;
		exports.writableServerSelector = writableServerSelector;
		exports.sameServerSelector = sameServerSelector;
		exports.secondaryWritableServerSelector = secondaryWritableServerSelector;
		exports.readPreferenceServerSelector = readPreferenceServerSelector;
		const error_1 = requireError();
		const read_preference_1 = requireRead_preference();
		const common_1 = requireCommon$1();
		// max staleness constants
		const IDLE_WRITE_PERIOD = 10000;
		const SMALLEST_MAX_STALENESS_SECONDS = 90;
		//  Minimum version to try writes on secondaries.
		exports.MIN_SECONDARY_WRITE_WIRE_VERSION = 13;
		/**
		 * Returns a server selector that selects for writable servers
		 */
		function writableServerSelector() {
		    return function writableServer(topologyDescription, servers) {
		        return latencyWindowReducer(topologyDescription, servers.filter((s) => s.isWritable));
		    };
		}
		/**
		 * The purpose of this selector is to select the same server, only
		 * if it is in a state that it can have commands sent to it.
		 */
		function sameServerSelector(description) {
		    return function sameServerSelector(topologyDescription, servers) {
		        if (!description)
		            return [];
		        // Filter the servers to match the provided description only if
		        // the type is not unknown.
		        return servers.filter(sd => {
		            return sd.address === description.address && sd.type !== common_1.ServerType.Unknown;
		        });
		    };
		}
		/**
		 * Returns a server selector that uses a read preference to select a
		 * server potentially for a write on a secondary.
		 */
		function secondaryWritableServerSelector(wireVersion, readPreference) {
		    // If server version < 5.0, read preference always primary.
		    // If server version >= 5.0...
		    // - If read preference is supplied, use that.
		    // - If no read preference is supplied, use primary.
		    if (!readPreference ||
		        !wireVersion ||
		        (wireVersion && wireVersion < exports.MIN_SECONDARY_WRITE_WIRE_VERSION)) {
		        return readPreferenceServerSelector(read_preference_1.ReadPreference.primary);
		    }
		    return readPreferenceServerSelector(readPreference);
		}
		/**
		 * Reduces the passed in array of servers by the rules of the "Max Staleness" specification
		 * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst
		 *
		 * @param readPreference - The read preference providing max staleness guidance
		 * @param topologyDescription - The topology description
		 * @param servers - The list of server descriptions to be reduced
		 * @returns The list of servers that satisfy the requirements of max staleness
		 */
		function maxStalenessReducer(readPreference, topologyDescription, servers) {
		    if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
		        return servers;
		    }
		    const maxStaleness = readPreference.maxStalenessSeconds;
		    const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;
		    if (maxStaleness < maxStalenessVariance) {
		        throw new error_1.MongoInvalidArgumentError(`Option "maxStalenessSeconds" must be at least ${maxStalenessVariance} seconds`);
		    }
		    if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
		        throw new error_1.MongoInvalidArgumentError(`Option "maxStalenessSeconds" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);
		    }
		    if (topologyDescription.type === common_1.TopologyType.ReplicaSetWithPrimary) {
		        const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
		        return servers.reduce((result, server) => {
		            const stalenessMS = server.lastUpdateTime -
		                server.lastWriteDate -
		                (primary.lastUpdateTime - primary.lastWriteDate) +
		                topologyDescription.heartbeatFrequencyMS;
		            const staleness = stalenessMS / 1000;
		            const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;
		            if (staleness <= maxStalenessSeconds) {
		                result.push(server);
		            }
		            return result;
		        }, []);
		    }
		    if (topologyDescription.type === common_1.TopologyType.ReplicaSetNoPrimary) {
		        if (servers.length === 0) {
		            return servers;
		        }
		        const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);
		        return servers.reduce((result, server) => {
		            const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
		            const staleness = stalenessMS / 1000;
		            const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;
		            if (staleness <= maxStalenessSeconds) {
		                result.push(server);
		            }
		            return result;
		        }, []);
		    }
		    return servers;
		}
		/**
		 * Determines whether a server's tags match a given set of tags
		 *
		 * @param tagSet - The requested tag set to match
		 * @param serverTags - The server's tags
		 */
		function tagSetMatch(tagSet, serverTags) {
		    const keys = Object.keys(tagSet);
		    const serverTagKeys = Object.keys(serverTags);
		    for (let i = 0; i < keys.length; ++i) {
		        const key = keys[i];
		        if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
		            return false;
		        }
		    }
		    return true;
		}
		/**
		 * Reduces a set of server descriptions based on tags requested by the read preference
		 *
		 * @param readPreference - The read preference providing the requested tags
		 * @param servers - The list of server descriptions to reduce
		 * @returns The list of servers matching the requested tags
		 */
		function tagSetReducer(readPreference, servers) {
		    if (readPreference.tags == null ||
		        (Array.isArray(readPreference.tags) && readPreference.tags.length === 0)) {
		        return servers;
		    }
		    for (let i = 0; i < readPreference.tags.length; ++i) {
		        const tagSet = readPreference.tags[i];
		        const serversMatchingTagset = servers.reduce((matched, server) => {
		            if (tagSetMatch(tagSet, server.tags))
		                matched.push(server);
		            return matched;
		        }, []);
		        if (serversMatchingTagset.length) {
		            return serversMatchingTagset;
		        }
		    }
		    return [];
		}
		/**
		 * Reduces a list of servers to ensure they fall within an acceptable latency window. This is
		 * further specified in the "Server Selection" specification, found here:
		 * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst
		 *
		 * @param topologyDescription - The topology description
		 * @param servers - The list of servers to reduce
		 * @returns The servers which fall within an acceptable latency window
		 */
		function latencyWindowReducer(topologyDescription, servers) {
		    const low = servers.reduce((min, server) => Math.min(server.roundTripTime, min), Infinity);
		    const high = low + topologyDescription.localThresholdMS;
		    return servers.reduce((result, server) => {
		        if (server.roundTripTime <= high && server.roundTripTime >= low)
		            result.push(server);
		        return result;
		    }, []);
		}
		// filters
		function primaryFilter(server) {
		    return server.type === common_1.ServerType.RSPrimary;
		}
		function secondaryFilter(server) {
		    return server.type === common_1.ServerType.RSSecondary;
		}
		function nearestFilter(server) {
		    return server.type === common_1.ServerType.RSSecondary || server.type === common_1.ServerType.RSPrimary;
		}
		function knownFilter(server) {
		    return server.type !== common_1.ServerType.Unknown;
		}
		function loadBalancerFilter(server) {
		    return server.type === common_1.ServerType.LoadBalancer;
		}
		/**
		 * Returns a function which selects servers based on a provided read preference
		 *
		 * @param readPreference - The read preference to select with
		 */
		function readPreferenceServerSelector(readPreference) {
		    if (!readPreference.isValid()) {
		        throw new error_1.MongoInvalidArgumentError('Invalid read preference specified');
		    }
		    return function readPreferenceServers(topologyDescription, servers, deprioritized = []) {
		        const commonWireVersion = topologyDescription.commonWireVersion;
		        if (commonWireVersion &&
		            readPreference.minWireVersion &&
		            readPreference.minWireVersion > commonWireVersion) {
		            throw new error_1.MongoCompatibilityError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);
		        }
		        if (topologyDescription.type === common_1.TopologyType.LoadBalanced) {
		            return servers.filter(loadBalancerFilter);
		        }
		        if (topologyDescription.type === common_1.TopologyType.Unknown) {
		            return [];
		        }
		        if (topologyDescription.type === common_1.TopologyType.Single) {
		            return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
		        }
		        if (topologyDescription.type === common_1.TopologyType.Sharded) {
		            const filtered = servers.filter(server => {
		                return !deprioritized.includes(server);
		            });
		            const selectable = filtered.length > 0 ? filtered : deprioritized;
		            return latencyWindowReducer(topologyDescription, selectable.filter(knownFilter));
		        }
		        const mode = readPreference.mode;
		        if (mode === read_preference_1.ReadPreference.PRIMARY) {
		            return servers.filter(primaryFilter);
		        }
		        if (mode === read_preference_1.ReadPreference.PRIMARY_PREFERRED) {
		            const result = servers.filter(primaryFilter);
		            if (result.length) {
		                return result;
		            }
		        }
		        const filter = mode === read_preference_1.ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
		        const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));
		        if (mode === read_preference_1.ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
		            return servers.filter(primaryFilter);
		        }
		        return selectedServers;
		    };
		}
		
	} (server_selection));
	return server_selection;
}

var utils$1 = {};

var constants$1 = {};

var hasRequiredConstants$1;

function requireConstants$1 () {
	if (hasRequiredConstants$1) return constants$1;
	hasRequiredConstants$1 = 1;
	Object.defineProperty(constants$1, "__esModule", { value: true });
	constants$1.OP_MSG = constants$1.OP_COMPRESSED = constants$1.OP_DELETE = constants$1.OP_QUERY = constants$1.OP_INSERT = constants$1.OP_UPDATE = constants$1.OP_REPLY = constants$1.MIN_SUPPORTED_QE_SERVER_VERSION = constants$1.MIN_SUPPORTED_QE_WIRE_VERSION = constants$1.MAX_SUPPORTED_WIRE_VERSION = constants$1.MIN_SUPPORTED_WIRE_VERSION = constants$1.MAX_SUPPORTED_SERVER_VERSION = constants$1.MIN_SUPPORTED_SERVER_VERSION = void 0;
	constants$1.MIN_SUPPORTED_SERVER_VERSION = '3.6';
	constants$1.MAX_SUPPORTED_SERVER_VERSION = '8.0';
	constants$1.MIN_SUPPORTED_WIRE_VERSION = 6;
	constants$1.MAX_SUPPORTED_WIRE_VERSION = 25;
	constants$1.MIN_SUPPORTED_QE_WIRE_VERSION = 21;
	constants$1.MIN_SUPPORTED_QE_SERVER_VERSION = '7.0';
	constants$1.OP_REPLY = 1;
	constants$1.OP_UPDATE = 2001;
	constants$1.OP_INSERT = 2002;
	constants$1.OP_QUERY = 2004;
	constants$1.OP_DELETE = 2006;
	constants$1.OP_COMPRESSED = 2012;
	constants$1.OP_MSG = 2013;
	
	return constants$1;
}

var constants = {};

var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.END = exports.CHANGE = exports.INIT = exports.MORE = exports.RESPONSE = exports.SERVER_HEARTBEAT_FAILED = exports.SERVER_HEARTBEAT_SUCCEEDED = exports.SERVER_HEARTBEAT_STARTED = exports.COMMAND_FAILED = exports.COMMAND_SUCCEEDED = exports.COMMAND_STARTED = exports.CLUSTER_TIME_RECEIVED = exports.CONNECTION_CHECKED_IN = exports.CONNECTION_CHECKED_OUT = exports.CONNECTION_CHECK_OUT_FAILED = exports.CONNECTION_CHECK_OUT_STARTED = exports.CONNECTION_CLOSED = exports.CONNECTION_READY = exports.CONNECTION_CREATED = exports.CONNECTION_POOL_READY = exports.CONNECTION_POOL_CLEARED = exports.CONNECTION_POOL_CLOSED = exports.CONNECTION_POOL_CREATED = exports.WAITING_FOR_SUITABLE_SERVER = exports.SERVER_SELECTION_SUCCEEDED = exports.SERVER_SELECTION_FAILED = exports.SERVER_SELECTION_STARTED = exports.TOPOLOGY_DESCRIPTION_CHANGED = exports.TOPOLOGY_CLOSED = exports.TOPOLOGY_OPENING = exports.SERVER_DESCRIPTION_CHANGED = exports.SERVER_CLOSED = exports.SERVER_OPENING = exports.DESCRIPTION_RECEIVED = exports.UNPINNED = exports.PINNED = exports.MESSAGE = exports.ENDED = exports.CLOSED = exports.CONNECT = exports.OPEN = exports.CLOSE = exports.TIMEOUT = exports.ERROR = exports.SYSTEM_JS_COLLECTION = exports.SYSTEM_COMMAND_COLLECTION = exports.SYSTEM_USER_COLLECTION = exports.SYSTEM_PROFILE_COLLECTION = exports.SYSTEM_INDEX_COLLECTION = exports.SYSTEM_NAMESPACE_COLLECTION = void 0;
		exports.kDecoratedKeys = exports.kDecorateResult = exports.LEGACY_HELLO_COMMAND_CAMEL_CASE = exports.LEGACY_HELLO_COMMAND = exports.MONGO_CLIENT_EVENTS = exports.LOCAL_SERVER_EVENTS = exports.SERVER_RELAY_EVENTS = exports.APM_EVENTS = exports.TOPOLOGY_EVENTS = exports.CMAP_EVENTS = exports.HEARTBEAT_EVENTS = exports.RESUME_TOKEN_CHANGED = void 0;
		/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */
		exports.SYSTEM_NAMESPACE_COLLECTION = 'system.namespaces';
		exports.SYSTEM_INDEX_COLLECTION = 'system.indexes';
		exports.SYSTEM_PROFILE_COLLECTION = 'system.profile';
		exports.SYSTEM_USER_COLLECTION = 'system.users';
		exports.SYSTEM_COMMAND_COLLECTION = '$cmd';
		exports.SYSTEM_JS_COLLECTION = 'system.js';
		// events
		exports.ERROR = 'error';
		exports.TIMEOUT = 'timeout';
		exports.CLOSE = 'close';
		exports.OPEN = 'open';
		exports.CONNECT = 'connect';
		exports.CLOSED = 'closed';
		exports.ENDED = 'ended';
		exports.MESSAGE = 'message';
		exports.PINNED = 'pinned';
		exports.UNPINNED = 'unpinned';
		exports.DESCRIPTION_RECEIVED = 'descriptionReceived';
		/** @internal */
		exports.SERVER_OPENING = 'serverOpening';
		/** @internal */
		exports.SERVER_CLOSED = 'serverClosed';
		/** @internal */
		exports.SERVER_DESCRIPTION_CHANGED = 'serverDescriptionChanged';
		/** @internal */
		exports.TOPOLOGY_OPENING = 'topologyOpening';
		/** @internal */
		exports.TOPOLOGY_CLOSED = 'topologyClosed';
		/** @internal */
		exports.TOPOLOGY_DESCRIPTION_CHANGED = 'topologyDescriptionChanged';
		/** @internal */
		exports.SERVER_SELECTION_STARTED = 'serverSelectionStarted';
		/** @internal */
		exports.SERVER_SELECTION_FAILED = 'serverSelectionFailed';
		/** @internal */
		exports.SERVER_SELECTION_SUCCEEDED = 'serverSelectionSucceeded';
		/** @internal */
		exports.WAITING_FOR_SUITABLE_SERVER = 'waitingForSuitableServer';
		/** @internal */
		exports.CONNECTION_POOL_CREATED = 'connectionPoolCreated';
		/** @internal */
		exports.CONNECTION_POOL_CLOSED = 'connectionPoolClosed';
		/** @internal */
		exports.CONNECTION_POOL_CLEARED = 'connectionPoolCleared';
		/** @internal */
		exports.CONNECTION_POOL_READY = 'connectionPoolReady';
		/** @internal */
		exports.CONNECTION_CREATED = 'connectionCreated';
		/** @internal */
		exports.CONNECTION_READY = 'connectionReady';
		/** @internal */
		exports.CONNECTION_CLOSED = 'connectionClosed';
		/** @internal */
		exports.CONNECTION_CHECK_OUT_STARTED = 'connectionCheckOutStarted';
		/** @internal */
		exports.CONNECTION_CHECK_OUT_FAILED = 'connectionCheckOutFailed';
		/** @internal */
		exports.CONNECTION_CHECKED_OUT = 'connectionCheckedOut';
		/** @internal */
		exports.CONNECTION_CHECKED_IN = 'connectionCheckedIn';
		exports.CLUSTER_TIME_RECEIVED = 'clusterTimeReceived';
		/** @internal */
		exports.COMMAND_STARTED = 'commandStarted';
		/** @internal */
		exports.COMMAND_SUCCEEDED = 'commandSucceeded';
		/** @internal */
		exports.COMMAND_FAILED = 'commandFailed';
		/** @internal */
		exports.SERVER_HEARTBEAT_STARTED = 'serverHeartbeatStarted';
		/** @internal */
		exports.SERVER_HEARTBEAT_SUCCEEDED = 'serverHeartbeatSucceeded';
		/** @internal */
		exports.SERVER_HEARTBEAT_FAILED = 'serverHeartbeatFailed';
		exports.RESPONSE = 'response';
		exports.MORE = 'more';
		exports.INIT = 'init';
		exports.CHANGE = 'change';
		exports.END = 'end';
		exports.RESUME_TOKEN_CHANGED = 'resumeTokenChanged';
		/** @public */
		exports.HEARTBEAT_EVENTS = Object.freeze([
		    exports.SERVER_HEARTBEAT_STARTED,
		    exports.SERVER_HEARTBEAT_SUCCEEDED,
		    exports.SERVER_HEARTBEAT_FAILED
		]);
		/** @public */
		exports.CMAP_EVENTS = Object.freeze([
		    exports.CONNECTION_POOL_CREATED,
		    exports.CONNECTION_POOL_READY,
		    exports.CONNECTION_POOL_CLEARED,
		    exports.CONNECTION_POOL_CLOSED,
		    exports.CONNECTION_CREATED,
		    exports.CONNECTION_READY,
		    exports.CONNECTION_CLOSED,
		    exports.CONNECTION_CHECK_OUT_STARTED,
		    exports.CONNECTION_CHECK_OUT_FAILED,
		    exports.CONNECTION_CHECKED_OUT,
		    exports.CONNECTION_CHECKED_IN
		]);
		/** @public */
		exports.TOPOLOGY_EVENTS = Object.freeze([
		    exports.SERVER_OPENING,
		    exports.SERVER_CLOSED,
		    exports.SERVER_DESCRIPTION_CHANGED,
		    exports.TOPOLOGY_OPENING,
		    exports.TOPOLOGY_CLOSED,
		    exports.TOPOLOGY_DESCRIPTION_CHANGED,
		    exports.ERROR,
		    exports.TIMEOUT,
		    exports.CLOSE
		]);
		/** @public */
		exports.APM_EVENTS = Object.freeze([
		    exports.COMMAND_STARTED,
		    exports.COMMAND_SUCCEEDED,
		    exports.COMMAND_FAILED
		]);
		/**
		 * All events that we relay to the `Topology`
		 * @internal
		 */
		exports.SERVER_RELAY_EVENTS = Object.freeze([
		    exports.SERVER_HEARTBEAT_STARTED,
		    exports.SERVER_HEARTBEAT_SUCCEEDED,
		    exports.SERVER_HEARTBEAT_FAILED,
		    exports.COMMAND_STARTED,
		    exports.COMMAND_SUCCEEDED,
		    exports.COMMAND_FAILED,
		    ...exports.CMAP_EVENTS
		]);
		/**
		 * All events we listen to from `Server` instances, but do not forward to the client
		 * @internal
		 */
		exports.LOCAL_SERVER_EVENTS = Object.freeze([
		    exports.CONNECT,
		    exports.DESCRIPTION_RECEIVED,
		    exports.CLOSED,
		    exports.ENDED
		]);
		/** @public */
		exports.MONGO_CLIENT_EVENTS = Object.freeze([
		    ...exports.CMAP_EVENTS,
		    ...exports.APM_EVENTS,
		    ...exports.TOPOLOGY_EVENTS,
		    ...exports.HEARTBEAT_EVENTS
		]);
		/**
		 * @internal
		 * The legacy hello command that was deprecated in MongoDB 5.0.
		 */
		exports.LEGACY_HELLO_COMMAND = 'ismaster';
		/**
		 * @internal
		 * The legacy hello command that was deprecated in MongoDB 5.0.
		 */
		exports.LEGACY_HELLO_COMMAND_CAMEL_CASE = 'isMaster';
		// Typescript errors if we index objects with `Symbol.for(...)`, so
		// to avoid TS errors we pull them out into variables.  Then we can type
		// the objects (and class) that we expect to see them on and prevent TS
		// errors.
		/** @internal */
		exports.kDecorateResult = Symbol.for('@@mdb.decorateDecryptionResult');
		/** @internal */
		exports.kDecoratedKeys = Symbol.for('@@mdb.decryptedKeys');
		
	} (constants));
	return constants;
}

var read_concern = {};

var hasRequiredRead_concern;

function requireRead_concern () {
	if (hasRequiredRead_concern) return read_concern;
	hasRequiredRead_concern = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ReadConcern = exports.ReadConcernLevel = void 0;
		/** @public */
		exports.ReadConcernLevel = Object.freeze({
		    local: 'local',
		    majority: 'majority',
		    linearizable: 'linearizable',
		    available: 'available',
		    snapshot: 'snapshot'
		});
		/**
		 * The MongoDB ReadConcern, which allows for control of the consistency and isolation properties
		 * of the data read from replica sets and replica set shards.
		 * @public
		 *
		 * @see https://www.mongodb.com/docs/manual/reference/read-concern/index.html
		 */
		class ReadConcern {
		    /** Constructs a ReadConcern from the read concern level.*/
		    constructor(level) {
		        /**
		         * A spec test exists that allows level to be any string.
		         * "invalid readConcern with out stage"
		         * @see ./test/spec/crud/v2/aggregate-out-readConcern.json
		         * @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#unknown-levels-and-additional-options-for-string-based-readconcerns
		         */
		        this.level = exports.ReadConcernLevel[level] ?? level;
		    }
		    /**
		     * Construct a ReadConcern given an options object.
		     *
		     * @param options - The options object from which to extract the write concern.
		     */
		    static fromOptions(options) {
		        if (options == null) {
		            return;
		        }
		        if (options.readConcern) {
		            const { readConcern } = options;
		            if (readConcern instanceof ReadConcern) {
		                return readConcern;
		            }
		            else if (typeof readConcern === 'string') {
		                return new ReadConcern(readConcern);
		            }
		            else if ('level' in readConcern && readConcern.level) {
		                return new ReadConcern(readConcern.level);
		            }
		        }
		        if (options.level) {
		            return new ReadConcern(options.level);
		        }
		        return;
		    }
		    static get MAJORITY() {
		        return exports.ReadConcernLevel.majority;
		    }
		    static get AVAILABLE() {
		        return exports.ReadConcernLevel.available;
		    }
		    static get LINEARIZABLE() {
		        return exports.ReadConcernLevel.linearizable;
		    }
		    static get SNAPSHOT() {
		        return exports.ReadConcernLevel.snapshot;
		    }
		    toJSON() {
		        return { level: this.level };
		    }
		}
		exports.ReadConcern = ReadConcern;
		
	} (read_concern));
	return read_concern;
}

var write_concern = {};

var responses = {};

var document$1 = {};

var hasRequiredDocument;

function requireDocument () {
	if (hasRequiredDocument) return document$1;
	hasRequiredDocument = 1;
	Object.defineProperty(document$1, "__esModule", { value: true });
	document$1.OnDemandDocument = void 0;
	const bson_1 = requireBson();
	/** @internal */
	class OnDemandDocument {
	    constructor(
	    /** BSON bytes, this document begins at offset */
	    bson, 
	    /** The start of the document */
	    offset = 0, 
	    /** If this is an embedded document, indicates if this was a BSON array */
	    isArray = false, 
	    /** If elements was already calculated */
	    elements) {
	        this.bson = bson;
	        this.offset = offset;
	        this.isArray = isArray;
	        /**
	         * Maps JS strings to elements and jsValues for speeding up subsequent lookups.
	         * - If `false` then name does not exist in the BSON document
	         * - If `CachedBSONElement` instance name exists
	         * - If `cache[name].value == null` jsValue has not yet been parsed
	         *   - Null/Undefined values do not get cached because they are zero-length values.
	         */
	        this.cache = Object.create(null);
	        /** Caches the index of elements that have been named */
	        this.indexFound = Object.create(null);
	        this.elements = elements ?? (0, bson_1.parseToElementsToArray)(this.bson, offset);
	    }
	    /** Only supports basic latin strings */
	    isElementName(name, element) {
	        const nameLength = element[2 /* BSONElementOffset.nameLength */];
	        const nameOffset = element[1 /* BSONElementOffset.nameOffset */];
	        if (name.length !== nameLength)
	            return false;
	        const nameEnd = nameOffset + nameLength;
	        for (let byteIndex = nameOffset, charIndex = 0; charIndex < name.length && byteIndex < nameEnd; charIndex++, byteIndex++) {
	            if (this.bson[byteIndex] !== name.charCodeAt(charIndex))
	                return false;
	        }
	        return true;
	    }
	    /**
	     * Seeks into the elements array for an element matching the given name.
	     *
	     * @remarks
	     * Caching:
	     * - Caches the existence of a property making subsequent look ups for non-existent properties return immediately
	     * - Caches names mapped to elements to avoid reiterating the array and comparing the name again
	     * - Caches the index at which an element has been found to prevent rechecking against elements already determined to belong to another name
	     *
	     * @param name - a basic latin string name of a BSON element
	     * @returns
	     */
	    getElement(name) {
	        const cachedElement = this.cache[name];
	        if (cachedElement === false)
	            return null;
	        if (cachedElement != null) {
	            return cachedElement;
	        }
	        if (typeof name === 'number') {
	            if (this.isArray) {
	                if (name < this.elements.length) {
	                    const element = this.elements[name];
	                    const cachedElement = { element, value: undefined };
	                    this.cache[name] = cachedElement;
	                    this.indexFound[name] = true;
	                    return cachedElement;
	                }
	                else {
	                    return null;
	                }
	            }
	            else {
	                return null;
	            }
	        }
	        for (let index = 0; index < this.elements.length; index++) {
	            const element = this.elements[index];
	            // skip this element if it has already been associated with a name
	            if (!(index in this.indexFound) && this.isElementName(name, element)) {
	                const cachedElement = { element, value: undefined };
	                this.cache[name] = cachedElement;
	                this.indexFound[index] = true;
	                return cachedElement;
	            }
	        }
	        this.cache[name] = false;
	        return null;
	    }
	    toJSValue(element, as) {
	        const type = element[0 /* BSONElementOffset.type */];
	        const offset = element[3 /* BSONElementOffset.offset */];
	        const length = element[4 /* BSONElementOffset.length */];
	        if (as !== type) {
	            return null;
	        }
	        switch (as) {
	            case bson_1.BSONType.null:
	            case bson_1.BSONType.undefined:
	                return null;
	            case bson_1.BSONType.double:
	                return (0, bson_1.getFloat64LE)(this.bson, offset);
	            case bson_1.BSONType.int:
	                return (0, bson_1.getInt32LE)(this.bson, offset);
	            case bson_1.BSONType.long:
	                return (0, bson_1.getBigInt64LE)(this.bson, offset);
	            case bson_1.BSONType.bool:
	                return Boolean(this.bson[offset]);
	            case bson_1.BSONType.objectId:
	                return new bson_1.ObjectId(this.bson.subarray(offset, offset + 12));
	            case bson_1.BSONType.timestamp:
	                return new bson_1.Timestamp((0, bson_1.getBigInt64LE)(this.bson, offset));
	            case bson_1.BSONType.string:
	                return (0, bson_1.toUTF8)(this.bson, offset + 4, offset + length - 1, false);
	            case bson_1.BSONType.binData: {
	                const totalBinarySize = (0, bson_1.getInt32LE)(this.bson, offset);
	                const subType = this.bson[offset + 4];
	                if (subType === 2) {
	                    const subType2BinarySize = (0, bson_1.getInt32LE)(this.bson, offset + 1 + 4);
	                    if (subType2BinarySize < 0)
	                        throw new bson_1.BSONError('Negative binary type element size found for subtype 0x02');
	                    if (subType2BinarySize > totalBinarySize - 4)
	                        throw new bson_1.BSONError('Binary type with subtype 0x02 contains too long binary size');
	                    if (subType2BinarySize < totalBinarySize - 4)
	                        throw new bson_1.BSONError('Binary type with subtype 0x02 contains too short binary size');
	                    return new bson_1.Binary(this.bson.subarray(offset + 1 + 4 + 4, offset + 1 + 4 + 4 + subType2BinarySize), 2);
	                }
	                return new bson_1.Binary(this.bson.subarray(offset + 1 + 4, offset + 1 + 4 + totalBinarySize), subType);
	            }
	            case bson_1.BSONType.date:
	                // Pretend this is correct.
	                return new Date(Number((0, bson_1.getBigInt64LE)(this.bson, offset)));
	            case bson_1.BSONType.object:
	                return new OnDemandDocument(this.bson, offset);
	            case bson_1.BSONType.array:
	                return new OnDemandDocument(this.bson, offset, true);
	            default:
	                throw new bson_1.BSONError(`Unsupported BSON type: ${as}`);
	        }
	    }
	    /**
	     * Returns the number of elements in this BSON document
	     */
	    size() {
	        return this.elements.length;
	    }
	    /**
	     * Checks for the existence of an element by name.
	     *
	     * @remarks
	     * Uses `getElement` with the expectation that will populate caches such that a `has` call
	     * followed by a `getElement` call will not repeat the cost paid by the first look up.
	     *
	     * @param name - element name
	     */
	    has(name) {
	        const cachedElement = this.cache[name];
	        if (cachedElement === false)
	            return false;
	        if (cachedElement != null)
	            return true;
	        return this.getElement(name) != null;
	    }
	    get(name, as, required) {
	        const element = this.getElement(name);
	        if (element == null) {
	            if (required === true) {
	                throw new bson_1.BSONError(`BSON element "${name}" is missing`);
	            }
	            else {
	                return null;
	            }
	        }
	        if (element.value == null) {
	            const value = this.toJSValue(element.element, as);
	            if (value == null) {
	                if (required === true) {
	                    throw new bson_1.BSONError(`BSON element "${name}" is missing`);
	                }
	                else {
	                    return null;
	                }
	            }
	            // It is important to never store null
	            element.value = value;
	        }
	        return element.value;
	    }
	    getNumber(name, required) {
	        const maybeBool = this.get(name, bson_1.BSONType.bool);
	        const bool = maybeBool == null ? null : maybeBool ? 1 : 0;
	        const maybeLong = this.get(name, bson_1.BSONType.long);
	        const long = maybeLong == null ? null : Number(maybeLong);
	        const result = bool ?? long ?? this.get(name, bson_1.BSONType.int) ?? this.get(name, bson_1.BSONType.double);
	        if (required === true && result == null) {
	            throw new bson_1.BSONError(`BSON element "${name}" is missing`);
	        }
	        return result;
	    }
	    /**
	     * Deserialize this object, DOES NOT cache result so avoid multiple invocations
	     * @param options - BSON deserialization options
	     */
	    toObject(options) {
	        return (0, bson_1.deserialize)(this.bson, {
	            ...options,
	            index: this.offset,
	            allowObjectSmallerThanBufferSize: true
	        });
	    }
	    /** Returns this document's bytes only */
	    toBytes() {
	        const size = (0, bson_1.getInt32LE)(this.bson, this.offset);
	        return this.bson.subarray(this.offset, this.offset + size);
	    }
	}
	document$1.OnDemandDocument = OnDemandDocument;
	
	return document$1;
}

var hasRequiredResponses;

function requireResponses () {
	if (hasRequiredResponses) return responses;
	hasRequiredResponses = 1;
	Object.defineProperty(responses, "__esModule", { value: true });
	responses.ExplainedCursorResponse = responses.CursorResponse = responses.MongoDBResponse = void 0;
	responses.isErrorResponse = isErrorResponse;
	const bson_1 = requireBson();
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	const document_1 = requireDocument();
	/**
	 * Accepts a BSON payload and checks for na "ok: 0" element.
	 * This utility is intended to prevent calling response class constructors
	 * that expect the result to be a success and demand certain properties to exist.
	 *
	 * For example, a cursor response always expects a cursor embedded document.
	 * In order to write the class such that the properties reflect that assertion (non-null)
	 * we cannot invoke the subclass constructor if the BSON represents an error.
	 *
	 * @param bytes - BSON document returned from the server
	 */
	function isErrorResponse(bson, elements) {
	    for (let eIdx = 0; eIdx < elements.length; eIdx++) {
	        const element = elements[eIdx];
	        if (element[2 /* BSONElementOffset.nameLength */] === 2) {
	            const nameOffset = element[1 /* BSONElementOffset.nameOffset */];
	            // 111 == "o", 107 == "k"
	            if (bson[nameOffset] === 111 && bson[nameOffset + 1] === 107) {
	                const valueOffset = element[3 /* BSONElementOffset.offset */];
	                const valueLength = element[4 /* BSONElementOffset.length */];
	                // If any byte in the length of the ok number (works for any type) is non zero,
	                // then it is considered "ok: 1"
	                for (let i = valueOffset; i < valueOffset + valueLength; i++) {
	                    if (bson[i] !== 0x00)
	                        return false;
	                }
	                return true;
	            }
	        }
	    }
	    return true;
	}
	/** @internal */
	class MongoDBResponse extends document_1.OnDemandDocument {
	    get(name, as, required) {
	        try {
	            return super.get(name, as, required);
	        }
	        catch (cause) {
	            throw new error_1.MongoUnexpectedServerResponseError(cause.message, { cause });
	        }
	    }
	    static is(value) {
	        return value instanceof MongoDBResponse;
	    }
	    static make(bson) {
	        const elements = (0, bson_1.parseToElementsToArray)(bson, 0);
	        const isError = isErrorResponse(bson, elements);
	        return isError
	            ? new MongoDBResponse(bson, 0, false, elements)
	            : new this(bson, 0, false, elements);
	    }
	    /**
	     * Drivers can safely assume that the `recoveryToken` field is always a BSON document but drivers MUST NOT modify the
	     * contents of the document.
	     */
	    get recoveryToken() {
	        return (this.get('recoveryToken', bson_1.BSONType.object)?.toObject({
	            promoteValues: false,
	            promoteLongs: false,
	            promoteBuffers: false,
	            validation: { utf8: true }
	        }) ?? null);
	    }
	    /**
	     * The server creates a cursor in response to a snapshot find/aggregate command and reports atClusterTime within the cursor field in the response.
	     * For the distinct command the server adds a top-level atClusterTime field to the response.
	     * The atClusterTime field represents the timestamp of the read and is guaranteed to be majority committed.
	     */
	    get atClusterTime() {
	        return (this.get('cursor', bson_1.BSONType.object)?.get('atClusterTime', bson_1.BSONType.timestamp) ??
	            this.get('atClusterTime', bson_1.BSONType.timestamp));
	    }
	    get operationTime() {
	        return this.get('operationTime', bson_1.BSONType.timestamp);
	    }
	    /** Normalizes whatever BSON value is "ok" to a JS number 1 or 0. */
	    get ok() {
	        return this.getNumber('ok') ? 1 : 0;
	    }
	    get $err() {
	        return this.get('$err', bson_1.BSONType.string);
	    }
	    get errmsg() {
	        return this.get('errmsg', bson_1.BSONType.string);
	    }
	    get code() {
	        return this.getNumber('code');
	    }
	    get $clusterTime() {
	        if (!('clusterTime' in this)) {
	            const clusterTimeDoc = this.get('$clusterTime', bson_1.BSONType.object);
	            if (clusterTimeDoc == null) {
	                this.clusterTime = null;
	                return null;
	            }
	            const clusterTime = clusterTimeDoc.get('clusterTime', bson_1.BSONType.timestamp, true);
	            const signature = clusterTimeDoc.get('signature', bson_1.BSONType.object)?.toObject();
	            // @ts-expect-error: `signature` is incorrectly typed. It is public API.
	            this.clusterTime = { clusterTime, signature };
	        }
	        return this.clusterTime ?? null;
	    }
	    toObject(options) {
	        const exactBSONOptions = {
	            ...(0, bson_1.pluckBSONSerializeOptions)(options ?? {}),
	            validation: (0, bson_1.parseUtf8ValidationOption)(options)
	        };
	        return super.toObject(exactBSONOptions);
	    }
	}
	responses.MongoDBResponse = MongoDBResponse;
	// {ok:1}
	MongoDBResponse.empty = new MongoDBResponse(new Uint8Array([13, 0, 0, 0, 16, 111, 107, 0, 1, 0, 0, 0, 0]));
	/** @internal */
	class CursorResponse extends MongoDBResponse {
	    constructor() {
	        super(...arguments);
	        this._batch = null;
	        this.iterated = 0;
	        this._encryptedBatch = null;
	    }
	    static is(value) {
	        return value instanceof CursorResponse || value === CursorResponse.emptyGetMore;
	    }
	    get cursor() {
	        return this.get('cursor', bson_1.BSONType.object, true);
	    }
	    get id() {
	        try {
	            return bson_1.Long.fromBigInt(this.cursor.get('id', bson_1.BSONType.long, true));
	        }
	        catch (cause) {
	            throw new error_1.MongoUnexpectedServerResponseError(cause.message, { cause });
	        }
	    }
	    get ns() {
	        const namespace = this.cursor.get('ns', bson_1.BSONType.string);
	        if (namespace != null)
	            return (0, utils_1.ns)(namespace);
	        return null;
	    }
	    get length() {
	        return Math.max(this.batchSize - this.iterated, 0);
	    }
	    get encryptedBatch() {
	        if (this.encryptedResponse == null)
	            return null;
	        if (this._encryptedBatch != null)
	            return this._encryptedBatch;
	        const cursor = this.encryptedResponse?.get('cursor', bson_1.BSONType.object);
	        if (cursor?.has('firstBatch'))
	            this._encryptedBatch = cursor.get('firstBatch', bson_1.BSONType.array, true);
	        else if (cursor?.has('nextBatch'))
	            this._encryptedBatch = cursor.get('nextBatch', bson_1.BSONType.array, true);
	        else
	            throw new error_1.MongoUnexpectedServerResponseError('Cursor document did not contain a batch');
	        return this._encryptedBatch;
	    }
	    get batch() {
	        if (this._batch != null)
	            return this._batch;
	        const cursor = this.cursor;
	        if (cursor.has('firstBatch'))
	            this._batch = cursor.get('firstBatch', bson_1.BSONType.array, true);
	        else if (cursor.has('nextBatch'))
	            this._batch = cursor.get('nextBatch', bson_1.BSONType.array, true);
	        else
	            throw new error_1.MongoUnexpectedServerResponseError('Cursor document did not contain a batch');
	        return this._batch;
	    }
	    get batchSize() {
	        return this.batch?.size();
	    }
	    get postBatchResumeToken() {
	        return (this.cursor.get('postBatchResumeToken', bson_1.BSONType.object)?.toObject({
	            promoteValues: false,
	            promoteLongs: false,
	            promoteBuffers: false,
	            validation: { utf8: true }
	        }) ?? null);
	    }
	    shift(options) {
	        if (this.iterated >= this.batchSize) {
	            return null;
	        }
	        const result = this.batch.get(this.iterated, bson_1.BSONType.object, true) ?? null;
	        const encryptedResult = this.encryptedBatch?.get(this.iterated, bson_1.BSONType.object, true) ?? null;
	        this.iterated += 1;
	        if (options?.raw) {
	            return result.toBytes();
	        }
	        else {
	            const object = result.toObject(options);
	            if (encryptedResult) {
	                (0, utils_1.decorateDecryptionResult)(object, encryptedResult.toObject(options), true);
	            }
	            return object;
	        }
	    }
	    clear() {
	        this.iterated = this.batchSize;
	    }
	}
	responses.CursorResponse = CursorResponse;
	/**
	 * This supports a feature of the FindCursor.
	 * It is an optimization to avoid an extra getMore when the limit has been reached
	 */
	CursorResponse.emptyGetMore = {
	    id: new bson_1.Long(0),
	    length: 0,
	    shift: () => null
	};
	/**
	 * Explain responses have nothing to do with cursor responses
	 * This class serves to temporarily avoid refactoring how cursors handle
	 * explain responses which is to detect that the response is not cursor-like and return the explain
	 * result as the "first and only" document in the "batch" and end the "cursor"
	 */
	class ExplainedCursorResponse extends CursorResponse {
	    constructor() {
	        super(...arguments);
	        this.isExplain = true;
	        this._length = 1;
	    }
	    get id() {
	        return bson_1.Long.fromBigInt(0n);
	    }
	    get batchSize() {
	        return 0;
	    }
	    get ns() {
	        return null;
	    }
	    get length() {
	        return this._length;
	    }
	    shift(options) {
	        if (this._length === 0)
	            return null;
	        this._length -= 1;
	        return this.toObject(options);
	    }
	}
	responses.ExplainedCursorResponse = ExplainedCursorResponse;
	
	return responses;
}

var hasRequiredWrite_concern;

function requireWrite_concern () {
	if (hasRequiredWrite_concern) return write_concern;
	hasRequiredWrite_concern = 1;
	Object.defineProperty(write_concern, "__esModule", { value: true });
	write_concern.WriteConcern = write_concern.WRITE_CONCERN_KEYS = void 0;
	write_concern.throwIfWriteConcernError = throwIfWriteConcernError;
	const responses_1 = requireResponses();
	const error_1 = requireError();
	write_concern.WRITE_CONCERN_KEYS = ['w', 'wtimeout', 'j', 'journal', 'fsync'];
	/**
	 * A MongoDB WriteConcern, which describes the level of acknowledgement
	 * requested from MongoDB for write operations.
	 * @public
	 *
	 * @see https://www.mongodb.com/docs/manual/reference/write-concern/
	 */
	class WriteConcern {
	    /**
	     * Constructs a WriteConcern from the write concern properties.
	     * @param w - request acknowledgment that the write operation has propagated to a specified number of mongod instances or to mongod instances with specified tags.
	     * @param wtimeoutMS - specify a time limit to prevent write operations from blocking indefinitely
	     * @param journal - request acknowledgment that the write operation has been written to the on-disk journal
	     * @param fsync - equivalent to the j option. Is deprecated and will be removed in the next major version.
	     */
	    constructor(w, wtimeoutMS, journal, fsync) {
	        if (w != null) {
	            if (!Number.isNaN(Number(w))) {
	                this.w = Number(w);
	            }
	            else {
	                this.w = w;
	            }
	        }
	        if (wtimeoutMS != null) {
	            this.wtimeoutMS = this.wtimeout = wtimeoutMS;
	        }
	        if (journal != null) {
	            this.journal = this.j = journal;
	        }
	        if (fsync != null) {
	            this.journal = this.j = fsync ? true : false;
	        }
	    }
	    /**
	     * Apply a write concern to a command document. Will modify and return the command.
	     */
	    static apply(command, writeConcern) {
	        const wc = {};
	        // The write concern document sent to the server has w/wtimeout/j fields.
	        if (writeConcern.w != null)
	            wc.w = writeConcern.w;
	        if (writeConcern.wtimeoutMS != null)
	            wc.wtimeout = writeConcern.wtimeoutMS;
	        if (writeConcern.journal != null)
	            wc.j = writeConcern.j;
	        command.writeConcern = wc;
	        return command;
	    }
	    /** Construct a WriteConcern given an options object. */
	    static fromOptions(options, inherit) {
	        if (options == null)
	            return undefined;
	        inherit = inherit ?? {};
	        let opts;
	        if (typeof options === 'string' || typeof options === 'number') {
	            opts = { w: options };
	        }
	        else if (options instanceof WriteConcern) {
	            opts = options;
	        }
	        else {
	            opts = options.writeConcern;
	        }
	        const parentOpts = inherit instanceof WriteConcern ? inherit : inherit.writeConcern;
	        const { w = undefined, wtimeout = undefined, j = undefined, fsync = undefined, journal = undefined, wtimeoutMS = undefined } = {
	            ...parentOpts,
	            ...opts
	        };
	        if (w != null ||
	            wtimeout != null ||
	            wtimeoutMS != null ||
	            j != null ||
	            journal != null ||
	            fsync != null) {
	            return new WriteConcern(w, wtimeout ?? wtimeoutMS, j ?? journal, fsync);
	        }
	        return undefined;
	    }
	}
	write_concern.WriteConcern = WriteConcern;
	/** Called with either a plain object or MongoDBResponse */
	function throwIfWriteConcernError(response) {
	    if (typeof response === 'object' && response != null) {
	        const writeConcernError = responses_1.MongoDBResponse.is(response) && response.has('writeConcernError')
	            ? response.toObject()
	            : !responses_1.MongoDBResponse.is(response) && 'writeConcernError' in response
	                ? response
	                : null;
	        if (writeConcernError != null) {
	            throw new error_1.MongoWriteConcernError(writeConcernError);
	        }
	    }
	}
	
	return write_concern;
}

var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$1;
	hasRequiredUtils$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.randomBytes = exports.COSMOS_DB_MSG = exports.DOCUMENT_DB_MSG = exports.COSMOS_DB_CHECK = exports.DOCUMENT_DB_CHECK = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.List = exports.MongoDBCollectionNamespace = exports.MongoDBNamespace = exports.ByteUtils = void 0;
		exports.isUint8Array = isUint8Array;
		exports.hostMatchesWildcards = hostMatchesWildcards;
		exports.normalizeHintField = normalizeHintField;
		exports.isObject = isObject;
		exports.mergeOptions = mergeOptions;
		exports.filterOptions = filterOptions;
		exports.applyRetryableWrites = applyRetryableWrites;
		exports.isPromiseLike = isPromiseLike;
		exports.decorateWithCollation = decorateWithCollation;
		exports.decorateWithReadConcern = decorateWithReadConcern;
		exports.decorateWithExplain = decorateWithExplain;
		exports.getTopology = getTopology;
		exports.ns = ns;
		exports.makeCounter = makeCounter;
		exports.uuidV4 = uuidV4;
		exports.maxWireVersion = maxWireVersion;
		exports.arrayStrictEqual = arrayStrictEqual;
		exports.errorStrictEqual = errorStrictEqual;
		exports.makeStateMachine = makeStateMachine;
		exports.now = now;
		exports.calculateDurationInMs = calculateDurationInMs;
		exports.hasAtomicOperators = hasAtomicOperators;
		exports.resolveOptions = resolveOptions;
		exports.isSuperset = isSuperset;
		exports.isHello = isHello;
		exports.setDifference = setDifference;
		exports.isRecord = isRecord;
		exports.deepCopy = deepCopy;
		exports.emitWarning = emitWarning;
		exports.emitWarningOnce = emitWarningOnce;
		exports.enumToString = enumToString;
		exports.supportsRetryableWrites = supportsRetryableWrites;
		exports.shuffle = shuffle;
		exports.commandSupportsReadConcern = commandSupportsReadConcern;
		exports.compareObjectId = compareObjectId;
		exports.parseInteger = parseInteger;
		exports.parseUnsignedInteger = parseUnsignedInteger;
		exports.matchesParentDomain = matchesParentDomain;
		exports.get = get;
		exports.request = request;
		exports.isHostMatch = isHostMatch;
		exports.promiseWithResolvers = promiseWithResolvers;
		exports.squashError = squashError;
		exports.once = once;
		exports.maybeAddIdToDocuments = maybeAddIdToDocuments;
		exports.fileIsAccessible = fileIsAccessible;
		exports.noop = noop;
		exports.decorateDecryptionResult = decorateDecryptionResult;
		const crypto = require$$0$c;
		const fs_1 = fs;
		const http = require$$0$b;
		const timers_1 = require$$0$d;
		const url = require$$4$1;
		const url_1 = require$$4$1;
		const util_1 = require$$0$6;
		const bson_1 = requireBson();
		const constants_1 = requireConstants$1();
		const constants_2 = requireConstants();
		const error_1 = requireError();
		const read_concern_1 = requireRead_concern();
		const read_preference_1 = requireRead_preference();
		const common_1 = requireCommon$1();
		const write_concern_1 = requireWrite_concern();
		exports.ByteUtils = {
		    toLocalBufferType(buffer) {
		        return Buffer.isBuffer(buffer)
		            ? buffer
		            : Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
		    },
		    equals(seqA, seqB) {
		        return exports.ByteUtils.toLocalBufferType(seqA).equals(seqB);
		    },
		    compare(seqA, seqB) {
		        return exports.ByteUtils.toLocalBufferType(seqA).compare(seqB);
		    },
		    toBase64(uint8array) {
		        return exports.ByteUtils.toLocalBufferType(uint8array).toString('base64');
		    }
		};
		/**
		 * Returns true if value is a Uint8Array or a Buffer
		 * @param value - any value that may be a Uint8Array
		 */
		function isUint8Array(value) {
		    return (value != null &&
		        typeof value === 'object' &&
		        Symbol.toStringTag in value &&
		        value[Symbol.toStringTag] === 'Uint8Array');
		}
		/**
		 * Determines if a connection's address matches a user provided list
		 * of domain wildcards.
		 */
		function hostMatchesWildcards(host, wildcards) {
		    for (const wildcard of wildcards) {
		        if (host === wildcard ||
		            (wildcard.startsWith('*.') && host?.endsWith(wildcard.substring(2, wildcard.length))) ||
		            (wildcard.startsWith('*/') && host?.endsWith(wildcard.substring(2, wildcard.length)))) {
		            return true;
		        }
		    }
		    return false;
		}
		/**
		 * Ensure Hint field is in a shape we expect:
		 * - object of index names mapping to 1 or -1
		 * - just an index name
		 * @internal
		 */
		function normalizeHintField(hint) {
		    let finalHint = undefined;
		    if (typeof hint === 'string') {
		        finalHint = hint;
		    }
		    else if (Array.isArray(hint)) {
		        finalHint = {};
		        hint.forEach(param => {
		            finalHint[param] = 1;
		        });
		    }
		    else if (hint != null && typeof hint === 'object') {
		        finalHint = {};
		        for (const name in hint) {
		            finalHint[name] = hint[name];
		        }
		    }
		    return finalHint;
		}
		const TO_STRING = (object) => Object.prototype.toString.call(object);
		/**
		 * Checks if arg is an Object:
		 * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`
		 * @internal
		 */
		function isObject(arg) {
		    return '[object Object]' === TO_STRING(arg);
		}
		/** @internal */
		function mergeOptions(target, source) {
		    return { ...target, ...source };
		}
		/** @internal */
		function filterOptions(options, names) {
		    const filterOptions = {};
		    for (const name in options) {
		        if (names.includes(name)) {
		            filterOptions[name] = options[name];
		        }
		    }
		    // Filtered options
		    return filterOptions;
		}
		/**
		 * Applies retryWrites: true to a command if retryWrites is set on the command's database.
		 * @internal
		 *
		 * @param target - The target command to which we will apply retryWrites.
		 * @param db - The database from which we can inherit a retryWrites value.
		 */
		function applyRetryableWrites(target, db) {
		    if (db && db.s.options?.retryWrites) {
		        target.retryWrites = true;
		    }
		    return target;
		}
		/**
		 * Applies a write concern to a command based on well defined inheritance rules, optionally
		 * detecting support for the write concern in the first place.
		 * @internal
		 *
		 * @param target - the target command we will be applying the write concern to
		 * @param sources - sources where we can inherit default write concerns from
		 * @param options - optional settings passed into a command for write concern overrides
		 */
		/**
		 * Checks if a given value is a Promise
		 *
		 * @typeParam T - The resolution type of the possible promise
		 * @param value - An object that could be a promise
		 * @returns true if the provided value is a Promise
		 */
		function isPromiseLike(value) {
		    return (value != null &&
		        typeof value === 'object' &&
		        'then' in value &&
		        typeof value.then === 'function');
		}
		/**
		 * Applies collation to a given command.
		 * @internal
		 *
		 * @param command - the command on which to apply collation
		 * @param target - target of command
		 * @param options - options containing collation settings
		 */
		function decorateWithCollation(command, target, options) {
		    const capabilities = getTopology(target).capabilities;
		    if (options.collation && typeof options.collation === 'object') {
		        if (capabilities && capabilities.commandsTakeCollation) {
		            command.collation = options.collation;
		        }
		        else {
		            throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);
		        }
		    }
		}
		/**
		 * Applies a read concern to a given command.
		 * @internal
		 *
		 * @param command - the command on which to apply the read concern
		 * @param coll - the parent collection of the operation calling this method
		 */
		function decorateWithReadConcern(command, coll, options) {
		    if (options && options.session && options.session.inTransaction()) {
		        return;
		    }
		    const readConcern = Object.assign({}, command.readConcern || {});
		    if (coll.s.readConcern) {
		        Object.assign(readConcern, coll.s.readConcern);
		    }
		    if (Object.keys(readConcern).length > 0) {
		        Object.assign(command, { readConcern: readConcern });
		    }
		}
		/**
		 * Applies an explain to a given command.
		 * @internal
		 *
		 * @param command - the command on which to apply the explain
		 * @param options - the options containing the explain verbosity
		 */
		function decorateWithExplain(command, explain) {
		    if (command.explain) {
		        return command;
		    }
		    return { explain: command, verbosity: explain.verbosity };
		}
		/**
		 * A helper function to get the topology from a given provider. Throws
		 * if the topology cannot be found.
		 * @throws MongoNotConnectedError
		 * @internal
		 */
		function getTopology(provider) {
		    // MongoClient or ClientSession or AbstractCursor
		    if ('topology' in provider && provider.topology) {
		        return provider.topology;
		    }
		    else if ('client' in provider && provider.client.topology) {
		        return provider.client.topology;
		    }
		    throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');
		}
		/** @internal */
		function ns(ns) {
		    return MongoDBNamespace.fromString(ns);
		}
		/** @public */
		class MongoDBNamespace {
		    /**
		     * Create a namespace object
		     *
		     * @param db - database name
		     * @param collection - collection name
		     */
		    constructor(db, collection) {
		        this.db = db;
		        this.collection = collection;
		        this.collection = collection === '' ? undefined : collection;
		    }
		    toString() {
		        return this.collection ? `${this.db}.${this.collection}` : this.db;
		    }
		    withCollection(collection) {
		        return new MongoDBCollectionNamespace(this.db, collection);
		    }
		    static fromString(namespace) {
		        if (typeof namespace !== 'string' || namespace === '') {
		            // TODO(NODE-3483): Replace with MongoNamespaceError
		            throw new error_1.MongoRuntimeError(`Cannot parse namespace from "${namespace}"`);
		        }
		        const [db, ...collectionParts] = namespace.split('.');
		        const collection = collectionParts.join('.');
		        return new MongoDBNamespace(db, collection === '' ? undefined : collection);
		    }
		}
		exports.MongoDBNamespace = MongoDBNamespace;
		/**
		 * @public
		 *
		 * A class representing a collection's namespace.  This class enforces (through Typescript) that
		 * the `collection` portion of the namespace is defined and should only be
		 * used in scenarios where this can be guaranteed.
		 */
		class MongoDBCollectionNamespace extends MongoDBNamespace {
		    constructor(db, collection) {
		        super(db, collection);
		        this.collection = collection;
		    }
		    static fromString(namespace) {
		        return super.fromString(namespace);
		    }
		}
		exports.MongoDBCollectionNamespace = MongoDBCollectionNamespace;
		/** @internal */
		function* makeCounter(seed = 0) {
		    let count = seed;
		    while (true) {
		        const newCount = count;
		        count += 1;
		        yield newCount;
		    }
		}
		/**
		 * Synchronously Generate a UUIDv4
		 * @internal
		 */
		function uuidV4() {
		    const result = crypto.randomBytes(16);
		    result[6] = (result[6] & 0x0f) | 0x40;
		    result[8] = (result[8] & 0x3f) | 0x80;
		    return result;
		}
		/**
		 * A helper function for determining `maxWireVersion` between legacy and new topology instances
		 * @internal
		 */
		function maxWireVersion(topologyOrServer) {
		    if (topologyOrServer) {
		        if (topologyOrServer.loadBalanced || topologyOrServer.serverApi?.version) {
		            // Since we do not have a monitor in the load balanced mode,
		            // we assume the load-balanced server is always pointed at the latest mongodb version.
		            // There is a risk that for on-prem deployments
		            // that don't upgrade immediately that this could alert to the
		            // application that a feature is available that is actually not.
		            // We also return the max supported wire version for serverAPI.
		            return constants_1.MAX_SUPPORTED_WIRE_VERSION;
		        }
		        if (topologyOrServer.hello) {
		            return topologyOrServer.hello.maxWireVersion;
		        }
		        if ('lastHello' in topologyOrServer && typeof topologyOrServer.lastHello === 'function') {
		            const lastHello = topologyOrServer.lastHello();
		            if (lastHello) {
		                return lastHello.maxWireVersion;
		            }
		        }
		        if (topologyOrServer.description &&
		            'maxWireVersion' in topologyOrServer.description &&
		            topologyOrServer.description.maxWireVersion != null) {
		            return topologyOrServer.description.maxWireVersion;
		        }
		    }
		    return 0;
		}
		/** @internal */
		function arrayStrictEqual(arr, arr2) {
		    if (!Array.isArray(arr) || !Array.isArray(arr2)) {
		        return false;
		    }
		    return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);
		}
		/** @internal */
		function errorStrictEqual(lhs, rhs) {
		    if (lhs === rhs) {
		        return true;
		    }
		    if (!lhs || !rhs) {
		        return lhs === rhs;
		    }
		    if ((lhs == null && rhs != null) || (lhs != null && rhs == null)) {
		        return false;
		    }
		    if (lhs.constructor.name !== rhs.constructor.name) {
		        return false;
		    }
		    if (lhs.message !== rhs.message) {
		        return false;
		    }
		    return true;
		}
		/** @internal */
		function makeStateMachine(stateTable) {
		    return function stateTransition(target, newState) {
		        const legalStates = stateTable[target.s.state];
		        if (legalStates && legalStates.indexOf(newState) < 0) {
		            throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);
		        }
		        target.emit('stateChanged', target.s.state, newState);
		        target.s.state = newState;
		    };
		}
		/** @internal */
		function now() {
		    const hrtime = process.hrtime();
		    return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);
		}
		/** @internal */
		function calculateDurationInMs(started) {
		    if (typeof started !== 'number') {
		        return -1;
		    }
		    const elapsed = now() - started;
		    return elapsed < 0 ? 0 : elapsed;
		}
		/** @internal */
		function hasAtomicOperators(doc) {
		    if (Array.isArray(doc)) {
		        for (const document of doc) {
		            if (hasAtomicOperators(document)) {
		                return true;
		            }
		        }
		        return false;
		    }
		    const keys = Object.keys(doc);
		    return keys.length > 0 && keys[0][0] === '$';
		}
		/**
		 * Merge inherited properties from parent into options, prioritizing values from options,
		 * then values from parent.
		 * @internal
		 */
		function resolveOptions(parent, options) {
		    const result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent));
		    // Users cannot pass a readConcern/writeConcern to operations in a transaction
		    const session = options?.session;
		    if (!session?.inTransaction()) {
		        const readConcern = read_concern_1.ReadConcern.fromOptions(options) ?? parent?.readConcern;
		        if (readConcern) {
		            result.readConcern = readConcern;
		        }
		        const writeConcern = write_concern_1.WriteConcern.fromOptions(options) ?? parent?.writeConcern;
		        if (writeConcern) {
		            result.writeConcern = writeConcern;
		        }
		    }
		    const readPreference = read_preference_1.ReadPreference.fromOptions(options) ?? parent?.readPreference;
		    if (readPreference) {
		        result.readPreference = readPreference;
		    }
		    return result;
		}
		function isSuperset(set, subset) {
		    set = Array.isArray(set) ? new Set(set) : set;
		    subset = Array.isArray(subset) ? new Set(subset) : subset;
		    for (const elem of subset) {
		        if (!set.has(elem)) {
		            return false;
		        }
		    }
		    return true;
		}
		/**
		 * Checks if the document is a Hello request
		 * @internal
		 */
		function isHello(doc) {
		    return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;
		}
		/** Returns the items that are uniquely in setA */
		function setDifference(setA, setB) {
		    const difference = new Set(setA);
		    for (const elem of setB) {
		        difference.delete(elem);
		    }
		    return difference;
		}
		const HAS_OWN = (object, prop) => Object.prototype.hasOwnProperty.call(object, prop);
		function isRecord(value, requiredKeys = undefined) {
		    if (!isObject(value)) {
		        return false;
		    }
		    const ctor = value.constructor;
		    if (ctor && ctor.prototype) {
		        if (!isObject(ctor.prototype)) {
		            return false;
		        }
		        // Check to see if some method exists from the Object exists
		        if (!HAS_OWN(ctor.prototype, 'isPrototypeOf')) {
		            return false;
		        }
		    }
		    if (requiredKeys) {
		        const keys = Object.keys(value);
		        return isSuperset(keys, requiredKeys);
		    }
		    return true;
		}
		/**
		 * Make a deep copy of an object
		 *
		 * NOTE: This is not meant to be the perfect implementation of a deep copy,
		 * but instead something that is good enough for the purposes of
		 * command monitoring.
		 */
		function deepCopy(value) {
		    if (value == null) {
		        return value;
		    }
		    else if (Array.isArray(value)) {
		        return value.map(item => deepCopy(item));
		    }
		    else if (isRecord(value)) {
		        const res = {};
		        for (const key in value) {
		            res[key] = deepCopy(value[key]);
		        }
		        return res;
		    }
		    const ctor = value.constructor;
		    if (ctor) {
		        switch (ctor.name.toLowerCase()) {
		            case 'date':
		                return new ctor(Number(value));
		            case 'map':
		                return new Map(value);
		            case 'set':
		                return new Set(value);
		            case 'buffer':
		                return Buffer.from(value);
		        }
		    }
		    return value;
		}
		/**
		 * A sequential list of items in a circularly linked list
		 * @remarks
		 * The head node is special, it is always defined and has a value of null.
		 * It is never "included" in the list, in that, it is not returned by pop/shift or yielded by the iterator.
		 * The circular linkage and always defined head node are to reduce checks for null next/prev references to zero.
		 * New nodes are declared as object literals with keys always in the same order: next, prev, value.
		 * @internal
		 */
		class List {
		    get length() {
		        return this.count;
		    }
		    get [Symbol.toStringTag]() {
		        return 'List';
		    }
		    constructor() {
		        this.count = 0;
		        // this is carefully crafted:
		        // declaring a complete and consistently key ordered
		        // object is beneficial to the runtime optimizations
		        this.head = {
		            next: null,
		            prev: null,
		            value: null
		        };
		        this.head.next = this.head;
		        this.head.prev = this.head;
		    }
		    toArray() {
		        return Array.from(this);
		    }
		    toString() {
		        return `head <=> ${this.toArray().join(' <=> ')} <=> head`;
		    }
		    *[Symbol.iterator]() {
		        for (const node of this.nodes()) {
		            yield node.value;
		        }
		    }
		    *nodes() {
		        let ptr = this.head.next;
		        while (ptr !== this.head) {
		            // Save next before yielding so that we make removing within iteration safe
		            const { next } = ptr;
		            yield ptr;
		            ptr = next;
		        }
		    }
		    /** Insert at end of list */
		    push(value) {
		        this.count += 1;
		        const newNode = {
		            next: this.head,
		            prev: this.head.prev,
		            value
		        };
		        this.head.prev.next = newNode;
		        this.head.prev = newNode;
		    }
		    /** Inserts every item inside an iterable instead of the iterable itself */
		    pushMany(iterable) {
		        for (const value of iterable) {
		            this.push(value);
		        }
		    }
		    /** Insert at front of list */
		    unshift(value) {
		        this.count += 1;
		        const newNode = {
		            next: this.head.next,
		            prev: this.head,
		            value
		        };
		        this.head.next.prev = newNode;
		        this.head.next = newNode;
		    }
		    remove(node) {
		        if (node === this.head || this.length === 0) {
		            return null;
		        }
		        this.count -= 1;
		        const prevNode = node.prev;
		        const nextNode = node.next;
		        prevNode.next = nextNode;
		        nextNode.prev = prevNode;
		        return node.value;
		    }
		    /** Removes the first node at the front of the list */
		    shift() {
		        return this.remove(this.head.next);
		    }
		    /** Removes the last node at the end of the list */
		    pop() {
		        return this.remove(this.head.prev);
		    }
		    /** Iterates through the list and removes nodes where filter returns true */
		    prune(filter) {
		        for (const node of this.nodes()) {
		            if (filter(node.value)) {
		                this.remove(node);
		            }
		        }
		    }
		    clear() {
		        this.count = 0;
		        this.head.next = this.head;
		        this.head.prev = this.head;
		    }
		    /** Returns the first item in the list, does not remove */
		    first() {
		        // If the list is empty, value will be the head's null
		        return this.head.next.value;
		    }
		    /** Returns the last item in the list, does not remove */
		    last() {
		        // If the list is empty, value will be the head's null
		        return this.head.prev.value;
		    }
		}
		exports.List = List;
		/**
		 * A pool of Buffers which allow you to read them as if they were one
		 * @internal
		 */
		class BufferPool {
		    constructor() {
		        this.buffers = new List();
		        this.totalByteLength = 0;
		    }
		    get length() {
		        return this.totalByteLength;
		    }
		    /** Adds a buffer to the internal buffer pool list */
		    append(buffer) {
		        this.buffers.push(buffer);
		        this.totalByteLength += buffer.length;
		    }
		    /**
		     * If BufferPool contains 4 bytes or more construct an int32 from the leading bytes,
		     * otherwise return null. Size can be negative, caller should error check.
		     */
		    getInt32() {
		        if (this.totalByteLength < 4) {
		            return null;
		        }
		        const firstBuffer = this.buffers.first();
		        if (firstBuffer != null && firstBuffer.byteLength >= 4) {
		            return firstBuffer.readInt32LE(0);
		        }
		        // Unlikely case: an int32 is split across buffers.
		        // Use read and put the returned buffer back on top
		        const top4Bytes = this.read(4);
		        const value = top4Bytes.readInt32LE(0);
		        // Put it back.
		        this.totalByteLength += 4;
		        this.buffers.unshift(top4Bytes);
		        return value;
		    }
		    /** Reads the requested number of bytes, optionally consuming them */
		    read(size) {
		        if (typeof size !== 'number' || size < 0) {
		            throw new error_1.MongoInvalidArgumentError('Argument "size" must be a non-negative number');
		        }
		        // oversized request returns empty buffer
		        if (size > this.totalByteLength) {
		            return Buffer.alloc(0);
		        }
		        // We know we have enough, we just don't know how it is spread across chunks
		        // TODO(NODE-4732): alloc API should change based on raw option
		        const result = Buffer.allocUnsafe(size);
		        for (let bytesRead = 0; bytesRead < size;) {
		            const buffer = this.buffers.shift();
		            if (buffer == null) {
		                break;
		            }
		            const bytesRemaining = size - bytesRead;
		            const bytesReadable = Math.min(bytesRemaining, buffer.byteLength);
		            const bytes = buffer.subarray(0, bytesReadable);
		            result.set(bytes, bytesRead);
		            bytesRead += bytesReadable;
		            this.totalByteLength -= bytesReadable;
		            if (bytesReadable < buffer.byteLength) {
		                this.buffers.unshift(buffer.subarray(bytesReadable));
		            }
		        }
		        return result;
		    }
		}
		exports.BufferPool = BufferPool;
		/** @public */
		class HostAddress {
		    constructor(hostString) {
		        this.host = undefined;
		        this.port = undefined;
		        this.socketPath = undefined;
		        this.isIPv6 = false;
		        const escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts
		        if (escapedHost.endsWith('.sock')) {
		            // heuristically determine if we're working with a domain socket
		            this.socketPath = decodeURIComponent(escapedHost);
		            return;
		        }
		        const urlString = `iLoveJS://${escapedHost}`;
		        let url;
		        try {
		            url = new url_1.URL(urlString);
		        }
		        catch (urlError) {
		            const runtimeError = new error_1.MongoRuntimeError(`Unable to parse ${escapedHost} with URL`);
		            runtimeError.cause = urlError;
		            throw runtimeError;
		        }
		        const hostname = url.hostname;
		        const port = url.port;
		        let normalized = decodeURIComponent(hostname).toLowerCase();
		        if (normalized.startsWith('[') && normalized.endsWith(']')) {
		            this.isIPv6 = true;
		            normalized = normalized.substring(1, hostname.length - 1);
		        }
		        this.host = normalized.toLowerCase();
		        if (typeof port === 'number') {
		            this.port = port;
		        }
		        else if (typeof port === 'string' && port !== '') {
		            this.port = Number.parseInt(port, 10);
		        }
		        else {
		            this.port = 27017;
		        }
		        if (this.port === 0) {
		            throw new error_1.MongoParseError('Invalid port (zero) with hostname');
		        }
		        Object.freeze(this);
		    }
		    [Symbol.for('nodejs.util.inspect.custom')]() {
		        return this.inspect();
		    }
		    inspect() {
		        return `new HostAddress('${this.toString()}')`;
		    }
		    toString() {
		        if (typeof this.host === 'string') {
		            if (this.isIPv6) {
		                return `[${this.host}]:${this.port}`;
		            }
		            return `${this.host}:${this.port}`;
		        }
		        return `${this.socketPath}`;
		    }
		    static fromString(s) {
		        return new HostAddress(s);
		    }
		    static fromHostPort(host, port) {
		        if (host.includes(':')) {
		            host = `[${host}]`; // IPv6 address
		        }
		        return HostAddress.fromString(`${host}:${port}`);
		    }
		    static fromSrvRecord({ name, port }) {
		        return HostAddress.fromHostPort(name, port);
		    }
		    toHostPort() {
		        if (this.socketPath) {
		            return { host: this.socketPath, port: 0 };
		        }
		        const host = this.host ?? '';
		        const port = this.port ?? 0;
		        return { host, port };
		    }
		}
		exports.HostAddress = HostAddress;
		exports.DEFAULT_PK_FACTORY = {
		    // We prefer not to rely on ObjectId having a createPk method
		    createPk() {
		        return new bson_1.ObjectId();
		    }
		};
		/**
		 * When the driver used emitWarning the code will be equal to this.
		 * @public
		 *
		 * @example
		 * ```ts
		 * process.on('warning', (warning) => {
		 *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')
		 * })
		 * ```
		 */
		exports.MONGODB_WARNING_CODE = 'MONGODB DRIVER';
		/** @internal */
		function emitWarning(message) {
		    return process.emitWarning(message, { code: exports.MONGODB_WARNING_CODE });
		}
		const emittedWarnings = new Set();
		/**
		 * Will emit a warning once for the duration of the application.
		 * Uses the message to identify if it has already been emitted
		 * so using string interpolation can cause multiple emits
		 * @internal
		 */
		function emitWarningOnce(message) {
		    if (!emittedWarnings.has(message)) {
		        emittedWarnings.add(message);
		        return emitWarning(message);
		    }
		}
		/**
		 * Takes a JS object and joins the values into a string separated by ', '
		 */
		function enumToString(en) {
		    return Object.values(en).join(', ');
		}
		/**
		 * Determine if a server supports retryable writes.
		 *
		 * @internal
		 */
		function supportsRetryableWrites(server) {
		    if (!server) {
		        return false;
		    }
		    if (server.loadBalanced) {
		        // Loadbalanced topologies will always support retry writes
		        return true;
		    }
		    if (server.description.logicalSessionTimeoutMinutes != null) {
		        // that supports sessions
		        if (server.description.type !== common_1.ServerType.Standalone) {
		            // and that is not a standalone
		            return true;
		        }
		    }
		    return false;
		}
		/**
		 * FisherYates Shuffle
		 *
		 * Reference: https://bost.ocks.org/mike/shuffle/
		 * @param sequence - items to be shuffled
		 * @param limit - Defaults to `0`. If nonzero shuffle will slice the randomized array e.g, `.slice(0, limit)` otherwise will return the entire randomized array.
		 */
		function shuffle(sequence, limit = 0) {
		    const items = Array.from(sequence); // shallow copy in order to never shuffle the input
		    if (limit > items.length) {
		        throw new error_1.MongoRuntimeError('Limit must be less than the number of items');
		    }
		    let remainingItemsToShuffle = items.length;
		    const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;
		    while (remainingItemsToShuffle > lowerBound) {
		        // Pick a remaining element
		        const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);
		        remainingItemsToShuffle -= 1;
		        // And swap it with the current element
		        const swapHold = items[remainingItemsToShuffle];
		        items[remainingItemsToShuffle] = items[randomIndex];
		        items[randomIndex] = swapHold;
		    }
		    return limit % items.length === 0 ? items : items.slice(lowerBound);
		}
		// TODO(NODE-4936): read concern eligibility for commands should be codified in command construction
		// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern
		function commandSupportsReadConcern(command) {
		    if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {
		        return true;
		    }
		    return false;
		}
		/**
		 * Compare objectIds. `null` is always less
		 * - `+1 = oid1 is greater than oid2`
		 * - `-1 = oid1 is less than oid2`
		 * - `+0 = oid1 is equal oid2`
		 */
		function compareObjectId(oid1, oid2) {
		    if (oid1 == null && oid2 == null) {
		        return 0;
		    }
		    if (oid1 == null) {
		        return -1;
		    }
		    if (oid2 == null) {
		        return 1;
		    }
		    return exports.ByteUtils.compare(oid1.id, oid2.id);
		}
		function parseInteger(value) {
		    if (typeof value === 'number')
		        return Math.trunc(value);
		    const parsedValue = Number.parseInt(String(value), 10);
		    return Number.isNaN(parsedValue) ? null : parsedValue;
		}
		function parseUnsignedInteger(value) {
		    const parsedInt = parseInteger(value);
		    return parsedInt != null && parsedInt >= 0 ? parsedInt : null;
		}
		/**
		 * Determines whether a provided address matches the provided parent domain.
		 *
		 * If a DNS server were to become compromised SRV records would still need to
		 * advertise addresses that are under the same domain as the srvHost.
		 *
		 * @param address - The address to check against a domain
		 * @param srvHost - The domain to check the provided address against
		 * @returns Whether the provided address matches the parent domain
		 */
		function matchesParentDomain(address, srvHost) {
		    // Remove trailing dot if exists on either the resolved address or the srv hostname
		    const normalizedAddress = address.endsWith('.') ? address.slice(0, address.length - 1) : address;
		    const normalizedSrvHost = srvHost.endsWith('.') ? srvHost.slice(0, srvHost.length - 1) : srvHost;
		    const allCharacterBeforeFirstDot = /^.*?\./;
		    // Remove all characters before first dot
		    // Add leading dot back to string so
		    //   an srvHostDomain = '.trusted.site'
		    //   will not satisfy an addressDomain that endsWith '.fake-trusted.site'
		    const addressDomain = `.${normalizedAddress.replace(allCharacterBeforeFirstDot, '')}`;
		    const srvHostDomain = `.${normalizedSrvHost.replace(allCharacterBeforeFirstDot, '')}`;
		    return addressDomain.endsWith(srvHostDomain);
		}
		/**
		 * Perform a get request that returns status and body.
		 * @internal
		 */
		function get(url, options = {}) {
		    return new Promise((resolve, reject) => {
		        /* eslint-disable prefer-const */
		        let timeoutId;
		        const request = http
		            .get(url, options, response => {
		            response.setEncoding('utf8');
		            let body = '';
		            response.on('data', chunk => (body += chunk));
		            response.on('end', () => {
		                (0, timers_1.clearTimeout)(timeoutId);
		                resolve({ status: response.statusCode, body });
		            });
		        })
		            .on('error', error => {
		            (0, timers_1.clearTimeout)(timeoutId);
		            reject(error);
		        })
		            .end();
		        timeoutId = (0, timers_1.setTimeout)(() => {
		            request.destroy(new error_1.MongoNetworkTimeoutError(`request timed out after 10 seconds`));
		        }, 10000);
		    });
		}
		async function request(uri, options = {}) {
		    return await new Promise((resolve, reject) => {
		        const requestOptions = {
		            method: 'GET',
		            timeout: 10000,
		            json: true,
		            ...url.parse(uri),
		            ...options
		        };
		        const req = http.request(requestOptions, res => {
		            res.setEncoding('utf8');
		            let data = '';
		            res.on('data', d => {
		                data += d;
		            });
		            res.once('end', () => {
		                if (options.json === false) {
		                    resolve(data);
		                    return;
		                }
		                try {
		                    const parsed = JSON.parse(data);
		                    resolve(parsed);
		                }
		                catch {
		                    // TODO(NODE-3483)
		                    reject(new error_1.MongoRuntimeError(`Invalid JSON response: "${data}"`));
		                }
		            });
		        });
		        req.once('timeout', () => req.destroy(new error_1.MongoNetworkTimeoutError(`Network request to ${uri} timed out after ${options.timeout} ms`)));
		        req.once('error', error => reject(error));
		        req.end();
		    });
		}
		/** @internal */
		exports.DOCUMENT_DB_CHECK = /(\.docdb\.amazonaws\.com$)|(\.docdb-elastic\.amazonaws\.com$)/;
		/** @internal */
		exports.COSMOS_DB_CHECK = /\.cosmos\.azure\.com$/;
		/** @internal */
		exports.DOCUMENT_DB_MSG = 'You appear to be connected to a DocumentDB cluster. For more information regarding feature compatibility and support please visit https://www.mongodb.com/supportability/documentdb';
		/** @internal */
		exports.COSMOS_DB_MSG = 'You appear to be connected to a CosmosDB cluster. For more information regarding feature compatibility and support please visit https://www.mongodb.com/supportability/cosmosdb';
		/** @internal */
		function isHostMatch(match, host) {
		    return host && match.test(host.toLowerCase()) ? true : false;
		}
		function promiseWithResolvers() {
		    let resolve;
		    let reject;
		    const promise = new Promise(function withResolversExecutor(promiseResolve, promiseReject) {
		        resolve = promiseResolve;
		        reject = promiseReject;
		    });
		    return { promise, resolve, reject };
		}
		/**
		 * A noop function intended for use in preventing unhandled rejections.
		 *
		 * @example
		 * ```js
		 * const promise = myAsyncTask();
		 * // eslint-disable-next-line github/no-then
		 * promise.then(undefined, squashError);
		 * ```
		 */
		function squashError(_error) {
		    return;
		}
		exports.randomBytes = (0, util_1.promisify)(crypto.randomBytes);
		/**
		 * Replicates the events.once helper.
		 *
		 * Removes unused signal logic and It **only** supports 0 or 1 argument events.
		 *
		 * @param ee - An event emitter that may emit `ev`
		 * @param name - An event name to wait for
		 */
		async function once(ee, name) {
		    const { promise, resolve, reject } = promiseWithResolvers();
		    const onEvent = (data) => resolve(data);
		    const onError = (error) => reject(error);
		    ee.once(name, onEvent).once('error', onError);
		    try {
		        const res = await promise;
		        ee.off('error', onError);
		        return res;
		    }
		    catch (error) {
		        ee.off(name, onEvent);
		        throw error;
		    }
		}
		function maybeAddIdToDocuments(coll, docOrDocs, options) {
		    const forceServerObjectId = typeof options.forceServerObjectId === 'boolean'
		        ? options.forceServerObjectId
		        : coll.s.db.options?.forceServerObjectId;
		    // no need to modify the docs if server sets the ObjectId
		    if (forceServerObjectId === true) {
		        return docOrDocs;
		    }
		    const transform = (doc) => {
		        if (doc._id == null) {
		            doc._id = coll.s.pkFactory.createPk();
		        }
		        return doc;
		    };
		    return Array.isArray(docOrDocs) ? docOrDocs.map(transform) : transform(docOrDocs);
		}
		async function fileIsAccessible(fileName, mode) {
		    try {
		        await fs_1.promises.access(fileName, mode);
		        return true;
		    }
		    catch {
		        return false;
		    }
		}
		function noop() {
		    return;
		}
		/**
		 * Recurse through the (identically-shaped) `decrypted` and `original`
		 * objects and attach a `decryptedKeys` property on each sub-object that
		 * contained encrypted fields. Because we only call this on BSON responses,
		 * we do not need to worry about circular references.
		 *
		 * @internal
		 */
		function decorateDecryptionResult(decrypted, original, isTopLevelDecorateCall = true) {
		    if (isTopLevelDecorateCall) {
		        // The original value could have been either a JS object or a BSON buffer
		        if (Buffer.isBuffer(original)) {
		            original = (0, bson_1.deserialize)(original);
		        }
		        if (Buffer.isBuffer(decrypted)) {
		            throw new error_1.MongoRuntimeError('Expected result of decryption to be deserialized BSON object');
		        }
		    }
		    if (!decrypted || typeof decrypted !== 'object')
		        return;
		    for (const k of Object.keys(decrypted)) {
		        const originalValue = original[k];
		        // An object was decrypted by libmongocrypt if and only if it was
		        // a BSON Binary object with subtype 6.
		        if (originalValue && originalValue._bsontype === 'Binary' && originalValue.sub_type === 6) {
		            if (!decrypted[constants_2.kDecoratedKeys]) {
		                Object.defineProperty(decrypted, constants_2.kDecoratedKeys, {
		                    value: [],
		                    configurable: true,
		                    enumerable: false,
		                    writable: false
		                });
		            }
		            // this is defined in the preceding if-statement
		            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
		            decrypted[constants_2.kDecoratedKeys].push(k);
		            // Do not recurse into this decrypted value. It could be a sub-document/array,
		            // in which case there is no original value associated with its subfields.
		            continue;
		        }
		        decorateDecryptionResult(decrypted[k], originalValue, false);
		    }
		}
		
	} (utils$1));
	return utils$1;
}

var operation = {};

var hasRequiredOperation;

function requireOperation () {
	if (hasRequiredOperation) return operation;
	hasRequiredOperation = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.AbstractOperation = exports.Aspect = void 0;
		exports.defineAspects = defineAspects;
		const bson_1 = requireBson();
		const read_preference_1 = requireRead_preference();
		exports.Aspect = {
		    READ_OPERATION: Symbol('READ_OPERATION'),
		    WRITE_OPERATION: Symbol('WRITE_OPERATION'),
		    RETRYABLE: Symbol('RETRYABLE'),
		    EXPLAINABLE: Symbol('EXPLAINABLE'),
		    SKIP_COLLATION: Symbol('SKIP_COLLATION'),
		    CURSOR_CREATING: Symbol('CURSOR_CREATING'),
		    MUST_SELECT_SAME_SERVER: Symbol('MUST_SELECT_SAME_SERVER')
		};
		/** @internal */
		const kSession = Symbol('session');
		/**
		 * This class acts as a parent class for any operation and is responsible for setting this.options,
		 * as well as setting and getting a session.
		 * Additionally, this class implements `hasAspect`, which determines whether an operation has
		 * a specific aspect.
		 * @internal
		 */
		class AbstractOperation {
		    constructor(options = {}) {
		        this.readPreference = this.hasAspect(exports.Aspect.WRITE_OPERATION)
		            ? read_preference_1.ReadPreference.primary
		            : (read_preference_1.ReadPreference.fromOptions(options) ?? read_preference_1.ReadPreference.primary);
		        // Pull the BSON serialize options from the already-resolved options
		        this.bsonOptions = (0, bson_1.resolveBSONOptions)(options);
		        this[kSession] = options.session != null ? options.session : undefined;
		        this.options = options;
		        this.bypassPinningCheck = !!options.bypassPinningCheck;
		        this.trySecondaryWrite = false;
		    }
		    hasAspect(aspect) {
		        const ctor = this.constructor;
		        if (ctor.aspects == null) {
		            return false;
		        }
		        return ctor.aspects.has(aspect);
		    }
		    get session() {
		        return this[kSession];
		    }
		    clearSession() {
		        this[kSession] = undefined;
		    }
		    get canRetryRead() {
		        return this.hasAspect(exports.Aspect.RETRYABLE) && this.hasAspect(exports.Aspect.READ_OPERATION);
		    }
		    get canRetryWrite() {
		        return this.hasAspect(exports.Aspect.RETRYABLE) && this.hasAspect(exports.Aspect.WRITE_OPERATION);
		    }
		}
		exports.AbstractOperation = AbstractOperation;
		function defineAspects(operation, aspects) {
		    if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
		        aspects = [aspects];
		    }
		    aspects = new Set(aspects);
		    Object.defineProperty(operation, 'aspects', {
		        value: aspects,
		        writable: false
		    });
		    return aspects;
		}
		
	} (operation));
	return operation;
}

var hasRequiredExecute_operation;

function requireExecute_operation () {
	if (hasRequiredExecute_operation) return execute_operation;
	hasRequiredExecute_operation = 1;
	Object.defineProperty(execute_operation, "__esModule", { value: true });
	execute_operation.executeOperation = executeOperation;
	const error_1 = requireError();
	const read_preference_1 = requireRead_preference();
	const server_selection_1 = requireServer_selection();
	const utils_1 = requireUtils$1();
	const operation_1 = requireOperation();
	const MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;
	const MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';
	/**
	 * Executes the given operation with provided arguments.
	 * @internal
	 *
	 * @remarks
	 * Allows for a single point of entry to provide features such as implicit sessions, which
	 * are required by the Driver Sessions specification in the event that a ClientSession is
	 * not provided.
	 *
	 * The expectation is that this function:
	 * - Connects the MongoClient if it has not already been connected, see {@link autoConnect}
	 * - Creates a session if none is provided and cleans up the session it creates
	 * - Tries an operation and retries under certain conditions, see {@link tryOperation}
	 *
	 * @typeParam T - The operation's type
	 * @typeParam TResult - The type of the operation's result, calculated from T
	 *
	 * @param client - The MongoClient to execute this operation with
	 * @param operation - The operation to execute
	 */
	async function executeOperation(client, operation) {
	    if (!(operation instanceof operation_1.AbstractOperation)) {
	        // TODO(NODE-3483): Extend MongoRuntimeError
	        throw new error_1.MongoRuntimeError('This method requires a valid operation instance');
	    }
	    const topology = await autoConnect(client);
	    // The driver sessions spec mandates that we implicitly create sessions for operations
	    // that are not explicitly provided with a session.
	    let session = operation.session;
	    let owner;
	    if (session == null) {
	        owner = Symbol();
	        session = client.startSession({ owner, explicit: false });
	    }
	    else if (session.hasEnded) {
	        throw new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted');
	    }
	    else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {
	        throw new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');
	    }
	    else if (session.client !== client) {
	        throw new error_1.MongoInvalidArgumentError('ClientSession must be from the same MongoClient');
	    }
	    if (session.explicit && session?.timeoutMS != null && operation.options.timeoutMS != null) {
	        throw new error_1.MongoInvalidArgumentError('Do not specify timeoutMS on operation if already specified on an explicit session');
	    }
	    const readPreference = operation.readPreference ?? read_preference_1.ReadPreference.primary;
	    const inTransaction = !!session?.inTransaction();
	    const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
	    if (inTransaction &&
	        !readPreference.equals(read_preference_1.ReadPreference.primary) &&
	        (hasReadAspect || operation.commandName === 'runCommand')) {
	        throw new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`);
	    }
	    if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {
	        session.unpin();
	    }
	    try {
	        return await tryOperation(operation, {
	            topology,
	            session,
	            readPreference
	        });
	    }
	    finally {
	        if (session?.owner != null && session.owner === owner) {
	            await session.endSession();
	        }
	    }
	}
	/**
	 * Connects a client if it has not yet been connected
	 * @internal
	 */
	async function autoConnect(client) {
	    if (client.topology == null) {
	        if (client.s.hasBeenClosed) {
	            throw new error_1.MongoNotConnectedError('Client must be connected before running operations');
	        }
	        client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;
	        try {
	            await client.connect();
	            if (client.topology == null) {
	                throw new error_1.MongoRuntimeError('client.connect did not create a topology but also did not throw');
	            }
	            return client.topology;
	        }
	        finally {
	            delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];
	        }
	    }
	    return client.topology;
	}
	/**
	 * Executes an operation and retries as appropriate
	 * @internal
	 *
	 * @remarks
	 * Implements behaviour described in [Retryable Reads](https://github.com/mongodb/specifications/blob/master/source/retryable-reads/retryable-reads.md) and [Retryable
	 * Writes](https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.md) specification
	 *
	 * This function:
	 * - performs initial server selection
	 * - attempts to execute an operation
	 * - retries the operation if it meets the criteria for a retryable read or a retryable write
	 *
	 * @typeParam T - The operation's type
	 * @typeParam TResult - The type of the operation's result, calculated from T
	 *
	 * @param operation - The operation to execute
	 * */
	async function tryOperation(operation, { topology, session, readPreference }) {
	    let selector;
	    if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {
	        // GetMore and KillCursor operations must always select the same server, but run through
	        // server selection to potentially force monitor checks if the server is
	        // in an unknown state.
	        selector = (0, server_selection_1.sameServerSelector)(operation.server?.description);
	    }
	    else if (operation.trySecondaryWrite) {
	        // If operation should try to write to secondary use the custom server selector
	        // otherwise provide the read preference.
	        selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);
	    }
	    else {
	        selector = readPreference;
	    }
	    let server = await topology.selectServer(selector, {
	        session,
	        operationName: operation.commandName
	    });
	    const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
	    const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);
	    const inTransaction = session?.inTransaction() ?? false;
	    const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;
	    const willRetryWrite = topology.s.options.retryWrites &&
	        !inTransaction &&
	        (0, utils_1.supportsRetryableWrites)(server) &&
	        operation.canRetryWrite;
	    const willRetry = operation.hasAspect(operation_1.Aspect.RETRYABLE) &&
	        session != null &&
	        ((hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite));
	    if (hasWriteAspect && willRetryWrite && session != null) {
	        operation.options.willRetryWrite = true;
	        session.incrementTransactionNumber();
	    }
	    // TODO(NODE-6231): implement infinite retry within CSOT timeout here
	    const maxTries = willRetry ? 2 : 1;
	    let previousOperationError;
	    let previousServer;
	    // TODO(NODE-6231): implement infinite retry within CSOT timeout here
	    for (let tries = 0; tries < maxTries; tries++) {
	        if (previousOperationError) {
	            if (hasWriteAspect && previousOperationError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {
	                throw new error_1.MongoServerError({
	                    message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
	                    errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
	                    originalError: previousOperationError
	                });
	            }
	            if (hasWriteAspect && !(0, error_1.isRetryableWriteError)(previousOperationError))
	                throw previousOperationError;
	            if (hasReadAspect && !(0, error_1.isRetryableReadError)(previousOperationError))
	                throw previousOperationError;
	            if (previousOperationError instanceof error_1.MongoNetworkError &&
	                operation.hasAspect(operation_1.Aspect.CURSOR_CREATING) &&
	                session != null &&
	                session.isPinned &&
	                !session.inTransaction()) {
	                session.unpin({ force: true, forceClear: true });
	            }
	            server = await topology.selectServer(selector, {
	                session,
	                operationName: operation.commandName,
	                previousServer
	            });
	            if (hasWriteAspect && !(0, utils_1.supportsRetryableWrites)(server)) {
	                throw new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes');
	            }
	        }
	        try {
	            return await operation.execute(server, session);
	        }
	        catch (operationError) {
	            if (!(operationError instanceof error_1.MongoError))
	                throw operationError;
	            if (previousOperationError != null &&
	                operationError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {
	                throw previousOperationError;
	            }
	            previousServer = server.description;
	            previousOperationError = operationError;
	        }
	    }
	    throw (previousOperationError ??
	        new error_1.MongoRuntimeError('Tried to propagate retryability error, but no error was found.'));
	}
	
	return execute_operation;
}

var list_databases = {};

var command = {};

var explain = {};

var hasRequiredExplain;

function requireExplain () {
	if (hasRequiredExplain) return explain;
	hasRequiredExplain = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Explain = exports.ExplainVerbosity = void 0;
		const error_1 = requireError();
		/** @public */
		exports.ExplainVerbosity = Object.freeze({
		    queryPlanner: 'queryPlanner',
		    queryPlannerExtended: 'queryPlannerExtended',
		    executionStats: 'executionStats',
		    allPlansExecution: 'allPlansExecution'
		});
		/** @internal */
		class Explain {
		    constructor(verbosity) {
		        if (typeof verbosity === 'boolean') {
		            this.verbosity = verbosity
		                ? exports.ExplainVerbosity.allPlansExecution
		                : exports.ExplainVerbosity.queryPlanner;
		        }
		        else {
		            this.verbosity = verbosity;
		        }
		    }
		    static fromOptions(options) {
		        if (options?.explain == null)
		            return;
		        const explain = options.explain;
		        if (typeof explain === 'boolean' || typeof explain === 'string') {
		            return new Explain(explain);
		        }
		        throw new error_1.MongoInvalidArgumentError('Field "explain" must be a string or a boolean');
		    }
		}
		exports.Explain = Explain;
		
	} (explain));
	return explain;
}

var hasRequiredCommand;

function requireCommand () {
	if (hasRequiredCommand) return command;
	hasRequiredCommand = 1;
	Object.defineProperty(command, "__esModule", { value: true });
	command.CommandOperation = void 0;
	const error_1 = requireError();
	const explain_1 = requireExplain();
	const read_concern_1 = requireRead_concern();
	const server_selection_1 = requireServer_selection();
	const utils_1 = requireUtils$1();
	const write_concern_1 = requireWrite_concern();
	const operation_1 = requireOperation();
	/** @internal */
	class CommandOperation extends operation_1.AbstractOperation {
	    constructor(parent, options) {
	        super(options);
	        this.options = options ?? {};
	        // NOTE: this was explicitly added for the add/remove user operations, it's likely
	        //       something we'd want to reconsider. Perhaps those commands can use `Admin`
	        //       as a parent?
	        const dbNameOverride = options?.dbName || options?.authdb;
	        if (dbNameOverride) {
	            this.ns = new utils_1.MongoDBNamespace(dbNameOverride, '$cmd');
	        }
	        else {
	            this.ns = parent
	                ? parent.s.namespace.withCollection('$cmd')
	                : new utils_1.MongoDBNamespace('admin', '$cmd');
	        }
	        this.readConcern = read_concern_1.ReadConcern.fromOptions(options);
	        this.writeConcern = write_concern_1.WriteConcern.fromOptions(options);
	        if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
	            this.explain = explain_1.Explain.fromOptions(options);
	        }
	        else if (options?.explain != null) {
	            throw new error_1.MongoInvalidArgumentError(`Option "explain" is not supported on this command`);
	        }
	    }
	    get canRetryWrite() {
	        if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
	            return this.explain == null;
	        }
	        return super.canRetryWrite;
	    }
	    async executeCommand(server, session, cmd, responseType) {
	        this.server = server;
	        const options = {
	            ...this.options,
	            ...this.bsonOptions,
	            readPreference: this.readPreference,
	            session
	        };
	        const serverWireVersion = (0, utils_1.maxWireVersion)(server);
	        const inTransaction = this.session && this.session.inTransaction();
	        if (this.readConcern && (0, utils_1.commandSupportsReadConcern)(cmd) && !inTransaction) {
	            Object.assign(cmd, { readConcern: this.readConcern });
	        }
	        if (this.trySecondaryWrite && serverWireVersion < server_selection_1.MIN_SECONDARY_WRITE_WIRE_VERSION) {
	            options.omitReadPreference = true;
	        }
	        if (this.writeConcern && this.hasAspect(operation_1.Aspect.WRITE_OPERATION) && !inTransaction) {
	            write_concern_1.WriteConcern.apply(cmd, this.writeConcern);
	        }
	        if (options.collation &&
	            typeof options.collation === 'object' &&
	            !this.hasAspect(operation_1.Aspect.SKIP_COLLATION)) {
	            Object.assign(cmd, { collation: options.collation });
	        }
	        if (typeof options.maxTimeMS === 'number') {
	            cmd.maxTimeMS = options.maxTimeMS;
	        }
	        if (this.hasAspect(operation_1.Aspect.EXPLAINABLE) && this.explain) {
	            cmd = (0, utils_1.decorateWithExplain)(cmd, this.explain);
	        }
	        return await server.command(this.ns, cmd, options, responseType);
	    }
	}
	command.CommandOperation = CommandOperation;
	
	return command;
}

var hasRequiredList_databases;

function requireList_databases () {
	if (hasRequiredList_databases) return list_databases;
	hasRequiredList_databases = 1;
	Object.defineProperty(list_databases, "__esModule", { value: true });
	list_databases.ListDatabasesOperation = void 0;
	const utils_1 = requireUtils$1();
	const command_1 = requireCommand();
	const operation_1 = requireOperation();
	/** @internal */
	class ListDatabasesOperation extends command_1.CommandOperation {
	    constructor(db, options) {
	        super(db, options);
	        this.options = options ?? {};
	        this.ns = new utils_1.MongoDBNamespace('admin', '$cmd');
	    }
	    get commandName() {
	        return 'listDatabases';
	    }
	    async execute(server, session) {
	        const cmd = { listDatabases: 1 };
	        if (typeof this.options.nameOnly === 'boolean') {
	            cmd.nameOnly = this.options.nameOnly;
	        }
	        if (this.options.filter) {
	            cmd.filter = this.options.filter;
	        }
	        if (typeof this.options.authorizedDatabases === 'boolean') {
	            cmd.authorizedDatabases = this.options.authorizedDatabases;
	        }
	        // we check for undefined specifically here to allow falsy values
	        // eslint-disable-next-line no-restricted-syntax
	        if ((0, utils_1.maxWireVersion)(server) >= 9 && this.options.comment !== undefined) {
	            cmd.comment = this.options.comment;
	        }
	        return await super.executeCommand(server, session, cmd);
	    }
	}
	list_databases.ListDatabasesOperation = ListDatabasesOperation;
	(0, operation_1.defineAspects)(ListDatabasesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);
	
	return list_databases;
}

var remove_user = {};

var hasRequiredRemove_user;

function requireRemove_user () {
	if (hasRequiredRemove_user) return remove_user;
	hasRequiredRemove_user = 1;
	Object.defineProperty(remove_user, "__esModule", { value: true });
	remove_user.RemoveUserOperation = void 0;
	const command_1 = requireCommand();
	const operation_1 = requireOperation();
	/** @internal */
	class RemoveUserOperation extends command_1.CommandOperation {
	    constructor(db, username, options) {
	        super(db, options);
	        this.options = options;
	        this.username = username;
	    }
	    get commandName() {
	        return 'dropUser';
	    }
	    async execute(server, session) {
	        await super.executeCommand(server, session, { dropUser: this.username });
	        return true;
	    }
	}
	remove_user.RemoveUserOperation = RemoveUserOperation;
	(0, operation_1.defineAspects)(RemoveUserOperation, [operation_1.Aspect.WRITE_OPERATION]);
	
	return remove_user;
}

var run_command = {};

var hasRequiredRun_command;

function requireRun_command () {
	if (hasRequiredRun_command) return run_command;
	hasRequiredRun_command = 1;
	Object.defineProperty(run_command, "__esModule", { value: true });
	run_command.RunAdminCommandOperation = run_command.RunCommandOperation = void 0;
	const utils_1 = requireUtils$1();
	const operation_1 = requireOperation();
	/** @internal */
	class RunCommandOperation extends operation_1.AbstractOperation {
	    constructor(parent, command, options) {
	        super(options);
	        this.command = command;
	        this.options = options;
	        this.ns = parent.s.namespace.withCollection('$cmd');
	    }
	    get commandName() {
	        return 'runCommand';
	    }
	    async execute(server, session) {
	        this.server = server;
	        const res = await server.command(this.ns, this.command, {
	            ...this.options,
	            readPreference: this.readPreference,
	            session
	        }, this.options.responseType);
	        return res;
	    }
	}
	run_command.RunCommandOperation = RunCommandOperation;
	class RunAdminCommandOperation extends operation_1.AbstractOperation {
	    constructor(command, options) {
	        super(options);
	        this.command = command;
	        this.options = options;
	        this.ns = new utils_1.MongoDBNamespace('admin', '$cmd');
	    }
	    get commandName() {
	        return 'runCommand';
	    }
	    async execute(server, session) {
	        this.server = server;
	        const res = await server.command(this.ns, this.command, {
	            ...this.options,
	            readPreference: this.readPreference,
	            session
	        });
	        return res;
	    }
	}
	run_command.RunAdminCommandOperation = RunAdminCommandOperation;
	
	return run_command;
}

var validate_collection = {};

var hasRequiredValidate_collection;

function requireValidate_collection () {
	if (hasRequiredValidate_collection) return validate_collection;
	hasRequiredValidate_collection = 1;
	Object.defineProperty(validate_collection, "__esModule", { value: true });
	validate_collection.ValidateCollectionOperation = void 0;
	const error_1 = requireError();
	const command_1 = requireCommand();
	/** @internal */
	class ValidateCollectionOperation extends command_1.CommandOperation {
	    constructor(admin, collectionName, options) {
	        // Decorate command with extra options
	        const command = { validate: collectionName };
	        const keys = Object.keys(options);
	        for (let i = 0; i < keys.length; i++) {
	            if (Object.prototype.hasOwnProperty.call(options, keys[i]) && keys[i] !== 'session') {
	                command[keys[i]] = options[keys[i]];
	            }
	        }
	        super(admin.s.db, options);
	        this.options = options;
	        this.command = command;
	        this.collectionName = collectionName;
	    }
	    get commandName() {
	        return 'validate';
	    }
	    async execute(server, session) {
	        const collectionName = this.collectionName;
	        const doc = await super.executeCommand(server, session, this.command);
	        if (doc.result != null && typeof doc.result !== 'string')
	            throw new error_1.MongoUnexpectedServerResponseError('Error with validation data');
	        if (doc.result != null && doc.result.match(/exception|corrupt/) != null)
	            throw new error_1.MongoUnexpectedServerResponseError(`Invalid collection ${collectionName}`);
	        if (doc.valid != null && !doc.valid)
	            throw new error_1.MongoUnexpectedServerResponseError(`Invalid collection ${collectionName}`);
	        return doc;
	    }
	}
	validate_collection.ValidateCollectionOperation = ValidateCollectionOperation;
	
	return validate_collection;
}

var hasRequiredAdmin;

function requireAdmin () {
	if (hasRequiredAdmin) return admin;
	hasRequiredAdmin = 1;
	Object.defineProperty(admin, "__esModule", { value: true });
	admin.Admin = void 0;
	const bson_1 = requireBson();
	const execute_operation_1 = requireExecute_operation();
	const list_databases_1 = requireList_databases();
	const remove_user_1 = requireRemove_user();
	const run_command_1 = requireRun_command();
	const validate_collection_1 = requireValidate_collection();
	/**
	 * The **Admin** class is an internal class that allows convenient access to
	 * the admin functionality and commands for MongoDB.
	 *
	 * **ADMIN Cannot directly be instantiated**
	 * @public
	 *
	 * @example
	 * ```ts
	 * import { MongoClient } from 'mongodb';
	 *
	 * const client = new MongoClient('mongodb://localhost:27017');
	 * const admin = client.db().admin();
	 * const dbInfo = await admin.listDatabases();
	 * for (const db of dbInfo.databases) {
	 *   console.log(db.name);
	 * }
	 * ```
	 */
	class Admin {
	    /**
	     * Create a new Admin instance
	     * @internal
	     */
	    constructor(db) {
	        this.s = { db };
	    }
	    /**
	     * Execute a command
	     *
	     * The driver will ensure the following fields are attached to the command sent to the server:
	     * - `lsid` - sourced from an implicit session or options.session
	     * - `$readPreference` - defaults to primary or can be configured by options.readPreference
	     * - `$db` - sourced from the name of this database
	     *
	     * If the client has a serverApi setting:
	     * - `apiVersion`
	     * - `apiStrict`
	     * - `apiDeprecationErrors`
	     *
	     * When in a transaction:
	     * - `readConcern` - sourced from readConcern set on the TransactionOptions
	     * - `writeConcern` - sourced from writeConcern set on the TransactionOptions
	     *
	     * Attaching any of the above fields to the command will have no effect as the driver will overwrite the value.
	     *
	     * @param command - The command to execute
	     * @param options - Optional settings for the command
	     */
	    async command(command, options) {
	        return await (0, execute_operation_1.executeOperation)(this.s.db.client, new run_command_1.RunAdminCommandOperation(command, {
	            ...(0, bson_1.resolveBSONOptions)(options),
	            session: options?.session,
	            readPreference: options?.readPreference
	        }));
	    }
	    /**
	     * Retrieve the server build information
	     *
	     * @param options - Optional settings for the command
	     */
	    async buildInfo(options) {
	        return await this.command({ buildinfo: 1 }, options);
	    }
	    /**
	     * Retrieve the server build information
	     *
	     * @param options - Optional settings for the command
	     */
	    async serverInfo(options) {
	        return await this.command({ buildinfo: 1 }, options);
	    }
	    /**
	     * Retrieve this db's server status.
	     *
	     * @param options - Optional settings for the command
	     */
	    async serverStatus(options) {
	        return await this.command({ serverStatus: 1 }, options);
	    }
	    /**
	     * Ping the MongoDB server and retrieve results
	     *
	     * @param options - Optional settings for the command
	     */
	    async ping(options) {
	        return await this.command({ ping: 1 }, options);
	    }
	    /**
	     * Remove a user from a database
	     *
	     * @param username - The username to remove
	     * @param options - Optional settings for the command
	     */
	    async removeUser(username, options) {
	        return await (0, execute_operation_1.executeOperation)(this.s.db.client, new remove_user_1.RemoveUserOperation(this.s.db, username, { dbName: 'admin', ...options }));
	    }
	    /**
	     * Validate an existing collection
	     *
	     * @param collectionName - The name of the collection to validate.
	     * @param options - Optional settings for the command
	     */
	    async validateCollection(collectionName, options = {}) {
	        return await (0, execute_operation_1.executeOperation)(this.s.db.client, new validate_collection_1.ValidateCollectionOperation(this, collectionName, options));
	    }
	    /**
	     * List the available databases
	     *
	     * @param options - Optional settings for the command
	     */
	    async listDatabases(options) {
	        return await (0, execute_operation_1.executeOperation)(this.s.db.client, new list_databases_1.ListDatabasesOperation(this.s.db, options));
	    }
	    /**
	     * Get ReplicaSet status
	     *
	     * @param options - Optional settings for the command
	     */
	    async replSetGetStatus(options) {
	        return await this.command({ replSetGetStatus: 1 }, options);
	    }
	}
	admin.Admin = Admin;
	
	return admin;
}

var ordered = {};

var common = {};

var _delete = {};

var hasRequired_delete;

function require_delete () {
	if (hasRequired_delete) return _delete;
	hasRequired_delete = 1;
	Object.defineProperty(_delete, "__esModule", { value: true });
	_delete.DeleteManyOperation = _delete.DeleteOneOperation = _delete.DeleteOperation = void 0;
	_delete.makeDeleteStatement = makeDeleteStatement;
	const error_1 = requireError();
	const command_1 = requireCommand();
	const operation_1 = requireOperation();
	/** @internal */
	class DeleteOperation extends command_1.CommandOperation {
	    constructor(ns, statements, options) {
	        super(undefined, options);
	        this.options = options;
	        this.ns = ns;
	        this.statements = statements;
	    }
	    get commandName() {
	        return 'delete';
	    }
	    get canRetryWrite() {
	        if (super.canRetryWrite === false) {
	            return false;
	        }
	        return this.statements.every(op => (op.limit != null ? op.limit > 0 : true));
	    }
	    async execute(server, session) {
	        const options = this.options ?? {};
	        const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;
	        const command = {
	            delete: this.ns.collection,
	            deletes: this.statements,
	            ordered
	        };
	        if (options.let) {
	            command.let = options.let;
	        }
	        // we check for undefined specifically here to allow falsy values
	        // eslint-disable-next-line no-restricted-syntax
	        if (options.comment !== undefined) {
	            command.comment = options.comment;
	        }
	        const unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;
	        if (unacknowledgedWrite) {
	            if (this.statements.find((o) => o.hint)) {
	                // TODO(NODE-3541): fix error for hint with unacknowledged writes
	                throw new error_1.MongoCompatibilityError(`hint is not supported with unacknowledged writes`);
	            }
	        }
	        const res = await super.executeCommand(server, session, command);
	        return res;
	    }
	}
	_delete.DeleteOperation = DeleteOperation;
	class DeleteOneOperation extends DeleteOperation {
	    constructor(collection, filter, options) {
	        super(collection.s.namespace, [makeDeleteStatement(filter, { ...options, limit: 1 })], options);
	    }
	    async execute(server, session) {
	        const res = await super.execute(server, session);
	        if (this.explain)
	            return res;
	        if (res.code)
	            throw new error_1.MongoServerError(res);
	        if (res.writeErrors)
	            throw new error_1.MongoServerError(res.writeErrors[0]);
	        return {
	            acknowledged: this.writeConcern?.w !== 0,
	            deletedCount: res.n
	        };
	    }
	}
	_delete.DeleteOneOperation = DeleteOneOperation;
	class DeleteManyOperation extends DeleteOperation {
	    constructor(collection, filter, options) {
	        super(collection.s.namespace, [makeDeleteStatement(filter, options)], options);
	    }
	    async execute(server, session) {
	        const res = await super.execute(server, session);
	        if (this.explain)
	            return res;
	        if (res.code)
	            throw new error_1.MongoServerError(res);
	        if (res.writeErrors)
	            throw new error_1.MongoServerError(res.writeErrors[0]);
	        return {
	            acknowledged: this.writeConcern?.w !== 0,
	            deletedCount: res.n
	        };
	    }
	}
	_delete.DeleteManyOperation = DeleteManyOperation;
	function makeDeleteStatement(filter, options) {
	    const op = {
	        q: filter,
	        limit: typeof options.limit === 'number' ? options.limit : 0
	    };
	    if (options.collation) {
	        op.collation = options.collation;
	    }
	    if (options.hint) {
	        op.hint = options.hint;
	    }
	    return op;
	}
	(0, operation_1.defineAspects)(DeleteOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
	(0, operation_1.defineAspects)(DeleteOneOperation, [
	    operation_1.Aspect.RETRYABLE,
	    operation_1.Aspect.WRITE_OPERATION,
	    operation_1.Aspect.EXPLAINABLE,
	    operation_1.Aspect.SKIP_COLLATION
	]);
	(0, operation_1.defineAspects)(DeleteManyOperation, [
	    operation_1.Aspect.WRITE_OPERATION,
	    operation_1.Aspect.EXPLAINABLE,
	    operation_1.Aspect.SKIP_COLLATION
	]);
	
	return _delete;
}

var insert = {};

var bulk_write = {};

var hasRequiredBulk_write;

function requireBulk_write () {
	if (hasRequiredBulk_write) return bulk_write;
	hasRequiredBulk_write = 1;
	Object.defineProperty(bulk_write, "__esModule", { value: true });
	bulk_write.BulkWriteOperation = void 0;
	const operation_1 = requireOperation();
	/** @internal */
	class BulkWriteOperation extends operation_1.AbstractOperation {
	    constructor(collection, operations, options) {
	        super(options);
	        this.options = options;
	        this.collection = collection;
	        this.operations = operations;
	    }
	    get commandName() {
	        return 'bulkWrite';
	    }
	    async execute(server, session) {
	        const coll = this.collection;
	        const operations = this.operations;
	        const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };
	        // Create the bulk operation
	        const bulk = options.ordered === false
	            ? coll.initializeUnorderedBulkOp(options)
	            : coll.initializeOrderedBulkOp(options);
	        // for each op go through and add to the bulk
	        for (let i = 0; i < operations.length; i++) {
	            bulk.raw(operations[i]);
	        }
	        // Execute the bulk
	        return await bulk.execute({ ...options, session });
	    }
	}
	bulk_write.BulkWriteOperation = BulkWriteOperation;
	(0, operation_1.defineAspects)(BulkWriteOperation, [operation_1.Aspect.WRITE_OPERATION]);
	
	return bulk_write;
}

var hasRequiredInsert;

function requireInsert () {
	if (hasRequiredInsert) return insert;
	hasRequiredInsert = 1;
	Object.defineProperty(insert, "__esModule", { value: true });
	insert.InsertManyOperation = insert.InsertOneOperation = insert.InsertOperation = void 0;
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	const write_concern_1 = requireWrite_concern();
	const bulk_write_1 = requireBulk_write();
	const command_1 = requireCommand();
	const operation_1 = requireOperation();
	/** @internal */
	class InsertOperation extends command_1.CommandOperation {
	    constructor(ns, documents, options) {
	        super(undefined, options);
	        this.options = { ...options, checkKeys: options.checkKeys ?? false };
	        this.ns = ns;
	        this.documents = documents;
	    }
	    get commandName() {
	        return 'insert';
	    }
	    async execute(server, session) {
	        const options = this.options ?? {};
	        const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;
	        const command = {
	            insert: this.ns.collection,
	            documents: this.documents,
	            ordered
	        };
	        if (typeof options.bypassDocumentValidation === 'boolean') {
	            command.bypassDocumentValidation = options.bypassDocumentValidation;
	        }
	        // we check for undefined specifically here to allow falsy values
	        // eslint-disable-next-line no-restricted-syntax
	        if (options.comment !== undefined) {
	            command.comment = options.comment;
	        }
	        return await super.executeCommand(server, session, command);
	    }
	}
	insert.InsertOperation = InsertOperation;
	class InsertOneOperation extends InsertOperation {
	    constructor(collection, doc, options) {
	        super(collection.s.namespace, (0, utils_1.maybeAddIdToDocuments)(collection, [doc], options), options);
	    }
	    async execute(server, session) {
	        const res = await super.execute(server, session);
	        if (res.code)
	            throw new error_1.MongoServerError(res);
	        if (res.writeErrors) {
	            // This should be a WriteError but we can't change it now because of error hierarchy
	            throw new error_1.MongoServerError(res.writeErrors[0]);
	        }
	        return {
	            acknowledged: this.writeConcern?.w !== 0,
	            insertedId: this.documents[0]._id
	        };
	    }
	}
	insert.InsertOneOperation = InsertOneOperation;
	/** @internal */
	class InsertManyOperation extends operation_1.AbstractOperation {
	    constructor(collection, docs, options) {
	        super(options);
	        if (!Array.isArray(docs)) {
	            throw new error_1.MongoInvalidArgumentError('Argument "docs" must be an array of documents');
	        }
	        this.options = options;
	        this.collection = collection;
	        this.docs = docs;
	    }
	    get commandName() {
	        return 'insert';
	    }
	    async execute(server, session) {
	        const coll = this.collection;
	        const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };
	        const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
	        const bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, this.docs.map(document => ({
	            insertOne: { document }
	        })), options);
	        try {
	            const res = await bulkWriteOperation.execute(server, session);
	            return {
	                acknowledged: writeConcern?.w !== 0,
	                insertedCount: res.insertedCount,
	                insertedIds: res.insertedIds
	            };
	        }
	        catch (err) {
	            if (err && err.message === 'Operation must be an object with an operation key') {
	                throw new error_1.MongoInvalidArgumentError('Collection.insertMany() cannot be called with an array that has null/undefined values');
	            }
	            throw err;
	        }
	    }
	}
	insert.InsertManyOperation = InsertManyOperation;
	(0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
	(0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
	(0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);
	
	return insert;
}

var update$1 = {};

var hasRequiredUpdate$1;

function requireUpdate$1 () {
	if (hasRequiredUpdate$1) return update$1;
	hasRequiredUpdate$1 = 1;
	Object.defineProperty(update$1, "__esModule", { value: true });
	update$1.ReplaceOneOperation = update$1.UpdateManyOperation = update$1.UpdateOneOperation = update$1.UpdateOperation = void 0;
	update$1.makeUpdateStatement = makeUpdateStatement;
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	const command_1 = requireCommand();
	const operation_1 = requireOperation();
	/**
	 * @internal
	 * UpdateOperation is used in bulk write, while UpdateOneOperation and UpdateManyOperation are only used in the collections API
	 */
	class UpdateOperation extends command_1.CommandOperation {
	    constructor(ns, statements, options) {
	        super(undefined, options);
	        this.options = options;
	        this.ns = ns;
	        this.statements = statements;
	    }
	    get commandName() {
	        return 'update';
	    }
	    get canRetryWrite() {
	        if (super.canRetryWrite === false) {
	            return false;
	        }
	        return this.statements.every(op => op.multi == null || op.multi === false);
	    }
	    async execute(server, session) {
	        const options = this.options ?? {};
	        const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;
	        const command = {
	            update: this.ns.collection,
	            updates: this.statements,
	            ordered
	        };
	        if (typeof options.bypassDocumentValidation === 'boolean') {
	            command.bypassDocumentValidation = options.bypassDocumentValidation;
	        }
	        if (options.let) {
	            command.let = options.let;
	        }
	        // we check for undefined specifically here to allow falsy values
	        // eslint-disable-next-line no-restricted-syntax
	        if (options.comment !== undefined) {
	            command.comment = options.comment;
	        }
	        const unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;
	        if (unacknowledgedWrite) {
	            if (this.statements.find((o) => o.hint)) {
	                // TODO(NODE-3541): fix error for hint with unacknowledged writes
	                throw new error_1.MongoCompatibilityError(`hint is not supported with unacknowledged writes`);
	            }
	        }
	        const res = await super.executeCommand(server, session, command);
	        return res;
	    }
	}
	update$1.UpdateOperation = UpdateOperation;
	/** @internal */
	class UpdateOneOperation extends UpdateOperation {
	    constructor(collection, filter, update, options) {
	        super(collection.s.namespace, [makeUpdateStatement(filter, update, { ...options, multi: false })], options);
	        if (!(0, utils_1.hasAtomicOperators)(update)) {
	            throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
	        }
	    }
	    async execute(server, session) {
	        const res = await super.execute(server, session);
	        if (this.explain != null)
	            return res;
	        if (res.code)
	            throw new error_1.MongoServerError(res);
	        if (res.writeErrors)
	            throw new error_1.MongoServerError(res.writeErrors[0]);
	        return {
	            acknowledged: this.writeConcern?.w !== 0,
	            modifiedCount: res.nModified ?? res.n,
	            upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
	            upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
	            matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
	        };
	    }
	}
	update$1.UpdateOneOperation = UpdateOneOperation;
	/** @internal */
	class UpdateManyOperation extends UpdateOperation {
	    constructor(collection, filter, update, options) {
	        super(collection.s.namespace, [makeUpdateStatement(filter, update, { ...options, multi: true })], options);
	        if (!(0, utils_1.hasAtomicOperators)(update)) {
	            throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
	        }
	    }
	    async execute(server, session) {
	        const res = await super.execute(server, session);
	        if (this.explain != null)
	            return res;
	        if (res.code)
	            throw new error_1.MongoServerError(res);
	        if (res.writeErrors)
	            throw new error_1.MongoServerError(res.writeErrors[0]);
	        return {
	            acknowledged: this.writeConcern?.w !== 0,
	            modifiedCount: res.nModified ?? res.n,
	            upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
	            upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
	            matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
	        };
	    }
	}
	update$1.UpdateManyOperation = UpdateManyOperation;
	/** @internal */
	class ReplaceOneOperation extends UpdateOperation {
	    constructor(collection, filter, replacement, options) {
	        super(collection.s.namespace, [makeUpdateStatement(filter, replacement, { ...options, multi: false })], options);
	        if ((0, utils_1.hasAtomicOperators)(replacement)) {
	            throw new error_1.MongoInvalidArgumentError('Replacement document must not contain atomic operators');
	        }
	    }
	    async execute(server, session) {
	        const res = await super.execute(server, session);
	        if (this.explain != null)
	            return res;
	        if (res.code)
	            throw new error_1.MongoServerError(res);
	        if (res.writeErrors)
	            throw new error_1.MongoServerError(res.writeErrors[0]);
	        return {
	            acknowledged: this.writeConcern?.w !== 0,
	            modifiedCount: res.nModified ?? res.n,
	            upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
	            upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
	            matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
	        };
	    }
	}
	update$1.ReplaceOneOperation = ReplaceOneOperation;
	function makeUpdateStatement(filter, update, options) {
	    if (filter == null || typeof filter !== 'object') {
	        throw new error_1.MongoInvalidArgumentError('Selector must be a valid JavaScript object');
	    }
	    if (update == null || typeof update !== 'object') {
	        throw new error_1.MongoInvalidArgumentError('Document must be a valid JavaScript object');
	    }
	    const op = { q: filter, u: update };
	    if (typeof options.upsert === 'boolean') {
	        op.upsert = options.upsert;
	    }
	    if (options.multi) {
	        op.multi = options.multi;
	    }
	    if (options.hint) {
	        op.hint = options.hint;
	    }
	    if (options.arrayFilters) {
	        op.arrayFilters = options.arrayFilters;
	    }
	    if (options.collation) {
	        op.collation = options.collation;
	    }
	    return op;
	}
	(0, operation_1.defineAspects)(UpdateOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.SKIP_COLLATION]);
	(0, operation_1.defineAspects)(UpdateOneOperation, [
	    operation_1.Aspect.RETRYABLE,
	    operation_1.Aspect.WRITE_OPERATION,
	    operation_1.Aspect.EXPLAINABLE,
	    operation_1.Aspect.SKIP_COLLATION
	]);
	(0, operation_1.defineAspects)(UpdateManyOperation, [
	    operation_1.Aspect.WRITE_OPERATION,
	    operation_1.Aspect.EXPLAINABLE,
	    operation_1.Aspect.SKIP_COLLATION
	]);
	(0, operation_1.defineAspects)(ReplaceOneOperation, [
	    operation_1.Aspect.RETRYABLE,
	    operation_1.Aspect.WRITE_OPERATION,
	    operation_1.Aspect.SKIP_COLLATION
	]);
	
	return update$1;
}

var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.BulkOperationBase = exports.BulkWriteShimOperation = exports.FindOperators = exports.MongoBulkWriteError = exports.WriteError = exports.WriteConcernError = exports.BulkWriteResult = exports.Batch = exports.BatchType = void 0;
		exports.mergeBatchResults = mergeBatchResults;
		const util_1 = require$$0$6;
		const bson_1 = requireBson();
		const error_1 = requireError();
		const delete_1 = require_delete();
		const execute_operation_1 = requireExecute_operation();
		const insert_1 = requireInsert();
		const operation_1 = requireOperation();
		const update_1 = requireUpdate$1();
		const utils_1 = requireUtils$1();
		const write_concern_1 = requireWrite_concern();
		/** @internal */
		const kServerError = Symbol('serverError');
		/** @public */
		exports.BatchType = Object.freeze({
		    INSERT: 1,
		    UPDATE: 2,
		    DELETE: 3
		});
		/**
		 * Keeps the state of a unordered batch so we can rewrite the results
		 * correctly after command execution
		 *
		 * @public
		 */
		class Batch {
		    constructor(batchType, originalZeroIndex) {
		        this.originalZeroIndex = originalZeroIndex;
		        this.currentIndex = 0;
		        this.originalIndexes = [];
		        this.batchType = batchType;
		        this.operations = [];
		        this.size = 0;
		        this.sizeBytes = 0;
		    }
		}
		exports.Batch = Batch;
		/**
		 * @public
		 * The result of a bulk write.
		 */
		class BulkWriteResult {
		    static generateIdMap(ids) {
		        const idMap = {};
		        for (const doc of ids) {
		            idMap[doc.index] = doc._id;
		        }
		        return idMap;
		    }
		    /**
		     * Create a new BulkWriteResult instance
		     * @internal
		     */
		    constructor(bulkResult, isOrdered) {
		        this.result = bulkResult;
		        this.insertedCount = this.result.nInserted ?? 0;
		        this.matchedCount = this.result.nMatched ?? 0;
		        this.modifiedCount = this.result.nModified ?? 0;
		        this.deletedCount = this.result.nRemoved ?? 0;
		        this.upsertedCount = this.result.upserted.length ?? 0;
		        this.upsertedIds = BulkWriteResult.generateIdMap(this.result.upserted);
		        this.insertedIds = BulkWriteResult.generateIdMap(this.getSuccessfullyInsertedIds(bulkResult, isOrdered));
		        Object.defineProperty(this, 'result', { value: this.result, enumerable: false });
		    }
		    /** Evaluates to true if the bulk operation correctly executes */
		    get ok() {
		        return this.result.ok;
		    }
		    /**
		     * Returns document_ids that were actually inserted
		     * @internal
		     */
		    getSuccessfullyInsertedIds(bulkResult, isOrdered) {
		        if (bulkResult.writeErrors.length === 0)
		            return bulkResult.insertedIds;
		        if (isOrdered) {
		            return bulkResult.insertedIds.slice(0, bulkResult.writeErrors[0].index);
		        }
		        return bulkResult.insertedIds.filter(({ index }) => !bulkResult.writeErrors.some(writeError => index === writeError.index));
		    }
		    /** Returns the upserted id at the given index */
		    getUpsertedIdAt(index) {
		        return this.result.upserted[index];
		    }
		    /** Returns raw internal result */
		    getRawResponse() {
		        return this.result;
		    }
		    /** Returns true if the bulk operation contains a write error */
		    hasWriteErrors() {
		        return this.result.writeErrors.length > 0;
		    }
		    /** Returns the number of write errors off the bulk operation */
		    getWriteErrorCount() {
		        return this.result.writeErrors.length;
		    }
		    /** Returns a specific write error object */
		    getWriteErrorAt(index) {
		        return index < this.result.writeErrors.length ? this.result.writeErrors[index] : undefined;
		    }
		    /** Retrieve all write errors */
		    getWriteErrors() {
		        return this.result.writeErrors;
		    }
		    /** Retrieve the write concern error if one exists */
		    getWriteConcernError() {
		        if (this.result.writeConcernErrors.length === 0) {
		            return;
		        }
		        else if (this.result.writeConcernErrors.length === 1) {
		            // Return the error
		            return this.result.writeConcernErrors[0];
		        }
		        else {
		            // Combine the errors
		            let errmsg = '';
		            for (let i = 0; i < this.result.writeConcernErrors.length; i++) {
		                const err = this.result.writeConcernErrors[i];
		                errmsg = errmsg + err.errmsg;
		                // TODO: Something better
		                if (i === 0)
		                    errmsg = errmsg + ' and ';
		            }
		            return new WriteConcernError({ errmsg, code: error_1.MONGODB_ERROR_CODES.WriteConcernFailed });
		        }
		    }
		    toString() {
		        return `BulkWriteResult(${bson_1.EJSON.stringify(this.result)})`;
		    }
		    isOk() {
		        return this.result.ok === 1;
		    }
		}
		exports.BulkWriteResult = BulkWriteResult;
		/**
		 * An error representing a failure by the server to apply the requested write concern to the bulk operation.
		 * @public
		 * @category Error
		 */
		class WriteConcernError {
		    constructor(error) {
		        this[kServerError] = error;
		    }
		    /** Write concern error code. */
		    get code() {
		        return this[kServerError].code;
		    }
		    /** Write concern error message. */
		    get errmsg() {
		        return this[kServerError].errmsg;
		    }
		    /** Write concern error info. */
		    get errInfo() {
		        return this[kServerError].errInfo;
		    }
		    toJSON() {
		        return this[kServerError];
		    }
		    toString() {
		        return `WriteConcernError(${this.errmsg})`;
		    }
		}
		exports.WriteConcernError = WriteConcernError;
		/**
		 * An error that occurred during a BulkWrite on the server.
		 * @public
		 * @category Error
		 */
		class WriteError {
		    constructor(err) {
		        this.err = err;
		    }
		    /** WriteError code. */
		    get code() {
		        return this.err.code;
		    }
		    /** WriteError original bulk operation index. */
		    get index() {
		        return this.err.index;
		    }
		    /** WriteError message. */
		    get errmsg() {
		        return this.err.errmsg;
		    }
		    /** WriteError details. */
		    get errInfo() {
		        return this.err.errInfo;
		    }
		    /** Returns the underlying operation that caused the error */
		    getOperation() {
		        return this.err.op;
		    }
		    toJSON() {
		        return { code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op };
		    }
		    toString() {
		        return `WriteError(${JSON.stringify(this.toJSON())})`;
		    }
		}
		exports.WriteError = WriteError;
		/** Merges results into shared data structure */
		function mergeBatchResults(batch, bulkResult, err, result) {
		    // If we have an error set the result to be the err object
		    if (err) {
		        result = err;
		    }
		    else if (result && result.result) {
		        result = result.result;
		    }
		    if (result == null) {
		        return;
		    }
		    // Do we have a top level error stop processing and return
		    if (result.ok === 0 && bulkResult.ok === 1) {
		        bulkResult.ok = 0;
		        const writeError = {
		            index: 0,
		            code: result.code || 0,
		            errmsg: result.message,
		            errInfo: result.errInfo,
		            op: batch.operations[0]
		        };
		        bulkResult.writeErrors.push(new WriteError(writeError));
		        return;
		    }
		    else if (result.ok === 0 && bulkResult.ok === 0) {
		        return;
		    }
		    // If we have an insert Batch type
		    if (isInsertBatch(batch) && result.n) {
		        bulkResult.nInserted = bulkResult.nInserted + result.n;
		    }
		    // If we have an insert Batch type
		    if (isDeleteBatch(batch) && result.n) {
		        bulkResult.nRemoved = bulkResult.nRemoved + result.n;
		    }
		    let nUpserted = 0;
		    // We have an array of upserted values, we need to rewrite the indexes
		    if (Array.isArray(result.upserted)) {
		        nUpserted = result.upserted.length;
		        for (let i = 0; i < result.upserted.length; i++) {
		            bulkResult.upserted.push({
		                index: result.upserted[i].index + batch.originalZeroIndex,
		                _id: result.upserted[i]._id
		            });
		        }
		    }
		    else if (result.upserted) {
		        nUpserted = 1;
		        bulkResult.upserted.push({
		            index: batch.originalZeroIndex,
		            _id: result.upserted
		        });
		    }
		    // If we have an update Batch type
		    if (isUpdateBatch(batch) && result.n) {
		        const nModified = result.nModified;
		        bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
		        bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
		        if (typeof nModified === 'number') {
		            bulkResult.nModified = bulkResult.nModified + nModified;
		        }
		        else {
		            bulkResult.nModified = 0;
		        }
		    }
		    if (Array.isArray(result.writeErrors)) {
		        for (let i = 0; i < result.writeErrors.length; i++) {
		            const writeError = {
		                index: batch.originalIndexes[result.writeErrors[i].index],
		                code: result.writeErrors[i].code,
		                errmsg: result.writeErrors[i].errmsg,
		                errInfo: result.writeErrors[i].errInfo,
		                op: batch.operations[result.writeErrors[i].index]
		            };
		            bulkResult.writeErrors.push(new WriteError(writeError));
		        }
		    }
		    if (result.writeConcernError) {
		        bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
		    }
		}
		function executeCommands(bulkOperation, options, callback) {
		    if (bulkOperation.s.batches.length === 0) {
		        return callback(undefined, new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered));
		    }
		    const batch = bulkOperation.s.batches.shift();
		    function resultHandler(err, result) {
		        // Error is a driver related error not a bulk op error, return early
		        if (err && 'message' in err && !(err instanceof error_1.MongoWriteConcernError)) {
		            return callback(new MongoBulkWriteError(err, new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered)));
		        }
		        if (err instanceof error_1.MongoWriteConcernError) {
		            return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, bulkOperation.isOrdered, err, callback);
		        }
		        // Merge the results together
		        mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);
		        const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
		        if (bulkOperation.handleWriteError(callback, writeResult))
		            return;
		        // Execute the next command in line
		        executeCommands(bulkOperation, options, callback);
		    }
		    const finalOptions = (0, utils_1.resolveOptions)(bulkOperation, {
		        ...options,
		        ordered: bulkOperation.isOrdered
		    });
		    if (finalOptions.bypassDocumentValidation !== true) {
		        delete finalOptions.bypassDocumentValidation;
		    }
		    // Set an operationIf if provided
		    if (bulkOperation.operationId) {
		        resultHandler.operationId = bulkOperation.operationId;
		    }
		    // Is the bypassDocumentValidation options specific
		    if (bulkOperation.s.bypassDocumentValidation === true) {
		        finalOptions.bypassDocumentValidation = true;
		    }
		    // Is the checkKeys option disabled
		    if (bulkOperation.s.checkKeys === false) {
		        finalOptions.checkKeys = false;
		    }
		    if (finalOptions.retryWrites) {
		        if (isUpdateBatch(batch)) {
		            finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some(op => op.multi);
		        }
		        if (isDeleteBatch(batch)) {
		            finalOptions.retryWrites =
		                finalOptions.retryWrites && !batch.operations.some(op => op.limit === 0);
		        }
		    }
		    try {
		        const operation = isInsertBatch(batch)
		            ? new insert_1.InsertOperation(bulkOperation.s.namespace, batch.operations, finalOptions)
		            : isUpdateBatch(batch)
		                ? new update_1.UpdateOperation(bulkOperation.s.namespace, batch.operations, finalOptions)
		                : isDeleteBatch(batch)
		                    ? new delete_1.DeleteOperation(bulkOperation.s.namespace, batch.operations, finalOptions)
		                    : null;
		        if (operation != null) {
		            (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.client, operation).then(result => resultHandler(undefined, result), error => resultHandler(error));
		        }
		    }
		    catch (err) {
		        // Force top level error
		        err.ok = 0;
		        // Merge top level error and return
		        mergeBatchResults(batch, bulkOperation.s.bulkResult, err, undefined);
		        callback();
		    }
		}
		function handleMongoWriteConcernError(batch, bulkResult, isOrdered, err, callback) {
		    mergeBatchResults(batch, bulkResult, undefined, err.result);
		    callback(new MongoBulkWriteError({
		        message: err.result.writeConcernError.errmsg,
		        code: err.result.writeConcernError.code
		    }, new BulkWriteResult(bulkResult, isOrdered)));
		}
		/**
		 * An error indicating an unsuccessful Bulk Write
		 * @public
		 * @category Error
		 */
		class MongoBulkWriteError extends error_1.MongoServerError {
		    /**
		     * **Do not use this constructor!**
		     *
		     * Meant for internal use only.
		     *
		     * @remarks
		     * This class is only meant to be constructed within the driver. This constructor is
		     * not subject to semantic versioning compatibility guarantees and may change at any time.
		     *
		     * @public
		     **/
		    constructor(error, result) {
		        super(error);
		        this.writeErrors = [];
		        if (error instanceof WriteConcernError)
		            this.err = error;
		        else if (!(error instanceof Error)) {
		            this.message = error.message;
		            this.code = error.code;
		            this.writeErrors = error.writeErrors ?? [];
		        }
		        this.result = result;
		        Object.assign(this, error);
		    }
		    get name() {
		        return 'MongoBulkWriteError';
		    }
		    /** Number of documents inserted. */
		    get insertedCount() {
		        return this.result.insertedCount;
		    }
		    /** Number of documents matched for update. */
		    get matchedCount() {
		        return this.result.matchedCount;
		    }
		    /** Number of documents modified. */
		    get modifiedCount() {
		        return this.result.modifiedCount;
		    }
		    /** Number of documents deleted. */
		    get deletedCount() {
		        return this.result.deletedCount;
		    }
		    /** Number of documents upserted. */
		    get upsertedCount() {
		        return this.result.upsertedCount;
		    }
		    /** Inserted document generated Id's, hash key is the index of the originating operation */
		    get insertedIds() {
		        return this.result.insertedIds;
		    }
		    /** Upserted document generated Id's, hash key is the index of the originating operation */
		    get upsertedIds() {
		        return this.result.upsertedIds;
		    }
		}
		exports.MongoBulkWriteError = MongoBulkWriteError;
		/**
		 * A builder object that is returned from {@link BulkOperationBase#find}.
		 * Is used to build a write operation that involves a query filter.
		 *
		 * @public
		 */
		class FindOperators {
		    /**
		     * Creates a new FindOperators object.
		     * @internal
		     */
		    constructor(bulkOperation) {
		        this.bulkOperation = bulkOperation;
		    }
		    /** Add a multiple update operation to the bulk operation */
		    update(updateDocument) {
		        const currentOp = buildCurrentOp(this.bulkOperation);
		        return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, {
		            ...currentOp,
		            multi: true
		        }));
		    }
		    /** Add a single update operation to the bulk operation */
		    updateOne(updateDocument) {
		        if (!(0, utils_1.hasAtomicOperators)(updateDocument)) {
		            throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
		        }
		        const currentOp = buildCurrentOp(this.bulkOperation);
		        return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, { ...currentOp, multi: false }));
		    }
		    /** Add a replace one operation to the bulk operation */
		    replaceOne(replacement) {
		        if ((0, utils_1.hasAtomicOperators)(replacement)) {
		            throw new error_1.MongoInvalidArgumentError('Replacement document must not use atomic operators');
		        }
		        const currentOp = buildCurrentOp(this.bulkOperation);
		        return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, replacement, { ...currentOp, multi: false }));
		    }
		    /** Add a delete one operation to the bulk operation */
		    deleteOne() {
		        const currentOp = buildCurrentOp(this.bulkOperation);
		        return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, { ...currentOp, limit: 1 }));
		    }
		    /** Add a delete many operation to the bulk operation */
		    delete() {
		        const currentOp = buildCurrentOp(this.bulkOperation);
		        return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, { ...currentOp, limit: 0 }));
		    }
		    /** Upsert modifier for update bulk operation, noting that this operation is an upsert. */
		    upsert() {
		        if (!this.bulkOperation.s.currentOp) {
		            this.bulkOperation.s.currentOp = {};
		        }
		        this.bulkOperation.s.currentOp.upsert = true;
		        return this;
		    }
		    /** Specifies the collation for the query condition. */
		    collation(collation) {
		        if (!this.bulkOperation.s.currentOp) {
		            this.bulkOperation.s.currentOp = {};
		        }
		        this.bulkOperation.s.currentOp.collation = collation;
		        return this;
		    }
		    /** Specifies arrayFilters for UpdateOne or UpdateMany bulk operations. */
		    arrayFilters(arrayFilters) {
		        if (!this.bulkOperation.s.currentOp) {
		            this.bulkOperation.s.currentOp = {};
		        }
		        this.bulkOperation.s.currentOp.arrayFilters = arrayFilters;
		        return this;
		    }
		    /** Specifies hint for the bulk operation. */
		    hint(hint) {
		        if (!this.bulkOperation.s.currentOp) {
		            this.bulkOperation.s.currentOp = {};
		        }
		        this.bulkOperation.s.currentOp.hint = hint;
		        return this;
		    }
		}
		exports.FindOperators = FindOperators;
		const executeCommandsAsync = (0, util_1.promisify)(executeCommands);
		/**
		 * TODO(NODE-4063)
		 * BulkWrites merge complexity is implemented in executeCommands
		 * This provides a vehicle to treat bulkOperations like any other operation (hence "shim")
		 * We would like this logic to simply live inside the BulkWriteOperation class
		 * @internal
		 */
		class BulkWriteShimOperation extends operation_1.AbstractOperation {
		    constructor(bulkOperation, options) {
		        super(options);
		        this.bulkOperation = bulkOperation;
		    }
		    get commandName() {
		        return 'bulkWrite';
		    }
		    execute(_server, session) {
		        if (this.options.session == null) {
		            // An implicit session could have been created by 'executeOperation'
		            // So if we stick it on finalOptions here, each bulk operation
		            // will use this same session, it'll be passed in the same way
		            // an explicit session would be
		            this.options.session = session;
		        }
		        return executeCommandsAsync(this.bulkOperation, this.options);
		    }
		}
		exports.BulkWriteShimOperation = BulkWriteShimOperation;
		/** @public */
		class BulkOperationBase {
		    /**
		     * Create a new OrderedBulkOperation or UnorderedBulkOperation instance
		     * @internal
		     */
		    constructor(collection, options, isOrdered) {
		        this.collection = collection;
		        // determine whether bulkOperation is ordered or unordered
		        this.isOrdered = isOrdered;
		        const topology = (0, utils_1.getTopology)(collection);
		        options = options == null ? {} : options;
		        // TODO Bring from driver information in hello
		        // Get the namespace for the write operations
		        const namespace = collection.s.namespace;
		        // Used to mark operation as executed
		        const executed = false;
		        // Current item
		        const currentOp = undefined;
		        // Set max byte size
		        const hello = topology.lastHello();
		        // If we have autoEncryption on, batch-splitting must be done on 2mb chunks, but single documents
		        // over 2mb are still allowed
		        const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
		        const maxBsonObjectSize = hello && hello.maxBsonObjectSize ? hello.maxBsonObjectSize : 1024 * 1024 * 16;
		        const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
		        const maxWriteBatchSize = hello && hello.maxWriteBatchSize ? hello.maxWriteBatchSize : 1000;
		        // Calculates the largest possible size of an Array key, represented as a BSON string
		        // element. This calculation:
		        //     1 byte for BSON type
		        //     # of bytes = length of (string representation of (maxWriteBatchSize - 1))
		        //   + 1 bytes for null terminator
		        const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;
		        // Final options for retryable writes
		        let finalOptions = Object.assign({}, options);
		        finalOptions = (0, utils_1.applyRetryableWrites)(finalOptions, collection.s.db);
		        // Final results
		        const bulkResult = {
		            ok: 1,
		            writeErrors: [],
		            writeConcernErrors: [],
		            insertedIds: [],
		            nInserted: 0,
		            nUpserted: 0,
		            nMatched: 0,
		            nModified: 0,
		            nRemoved: 0,
		            upserted: []
		        };
		        // Internal state
		        this.s = {
		            // Final result
		            bulkResult,
		            // Current batch state
		            currentBatch: undefined,
		            currentIndex: 0,
		            // ordered specific
		            currentBatchSize: 0,
		            currentBatchSizeBytes: 0,
		            // unordered specific
		            currentInsertBatch: undefined,
		            currentUpdateBatch: undefined,
		            currentRemoveBatch: undefined,
		            batches: [],
		            // Write concern
		            writeConcern: write_concern_1.WriteConcern.fromOptions(options),
		            // Max batch size options
		            maxBsonObjectSize,
		            maxBatchSizeBytes,
		            maxWriteBatchSize,
		            maxKeySize,
		            // Namespace
		            namespace,
		            // Topology
		            topology,
		            // Options
		            options: finalOptions,
		            // BSON options
		            bsonOptions: (0, bson_1.resolveBSONOptions)(options),
		            // Current operation
		            currentOp,
		            // Executed
		            executed,
		            // Collection
		            collection,
		            // Fundamental error
		            err: undefined,
		            // check keys
		            checkKeys: typeof options.checkKeys === 'boolean' ? options.checkKeys : false
		        };
		        // bypass Validation
		        if (options.bypassDocumentValidation === true) {
		            this.s.bypassDocumentValidation = true;
		        }
		    }
		    /**
		     * Add a single insert document to the bulk operation
		     *
		     * @example
		     * ```ts
		     * const bulkOp = collection.initializeOrderedBulkOp();
		     *
		     * // Adds three inserts to the bulkOp.
		     * bulkOp
		     *   .insert({ a: 1 })
		     *   .insert({ b: 2 })
		     *   .insert({ c: 3 });
		     * await bulkOp.execute();
		     * ```
		     */
		    insert(document) {
		        (0, utils_1.maybeAddIdToDocuments)(this.collection, document, {
		            forceServerObjectId: this.shouldForceServerObjectId()
		        });
		        return this.addToOperationsList(exports.BatchType.INSERT, document);
		    }
		    /**
		     * Builds a find operation for an update/updateOne/delete/deleteOne/replaceOne.
		     * Returns a builder object used to complete the definition of the operation.
		     *
		     * @example
		     * ```ts
		     * const bulkOp = collection.initializeOrderedBulkOp();
		     *
		     * // Add an updateOne to the bulkOp
		     * bulkOp.find({ a: 1 }).updateOne({ $set: { b: 2 } });
		     *
		     * // Add an updateMany to the bulkOp
		     * bulkOp.find({ c: 3 }).update({ $set: { d: 4 } });
		     *
		     * // Add an upsert
		     * bulkOp.find({ e: 5 }).upsert().updateOne({ $set: { f: 6 } });
		     *
		     * // Add a deletion
		     * bulkOp.find({ g: 7 }).deleteOne();
		     *
		     * // Add a multi deletion
		     * bulkOp.find({ h: 8 }).delete();
		     *
		     * // Add a replaceOne
		     * bulkOp.find({ i: 9 }).replaceOne({writeConcern: { j: 10 }});
		     *
		     * // Update using a pipeline (requires Mongodb 4.2 or higher)
		     * bulk.find({ k: 11, y: { $exists: true }, z: { $exists: true } }).updateOne([
		     *   { $set: { total: { $sum: [ '$y', '$z' ] } } }
		     * ]);
		     *
		     * // All of the ops will now be executed
		     * await bulkOp.execute();
		     * ```
		     */
		    find(selector) {
		        if (!selector) {
		            throw new error_1.MongoInvalidArgumentError('Bulk find operation must specify a selector');
		        }
		        // Save a current selector
		        this.s.currentOp = {
		            selector: selector
		        };
		        return new FindOperators(this);
		    }
		    /** Specifies a raw operation to perform in the bulk write. */
		    raw(op) {
		        if (op == null || typeof op !== 'object') {
		            throw new error_1.MongoInvalidArgumentError('Operation must be an object with an operation key');
		        }
		        if ('insertOne' in op) {
		            const forceServerObjectId = this.shouldForceServerObjectId();
		            const document = op.insertOne && op.insertOne.document == null
		                ? // TODO(NODE-6003): remove support for omitting the `documents` subdocument in bulk inserts
		                    op.insertOne
		                : op.insertOne.document;
		            (0, utils_1.maybeAddIdToDocuments)(this.collection, document, { forceServerObjectId });
		            return this.addToOperationsList(exports.BatchType.INSERT, document);
		        }
		        if ('replaceOne' in op || 'updateOne' in op || 'updateMany' in op) {
		            if ('replaceOne' in op) {
		                if ('q' in op.replaceOne) {
		                    throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
		                }
		                const updateStatement = (0, update_1.makeUpdateStatement)(op.replaceOne.filter, op.replaceOne.replacement, { ...op.replaceOne, multi: false });
		                if ((0, utils_1.hasAtomicOperators)(updateStatement.u)) {
		                    throw new error_1.MongoInvalidArgumentError('Replacement document must not use atomic operators');
		                }
		                return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
		            }
		            if ('updateOne' in op) {
		                if ('q' in op.updateOne) {
		                    throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
		                }
		                const updateStatement = (0, update_1.makeUpdateStatement)(op.updateOne.filter, op.updateOne.update, {
		                    ...op.updateOne,
		                    multi: false
		                });
		                if (!(0, utils_1.hasAtomicOperators)(updateStatement.u)) {
		                    throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
		                }
		                return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
		            }
		            if ('updateMany' in op) {
		                if ('q' in op.updateMany) {
		                    throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
		                }
		                const updateStatement = (0, update_1.makeUpdateStatement)(op.updateMany.filter, op.updateMany.update, {
		                    ...op.updateMany,
		                    multi: true
		                });
		                if (!(0, utils_1.hasAtomicOperators)(updateStatement.u)) {
		                    throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
		                }
		                return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
		            }
		        }
		        if ('deleteOne' in op) {
		            if ('q' in op.deleteOne) {
		                throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
		            }
		            return this.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteOne.filter, { ...op.deleteOne, limit: 1 }));
		        }
		        if ('deleteMany' in op) {
		            if ('q' in op.deleteMany) {
		                throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');
		            }
		            return this.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteMany.filter, { ...op.deleteMany, limit: 0 }));
		        }
		        // otherwise an unknown operation was provided
		        throw new error_1.MongoInvalidArgumentError('bulkWrite only supports insertOne, updateOne, updateMany, deleteOne, deleteMany');
		    }
		    get length() {
		        return this.s.currentIndex;
		    }
		    get bsonOptions() {
		        return this.s.bsonOptions;
		    }
		    get writeConcern() {
		        return this.s.writeConcern;
		    }
		    get batches() {
		        const batches = [...this.s.batches];
		        if (this.isOrdered) {
		            if (this.s.currentBatch)
		                batches.push(this.s.currentBatch);
		        }
		        else {
		            if (this.s.currentInsertBatch)
		                batches.push(this.s.currentInsertBatch);
		            if (this.s.currentUpdateBatch)
		                batches.push(this.s.currentUpdateBatch);
		            if (this.s.currentRemoveBatch)
		                batches.push(this.s.currentRemoveBatch);
		        }
		        return batches;
		    }
		    async execute(options = {}) {
		        if (this.s.executed) {
		            throw new error_1.MongoBatchReExecutionError();
		        }
		        const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
		        if (writeConcern) {
		            this.s.writeConcern = writeConcern;
		        }
		        // If we have current batch
		        if (this.isOrdered) {
		            if (this.s.currentBatch)
		                this.s.batches.push(this.s.currentBatch);
		        }
		        else {
		            if (this.s.currentInsertBatch)
		                this.s.batches.push(this.s.currentInsertBatch);
		            if (this.s.currentUpdateBatch)
		                this.s.batches.push(this.s.currentUpdateBatch);
		            if (this.s.currentRemoveBatch)
		                this.s.batches.push(this.s.currentRemoveBatch);
		        }
		        // If we have no operations in the bulk raise an error
		        if (this.s.batches.length === 0) {
		            throw new error_1.MongoInvalidArgumentError('Invalid BulkOperation, Batch cannot be empty');
		        }
		        this.s.executed = true;
		        const finalOptions = { ...this.s.options, ...options };
		        const operation = new BulkWriteShimOperation(this, finalOptions);
		        return await (0, execute_operation_1.executeOperation)(this.s.collection.client, operation);
		    }
		    /**
		     * Handles the write error before executing commands
		     * @internal
		     */
		    handleWriteError(callback, writeResult) {
		        if (this.s.bulkResult.writeErrors.length > 0) {
		            const msg = this.s.bulkResult.writeErrors[0].errmsg
		                ? this.s.bulkResult.writeErrors[0].errmsg
		                : 'write operation failed';
		            callback(new MongoBulkWriteError({
		                message: msg,
		                code: this.s.bulkResult.writeErrors[0].code,
		                writeErrors: this.s.bulkResult.writeErrors
		            }, writeResult));
		            return true;
		        }
		        const writeConcernError = writeResult.getWriteConcernError();
		        if (writeConcernError) {
		            callback(new MongoBulkWriteError(writeConcernError, writeResult));
		            return true;
		        }
		        return false;
		    }
		    shouldForceServerObjectId() {
		        return (this.s.options.forceServerObjectId === true ||
		            this.s.collection.s.db.options?.forceServerObjectId === true);
		    }
		}
		exports.BulkOperationBase = BulkOperationBase;
		function isInsertBatch(batch) {
		    return batch.batchType === exports.BatchType.INSERT;
		}
		function isUpdateBatch(batch) {
		    return batch.batchType === exports.BatchType.UPDATE;
		}
		function isDeleteBatch(batch) {
		    return batch.batchType === exports.BatchType.DELETE;
		}
		function buildCurrentOp(bulkOp) {
		    let { currentOp } = bulkOp.s;
		    bulkOp.s.currentOp = undefined;
		    if (!currentOp)
		        currentOp = {};
		    return currentOp;
		}
		
	} (common));
	return common;
}

var hasRequiredOrdered;

function requireOrdered () {
	if (hasRequiredOrdered) return ordered;
	hasRequiredOrdered = 1;
	Object.defineProperty(ordered, "__esModule", { value: true });
	ordered.OrderedBulkOperation = void 0;
	const BSON = requireBson();
	const error_1 = requireError();
	const common_1 = requireCommon();
	/** @public */
	class OrderedBulkOperation extends common_1.BulkOperationBase {
	    /** @internal */
	    constructor(collection, options) {
	        super(collection, options, true);
	    }
	    addToOperationsList(batchType, document) {
	        // Get the bsonSize
	        const bsonSize = BSON.calculateObjectSize(document, {
	            checkKeys: false,
	            // Since we don't know what the user selected for BSON options here,
	            // err on the safe side, and check the size with ignoreUndefined: false.
	            ignoreUndefined: false
	        });
	        // Throw error if the doc is bigger than the max BSON size
	        if (bsonSize >= this.s.maxBsonObjectSize)
	            // TODO(NODE-3483): Change this to MongoBSONError
	            throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);
	        // Create a new batch object if we don't have a current one
	        if (this.s.currentBatch == null) {
	            this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
	        }
	        const maxKeySize = this.s.maxKeySize;
	        // Check if we need to create a new batch
	        if (
	        // New batch if we exceed the max batch op size
	        this.s.currentBatchSize + 1 >= this.s.maxWriteBatchSize ||
	            // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,
	            // since we can't sent an empty batch
	            (this.s.currentBatchSize > 0 &&
	                this.s.currentBatchSizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes) ||
	            // New batch if the new op does not have the same op type as the current batch
	            this.s.currentBatch.batchType !== batchType) {
	            // Save the batch to the execution stack
	            this.s.batches.push(this.s.currentBatch);
	            // Create a new batch
	            this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
	            // Reset the current size trackers
	            this.s.currentBatchSize = 0;
	            this.s.currentBatchSizeBytes = 0;
	        }
	        if (batchType === common_1.BatchType.INSERT) {
	            this.s.bulkResult.insertedIds.push({
	                index: this.s.currentIndex,
	                _id: document._id
	            });
	        }
	        // We have an array of documents
	        if (Array.isArray(document)) {
	            throw new error_1.MongoInvalidArgumentError('Operation passed in cannot be an Array');
	        }
	        this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
	        this.s.currentBatch.operations.push(document);
	        this.s.currentBatchSize += 1;
	        this.s.currentBatchSizeBytes += maxKeySize + bsonSize;
	        this.s.currentIndex += 1;
	        return this;
	    }
	}
	ordered.OrderedBulkOperation = OrderedBulkOperation;
	
	return ordered;
}

var unordered = {};

var hasRequiredUnordered;

function requireUnordered () {
	if (hasRequiredUnordered) return unordered;
	hasRequiredUnordered = 1;
	Object.defineProperty(unordered, "__esModule", { value: true });
	unordered.UnorderedBulkOperation = void 0;
	const BSON = requireBson();
	const error_1 = requireError();
	const common_1 = requireCommon();
	/** @public */
	class UnorderedBulkOperation extends common_1.BulkOperationBase {
	    /** @internal */
	    constructor(collection, options) {
	        super(collection, options, false);
	    }
	    handleWriteError(callback, writeResult) {
	        if (this.s.batches.length) {
	            return false;
	        }
	        return super.handleWriteError(callback, writeResult);
	    }
	    addToOperationsList(batchType, document) {
	        // Get the bsonSize
	        const bsonSize = BSON.calculateObjectSize(document, {
	            checkKeys: false,
	            // Since we don't know what the user selected for BSON options here,
	            // err on the safe side, and check the size with ignoreUndefined: false.
	            ignoreUndefined: false
	        });
	        // Throw error if the doc is bigger than the max BSON size
	        if (bsonSize >= this.s.maxBsonObjectSize) {
	            // TODO(NODE-3483): Change this to MongoBSONError
	            throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);
	        }
	        // Holds the current batch
	        this.s.currentBatch = undefined;
	        // Get the right type of batch
	        if (batchType === common_1.BatchType.INSERT) {
	            this.s.currentBatch = this.s.currentInsertBatch;
	        }
	        else if (batchType === common_1.BatchType.UPDATE) {
	            this.s.currentBatch = this.s.currentUpdateBatch;
	        }
	        else if (batchType === common_1.BatchType.DELETE) {
	            this.s.currentBatch = this.s.currentRemoveBatch;
	        }
	        const maxKeySize = this.s.maxKeySize;
	        // Create a new batch object if we don't have a current one
	        if (this.s.currentBatch == null) {
	            this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
	        }
	        // Check if we need to create a new batch
	        if (
	        // New batch if we exceed the max batch op size
	        this.s.currentBatch.size + 1 >= this.s.maxWriteBatchSize ||
	            // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,
	            // since we can't sent an empty batch
	            (this.s.currentBatch.size > 0 &&
	                this.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes) ||
	            // New batch if the new op does not have the same op type as the current batch
	            this.s.currentBatch.batchType !== batchType) {
	            // Save the batch to the execution stack
	            this.s.batches.push(this.s.currentBatch);
	            // Create a new batch
	            this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
	        }
	        // We have an array of documents
	        if (Array.isArray(document)) {
	            throw new error_1.MongoInvalidArgumentError('Operation passed in cannot be an Array');
	        }
	        this.s.currentBatch.operations.push(document);
	        this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
	        this.s.currentIndex = this.s.currentIndex + 1;
	        // Save back the current Batch to the right type
	        if (batchType === common_1.BatchType.INSERT) {
	            this.s.currentInsertBatch = this.s.currentBatch;
	            this.s.bulkResult.insertedIds.push({
	                index: this.s.bulkResult.insertedIds.length,
	                _id: document._id
	            });
	        }
	        else if (batchType === common_1.BatchType.UPDATE) {
	            this.s.currentUpdateBatch = this.s.currentBatch;
	        }
	        else if (batchType === common_1.BatchType.DELETE) {
	            this.s.currentRemoveBatch = this.s.currentBatch;
	        }
	        // Update current batch size
	        this.s.currentBatch.size += 1;
	        this.s.currentBatch.sizeBytes += maxKeySize + bsonSize;
	        return this;
	    }
	}
	unordered.UnorderedBulkOperation = UnorderedBulkOperation;
	
	return unordered;
}

var change_stream = {};

var collection = {};

var aggregation_cursor = {};

var aggregate = {};

var hasRequiredAggregate;

function requireAggregate () {
	if (hasRequiredAggregate) return aggregate;
	hasRequiredAggregate = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.AggregateOperation = exports.DB_AGGREGATE_COLLECTION = void 0;
		const responses_1 = requireResponses();
		const error_1 = requireError();
		const utils_1 = requireUtils$1();
		const write_concern_1 = requireWrite_concern();
		const command_1 = requireCommand();
		const operation_1 = requireOperation();
		/** @internal */
		// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
		exports.DB_AGGREGATE_COLLECTION = 1;
		const MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;
		/** @internal */
		class AggregateOperation extends command_1.CommandOperation {
		    constructor(ns, pipeline, options) {
		        super(undefined, { ...options, dbName: ns.db });
		        this.options = { ...options };
		        // Covers when ns.collection is null, undefined or the empty string, use DB_AGGREGATE_COLLECTION
		        this.target = ns.collection || exports.DB_AGGREGATE_COLLECTION;
		        this.pipeline = pipeline;
		        // determine if we have a write stage, override read preference if so
		        this.hasWriteStage = false;
		        if (typeof options?.out === 'string') {
		            this.pipeline = this.pipeline.concat({ $out: options.out });
		            this.hasWriteStage = true;
		        }
		        else if (pipeline.length > 0) {
		            const finalStage = pipeline[pipeline.length - 1];
		            if (finalStage.$out || finalStage.$merge) {
		                this.hasWriteStage = true;
		            }
		        }
		        if (this.hasWriteStage) {
		            this.trySecondaryWrite = true;
		        }
		        else {
		            delete this.options.writeConcern;
		        }
		        if (this.explain && this.writeConcern) {
		            throw new error_1.MongoInvalidArgumentError('Option "explain" cannot be used on an aggregate call with writeConcern');
		        }
		        if (options?.cursor != null && typeof options.cursor !== 'object') {
		            throw new error_1.MongoInvalidArgumentError('Cursor options must be an object');
		        }
		    }
		    get commandName() {
		        return 'aggregate';
		    }
		    get canRetryRead() {
		        return !this.hasWriteStage;
		    }
		    addToPipeline(stage) {
		        this.pipeline.push(stage);
		    }
		    async execute(server, session) {
		        const options = this.options;
		        const serverWireVersion = (0, utils_1.maxWireVersion)(server);
		        const command = { aggregate: this.target, pipeline: this.pipeline };
		        if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
		            this.readConcern = undefined;
		        }
		        if (this.hasWriteStage && this.writeConcern) {
		            write_concern_1.WriteConcern.apply(command, this.writeConcern);
		        }
		        if (options.bypassDocumentValidation === true) {
		            command.bypassDocumentValidation = options.bypassDocumentValidation;
		        }
		        if (typeof options.allowDiskUse === 'boolean') {
		            command.allowDiskUse = options.allowDiskUse;
		        }
		        if (options.hint) {
		            command.hint = options.hint;
		        }
		        if (options.let) {
		            command.let = options.let;
		        }
		        // we check for undefined specifically here to allow falsy values
		        // eslint-disable-next-line no-restricted-syntax
		        if (options.comment !== undefined) {
		            command.comment = options.comment;
		        }
		        command.cursor = options.cursor || {};
		        if (options.batchSize && !this.hasWriteStage) {
		            command.cursor.batchSize = options.batchSize;
		        }
		        return await super.executeCommand(server, session, command, this.explain ? responses_1.ExplainedCursorResponse : responses_1.CursorResponse);
		    }
		}
		exports.AggregateOperation = AggregateOperation;
		(0, operation_1.defineAspects)(AggregateOperation, [
		    operation_1.Aspect.READ_OPERATION,
		    operation_1.Aspect.RETRYABLE,
		    operation_1.Aspect.EXPLAINABLE,
		    operation_1.Aspect.CURSOR_CREATING
		]);
		
	} (aggregate));
	return aggregate;
}

var abstract_cursor = {};

var mongo_types = {};

var mongo_logger = {};

var hasRequiredMongo_logger;

function requireMongo_logger () {
	if (hasRequiredMongo_logger) return mongo_logger;
	hasRequiredMongo_logger = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.MongoLogger = exports.MongoLoggableComponent = exports.SEVERITY_LEVEL_MAP = exports.DEFAULT_MAX_DOCUMENT_LENGTH = exports.SeverityLevel = void 0;
		exports.parseSeverityFromString = parseSeverityFromString;
		exports.createStdioLogger = createStdioLogger;
		exports.stringifyWithMaxLen = stringifyWithMaxLen;
		exports.defaultLogTransform = defaultLogTransform;
		const util_1 = require$$0$6;
		const bson_1 = requireBson();
		const constants_1 = requireConstants();
		const utils_1 = requireUtils$1();
		/** @internal */
		exports.SeverityLevel = Object.freeze({
		    EMERGENCY: 'emergency',
		    ALERT: 'alert',
		    CRITICAL: 'critical',
		    ERROR: 'error',
		    WARNING: 'warn',
		    NOTICE: 'notice',
		    INFORMATIONAL: 'info',
		    DEBUG: 'debug',
		    TRACE: 'trace',
		    OFF: 'off'
		});
		/** @internal */
		exports.DEFAULT_MAX_DOCUMENT_LENGTH = 1000;
		/** @internal */
		class SeverityLevelMap extends Map {
		    constructor(entries) {
		        const newEntries = [];
		        for (const [level, value] of entries) {
		            newEntries.push([value, level]);
		        }
		        newEntries.push(...entries);
		        super(newEntries);
		    }
		    getNumericSeverityLevel(severity) {
		        return this.get(severity);
		    }
		    getSeverityLevelName(level) {
		        return this.get(level);
		    }
		}
		/** @internal */
		exports.SEVERITY_LEVEL_MAP = new SeverityLevelMap([
		    [exports.SeverityLevel.OFF, -Infinity],
		    [exports.SeverityLevel.EMERGENCY, 0],
		    [exports.SeverityLevel.ALERT, 1],
		    [exports.SeverityLevel.CRITICAL, 2],
		    [exports.SeverityLevel.ERROR, 3],
		    [exports.SeverityLevel.WARNING, 4],
		    [exports.SeverityLevel.NOTICE, 5],
		    [exports.SeverityLevel.INFORMATIONAL, 6],
		    [exports.SeverityLevel.DEBUG, 7],
		    [exports.SeverityLevel.TRACE, 8]
		]);
		/** @internal */
		exports.MongoLoggableComponent = Object.freeze({
		    COMMAND: 'command',
		    TOPOLOGY: 'topology',
		    SERVER_SELECTION: 'serverSelection',
		    CONNECTION: 'connection',
		    CLIENT: 'client'
		});
		/**
		 * Parses a string as one of SeverityLevel
		 * @internal
		 *
		 * @param s - the value to be parsed
		 * @returns one of SeverityLevel if value can be parsed as such, otherwise null
		 */
		function parseSeverityFromString(s) {
		    const validSeverities = Object.values(exports.SeverityLevel);
		    const lowerSeverity = s?.toLowerCase();
		    if (lowerSeverity != null && validSeverities.includes(lowerSeverity)) {
		        return lowerSeverity;
		    }
		    return null;
		}
		/** @internal */
		function createStdioLogger(stream) {
		    return {
		        write: (0, util_1.promisify)((log, cb) => {
		            const logLine = (0, util_1.inspect)(log, { compact: true, breakLength: Infinity });
		            stream.write(`${logLine}\n`, 'utf-8', cb);
		            return;
		        })
		    };
		}
		/**
		 * resolves the MONGODB_LOG_PATH and mongodbLogPath options from the environment and the
		 * mongo client options respectively. The mongodbLogPath can be either 'stdout', 'stderr', a NodeJS
		 * Writable or an object which has a `write` method with the signature:
		 * ```ts
		 * write(log: Log): void
		 * ```
		 *
		 * @returns the MongoDBLogWritable object to write logs to
		 */
		function resolveLogPath({ MONGODB_LOG_PATH }, { mongodbLogPath }) {
		    if (typeof mongodbLogPath === 'string' && /^stderr$/i.test(mongodbLogPath)) {
		        return { mongodbLogPath: createStdioLogger(process.stderr), mongodbLogPathIsStdErr: true };
		    }
		    if (typeof mongodbLogPath === 'string' && /^stdout$/i.test(mongodbLogPath)) {
		        return { mongodbLogPath: createStdioLogger(process.stdout), mongodbLogPathIsStdErr: false };
		    }
		    if (typeof mongodbLogPath === 'object' && typeof mongodbLogPath?.write === 'function') {
		        return { mongodbLogPath: mongodbLogPath, mongodbLogPathIsStdErr: false };
		    }
		    if (MONGODB_LOG_PATH && /^stderr$/i.test(MONGODB_LOG_PATH)) {
		        return { mongodbLogPath: createStdioLogger(process.stderr), mongodbLogPathIsStdErr: true };
		    }
		    if (MONGODB_LOG_PATH && /^stdout$/i.test(MONGODB_LOG_PATH)) {
		        return { mongodbLogPath: createStdioLogger(process.stdout), mongodbLogPathIsStdErr: false };
		    }
		    return { mongodbLogPath: createStdioLogger(process.stderr), mongodbLogPathIsStdErr: true };
		}
		function resolveSeverityConfiguration(clientOption, environmentOption, defaultSeverity) {
		    return (parseSeverityFromString(clientOption) ??
		        parseSeverityFromString(environmentOption) ??
		        defaultSeverity);
		}
		function compareSeverity(s0, s1) {
		    const s0Num = exports.SEVERITY_LEVEL_MAP.getNumericSeverityLevel(s0);
		    const s1Num = exports.SEVERITY_LEVEL_MAP.getNumericSeverityLevel(s1);
		    return s0Num < s1Num ? -1 : s0Num > s1Num ? 1 : 0;
		}
		/** @internal */
		function stringifyWithMaxLen(value, maxDocumentLength, options = {}) {
		    let strToTruncate = '';
		    if (typeof value === 'string') {
		        strToTruncate = value;
		    }
		    else if (typeof value === 'function') {
		        strToTruncate = value.name;
		    }
		    else {
		        try {
		            strToTruncate = bson_1.EJSON.stringify(value, options);
		        }
		        catch (e) {
		            strToTruncate = `Extended JSON serialization failed with: ${e.message}`;
		        }
		    }
		    // handle truncation that occurs in the middle of multi-byte codepoints
		    if (maxDocumentLength !== 0 &&
		        strToTruncate.length > maxDocumentLength &&
		        strToTruncate.charCodeAt(maxDocumentLength - 1) !==
		            strToTruncate.codePointAt(maxDocumentLength - 1)) {
		        maxDocumentLength--;
		        if (maxDocumentLength === 0) {
		            return '';
		        }
		    }
		    return maxDocumentLength !== 0 && strToTruncate.length > maxDocumentLength
		        ? `${strToTruncate.slice(0, maxDocumentLength)}...`
		        : strToTruncate;
		}
		function isLogConvertible(obj) {
		    const objAsLogConvertible = obj;
		    // eslint-disable-next-line no-restricted-syntax
		    return objAsLogConvertible.toLog !== undefined && typeof objAsLogConvertible.toLog === 'function';
		}
		function attachServerSelectionFields(log, serverSelectionEvent, maxDocumentLength = exports.DEFAULT_MAX_DOCUMENT_LENGTH) {
		    const { selector, operation, topologyDescription, message } = serverSelectionEvent;
		    log.selector = stringifyWithMaxLen(selector, maxDocumentLength);
		    log.operation = operation;
		    log.topologyDescription = stringifyWithMaxLen(topologyDescription, maxDocumentLength);
		    log.message = message;
		    return log;
		}
		function attachCommandFields(log, commandEvent) {
		    log.commandName = commandEvent.commandName;
		    log.requestId = commandEvent.requestId;
		    log.driverConnectionId = commandEvent.connectionId;
		    const { host, port } = utils_1.HostAddress.fromString(commandEvent.address).toHostPort();
		    log.serverHost = host;
		    log.serverPort = port;
		    if (commandEvent?.serviceId) {
		        log.serviceId = commandEvent.serviceId.toHexString();
		    }
		    log.databaseName = commandEvent.databaseName;
		    log.serverConnectionId = commandEvent.serverConnectionId;
		    return log;
		}
		function attachConnectionFields(log, event) {
		    const { host, port } = utils_1.HostAddress.fromString(event.address).toHostPort();
		    log.serverHost = host;
		    log.serverPort = port;
		    return log;
		}
		function attachSDAMFields(log, sdamEvent) {
		    log.topologyId = sdamEvent.topologyId;
		    return log;
		}
		function attachServerHeartbeatFields(log, serverHeartbeatEvent) {
		    const { awaited, connectionId } = serverHeartbeatEvent;
		    log.awaited = awaited;
		    log.driverConnectionId = serverHeartbeatEvent.connectionId;
		    const { host, port } = utils_1.HostAddress.fromString(connectionId).toHostPort();
		    log.serverHost = host;
		    log.serverPort = port;
		    return log;
		}
		/** @internal */
		function defaultLogTransform(logObject, maxDocumentLength = exports.DEFAULT_MAX_DOCUMENT_LENGTH) {
		    let log = Object.create(null);
		    switch (logObject.name) {
		        case constants_1.SERVER_SELECTION_STARTED:
		            log = attachServerSelectionFields(log, logObject, maxDocumentLength);
		            return log;
		        case constants_1.SERVER_SELECTION_FAILED:
		            log = attachServerSelectionFields(log, logObject, maxDocumentLength);
		            log.failure = logObject.failure?.message;
		            return log;
		        case constants_1.SERVER_SELECTION_SUCCEEDED:
		            log = attachServerSelectionFields(log, logObject, maxDocumentLength);
		            log.serverHost = logObject.serverHost;
		            log.serverPort = logObject.serverPort;
		            return log;
		        case constants_1.WAITING_FOR_SUITABLE_SERVER:
		            log = attachServerSelectionFields(log, logObject, maxDocumentLength);
		            log.remainingTimeMS = logObject.remainingTimeMS;
		            return log;
		        case constants_1.COMMAND_STARTED:
		            log = attachCommandFields(log, logObject);
		            log.message = 'Command started';
		            log.command = stringifyWithMaxLen(logObject.command, maxDocumentLength, { relaxed: true });
		            log.databaseName = logObject.databaseName;
		            return log;
		        case constants_1.COMMAND_SUCCEEDED:
		            log = attachCommandFields(log, logObject);
		            log.message = 'Command succeeded';
		            log.durationMS = logObject.duration;
		            log.reply = stringifyWithMaxLen(logObject.reply, maxDocumentLength, { relaxed: true });
		            return log;
		        case constants_1.COMMAND_FAILED:
		            log = attachCommandFields(log, logObject);
		            log.message = 'Command failed';
		            log.durationMS = logObject.duration;
		            log.failure = logObject.failure?.message ?? '(redacted)';
		            return log;
		        case constants_1.CONNECTION_POOL_CREATED:
		            log = attachConnectionFields(log, logObject);
		            log.message = 'Connection pool created';
		            if (logObject.options) {
		                const { maxIdleTimeMS, minPoolSize, maxPoolSize, maxConnecting, waitQueueTimeoutMS } = logObject.options;
		                log = {
		                    ...log,
		                    maxIdleTimeMS,
		                    minPoolSize,
		                    maxPoolSize,
		                    maxConnecting,
		                    waitQueueTimeoutMS
		                };
		            }
		            return log;
		        case constants_1.CONNECTION_POOL_READY:
		            log = attachConnectionFields(log, logObject);
		            log.message = 'Connection pool ready';
		            return log;
		        case constants_1.CONNECTION_POOL_CLEARED:
		            log = attachConnectionFields(log, logObject);
		            log.message = 'Connection pool cleared';
		            if (logObject.serviceId?._bsontype === 'ObjectId') {
		                log.serviceId = logObject.serviceId?.toHexString();
		            }
		            return log;
		        case constants_1.CONNECTION_POOL_CLOSED:
		            log = attachConnectionFields(log, logObject);
		            log.message = 'Connection pool closed';
		            return log;
		        case constants_1.CONNECTION_CREATED:
		            log = attachConnectionFields(log, logObject);
		            log.message = 'Connection created';
		            log.driverConnectionId = logObject.connectionId;
		            return log;
		        case constants_1.CONNECTION_READY:
		            log = attachConnectionFields(log, logObject);
		            log.message = 'Connection ready';
		            log.driverConnectionId = logObject.connectionId;
		            log.durationMS = logObject.durationMS;
		            return log;
		        case constants_1.CONNECTION_CLOSED:
		            log = attachConnectionFields(log, logObject);
		            log.message = 'Connection closed';
		            log.driverConnectionId = logObject.connectionId;
		            switch (logObject.reason) {
		                case 'stale':
		                    log.reason = 'Connection became stale because the pool was cleared';
		                    break;
		                case 'idle':
		                    log.reason =
		                        'Connection has been available but unused for longer than the configured max idle time';
		                    break;
		                case 'error':
		                    log.reason = 'An error occurred while using the connection';
		                    if (logObject.error) {
		                        log.error = logObject.error;
		                    }
		                    break;
		                case 'poolClosed':
		                    log.reason = 'Connection pool was closed';
		                    break;
		                default:
		                    log.reason = `Unknown close reason: ${logObject.reason}`;
		            }
		            return log;
		        case constants_1.CONNECTION_CHECK_OUT_STARTED:
		            log = attachConnectionFields(log, logObject);
		            log.message = 'Connection checkout started';
		            return log;
		        case constants_1.CONNECTION_CHECK_OUT_FAILED:
		            log = attachConnectionFields(log, logObject);
		            log.message = 'Connection checkout failed';
		            switch (logObject.reason) {
		                case 'poolClosed':
		                    log.reason = 'Connection pool was closed';
		                    break;
		                case 'timeout':
		                    log.reason = 'Wait queue timeout elapsed without a connection becoming available';
		                    break;
		                case 'connectionError':
		                    log.reason = 'An error occurred while trying to establish a new connection';
		                    if (logObject.error) {
		                        log.error = logObject.error;
		                    }
		                    break;
		                default:
		                    log.reason = `Unknown close reason: ${logObject.reason}`;
		            }
		            log.durationMS = logObject.durationMS;
		            return log;
		        case constants_1.CONNECTION_CHECKED_OUT:
		            log = attachConnectionFields(log, logObject);
		            log.message = 'Connection checked out';
		            log.driverConnectionId = logObject.connectionId;
		            log.durationMS = logObject.durationMS;
		            return log;
		        case constants_1.CONNECTION_CHECKED_IN:
		            log = attachConnectionFields(log, logObject);
		            log.message = 'Connection checked in';
		            log.driverConnectionId = logObject.connectionId;
		            return log;
		        case constants_1.SERVER_OPENING:
		            log = attachSDAMFields(log, logObject);
		            log = attachConnectionFields(log, logObject);
		            log.message = 'Starting server monitoring';
		            return log;
		        case constants_1.SERVER_CLOSED:
		            log = attachSDAMFields(log, logObject);
		            log = attachConnectionFields(log, logObject);
		            log.message = 'Stopped server monitoring';
		            return log;
		        case constants_1.SERVER_HEARTBEAT_STARTED:
		            log = attachSDAMFields(log, logObject);
		            log = attachServerHeartbeatFields(log, logObject);
		            log.message = 'Server heartbeat started';
		            return log;
		        case constants_1.SERVER_HEARTBEAT_SUCCEEDED:
		            log = attachSDAMFields(log, logObject);
		            log = attachServerHeartbeatFields(log, logObject);
		            log.message = 'Server heartbeat succeeded';
		            log.durationMS = logObject.duration;
		            log.serverConnectionId = logObject.serverConnectionId;
		            log.reply = stringifyWithMaxLen(logObject.reply, maxDocumentLength, { relaxed: true });
		            return log;
		        case constants_1.SERVER_HEARTBEAT_FAILED:
		            log = attachSDAMFields(log, logObject);
		            log = attachServerHeartbeatFields(log, logObject);
		            log.message = 'Server heartbeat failed';
		            log.durationMS = logObject.duration;
		            log.failure = logObject.failure?.message;
		            return log;
		        case constants_1.TOPOLOGY_OPENING:
		            log = attachSDAMFields(log, logObject);
		            log.message = 'Starting topology monitoring';
		            return log;
		        case constants_1.TOPOLOGY_CLOSED:
		            log = attachSDAMFields(log, logObject);
		            log.message = 'Stopped topology monitoring';
		            return log;
		        case constants_1.TOPOLOGY_DESCRIPTION_CHANGED:
		            log = attachSDAMFields(log, logObject);
		            log.message = 'Topology description changed';
		            log.previousDescription = log.reply = stringifyWithMaxLen(logObject.previousDescription, maxDocumentLength);
		            log.newDescription = log.reply = stringifyWithMaxLen(logObject.newDescription, maxDocumentLength);
		            return log;
		        default:
		            for (const [key, value] of Object.entries(logObject)) {
		                if (value != null)
		                    log[key] = value;
		            }
		    }
		    return log;
		}
		/** @internal */
		class MongoLogger {
		    constructor(options) {
		        this.pendingLog = null;
		        /**
		         * This method should be used when logging errors that do not have a public driver API for
		         * reporting errors.
		         */
		        this.error = this.log.bind(this, 'error');
		        /**
		         * This method should be used to log situations where undesirable application behaviour might
		         * occur. For example, failing to end sessions on `MongoClient.close`.
		         */
		        this.warn = this.log.bind(this, 'warn');
		        /**
		         * This method should be used to report high-level information about normal driver behaviour.
		         * For example, the creation of a `MongoClient`.
		         */
		        this.info = this.log.bind(this, 'info');
		        /**
		         * This method should be used to report information that would be helpful when debugging an
		         * application. For example, a command starting, succeeding or failing.
		         */
		        this.debug = this.log.bind(this, 'debug');
		        /**
		         * This method should be used to report fine-grained details related to logic flow. For example,
		         * entering and exiting a function body.
		         */
		        this.trace = this.log.bind(this, 'trace');
		        this.componentSeverities = options.componentSeverities;
		        this.maxDocumentLength = options.maxDocumentLength;
		        this.logDestination = options.logDestination;
		        this.logDestinationIsStdErr = options.logDestinationIsStdErr;
		        this.severities = this.createLoggingSeverities();
		    }
		    createLoggingSeverities() {
		        const severities = Object();
		        for (const component of Object.values(exports.MongoLoggableComponent)) {
		            severities[component] = {};
		            for (const severityLevel of Object.values(exports.SeverityLevel)) {
		                severities[component][severityLevel] =
		                    compareSeverity(severityLevel, this.componentSeverities[component]) <= 0;
		            }
		        }
		        return severities;
		    }
		    turnOffSeverities() {
		        for (const component of Object.values(exports.MongoLoggableComponent)) {
		            this.componentSeverities[component] = exports.SeverityLevel.OFF;
		            for (const severityLevel of Object.values(exports.SeverityLevel)) {
		                this.severities[component][severityLevel] = false;
		            }
		        }
		    }
		    logWriteFailureHandler(error) {
		        if (this.logDestinationIsStdErr) {
		            this.turnOffSeverities();
		            this.clearPendingLog();
		            return;
		        }
		        this.logDestination = createStdioLogger(process.stderr);
		        this.logDestinationIsStdErr = true;
		        this.clearPendingLog();
		        this.error(exports.MongoLoggableComponent.CLIENT, {
		            toLog: function () {
		                return {
		                    message: 'User input for mongodbLogPath is now invalid. Logging is halted.',
		                    error: error.message
		                };
		            }
		        });
		        this.turnOffSeverities();
		        this.clearPendingLog();
		    }
		    clearPendingLog() {
		        this.pendingLog = null;
		    }
		    willLog(component, severity) {
		        if (severity === exports.SeverityLevel.OFF)
		            return false;
		        return this.severities[component][severity];
		    }
		    log(severity, component, message) {
		        if (!this.willLog(component, severity))
		            return;
		        let logMessage = { t: new Date(), c: component, s: severity };
		        if (typeof message === 'string') {
		            logMessage.message = message;
		        }
		        else if (typeof message === 'object') {
		            if (isLogConvertible(message)) {
		                logMessage = { ...logMessage, ...message.toLog() };
		            }
		            else {
		                logMessage = { ...logMessage, ...defaultLogTransform(message, this.maxDocumentLength) };
		            }
		        }
		        if ((0, utils_1.isPromiseLike)(this.pendingLog)) {
		            this.pendingLog = this.pendingLog
		                .then(() => this.logDestination.write(logMessage))
		                .then(this.clearPendingLog.bind(this), this.logWriteFailureHandler.bind(this));
		            return;
		        }
		        try {
		            const logResult = this.logDestination.write(logMessage);
		            if ((0, utils_1.isPromiseLike)(logResult)) {
		                this.pendingLog = logResult.then(this.clearPendingLog.bind(this), this.logWriteFailureHandler.bind(this));
		            }
		        }
		        catch (error) {
		            this.logWriteFailureHandler(error);
		        }
		    }
		    /**
		     * Merges options set through environment variables and the MongoClient, preferring environment
		     * variables when both are set, and substituting defaults for values not set. Options set in
		     * constructor take precedence over both environment variables and MongoClient options.
		     *
		     * @remarks
		     * When parsing component severity levels, invalid values are treated as unset and replaced with
		     * the default severity.
		     *
		     * @param envOptions - options set for the logger from the environment
		     * @param clientOptions - options set for the logger in the MongoClient options
		     * @returns a MongoLoggerOptions object to be used when instantiating a new MongoLogger
		     */
		    static resolveOptions(envOptions, clientOptions) {
		        // client options take precedence over env options
		        const resolvedLogPath = resolveLogPath(envOptions, clientOptions);
		        const combinedOptions = {
		            ...envOptions,
		            ...clientOptions,
		            mongodbLogPath: resolvedLogPath.mongodbLogPath,
		            mongodbLogPathIsStdErr: resolvedLogPath.mongodbLogPathIsStdErr
		        };
		        const defaultSeverity = resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.default, combinedOptions.MONGODB_LOG_ALL, exports.SeverityLevel.OFF);
		        return {
		            componentSeverities: {
		                command: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.command, combinedOptions.MONGODB_LOG_COMMAND, defaultSeverity),
		                topology: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.topology, combinedOptions.MONGODB_LOG_TOPOLOGY, defaultSeverity),
		                serverSelection: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.serverSelection, combinedOptions.MONGODB_LOG_SERVER_SELECTION, defaultSeverity),
		                connection: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.connection, combinedOptions.MONGODB_LOG_CONNECTION, defaultSeverity),
		                client: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.client, combinedOptions.MONGODB_LOG_CLIENT, defaultSeverity),
		                default: defaultSeverity
		            },
		            maxDocumentLength: combinedOptions.mongodbLogMaxDocumentLength ??
		                (0, utils_1.parseUnsignedInteger)(combinedOptions.MONGODB_LOG_MAX_DOCUMENT_LENGTH) ??
		                1000,
		            logDestination: combinedOptions.mongodbLogPath,
		            logDestinationIsStdErr: combinedOptions.mongodbLogPathIsStdErr
		        };
		    }
		}
		exports.MongoLogger = MongoLogger;
		
	} (mongo_logger));
	return mongo_logger;
}

var hasRequiredMongo_types;

function requireMongo_types () {
	if (hasRequiredMongo_types) return mongo_types;
	hasRequiredMongo_types = 1;
	Object.defineProperty(mongo_types, "__esModule", { value: true });
	mongo_types.CancellationToken = mongo_types.TypedEventEmitter = void 0;
	const events_1 = require$$0$8;
	const mongo_logger_1 = requireMongo_logger();
	/**
	 * Typescript type safe event emitter
	 * @public
	 */
	// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging
	class TypedEventEmitter extends events_1.EventEmitter {
	    /** @internal */
	    emitAndLog(event, ...args) {
	        this.emit(event, ...args);
	        if (this.component)
	            this.mongoLogger?.debug(this.component, args[0]);
	    }
	    /** @internal */
	    emitAndLogHeartbeat(event, topologyId, serverConnectionId, ...args) {
	        this.emit(event, ...args);
	        if (this.component) {
	            const loggableHeartbeatEvent = {
	                topologyId: topologyId,
	                serverConnectionId: serverConnectionId ?? null,
	                ...args[0]
	            };
	            this.mongoLogger?.debug(this.component, loggableHeartbeatEvent);
	        }
	    }
	    /** @internal */
	    emitAndLogCommand(monitorCommands, event, databaseName, connectionEstablished, ...args) {
	        if (monitorCommands) {
	            this.emit(event, ...args);
	        }
	        if (connectionEstablished) {
	            const loggableCommandEvent = {
	                databaseName: databaseName,
	                ...args[0]
	            };
	            this.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.COMMAND, loggableCommandEvent);
	        }
	    }
	}
	mongo_types.TypedEventEmitter = TypedEventEmitter;
	/** @public */
	class CancellationToken extends TypedEventEmitter {
	}
	mongo_types.CancellationToken = CancellationToken;
	
	return mongo_types;
}

var get_more = {};

var hasRequiredGet_more;

function requireGet_more () {
	if (hasRequiredGet_more) return get_more;
	hasRequiredGet_more = 1;
	Object.defineProperty(get_more, "__esModule", { value: true });
	get_more.GetMoreOperation = void 0;
	const responses_1 = requireResponses();
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	const operation_1 = requireOperation();
	/** @internal */
	class GetMoreOperation extends operation_1.AbstractOperation {
	    constructor(ns, cursorId, server, options) {
	        super(options);
	        this.options = options;
	        this.ns = ns;
	        this.cursorId = cursorId;
	        this.server = server;
	    }
	    get commandName() {
	        return 'getMore';
	    }
	    /**
	     * Although there is a server already associated with the get more operation, the signature
	     * for execute passes a server so we will just use that one.
	     */
	    async execute(server, _session) {
	        if (server !== this.server) {
	            throw new error_1.MongoRuntimeError('Getmore must run on the same server operation began on');
	        }
	        if (this.cursorId == null || this.cursorId.isZero()) {
	            throw new error_1.MongoRuntimeError('Unable to iterate cursor with no id');
	        }
	        const collection = this.ns.collection;
	        if (collection == null) {
	            // Cursors should have adopted the namespace returned by MongoDB
	            // which should always defined a collection name (even a pseudo one, ex. db.aggregate())
	            throw new error_1.MongoRuntimeError('A collection name must be determined before getMore');
	        }
	        const getMoreCmd = {
	            getMore: this.cursorId,
	            collection
	        };
	        if (typeof this.options.batchSize === 'number') {
	            getMoreCmd.batchSize = Math.abs(this.options.batchSize);
	        }
	        if (typeof this.options.maxAwaitTimeMS === 'number') {
	            getMoreCmd.maxTimeMS = this.options.maxAwaitTimeMS;
	        }
	        // we check for undefined specifically here to allow falsy values
	        // eslint-disable-next-line no-restricted-syntax
	        if (this.options.comment !== undefined && (0, utils_1.maxWireVersion)(server) >= 9) {
	            getMoreCmd.comment = this.options.comment;
	        }
	        const commandOptions = {
	            returnFieldSelector: null,
	            documentsReturnedIn: 'nextBatch',
	            ...this.options
	        };
	        return await server.command(this.ns, getMoreCmd, commandOptions, responses_1.CursorResponse);
	    }
	}
	get_more.GetMoreOperation = GetMoreOperation;
	(0, operation_1.defineAspects)(GetMoreOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.MUST_SELECT_SAME_SERVER]);
	
	return get_more;
}

var kill_cursors = {};

var hasRequiredKill_cursors;

function requireKill_cursors () {
	if (hasRequiredKill_cursors) return kill_cursors;
	hasRequiredKill_cursors = 1;
	Object.defineProperty(kill_cursors, "__esModule", { value: true });
	kill_cursors.KillCursorsOperation = void 0;
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	const operation_1 = requireOperation();
	class KillCursorsOperation extends operation_1.AbstractOperation {
	    constructor(cursorId, ns, server, options) {
	        super(options);
	        this.ns = ns;
	        this.cursorId = cursorId;
	        this.server = server;
	    }
	    get commandName() {
	        return 'killCursors';
	    }
	    async execute(server, session) {
	        if (server !== this.server) {
	            throw new error_1.MongoRuntimeError('Killcursor must run on the same server operation began on');
	        }
	        const killCursors = this.ns.collection;
	        if (killCursors == null) {
	            // Cursors should have adopted the namespace returned by MongoDB
	            // which should always defined a collection name (even a pseudo one, ex. db.aggregate())
	            throw new error_1.MongoRuntimeError('A collection name must be determined before killCursors');
	        }
	        const killCursorsCommand = {
	            killCursors,
	            cursors: [this.cursorId]
	        };
	        try {
	            await server.command(this.ns, killCursorsCommand, { session });
	        }
	        catch (error) {
	            // The driver should never emit errors from killCursors, this is spec-ed behavior
	            (0, utils_1.squashError)(error);
	        }
	    }
	}
	kill_cursors.KillCursorsOperation = KillCursorsOperation;
	(0, operation_1.defineAspects)(KillCursorsOperation, [operation_1.Aspect.MUST_SELECT_SAME_SERVER]);
	
	return kill_cursors;
}

var resource_management = {};

var mongo_client = {};

var mongo_credentials = {};

var gssapi = {};

var deps = {};

var hasRequiredDeps;

function requireDeps () {
	if (hasRequiredDeps) return deps;
	hasRequiredDeps = 1;
	Object.defineProperty(deps, "__esModule", { value: true });
	deps.aws4 = void 0;
	deps.getKerberos = getKerberos;
	deps.getZstdLibrary = getZstdLibrary;
	deps.getAwsCredentialProvider = getAwsCredentialProvider;
	deps.getGcpMetadata = getGcpMetadata;
	deps.getSnappy = getSnappy;
	deps.getSocks = getSocks;
	deps.getMongoDBClientEncryption = getMongoDBClientEncryption;
	const error_1 = requireError();
	function makeErrorModule(error) {
	    const props = error ? { kModuleError: error } : {};
	    return new Proxy(props, {
	        get: (_, key) => {
	            if (key === 'kModuleError') {
	                return error;
	            }
	            throw error;
	        },
	        set: () => {
	            throw error;
	        }
	    });
	}
	function getKerberos() {
	    let kerberos;
	    try {
	        // Ensure you always wrap an optional require in the try block NODE-3199
	        // eslint-disable-next-line @typescript-eslint/no-require-imports
	        kerberos = require('kerberos');
	    }
	    catch (error) {
	        kerberos = makeErrorModule(new error_1.MongoMissingDependencyError('Optional module `kerberos` not found. Please install it to enable kerberos authentication', { cause: error, dependencyName: 'kerberos' }));
	    }
	    return kerberos;
	}
	function getZstdLibrary() {
	    let ZStandard;
	    try {
	        // eslint-disable-next-line @typescript-eslint/no-require-imports
	        ZStandard = require('@mongodb-js/zstd');
	    }
	    catch (error) {
	        ZStandard = makeErrorModule(new error_1.MongoMissingDependencyError('Optional module `@mongodb-js/zstd` not found. Please install it to enable zstd compression', { cause: error, dependencyName: 'zstd' }));
	    }
	    return ZStandard;
	}
	function getAwsCredentialProvider() {
	    try {
	        // Ensure you always wrap an optional require in the try block NODE-3199
	        // eslint-disable-next-line @typescript-eslint/no-require-imports
	        const credentialProvider = require('@aws-sdk/credential-providers');
	        return credentialProvider;
	    }
	    catch (error) {
	        return makeErrorModule(new error_1.MongoMissingDependencyError('Optional module `@aws-sdk/credential-providers` not found.' +
	            ' Please install it to enable getting aws credentials via the official sdk.', { cause: error, dependencyName: '@aws-sdk/credential-providers' }));
	    }
	}
	function getGcpMetadata() {
	    try {
	        // Ensure you always wrap an optional require in the try block NODE-3199
	        // eslint-disable-next-line @typescript-eslint/no-require-imports
	        const credentialProvider = require('gcp-metadata');
	        return credentialProvider;
	    }
	    catch (error) {
	        return makeErrorModule(new error_1.MongoMissingDependencyError('Optional module `gcp-metadata` not found.' +
	            ' Please install it to enable getting gcp credentials via the official sdk.', { cause: error, dependencyName: 'gcp-metadata' }));
	    }
	}
	function getSnappy() {
	    try {
	        // Ensure you always wrap an optional require in the try block NODE-3199
	        // eslint-disable-next-line @typescript-eslint/no-require-imports
	        const value = require('snappy');
	        return value;
	    }
	    catch (error) {
	        const kModuleError = new error_1.MongoMissingDependencyError('Optional module `snappy` not found. Please install it to enable snappy compression', { cause: error, dependencyName: 'snappy' });
	        return { kModuleError };
	    }
	}
	function getSocks() {
	    try {
	        // Ensure you always wrap an optional require in the try block NODE-3199
	        // eslint-disable-next-line @typescript-eslint/no-require-imports
	        const value = require('socks');
	        return value;
	    }
	    catch (error) {
	        const kModuleError = new error_1.MongoMissingDependencyError('Optional module `socks` not found. Please install it to connections over a SOCKS5 proxy', { cause: error, dependencyName: 'socks' });
	        return { kModuleError };
	    }
	}
	deps.aws4 = loadAws4();
	function loadAws4() {
	    let aws4;
	    try {
	        // eslint-disable-next-line @typescript-eslint/no-require-imports
	        aws4 = require('aws4');
	    }
	    catch (error) {
	        aws4 = makeErrorModule(new error_1.MongoMissingDependencyError('Optional module `aws4` not found. Please install it to enable AWS authentication', { cause: error, dependencyName: 'aws4' }));
	    }
	    return aws4;
	}
	/** A utility function to get the instance of mongodb-client-encryption, if it exists. */
	function getMongoDBClientEncryption() {
	    let mongodbClientEncryption = null;
	    try {
	        // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block
	        // Cannot be moved to helper utility function, bundlers search and replace the actual require call
	        // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed
	        // eslint-disable-next-line @typescript-eslint/no-require-imports
	        mongodbClientEncryption = require('mongodb-client-encryption');
	    }
	    catch (error) {
	        const kModuleError = new error_1.MongoMissingDependencyError('Optional module `mongodb-client-encryption` not found. Please install it to use auto encryption or ClientEncryption.', { cause: error, dependencyName: 'mongodb-client-encryption' });
	        return { kModuleError };
	    }
	    return mongodbClientEncryption;
	}
	
	return deps;
}

var auth_provider = {};

var hasRequiredAuth_provider;

function requireAuth_provider () {
	if (hasRequiredAuth_provider) return auth_provider;
	hasRequiredAuth_provider = 1;
	Object.defineProperty(auth_provider, "__esModule", { value: true });
	auth_provider.AuthProvider = auth_provider.AuthContext = void 0;
	const error_1 = requireError();
	/**
	 * Context used during authentication
	 * @internal
	 */
	class AuthContext {
	    constructor(connection, credentials, options) {
	        /** If the context is for reauthentication. */
	        this.reauthenticating = false;
	        this.connection = connection;
	        this.credentials = credentials;
	        this.options = options;
	    }
	}
	auth_provider.AuthContext = AuthContext;
	/**
	 * Provider used during authentication.
	 * @internal
	 */
	class AuthProvider {
	    /**
	     * Prepare the handshake document before the initial handshake.
	     *
	     * @param handshakeDoc - The document used for the initial handshake on a connection
	     * @param authContext - Context for authentication flow
	     */
	    async prepare(handshakeDoc, _authContext) {
	        return handshakeDoc;
	    }
	    /**
	     * Reauthenticate.
	     * @param context - The shared auth context.
	     */
	    async reauth(context) {
	        if (context.reauthenticating) {
	            throw new error_1.MongoRuntimeError('Reauthentication already in progress.');
	        }
	        try {
	            context.reauthenticating = true;
	            await this.auth(context);
	        }
	        finally {
	            context.reauthenticating = false;
	        }
	    }
	}
	auth_provider.AuthProvider = AuthProvider;
	
	return auth_provider;
}

var hasRequiredGssapi;

function requireGssapi () {
	if (hasRequiredGssapi) return gssapi;
	hasRequiredGssapi = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.GSSAPI = exports.GSSAPICanonicalizationValue = void 0;
		exports.performGSSAPICanonicalizeHostName = performGSSAPICanonicalizeHostName;
		exports.resolveCname = resolveCname;
		const dns = require$$0$e;
		const deps_1 = requireDeps();
		const error_1 = requireError();
		const utils_1 = requireUtils$1();
		const auth_provider_1 = requireAuth_provider();
		/** @public */
		exports.GSSAPICanonicalizationValue = Object.freeze({
		    on: true,
		    off: false,
		    none: 'none',
		    forward: 'forward',
		    forwardAndReverse: 'forwardAndReverse'
		});
		async function externalCommand(connection, command) {
		    const response = await connection.command((0, utils_1.ns)('$external.$cmd'), command);
		    return response;
		}
		let krb;
		class GSSAPI extends auth_provider_1.AuthProvider {
		    async auth(authContext) {
		        const { connection, credentials } = authContext;
		        if (credentials == null) {
		            throw new error_1.MongoMissingCredentialsError('Credentials required for GSSAPI authentication');
		        }
		        const { username } = credentials;
		        const client = await makeKerberosClient(authContext);
		        const payload = await client.step('');
		        const saslStartResponse = await externalCommand(connection, saslStart(payload));
		        const negotiatedPayload = await negotiate(client, 10, saslStartResponse.payload);
		        const saslContinueResponse = await externalCommand(connection, saslContinue(negotiatedPayload, saslStartResponse.conversationId));
		        const finalizePayload = await finalize(client, username, saslContinueResponse.payload);
		        await externalCommand(connection, {
		            saslContinue: 1,
		            conversationId: saslContinueResponse.conversationId,
		            payload: finalizePayload
		        });
		    }
		}
		exports.GSSAPI = GSSAPI;
		async function makeKerberosClient(authContext) {
		    const { hostAddress } = authContext.options;
		    const { credentials } = authContext;
		    if (!hostAddress || typeof hostAddress.host !== 'string' || !credentials) {
		        throw new error_1.MongoInvalidArgumentError('Connection must have host and port and credentials defined.');
		    }
		    loadKrb();
		    if ('kModuleError' in krb) {
		        throw krb['kModuleError'];
		    }
		    const { initializeClient } = krb;
		    const { username, password } = credentials;
		    const mechanismProperties = credentials.mechanismProperties;
		    const serviceName = mechanismProperties.SERVICE_NAME ?? 'mongodb';
		    const host = await performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties);
		    const initOptions = {};
		    if (password != null) {
		        // TODO(NODE-5139): These do not match the typescript options in initializeClient
		        Object.assign(initOptions, { user: username, password: password });
		    }
		    const spnHost = mechanismProperties.SERVICE_HOST ?? host;
		    let spn = `${serviceName}${process.platform === 'win32' ? '/' : '@'}${spnHost}`;
		    if ('SERVICE_REALM' in mechanismProperties) {
		        spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;
		    }
		    return await initializeClient(spn, initOptions);
		}
		function saslStart(payload) {
		    return {
		        saslStart: 1,
		        mechanism: 'GSSAPI',
		        payload,
		        autoAuthorize: 1
		    };
		}
		function saslContinue(payload, conversationId) {
		    return {
		        saslContinue: 1,
		        conversationId,
		        payload
		    };
		}
		async function negotiate(client, retries, payload) {
		    try {
		        const response = await client.step(payload);
		        return response || '';
		    }
		    catch (error) {
		        if (retries === 0) {
		            // Retries exhausted, raise error
		            throw error;
		        }
		        // Adjust number of retries and call step again
		        return await negotiate(client, retries - 1, payload);
		    }
		}
		async function finalize(client, user, payload) {
		    // GSS Client Unwrap
		    const response = await client.unwrap(payload);
		    return await client.wrap(response || '', { user });
		}
		async function performGSSAPICanonicalizeHostName(host, mechanismProperties) {
		    const mode = mechanismProperties.CANONICALIZE_HOST_NAME;
		    if (!mode || mode === exports.GSSAPICanonicalizationValue.none) {
		        return host;
		    }
		    // If forward and reverse or true
		    if (mode === exports.GSSAPICanonicalizationValue.on ||
		        mode === exports.GSSAPICanonicalizationValue.forwardAndReverse) {
		        // Perform the lookup of the ip address.
		        const { address } = await dns.promises.lookup(host);
		        try {
		            // Perform a reverse ptr lookup on the ip address.
		            const results = await dns.promises.resolvePtr(address);
		            // If the ptr did not error but had no results, return the host.
		            return results.length > 0 ? results[0] : host;
		        }
		        catch {
		            // This can error as ptr records may not exist for all ips. In this case
		            // fallback to a cname lookup as dns.lookup() does not return the
		            // cname.
		            return await resolveCname(host);
		        }
		    }
		    else {
		        // The case for forward is just to resolve the cname as dns.lookup()
		        // will not return it.
		        return await resolveCname(host);
		    }
		}
		async function resolveCname(host) {
		    // Attempt to resolve the host name
		    try {
		        const results = await dns.promises.resolveCname(host);
		        // Get the first resolved host id
		        return results.length > 0 ? results[0] : host;
		    }
		    catch {
		        return host;
		    }
		}
		/**
		 * Load the Kerberos library.
		 */
		function loadKrb() {
		    if (!krb) {
		        krb = (0, deps_1.getKerberos)();
		    }
		}
		
	} (gssapi));
	return gssapi;
}

var providers$1 = {};

var hasRequiredProviders$1;

function requireProviders$1 () {
	if (hasRequiredProviders$1) return providers$1;
	hasRequiredProviders$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.AUTH_MECHS_AUTH_SRC_EXTERNAL = exports.AuthMechanism = void 0;
		/** @public */
		exports.AuthMechanism = Object.freeze({
		    MONGODB_AWS: 'MONGODB-AWS',
		    MONGODB_CR: 'MONGODB-CR',
		    MONGODB_DEFAULT: 'DEFAULT',
		    MONGODB_GSSAPI: 'GSSAPI',
		    MONGODB_PLAIN: 'PLAIN',
		    MONGODB_SCRAM_SHA1: 'SCRAM-SHA-1',
		    MONGODB_SCRAM_SHA256: 'SCRAM-SHA-256',
		    MONGODB_X509: 'MONGODB-X509',
		    MONGODB_OIDC: 'MONGODB-OIDC'
		});
		/** @internal */
		exports.AUTH_MECHS_AUTH_SRC_EXTERNAL = new Set([
		    exports.AuthMechanism.MONGODB_GSSAPI,
		    exports.AuthMechanism.MONGODB_AWS,
		    exports.AuthMechanism.MONGODB_OIDC,
		    exports.AuthMechanism.MONGODB_X509
		]);
		
	} (providers$1));
	return providers$1;
}

var hasRequiredMongo_credentials;

function requireMongo_credentials () {
	if (hasRequiredMongo_credentials) return mongo_credentials;
	hasRequiredMongo_credentials = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.MongoCredentials = exports.DEFAULT_ALLOWED_HOSTS = void 0;
		const error_1 = requireError();
		const gssapi_1 = requireGssapi();
		const providers_1 = requireProviders$1();
		// https://github.com/mongodb/specifications/blob/master/source/auth/auth.rst
		function getDefaultAuthMechanism(hello) {
		    if (hello) {
		        // If hello contains saslSupportedMechs, use scram-sha-256
		        // if it is available, else scram-sha-1
		        if (Array.isArray(hello.saslSupportedMechs)) {
		            return hello.saslSupportedMechs.includes(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256)
		                ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA256
		                : providers_1.AuthMechanism.MONGODB_SCRAM_SHA1;
		        }
		        // Fallback to legacy selection method. If wire version >= 3, use scram-sha-1
		        if (hello.maxWireVersion >= 3) {
		            return providers_1.AuthMechanism.MONGODB_SCRAM_SHA1;
		        }
		    }
		    // Default for wireprotocol < 3
		    return providers_1.AuthMechanism.MONGODB_CR;
		}
		const ALLOWED_ENVIRONMENT_NAMES = [
		    'test',
		    'azure',
		    'gcp'
		];
		const ALLOWED_HOSTS_ERROR = 'Auth mechanism property ALLOWED_HOSTS must be an array of strings.';
		/** @internal */
		exports.DEFAULT_ALLOWED_HOSTS = [
		    '*.mongodb.net',
		    '*.mongodb-qa.net',
		    '*.mongodb-dev.net',
		    '*.mongodbgov.net',
		    'localhost',
		    '127.0.0.1',
		    '::1'
		];
		/** Error for when the token audience is missing in the environment. */
		const TOKEN_RESOURCE_MISSING_ERROR = 'TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is azure or gcp.';
		/**
		 * A representation of the credentials used by MongoDB
		 * @public
		 */
		class MongoCredentials {
		    constructor(options) {
		        this.username = options.username ?? '';
		        this.password = options.password;
		        this.source = options.source;
		        if (!this.source && options.db) {
		            this.source = options.db;
		        }
		        this.mechanism = options.mechanism || providers_1.AuthMechanism.MONGODB_DEFAULT;
		        this.mechanismProperties = options.mechanismProperties || {};
		        if (this.mechanism.match(/MONGODB-AWS/i)) {
		            if (!this.username && process.env.AWS_ACCESS_KEY_ID) {
		                this.username = process.env.AWS_ACCESS_KEY_ID;
		            }
		            if (!this.password && process.env.AWS_SECRET_ACCESS_KEY) {
		                this.password = process.env.AWS_SECRET_ACCESS_KEY;
		            }
		            if (this.mechanismProperties.AWS_SESSION_TOKEN == null &&
		                process.env.AWS_SESSION_TOKEN != null) {
		                this.mechanismProperties = {
		                    ...this.mechanismProperties,
		                    AWS_SESSION_TOKEN: process.env.AWS_SESSION_TOKEN
		                };
		            }
		        }
		        if (this.mechanism === providers_1.AuthMechanism.MONGODB_OIDC && !this.mechanismProperties.ALLOWED_HOSTS) {
		            this.mechanismProperties = {
		                ...this.mechanismProperties,
		                ALLOWED_HOSTS: exports.DEFAULT_ALLOWED_HOSTS
		            };
		        }
		        Object.freeze(this.mechanismProperties);
		        Object.freeze(this);
		    }
		    /** Determines if two MongoCredentials objects are equivalent */
		    equals(other) {
		        return (this.mechanism === other.mechanism &&
		            this.username === other.username &&
		            this.password === other.password &&
		            this.source === other.source);
		    }
		    /**
		     * If the authentication mechanism is set to "default", resolves the authMechanism
		     * based on the server version and server supported sasl mechanisms.
		     *
		     * @param hello - A hello response from the server
		     */
		    resolveAuthMechanism(hello) {
		        // If the mechanism is not "default", then it does not need to be resolved
		        if (this.mechanism.match(/DEFAULT/i)) {
		            return new MongoCredentials({
		                username: this.username,
		                password: this.password,
		                source: this.source,
		                mechanism: getDefaultAuthMechanism(hello),
		                mechanismProperties: this.mechanismProperties
		            });
		        }
		        return this;
		    }
		    validate() {
		        if ((this.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI ||
		            this.mechanism === providers_1.AuthMechanism.MONGODB_CR ||
		            this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN ||
		            this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 ||
		            this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) &&
		            !this.username) {
		            throw new error_1.MongoMissingCredentialsError(`Username required for mechanism '${this.mechanism}'`);
		        }
		        if (this.mechanism === providers_1.AuthMechanism.MONGODB_OIDC) {
		            if (this.username &&
		                this.mechanismProperties.ENVIRONMENT &&
		                this.mechanismProperties.ENVIRONMENT !== 'azure') {
		                throw new error_1.MongoInvalidArgumentError(`username and ENVIRONMENT '${this.mechanismProperties.ENVIRONMENT}' may not be used together for mechanism '${this.mechanism}'.`);
		            }
		            if (this.username && this.password) {
		                throw new error_1.MongoInvalidArgumentError(`No password is allowed in ENVIRONMENT '${this.mechanismProperties.ENVIRONMENT}' for '${this.mechanism}'.`);
		            }
		            if ((this.mechanismProperties.ENVIRONMENT === 'azure' ||
		                this.mechanismProperties.ENVIRONMENT === 'gcp') &&
		                !this.mechanismProperties.TOKEN_RESOURCE) {
		                throw new error_1.MongoInvalidArgumentError(TOKEN_RESOURCE_MISSING_ERROR);
		            }
		            if (this.mechanismProperties.ENVIRONMENT &&
		                !ALLOWED_ENVIRONMENT_NAMES.includes(this.mechanismProperties.ENVIRONMENT)) {
		                throw new error_1.MongoInvalidArgumentError(`Currently only a ENVIRONMENT in ${ALLOWED_ENVIRONMENT_NAMES.join(',')} is supported for mechanism '${this.mechanism}'.`);
		            }
		            if (!this.mechanismProperties.ENVIRONMENT &&
		                !this.mechanismProperties.OIDC_CALLBACK &&
		                !this.mechanismProperties.OIDC_HUMAN_CALLBACK) {
		                throw new error_1.MongoInvalidArgumentError(`Either a ENVIRONMENT, OIDC_CALLBACK, or OIDC_HUMAN_CALLBACK must be specified for mechanism '${this.mechanism}'.`);
		            }
		            if (this.mechanismProperties.ALLOWED_HOSTS) {
		                const hosts = this.mechanismProperties.ALLOWED_HOSTS;
		                if (!Array.isArray(hosts)) {
		                    throw new error_1.MongoInvalidArgumentError(ALLOWED_HOSTS_ERROR);
		                }
		                for (const host of hosts) {
		                    if (typeof host !== 'string') {
		                        throw new error_1.MongoInvalidArgumentError(ALLOWED_HOSTS_ERROR);
		                    }
		                }
		            }
		        }
		        if (providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(this.mechanism)) {
		            if (this.source != null && this.source !== '$external') {
		                // TODO(NODE-3485): Replace this with a MongoAuthValidationError
		                throw new error_1.MongoAPIError(`Invalid source '${this.source}' for mechanism '${this.mechanism}' specified.`);
		            }
		        }
		        if (this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN && this.source == null) {
		            // TODO(NODE-3485): Replace this with a MongoAuthValidationError
		            throw new error_1.MongoAPIError('PLAIN Authentication Mechanism needs an auth source');
		        }
		        if (this.mechanism === providers_1.AuthMechanism.MONGODB_X509 && this.password != null) {
		            if (this.password === '') {
		                Reflect.set(this, 'password', undefined);
		                return;
		            }
		            // TODO(NODE-3485): Replace this with a MongoAuthValidationError
		            throw new error_1.MongoAPIError(`Password not allowed for mechanism MONGODB-X509`);
		        }
		        const canonicalization = this.mechanismProperties.CANONICALIZE_HOST_NAME ?? false;
		        if (!Object.values(gssapi_1.GSSAPICanonicalizationValue).includes(canonicalization)) {
		            throw new error_1.MongoAPIError(`Invalid CANONICALIZE_HOST_NAME value: ${canonicalization}`);
		        }
		    }
		    static merge(creds, options) {
		        return new MongoCredentials({
		            username: options.username ?? creds?.username ?? '',
		            password: options.password ?? creds?.password ?? '',
		            mechanism: options.mechanism ?? creds?.mechanism ?? providers_1.AuthMechanism.MONGODB_DEFAULT,
		            mechanismProperties: options.mechanismProperties ?? creds?.mechanismProperties ?? {},
		            source: options.source ?? options.db ?? creds?.source ?? 'admin'
		        });
		    }
		}
		exports.MongoCredentials = MongoCredentials;
		
	} (mongo_credentials));
	return mongo_credentials;
}

var connection_string = {};

var lib$1 = {};

var whatwgUrl = {};

var webidl2jsWrapper = {};

var URL$1 = {};

var lib = {};

var hasRequiredLib$2;

function requireLib$2 () {
	if (hasRequiredLib$2) return lib;
	hasRequiredLib$2 = 1;
	(function (exports) {

		function makeException(ErrorType, message, options) {
		  if (options.globals) {
		    ErrorType = options.globals[ErrorType.name];
		  }
		  return new ErrorType(`${options.context ? options.context : "Value"} ${message}.`);
		}

		function toNumber(value, options) {
		  if (typeof value === "bigint") {
		    throw makeException(TypeError, "is a BigInt which cannot be converted to a number", options);
		  }
		  if (!options.globals) {
		    return Number(value);
		  }
		  return options.globals.Number(value);
		}

		// Round x to the nearest integer, choosing the even integer if it lies halfway between two.
		function evenRound(x) {
		  // There are four cases for numbers with fractional part being .5:
		  //
		  // case |     x     | floor(x) | round(x) | expected | x <> 0 | x % 1 | x & 1 |   example
		  //   1  |  2n + 0.5 |  2n      |  2n + 1  |  2n      |   >    |  0.5  |   0   |  0.5 ->  0
		  //   2  |  2n + 1.5 |  2n + 1  |  2n + 2  |  2n + 2  |   >    |  0.5  |   1   |  1.5 ->  2
		  //   3  | -2n - 0.5 | -2n - 1  | -2n      | -2n      |   <    | -0.5  |   0   | -0.5 ->  0
		  //   4  | -2n - 1.5 | -2n - 2  | -2n - 1  | -2n - 2  |   <    | -0.5  |   1   | -1.5 -> -2
		  // (where n is a non-negative integer)
		  //
		  // Branch here for cases 1 and 4
		  if ((x > 0 && (x % 1) === +0.5 && (x & 1) === 0) ||
		        (x < 0 && (x % 1) === -0.5 && (x & 1) === 1)) {
		    return censorNegativeZero(Math.floor(x));
		  }

		  return censorNegativeZero(Math.round(x));
		}

		function integerPart(n) {
		  return censorNegativeZero(Math.trunc(n));
		}

		function sign(x) {
		  return x < 0 ? -1 : 1;
		}

		function modulo(x, y) {
		  // https://tc39.github.io/ecma262/#eqn-modulo
		  // Note that http://stackoverflow.com/a/4467559/3191 does NOT work for large modulos
		  const signMightNotMatch = x % y;
		  if (sign(y) !== sign(signMightNotMatch)) {
		    return signMightNotMatch + y;
		  }
		  return signMightNotMatch;
		}

		function censorNegativeZero(x) {
		  return x === 0 ? 0 : x;
		}

		function createIntegerConversion(bitLength, { unsigned }) {
		  let lowerBound, upperBound;
		  if (unsigned) {
		    lowerBound = 0;
		    upperBound = 2 ** bitLength - 1;
		  } else {
		    lowerBound = -(2 ** (bitLength - 1));
		    upperBound = 2 ** (bitLength - 1) - 1;
		  }

		  const twoToTheBitLength = 2 ** bitLength;
		  const twoToOneLessThanTheBitLength = 2 ** (bitLength - 1);

		  return (value, options = {}) => {
		    let x = toNumber(value, options);
		    x = censorNegativeZero(x);

		    if (options.enforceRange) {
		      if (!Number.isFinite(x)) {
		        throw makeException(TypeError, "is not a finite number", options);
		      }

		      x = integerPart(x);

		      if (x < lowerBound || x > upperBound) {
		        throw makeException(
		          TypeError,
		          `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,
		          options
		        );
		      }

		      return x;
		    }

		    if (!Number.isNaN(x) && options.clamp) {
		      x = Math.min(Math.max(x, lowerBound), upperBound);
		      x = evenRound(x);
		      return x;
		    }

		    if (!Number.isFinite(x) || x === 0) {
		      return 0;
		    }
		    x = integerPart(x);

		    // Math.pow(2, 64) is not accurately representable in JavaScript, so try to avoid these per-spec operations if
		    // possible. Hopefully it's an optimization for the non-64-bitLength cases too.
		    if (x >= lowerBound && x <= upperBound) {
		      return x;
		    }

		    // These will not work great for bitLength of 64, but oh well. See the README for more details.
		    x = modulo(x, twoToTheBitLength);
		    if (!unsigned && x >= twoToOneLessThanTheBitLength) {
		      return x - twoToTheBitLength;
		    }
		    return x;
		  };
		}

		function createLongLongConversion(bitLength, { unsigned }) {
		  const upperBound = Number.MAX_SAFE_INTEGER;
		  const lowerBound = unsigned ? 0 : Number.MIN_SAFE_INTEGER;
		  const asBigIntN = unsigned ? BigInt.asUintN : BigInt.asIntN;

		  return (value, options = {}) => {
		    let x = toNumber(value, options);
		    x = censorNegativeZero(x);

		    if (options.enforceRange) {
		      if (!Number.isFinite(x)) {
		        throw makeException(TypeError, "is not a finite number", options);
		      }

		      x = integerPart(x);

		      if (x < lowerBound || x > upperBound) {
		        throw makeException(
		          TypeError,
		          `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,
		          options
		        );
		      }

		      return x;
		    }

		    if (!Number.isNaN(x) && options.clamp) {
		      x = Math.min(Math.max(x, lowerBound), upperBound);
		      x = evenRound(x);
		      return x;
		    }

		    if (!Number.isFinite(x) || x === 0) {
		      return 0;
		    }

		    let xBigInt = BigInt(integerPart(x));
		    xBigInt = asBigIntN(bitLength, xBigInt);
		    return Number(xBigInt);
		  };
		}

		exports.any = value => {
		  return value;
		};

		exports.undefined = () => {
		  return undefined;
		};

		exports.boolean = value => {
		  return Boolean(value);
		};

		exports.byte = createIntegerConversion(8, { unsigned: false });
		exports.octet = createIntegerConversion(8, { unsigned: true });

		exports.short = createIntegerConversion(16, { unsigned: false });
		exports["unsigned short"] = createIntegerConversion(16, { unsigned: true });

		exports.long = createIntegerConversion(32, { unsigned: false });
		exports["unsigned long"] = createIntegerConversion(32, { unsigned: true });

		exports["long long"] = createLongLongConversion(64, { unsigned: false });
		exports["unsigned long long"] = createLongLongConversion(64, { unsigned: true });

		exports.double = (value, options = {}) => {
		  const x = toNumber(value, options);

		  if (!Number.isFinite(x)) {
		    throw makeException(TypeError, "is not a finite floating-point value", options);
		  }

		  return x;
		};

		exports["unrestricted double"] = (value, options = {}) => {
		  const x = toNumber(value, options);

		  return x;
		};

		exports.float = (value, options = {}) => {
		  const x = toNumber(value, options);

		  if (!Number.isFinite(x)) {
		    throw makeException(TypeError, "is not a finite floating-point value", options);
		  }

		  if (Object.is(x, -0)) {
		    return x;
		  }

		  const y = Math.fround(x);

		  if (!Number.isFinite(y)) {
		    throw makeException(TypeError, "is outside the range of a single-precision floating-point value", options);
		  }

		  return y;
		};

		exports["unrestricted float"] = (value, options = {}) => {
		  const x = toNumber(value, options);

		  if (isNaN(x)) {
		    return x;
		  }

		  if (Object.is(x, -0)) {
		    return x;
		  }

		  return Math.fround(x);
		};

		exports.DOMString = (value, options = {}) => {
		  if (options.treatNullAsEmptyString && value === null) {
		    return "";
		  }

		  if (typeof value === "symbol") {
		    throw makeException(TypeError, "is a symbol, which cannot be converted to a string", options);
		  }

		  const StringCtor = options.globals ? options.globals.String : String;
		  return StringCtor(value);
		};

		exports.ByteString = (value, options = {}) => {
		  const x = exports.DOMString(value, options);
		  let c;
		  for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {
		    if (c > 255) {
		      throw makeException(TypeError, "is not a valid ByteString", options);
		    }
		  }

		  return x;
		};

		exports.USVString = (value, options = {}) => {
		  const S = exports.DOMString(value, options);
		  const n = S.length;
		  const U = [];
		  for (let i = 0; i < n; ++i) {
		    const c = S.charCodeAt(i);
		    if (c < 0xD800 || c > 0xDFFF) {
		      U.push(String.fromCodePoint(c));
		    } else if (0xDC00 <= c && c <= 0xDFFF) {
		      U.push(String.fromCodePoint(0xFFFD));
		    } else if (i === n - 1) {
		      U.push(String.fromCodePoint(0xFFFD));
		    } else {
		      const d = S.charCodeAt(i + 1);
		      if (0xDC00 <= d && d <= 0xDFFF) {
		        const a = c & 0x3FF;
		        const b = d & 0x3FF;
		        U.push(String.fromCodePoint((2 << 15) + ((2 << 9) * a) + b));
		        ++i;
		      } else {
		        U.push(String.fromCodePoint(0xFFFD));
		      }
		    }
		  }

		  return U.join("");
		};

		exports.object = (value, options = {}) => {
		  if (value === null || (typeof value !== "object" && typeof value !== "function")) {
		    throw makeException(TypeError, "is not an object", options);
		  }

		  return value;
		};

		const abByteLengthGetter =
		    Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
		const sabByteLengthGetter =
		    typeof SharedArrayBuffer === "function" ?
		      Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, "byteLength").get :
		      null;

		function isNonSharedArrayBuffer(value) {
		  try {
		    // This will throw on SharedArrayBuffers, but not detached ArrayBuffers.
		    // (The spec says it should throw, but the spec conflicts with implementations: https://github.com/tc39/ecma262/issues/678)
		    abByteLengthGetter.call(value);

		    return true;
		  } catch {
		    return false;
		  }
		}

		function isSharedArrayBuffer(value) {
		  try {
		    sabByteLengthGetter.call(value);
		    return true;
		  } catch {
		    return false;
		  }
		}

		function isArrayBufferDetached(value) {
		  try {
		    // eslint-disable-next-line no-new
		    new Uint8Array(value);
		    return false;
		  } catch {
		    return true;
		  }
		}

		exports.ArrayBuffer = (value, options = {}) => {
		  if (!isNonSharedArrayBuffer(value)) {
		    if (options.allowShared && !isSharedArrayBuffer(value)) {
		      throw makeException(TypeError, "is not an ArrayBuffer or SharedArrayBuffer", options);
		    }
		    throw makeException(TypeError, "is not an ArrayBuffer", options);
		  }
		  if (isArrayBufferDetached(value)) {
		    throw makeException(TypeError, "is a detached ArrayBuffer", options);
		  }

		  return value;
		};

		const dvByteLengthGetter =
		    Object.getOwnPropertyDescriptor(DataView.prototype, "byteLength").get;
		exports.DataView = (value, options = {}) => {
		  try {
		    dvByteLengthGetter.call(value);
		  } catch (e) {
		    throw makeException(TypeError, "is not a DataView", options);
		  }

		  if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
		    throw makeException(TypeError, "is backed by a SharedArrayBuffer, which is not allowed", options);
		  }
		  if (isArrayBufferDetached(value.buffer)) {
		    throw makeException(TypeError, "is backed by a detached ArrayBuffer", options);
		  }

		  return value;
		};

		// Returns the unforgeable `TypedArray` constructor name or `undefined`,
		// if the `this` value isn't a valid `TypedArray` object.
		//
		// https://tc39.es/ecma262/#sec-get-%typedarray%.prototype-@@tostringtag
		const typedArrayNameGetter = Object.getOwnPropertyDescriptor(
		  Object.getPrototypeOf(Uint8Array).prototype,
		  Symbol.toStringTag
		).get;
		[
		  Int8Array,
		  Int16Array,
		  Int32Array,
		  Uint8Array,
		  Uint16Array,
		  Uint32Array,
		  Uint8ClampedArray,
		  Float32Array,
		  Float64Array
		].forEach(func => {
		  const { name } = func;
		  const article = /^[AEIOU]/u.test(name) ? "an" : "a";
		  exports[name] = (value, options = {}) => {
		    if (!ArrayBuffer.isView(value) || typedArrayNameGetter.call(value) !== name) {
		      throw makeException(TypeError, `is not ${article} ${name} object`, options);
		    }
		    if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
		      throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
		    }
		    if (isArrayBufferDetached(value.buffer)) {
		      throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
		    }

		    return value;
		  };
		});

		// Common definitions

		exports.ArrayBufferView = (value, options = {}) => {
		  if (!ArrayBuffer.isView(value)) {
		    throw makeException(TypeError, "is not a view on an ArrayBuffer or SharedArrayBuffer", options);
		  }

		  if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
		    throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
		  }

		  if (isArrayBufferDetached(value.buffer)) {
		    throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
		  }
		  return value;
		};

		exports.BufferSource = (value, options = {}) => {
		  if (ArrayBuffer.isView(value)) {
		    if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
		      throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
		    }

		    if (isArrayBufferDetached(value.buffer)) {
		      throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
		    }
		    return value;
		  }

		  if (!options.allowShared && !isNonSharedArrayBuffer(value)) {
		    throw makeException(TypeError, "is not an ArrayBuffer or a view on one", options);
		  }
		  if (options.allowShared && !isSharedArrayBuffer(value) && !isNonSharedArrayBuffer(value)) {
		    throw makeException(TypeError, "is not an ArrayBuffer, SharedArrayBuffer, or a view on one", options);
		  }
		  if (isArrayBufferDetached(value)) {
		    throw makeException(TypeError, "is a detached ArrayBuffer", options);
		  }

		  return value;
		};

		exports.DOMTimeStamp = exports["unsigned long long"]; 
	} (lib));
	return lib;
}

var utils = {exports: {}};

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils.exports;
	hasRequiredUtils = 1;
	(function (module, exports) {

		// Returns "Type(value) is Object" in ES terminology.
		function isObject(value) {
		  return (typeof value === "object" && value !== null) || typeof value === "function";
		}

		const hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty);

		// Like `Object.assign`, but using `[[GetOwnProperty]]` and `[[DefineOwnProperty]]`
		// instead of `[[Get]]` and `[[Set]]` and only allowing objects
		function define(target, source) {
		  for (const key of Reflect.ownKeys(source)) {
		    const descriptor = Reflect.getOwnPropertyDescriptor(source, key);
		    if (descriptor && !Reflect.defineProperty(target, key, descriptor)) {
		      throw new TypeError(`Cannot redefine property: ${String(key)}`);
		    }
		  }
		}

		function newObjectInRealm(globalObject, object) {
		  const ctorRegistry = initCtorRegistry(globalObject);
		  return Object.defineProperties(
		    Object.create(ctorRegistry["%Object.prototype%"]),
		    Object.getOwnPropertyDescriptors(object)
		  );
		}

		const wrapperSymbol = Symbol("wrapper");
		const implSymbol = Symbol("impl");
		const sameObjectCaches = Symbol("SameObject caches");
		const ctorRegistrySymbol = Symbol.for("[webidl2js] constructor registry");

		const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {}).prototype);

		function initCtorRegistry(globalObject) {
		  if (hasOwn(globalObject, ctorRegistrySymbol)) {
		    return globalObject[ctorRegistrySymbol];
		  }

		  const ctorRegistry = Object.create(null);

		  // In addition to registering all the WebIDL2JS-generated types in the constructor registry,
		  // we also register a few intrinsics that we make use of in generated code, since they are not
		  // easy to grab from the globalObject variable.
		  ctorRegistry["%Object.prototype%"] = globalObject.Object.prototype;
		  ctorRegistry["%IteratorPrototype%"] = Object.getPrototypeOf(
		    Object.getPrototypeOf(new globalObject.Array()[Symbol.iterator]())
		  );

		  try {
		    ctorRegistry["%AsyncIteratorPrototype%"] = Object.getPrototypeOf(
		      Object.getPrototypeOf(
		        globalObject.eval("(async function* () {})").prototype
		      )
		    );
		  } catch {
		    ctorRegistry["%AsyncIteratorPrototype%"] = AsyncIteratorPrototype;
		  }

		  globalObject[ctorRegistrySymbol] = ctorRegistry;
		  return ctorRegistry;
		}

		function getSameObject(wrapper, prop, creator) {
		  if (!wrapper[sameObjectCaches]) {
		    wrapper[sameObjectCaches] = Object.create(null);
		  }

		  if (prop in wrapper[sameObjectCaches]) {
		    return wrapper[sameObjectCaches][prop];
		  }

		  wrapper[sameObjectCaches][prop] = creator();
		  return wrapper[sameObjectCaches][prop];
		}

		function wrapperForImpl(impl) {
		  return impl ? impl[wrapperSymbol] : null;
		}

		function implForWrapper(wrapper) {
		  return wrapper ? wrapper[implSymbol] : null;
		}

		function tryWrapperForImpl(impl) {
		  const wrapper = wrapperForImpl(impl);
		  return wrapper ? wrapper : impl;
		}

		function tryImplForWrapper(wrapper) {
		  const impl = implForWrapper(wrapper);
		  return impl ? impl : wrapper;
		}

		const iterInternalSymbol = Symbol("internal");

		function isArrayIndexPropName(P) {
		  if (typeof P !== "string") {
		    return false;
		  }
		  const i = P >>> 0;
		  if (i === 2 ** 32 - 1) {
		    return false;
		  }
		  const s = `${i}`;
		  if (P !== s) {
		    return false;
		  }
		  return true;
		}

		const byteLengthGetter =
		    Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
		function isArrayBuffer(value) {
		  try {
		    byteLengthGetter.call(value);
		    return true;
		  } catch (e) {
		    return false;
		  }
		}

		function iteratorResult([key, value], kind) {
		  let result;
		  switch (kind) {
		    case "key":
		      result = key;
		      break;
		    case "value":
		      result = value;
		      break;
		    case "key+value":
		      result = [key, value];
		      break;
		  }
		  return { value: result, done: false };
		}

		const supportsPropertyIndex = Symbol("supports property index");
		const supportedPropertyIndices = Symbol("supported property indices");
		const supportsPropertyName = Symbol("supports property name");
		const supportedPropertyNames = Symbol("supported property names");
		const indexedGet = Symbol("indexed property get");
		const indexedSetNew = Symbol("indexed property set new");
		const indexedSetExisting = Symbol("indexed property set existing");
		const namedGet = Symbol("named property get");
		const namedSetNew = Symbol("named property set new");
		const namedSetExisting = Symbol("named property set existing");
		const namedDelete = Symbol("named property delete");

		const asyncIteratorNext = Symbol("async iterator get the next iteration result");
		const asyncIteratorReturn = Symbol("async iterator return steps");
		const asyncIteratorInit = Symbol("async iterator initialization steps");
		const asyncIteratorEOI = Symbol("async iterator end of iteration");

		module.exports = {
		  isObject,
		  hasOwn,
		  define,
		  newObjectInRealm,
		  wrapperSymbol,
		  implSymbol,
		  getSameObject,
		  ctorRegistrySymbol,
		  initCtorRegistry,
		  wrapperForImpl,
		  implForWrapper,
		  tryWrapperForImpl,
		  tryImplForWrapper,
		  iterInternalSymbol,
		  isArrayBuffer,
		  isArrayIndexPropName,
		  supportsPropertyIndex,
		  supportedPropertyIndices,
		  supportsPropertyName,
		  supportedPropertyNames,
		  indexedGet,
		  indexedSetNew,
		  indexedSetExisting,
		  namedGet,
		  namedSetNew,
		  namedSetExisting,
		  namedDelete,
		  asyncIteratorNext,
		  asyncIteratorReturn,
		  asyncIteratorInit,
		  asyncIteratorEOI,
		  iteratorResult
		}; 
	} (utils));
	return utils.exports;
}

var URLImpl = {};

var urlStateMachine = {exports: {}};

/** Highest positive signed 32-bit float value */
const maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128; // 0x80
const delimiter = '-'; // '\x2D'

/** Regular expressions */
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7F]/; // Note: U+007F DEL is excluded too.
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
const errors$2 = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error(type) {
	throw new RangeError(errors$2[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, callback) {
	const result = [];
	let length = array.length;
	while (length--) {
		result[length] = callback(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {String} A new string of characters returned by the callback
 * function.
 */
function mapDomain(domain, callback) {
	const parts = domain.split('@');
	let result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		domain = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	domain = domain.replace(regexSeparators, '\x2E');
	const labels = domain.split('.');
	const encoded = map(labels, callback).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	const output = [];
	let counter = 0;
	const length = string.length;
	while (counter < length) {
		const value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			const extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
const ucs2encode = codePoints => String.fromCodePoint(...codePoints);

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
const basicToDigit = function(codePoint) {
	if (codePoint >= 0x30 && codePoint < 0x3A) {
		return 26 + (codePoint - 0x30);
	}
	if (codePoint >= 0x41 && codePoint < 0x5B) {
		return codePoint - 0x41;
	}
	if (codePoint >= 0x61 && codePoint < 0x7B) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
const digitToBasic = function(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
const adapt = function(delta, numPoints, firstTime) {
	let k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
const decode = function(input) {
	// Don't use UCS-2.
	const output = [];
	const inputLength = input.length;
	let i = 0;
	let n = initialN;
	let bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	let basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (let j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		const oldi = i;
		for (let w = 1, k = base; /* no condition */; k += base) {

			if (index >= inputLength) {
				error('invalid-input');
			}

			const digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base) {
				error('invalid-input');
			}
			if (digit > floor((maxInt - i) / w)) {
				error('overflow');
			}

			i += digit * w;
			const t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

			if (digit < t) {
				break;
			}

			const baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error('overflow');
			}

			w *= baseMinusT;

		}

		const out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);

	}

	return String.fromCodePoint(...output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
const encode = function(input) {
	const output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	const inputLength = input.length;

	// Initialize the state.
	let n = initialN;
	let delta = 0;
	let bias = initialBias;

	// Handle the basic code points.
	for (const currentValue of input) {
		if (currentValue < 0x80) {
			output.push(stringFromCharCode(currentValue));
		}
	}

	const basicLength = output.length;
	let handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		let m = maxInt;
		for (const currentValue of input) {
			if (currentValue >= n && currentValue < m) {
				m = currentValue;
			}
		}

		// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
		// but guard against overflow.
		const handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		for (const currentValue of input) {
			if (currentValue < n && ++delta > maxInt) {
				error('overflow');
			}
			if (currentValue === n) {
				// Represent delta as a generalized variable-length integer.
				let q = delta;
				for (let k = base; /* no condition */; k += base) {
					const t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
					if (q < t) {
						break;
					}
					const qMinusT = q - t;
					const baseMinusT = base - t;
					output.push(
						stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
					);
					q = floor(qMinusT / baseMinusT);
				}

				output.push(stringFromCharCode(digitToBasic(q, 0)));
				bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
				delta = 0;
				++handledCPCount;
			}
		}

		++delta;
		++n;

	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
const toUnicode = function(input) {
	return mapDomain(input, function(string) {
		return regexPunycode.test(string)
			? decode(string.slice(4).toLowerCase())
			: string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
const toASCII = function(input) {
	return mapDomain(input, function(string) {
		return regexNonASCII.test(string)
			? 'xn--' + encode(string)
			: string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
const punycode = {
	/**
	 * A string representing the current Punycode.js version number.
	 * @memberOf punycode
	 * @type String
	 */
	'version': '2.3.1',
	/**
	 * An object of methods to convert from JavaScript's internal character
	 * representation (UCS-2) to Unicode code points, and back.
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode
	 * @type Object
	 */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

var punycode_es6 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	decode: decode,
	default: punycode,
	encode: encode,
	toASCII: toASCII,
	toUnicode: toUnicode,
	ucs2decode: ucs2decode,
	ucs2encode: ucs2encode
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(punycode_es6);

var regexes;
var hasRequiredRegexes;

function requireRegexes () {
	if (hasRequiredRegexes) return regexes;
	hasRequiredRegexes = 1;

	const combiningMarks = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{11002}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11082}\u{110B0}-\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{11134}\u{11145}\u{11146}\u{11173}\u{11180}-\u{11182}\u{111B3}-\u{111C0}\u{111C9}-\u{111CC}\u{111CE}\u{111CF}\u{1122C}-\u{11237}\u{1123E}\u{11241}\u{112DF}-\u{112EA}\u{11300}-\u{11303}\u{1133B}\u{1133C}\u{1133E}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11357}\u{11362}\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11435}-\u{11446}\u{1145E}\u{114B0}-\u{114C3}\u{115AF}-\u{115B5}\u{115B8}-\u{115C0}\u{115DC}\u{115DD}\u{11630}-\u{11640}\u{116AB}-\u{116B7}\u{1171D}-\u{1172B}\u{1182C}-\u{1183A}\u{11930}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{1193E}\u{11940}\u{11942}\u{11943}\u{119D1}-\u{119D7}\u{119DA}-\u{119E0}\u{119E4}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A39}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A5B}\u{11A8A}-\u{11A99}\u{11C2F}-\u{11C36}\u{11C38}-\u{11C3F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D8A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D97}\u{11EF3}-\u{11EF6}\u{11F00}\u{11F01}\u{11F03}\u{11F34}-\u{11F3A}\u{11F3E}-\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F51}-\u{16F87}\u{16F8F}-\u{16F92}\u{16FE4}\u{16FF0}\u{16FF1}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D165}-\u{1D169}\u{1D16D}-\u{1D172}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]/u;
	const combiningClassVirama = /[\u094D\u09CD\u0A4D\u0ACD\u0B4D\u0BCD\u0C4D\u0CCD\u0D3B\u0D3C\u0D4D\u0DCA\u0E3A\u0EBA\u0F84\u1039\u103A\u1714\u1734\u17D2\u1A60\u1B44\u1BAA\u1BAB\u1BF2\u1BF3\u2D7F\uA806\uA8C4\uA953\uA9C0\uAAF6\uABED\u{10A3F}\u{11046}\u{1107F}\u{110B9}\u{11133}\u{11134}\u{111C0}\u{11235}\u{112EA}\u{1134D}\u{11442}\u{114C2}\u{115BF}\u{1163F}\u{116B6}\u{1172B}\u{11839}\u{119E0}\u{11A34}\u{11A47}\u{11A99}\u{11C3F}\u{11D44}\u{11D45}\u{11D97}]/u;
	const validZWNJ = /[\u0620\u0626\u0628\u062A-\u062E\u0633-\u063F\u0641-\u0647\u0649\u064A\u066E\u066F\u0678-\u0687\u069A-\u06BF\u06C1\u06C2\u06CC\u06CE\u06D0\u06D1\u06FA-\u06FC\u06FF\u0712-\u0714\u071A-\u071D\u071F-\u0727\u0729\u072B\u072D\u072E\u074E-\u0758\u075C-\u076A\u076D-\u0770\u0772\u0775-\u0777\u077A-\u077F\u07CA-\u07EA\u0841-\u0845\u0848\u084A-\u0853\u0855\u0860\u0862-\u0865\u0868\u08A0-\u08A9\u08AF\u08B0\u08B3\u08B4\u08B6-\u08B8\u08BA-\u08BD\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA872\u{10AC0}-\u{10AC4}\u{10ACD}\u{10AD3}-\u{10ADC}\u{10ADE}-\u{10AE0}\u{10AEB}-\u{10AEE}\u{10B80}\u{10B82}\u{10B86}-\u{10B88}\u{10B8A}\u{10B8B}\u{10B8D}\u{10B90}\u{10BAD}\u{10BAE}\u{10D00}-\u{10D21}\u{10D23}\u{10F30}-\u{10F32}\u{10F34}-\u{10F44}\u{10F51}-\u{10F53}\u{1E900}-\u{1E943}][\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10F46}-\u{10F50}\u{11001}\u{11038}-\u{11046}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{13430}-\u{13438}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E130}-\u{1E136}\u{1E2EC}-\u{1E2EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*\u200C[\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10F46}-\u{10F50}\u{11001}\u{11038}-\u{11046}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{13430}-\u{13438}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E130}-\u{1E136}\u{1E2EC}-\u{1E2EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*[\u0620\u0622-\u063F\u0641-\u064A\u066E\u066F\u0671-\u0673\u0675-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u077F\u07CA-\u07EA\u0840-\u0855\u0860\u0862-\u0865\u0867-\u086A\u08A0-\u08AC\u08AE-\u08B4\u08B6-\u08BD\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA871\u{10AC0}-\u{10AC5}\u{10AC7}\u{10AC9}\u{10ACA}\u{10ACE}-\u{10AD6}\u{10AD8}-\u{10AE1}\u{10AE4}\u{10AEB}-\u{10AEF}\u{10B80}-\u{10B91}\u{10BA9}-\u{10BAE}\u{10D01}-\u{10D23}\u{10F30}-\u{10F44}\u{10F51}-\u{10F54}\u{1E900}-\u{1E943}]/u;
	const bidiDomain = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
	const bidiS1LTR = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B50-\u1B6A\u1B74-\u1B7E\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11F02}-\u{11F10}\u{11F12}-\u{11F35}\u{11F3E}\u{11F3F}\u{11F41}\u{11F43}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1343F}\u{13441}-\u{13446}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6DA}\u{1D6DC}-\u{1D714}\u{1D716}-\u{1D74E}\u{1D750}-\u{1D788}\u{1D78A}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D800}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E4D0}-\u{1E4EB}\u{1E4F0}-\u{1E4F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]/u;
	const bidiS1RTL = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
	const bidiS2 = /^[\0-\x08\x0E-\x1B!-@\[-`\{-\x84\x86-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02B9\u02BA\u02C2-\u02CF\u02D2-\u02DF\u02E5-\u02ED\u02EF-\u036F\u0374\u0375\u037E\u0384\u0385\u0387\u03F6\u0483-\u0489\u058A\u058D-\u058F\u0591-\u05C7\u05D0-\u05EA\u05EF-\u05F4\u0600-\u070D\u070F-\u074A\u074D-\u07B1\u07C0-\u07FA\u07FD-\u082D\u0830-\u083E\u0840-\u085B\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u0898-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09F2\u09F3\u09FB\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AF1\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0BF3-\u0BFA\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C78-\u0C7E\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E3F\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39-\u0F3D\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1390-\u1399\u1400\u169B\u169C\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DB\u17DD\u17F0-\u17F9\u1800-\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1940\u1944\u1945\u19DE-\u19FF\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u200B-\u200D\u200F-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20C0\u20D0-\u20F0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u2150-\u215F\u2189-\u218B\u2190-\u2335\u237B-\u2394\u2396-\u2426\u2440-\u244A\u2460-\u249B\u24EA-\u26AB\u26AD-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2CEF-\u2CF1\u2CF9-\u2CFF\u2D7F\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u3004\u3008-\u3020\u302A-\u302D\u3030\u3036\u3037\u303D-\u303F\u3099-\u309C\u30A0\u30FB\u31C0-\u31E3\u321D\u321E\u3250-\u325F\u327C-\u327E\u32B1-\u32BF\u32CC-\u32CF\u3377-\u337A\u33DE\u33DF\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA60D-\uA60F\uA66F-\uA67F\uA69E\uA69F\uA6F0\uA6F1\uA700-\uA721\uA788\uA802\uA806\uA80B\uA825\uA826\uA828-\uA82C\uA838\uA839\uA874-\uA877\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uAB6A\uAB6B\uABE5\uABE8\uABED\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD8F\uFD92-\uFDC7\uFDCF\uFDF0-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFE70-\uFE74\uFE76-\uFEFC\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10101}\u{10140}-\u{1018C}\u{10190}-\u{1019C}\u{101A0}\u{101FD}\u{102E0}-\u{102FB}\u{10376}-\u{1037A}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{1091F}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A38}-\u{10A3A}\u{10A3F}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE6}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B39}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D27}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAB}-\u{10EAD}\u{10EB0}\u{10EB1}\u{10EFD}-\u{10F27}\u{10F30}-\u{10F59}\u{10F70}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{11001}\u{11038}-\u{11046}\u{11052}-\u{11065}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{11660}-\u{1166C}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11FD5}-\u{11FF1}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE2}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D1E9}\u{1D1EA}\u{1D200}-\u{1D245}\u{1D300}-\u{1D356}\u{1D6DB}\u{1D715}\u{1D74F}\u{1D789}\u{1D7C3}\u{1D7CE}-\u{1D7FF}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E2FF}\u{1E4EC}-\u{1E4EF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8D6}\u{1E900}-\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F10F}\u{1F12F}\u{1F16A}-\u{1F16F}\u{1F1AD}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DC}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F776}\u{1F77B}-\u{1F7D9}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}\u{1F8B1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA88}\u{1FA90}-\u{1FABD}\u{1FABF}-\u{1FAC5}\u{1FACE}-\u{1FADB}\u{1FAE0}-\u{1FAE8}\u{1FAF0}-\u{1FAF8}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBCA}\u{1FBF0}-\u{1FBF9}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*$/u;
	const bidiS3 = /[0-9\xB2\xB3\xB9\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\u{102E1}-\u{102FB}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1D7CE}-\u{1D7FF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
	const bidiS4EN = /[0-9\xB2\xB3\xB9\u06F0-\u06F9\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFF10-\uFF19\u{102E1}-\u{102FB}\u{1D7CE}-\u{1D7FF}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}]/u;
	const bidiS4AN = /[\u0600-\u0605\u0660-\u0669\u066B\u066C\u06DD\u0890\u0891\u08E2\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}]/u;
	const bidiS5 = /^[\0-\x08\x0E-\x1B!-\x84\x86-\u0377\u037A-\u037F\u0384-\u038A\u038C\u038E-\u03A1\u03A3-\u052F\u0531-\u0556\u0559-\u058A\u058D-\u058F\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0606\u0607\u0609\u060A\u060C\u060E-\u061A\u064B-\u065F\u066A\u0670\u06D6-\u06DC\u06DE-\u06E4\u06E7-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07F6-\u07F9\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A76\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C77-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E3A\u0E3F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECE\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FDA\u1000-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u13A0-\u13F5\u13F8-\u13FD\u1400-\u167F\u1681-\u169C\u16A0-\u16F8\u1700-\u1715\u171F-\u1736\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u1800-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE-\u1A1B\u1A1E-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1AB0-\u1ACE\u1B00-\u1B4C\u1B50-\u1B7E\u1B80-\u1BF3\u1BFC-\u1C37\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD0-\u1CFA\u1D00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u200B-\u200E\u2010-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2071\u2074-\u208E\u2090-\u209C\u20A0-\u20C0\u20D0-\u20F0\u2100-\u218B\u2190-\u2426\u2440-\u244A\u2460-\u2B73\u2B76-\u2B95\u2B97-\u2CF3\u2CF9-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303F\u3041-\u3096\u3099-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31E3\u31F0-\u321E\u3220-\uA48C\uA490-\uA4C6\uA4D0-\uA62B\uA640-\uA6F7\uA700-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA82C\uA830-\uA839\uA840-\uA877\uA880-\uA8C5\uA8CE-\uA8D9\uA8E0-\uA953\uA95F-\uA97C\uA980-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAAC2\uAADB-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB6B\uAB70-\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1E\uFB29\uFD3E-\uFD4F\uFDCF\uFDFD-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}-\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1018E}\u{10190}-\u{1019C}\u{101A0}\u{101D0}-\u{101FD}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E0}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{1037A}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{1091F}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10B39}-\u{10B3F}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{1104D}\u{11052}-\u{11075}\u{1107F}-\u{110C2}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11100}-\u{11134}\u{11136}-\u{11147}\u{11150}-\u{11176}\u{11180}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{11241}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112EA}\u{112F0}-\u{112F9}\u{11300}-\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133B}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11400}-\u{1145B}\u{1145D}-\u{11461}\u{11480}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B5}\u{115B8}-\u{115DD}\u{11600}-\u{11644}\u{11650}-\u{11659}\u{11660}-\u{1166C}\u{11680}-\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{1171D}-\u{1172B}\u{11730}-\u{11746}\u{11800}-\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D7}\u{119DA}-\u{119E4}\u{11A00}-\u{11A47}\u{11A50}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C36}\u{11C38}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D47}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF8}\u{11F00}-\u{11F10}\u{11F12}-\u{11F3A}\u{11F3E}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FF1}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{13455}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF0}-\u{16AF5}\u{16B00}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F4F}-\u{16F87}\u{16F8F}-\u{16F9F}\u{16FE0}-\u{16FE4}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D1EA}\u{1D200}-\u{1D245}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D300}-\u{1D356}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D7CB}\u{1D7CE}-\u{1DA8B}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E030}-\u{1E06D}\u{1E08F}\u{1E100}-\u{1E12C}\u{1E130}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AE}\u{1E2C0}-\u{1E2F9}\u{1E2FF}\u{1E4D0}-\u{1E4F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F1AD}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DC}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F776}\u{1F77B}-\u{1F7D9}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}\u{1F8B1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA88}\u{1FA90}-\u{1FABD}\u{1FABF}-\u{1FAC5}\u{1FACE}-\u{1FADB}\u{1FAE0}-\u{1FAE8}\u{1FAF0}-\u{1FAF8}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBCA}\u{1FBF0}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]*$/u;
	const bidiS6 = /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u06F0-\u06F9\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B50-\u1B6A\u1B74-\u1B7E\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u2488-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E1}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11F02}-\u{11F10}\u{11F12}-\u{11F35}\u{11F3E}\u{11F3F}\u{11F41}\u{11F43}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1343F}\u{13441}-\u{13446}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6DA}\u{1D6DC}-\u{1D714}\u{1D716}-\u{1D74E}\u{1D750}-\u{1D788}\u{1D78A}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D7CE}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E4D0}-\u{1E4EB}\u{1E4F0}-\u{1E4F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F100}-\u{1F10A}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1FBF0}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;

	regexes = {
	  combiningMarks,
	  combiningClassVirama,
	  validZWNJ,
	  bidiDomain,
	  bidiS1LTR,
	  bidiS1RTL,
	  bidiS2,
	  bidiS3,
	  bidiS4EN,
	  bidiS4AN,
	  bidiS5,
	  bidiS6
	};
	return regexes;
}

var require$$2 = [
	[
		[
			0,
			44
		],
		4
	],
	[
		[
			45,
			46
		],
		2
	],
	[
		47,
		4
	],
	[
		[
			48,
			57
		],
		2
	],
	[
		[
			58,
			64
		],
		4
	],
	[
		65,
		1,
		"a"
	],
	[
		66,
		1,
		"b"
	],
	[
		67,
		1,
		"c"
	],
	[
		68,
		1,
		"d"
	],
	[
		69,
		1,
		"e"
	],
	[
		70,
		1,
		"f"
	],
	[
		71,
		1,
		"g"
	],
	[
		72,
		1,
		"h"
	],
	[
		73,
		1,
		"i"
	],
	[
		74,
		1,
		"j"
	],
	[
		75,
		1,
		"k"
	],
	[
		76,
		1,
		"l"
	],
	[
		77,
		1,
		"m"
	],
	[
		78,
		1,
		"n"
	],
	[
		79,
		1,
		"o"
	],
	[
		80,
		1,
		"p"
	],
	[
		81,
		1,
		"q"
	],
	[
		82,
		1,
		"r"
	],
	[
		83,
		1,
		"s"
	],
	[
		84,
		1,
		"t"
	],
	[
		85,
		1,
		"u"
	],
	[
		86,
		1,
		"v"
	],
	[
		87,
		1,
		"w"
	],
	[
		88,
		1,
		"x"
	],
	[
		89,
		1,
		"y"
	],
	[
		90,
		1,
		"z"
	],
	[
		[
			91,
			96
		],
		4
	],
	[
		[
			97,
			122
		],
		2
	],
	[
		[
			123,
			127
		],
		4
	],
	[
		[
			128,
			159
		],
		3
	],
	[
		160,
		5,
		" "
	],
	[
		[
			161,
			167
		],
		2
	],
	[
		168,
		5,
		" "
	],
	[
		169,
		2
	],
	[
		170,
		1,
		"a"
	],
	[
		[
			171,
			172
		],
		2
	],
	[
		173,
		7
	],
	[
		174,
		2
	],
	[
		175,
		5,
		" "
	],
	[
		[
			176,
			177
		],
		2
	],
	[
		178,
		1,
		"2"
	],
	[
		179,
		1,
		"3"
	],
	[
		180,
		5,
		" "
	],
	[
		181,
		1,
		""
	],
	[
		182,
		2
	],
	[
		183,
		2
	],
	[
		184,
		5,
		" "
	],
	[
		185,
		1,
		"1"
	],
	[
		186,
		1,
		"o"
	],
	[
		187,
		2
	],
	[
		188,
		1,
		"14"
	],
	[
		189,
		1,
		"12"
	],
	[
		190,
		1,
		"34"
	],
	[
		191,
		2
	],
	[
		192,
		1,
		""
	],
	[
		193,
		1,
		""
	],
	[
		194,
		1,
		""
	],
	[
		195,
		1,
		""
	],
	[
		196,
		1,
		""
	],
	[
		197,
		1,
		""
	],
	[
		198,
		1,
		""
	],
	[
		199,
		1,
		""
	],
	[
		200,
		1,
		""
	],
	[
		201,
		1,
		""
	],
	[
		202,
		1,
		""
	],
	[
		203,
		1,
		""
	],
	[
		204,
		1,
		""
	],
	[
		205,
		1,
		""
	],
	[
		206,
		1,
		""
	],
	[
		207,
		1,
		""
	],
	[
		208,
		1,
		""
	],
	[
		209,
		1,
		""
	],
	[
		210,
		1,
		""
	],
	[
		211,
		1,
		""
	],
	[
		212,
		1,
		""
	],
	[
		213,
		1,
		""
	],
	[
		214,
		1,
		""
	],
	[
		215,
		2
	],
	[
		216,
		1,
		""
	],
	[
		217,
		1,
		""
	],
	[
		218,
		1,
		""
	],
	[
		219,
		1,
		""
	],
	[
		220,
		1,
		""
	],
	[
		221,
		1,
		""
	],
	[
		222,
		1,
		""
	],
	[
		223,
		6,
		"ss"
	],
	[
		[
			224,
			246
		],
		2
	],
	[
		247,
		2
	],
	[
		[
			248,
			255
		],
		2
	],
	[
		256,
		1,
		""
	],
	[
		257,
		2
	],
	[
		258,
		1,
		""
	],
	[
		259,
		2
	],
	[
		260,
		1,
		""
	],
	[
		261,
		2
	],
	[
		262,
		1,
		""
	],
	[
		263,
		2
	],
	[
		264,
		1,
		""
	],
	[
		265,
		2
	],
	[
		266,
		1,
		""
	],
	[
		267,
		2
	],
	[
		268,
		1,
		""
	],
	[
		269,
		2
	],
	[
		270,
		1,
		""
	],
	[
		271,
		2
	],
	[
		272,
		1,
		""
	],
	[
		273,
		2
	],
	[
		274,
		1,
		""
	],
	[
		275,
		2
	],
	[
		276,
		1,
		""
	],
	[
		277,
		2
	],
	[
		278,
		1,
		""
	],
	[
		279,
		2
	],
	[
		280,
		1,
		""
	],
	[
		281,
		2
	],
	[
		282,
		1,
		""
	],
	[
		283,
		2
	],
	[
		284,
		1,
		""
	],
	[
		285,
		2
	],
	[
		286,
		1,
		""
	],
	[
		287,
		2
	],
	[
		288,
		1,
		""
	],
	[
		289,
		2
	],
	[
		290,
		1,
		""
	],
	[
		291,
		2
	],
	[
		292,
		1,
		""
	],
	[
		293,
		2
	],
	[
		294,
		1,
		""
	],
	[
		295,
		2
	],
	[
		296,
		1,
		""
	],
	[
		297,
		2
	],
	[
		298,
		1,
		""
	],
	[
		299,
		2
	],
	[
		300,
		1,
		""
	],
	[
		301,
		2
	],
	[
		302,
		1,
		""
	],
	[
		303,
		2
	],
	[
		304,
		1,
		"i"
	],
	[
		305,
		2
	],
	[
		[
			306,
			307
		],
		1,
		"ij"
	],
	[
		308,
		1,
		""
	],
	[
		309,
		2
	],
	[
		310,
		1,
		""
	],
	[
		[
			311,
			312
		],
		2
	],
	[
		313,
		1,
		""
	],
	[
		314,
		2
	],
	[
		315,
		1,
		""
	],
	[
		316,
		2
	],
	[
		317,
		1,
		""
	],
	[
		318,
		2
	],
	[
		[
			319,
			320
		],
		1,
		"l"
	],
	[
		321,
		1,
		""
	],
	[
		322,
		2
	],
	[
		323,
		1,
		""
	],
	[
		324,
		2
	],
	[
		325,
		1,
		""
	],
	[
		326,
		2
	],
	[
		327,
		1,
		""
	],
	[
		328,
		2
	],
	[
		329,
		1,
		"n"
	],
	[
		330,
		1,
		""
	],
	[
		331,
		2
	],
	[
		332,
		1,
		""
	],
	[
		333,
		2
	],
	[
		334,
		1,
		""
	],
	[
		335,
		2
	],
	[
		336,
		1,
		""
	],
	[
		337,
		2
	],
	[
		338,
		1,
		""
	],
	[
		339,
		2
	],
	[
		340,
		1,
		""
	],
	[
		341,
		2
	],
	[
		342,
		1,
		""
	],
	[
		343,
		2
	],
	[
		344,
		1,
		""
	],
	[
		345,
		2
	],
	[
		346,
		1,
		""
	],
	[
		347,
		2
	],
	[
		348,
		1,
		""
	],
	[
		349,
		2
	],
	[
		350,
		1,
		""
	],
	[
		351,
		2
	],
	[
		352,
		1,
		""
	],
	[
		353,
		2
	],
	[
		354,
		1,
		""
	],
	[
		355,
		2
	],
	[
		356,
		1,
		""
	],
	[
		357,
		2
	],
	[
		358,
		1,
		""
	],
	[
		359,
		2
	],
	[
		360,
		1,
		""
	],
	[
		361,
		2
	],
	[
		362,
		1,
		""
	],
	[
		363,
		2
	],
	[
		364,
		1,
		""
	],
	[
		365,
		2
	],
	[
		366,
		1,
		""
	],
	[
		367,
		2
	],
	[
		368,
		1,
		""
	],
	[
		369,
		2
	],
	[
		370,
		1,
		""
	],
	[
		371,
		2
	],
	[
		372,
		1,
		""
	],
	[
		373,
		2
	],
	[
		374,
		1,
		""
	],
	[
		375,
		2
	],
	[
		376,
		1,
		""
	],
	[
		377,
		1,
		""
	],
	[
		378,
		2
	],
	[
		379,
		1,
		""
	],
	[
		380,
		2
	],
	[
		381,
		1,
		""
	],
	[
		382,
		2
	],
	[
		383,
		1,
		"s"
	],
	[
		384,
		2
	],
	[
		385,
		1,
		""
	],
	[
		386,
		1,
		""
	],
	[
		387,
		2
	],
	[
		388,
		1,
		""
	],
	[
		389,
		2
	],
	[
		390,
		1,
		""
	],
	[
		391,
		1,
		""
	],
	[
		392,
		2
	],
	[
		393,
		1,
		""
	],
	[
		394,
		1,
		""
	],
	[
		395,
		1,
		""
	],
	[
		[
			396,
			397
		],
		2
	],
	[
		398,
		1,
		""
	],
	[
		399,
		1,
		""
	],
	[
		400,
		1,
		""
	],
	[
		401,
		1,
		""
	],
	[
		402,
		2
	],
	[
		403,
		1,
		""
	],
	[
		404,
		1,
		""
	],
	[
		405,
		2
	],
	[
		406,
		1,
		""
	],
	[
		407,
		1,
		""
	],
	[
		408,
		1,
		""
	],
	[
		[
			409,
			411
		],
		2
	],
	[
		412,
		1,
		""
	],
	[
		413,
		1,
		""
	],
	[
		414,
		2
	],
	[
		415,
		1,
		""
	],
	[
		416,
		1,
		""
	],
	[
		417,
		2
	],
	[
		418,
		1,
		""
	],
	[
		419,
		2
	],
	[
		420,
		1,
		""
	],
	[
		421,
		2
	],
	[
		422,
		1,
		""
	],
	[
		423,
		1,
		""
	],
	[
		424,
		2
	],
	[
		425,
		1,
		""
	],
	[
		[
			426,
			427
		],
		2
	],
	[
		428,
		1,
		""
	],
	[
		429,
		2
	],
	[
		430,
		1,
		""
	],
	[
		431,
		1,
		""
	],
	[
		432,
		2
	],
	[
		433,
		1,
		""
	],
	[
		434,
		1,
		""
	],
	[
		435,
		1,
		""
	],
	[
		436,
		2
	],
	[
		437,
		1,
		""
	],
	[
		438,
		2
	],
	[
		439,
		1,
		""
	],
	[
		440,
		1,
		""
	],
	[
		[
			441,
			443
		],
		2
	],
	[
		444,
		1,
		""
	],
	[
		[
			445,
			451
		],
		2
	],
	[
		[
			452,
			454
		],
		1,
		"d"
	],
	[
		[
			455,
			457
		],
		1,
		"lj"
	],
	[
		[
			458,
			460
		],
		1,
		"nj"
	],
	[
		461,
		1,
		""
	],
	[
		462,
		2
	],
	[
		463,
		1,
		""
	],
	[
		464,
		2
	],
	[
		465,
		1,
		""
	],
	[
		466,
		2
	],
	[
		467,
		1,
		""
	],
	[
		468,
		2
	],
	[
		469,
		1,
		""
	],
	[
		470,
		2
	],
	[
		471,
		1,
		""
	],
	[
		472,
		2
	],
	[
		473,
		1,
		""
	],
	[
		474,
		2
	],
	[
		475,
		1,
		""
	],
	[
		[
			476,
			477
		],
		2
	],
	[
		478,
		1,
		""
	],
	[
		479,
		2
	],
	[
		480,
		1,
		""
	],
	[
		481,
		2
	],
	[
		482,
		1,
		""
	],
	[
		483,
		2
	],
	[
		484,
		1,
		""
	],
	[
		485,
		2
	],
	[
		486,
		1,
		""
	],
	[
		487,
		2
	],
	[
		488,
		1,
		""
	],
	[
		489,
		2
	],
	[
		490,
		1,
		""
	],
	[
		491,
		2
	],
	[
		492,
		1,
		""
	],
	[
		493,
		2
	],
	[
		494,
		1,
		""
	],
	[
		[
			495,
			496
		],
		2
	],
	[
		[
			497,
			499
		],
		1,
		"dz"
	],
	[
		500,
		1,
		""
	],
	[
		501,
		2
	],
	[
		502,
		1,
		""
	],
	[
		503,
		1,
		""
	],
	[
		504,
		1,
		""
	],
	[
		505,
		2
	],
	[
		506,
		1,
		""
	],
	[
		507,
		2
	],
	[
		508,
		1,
		""
	],
	[
		509,
		2
	],
	[
		510,
		1,
		""
	],
	[
		511,
		2
	],
	[
		512,
		1,
		""
	],
	[
		513,
		2
	],
	[
		514,
		1,
		""
	],
	[
		515,
		2
	],
	[
		516,
		1,
		""
	],
	[
		517,
		2
	],
	[
		518,
		1,
		""
	],
	[
		519,
		2
	],
	[
		520,
		1,
		""
	],
	[
		521,
		2
	],
	[
		522,
		1,
		""
	],
	[
		523,
		2
	],
	[
		524,
		1,
		""
	],
	[
		525,
		2
	],
	[
		526,
		1,
		""
	],
	[
		527,
		2
	],
	[
		528,
		1,
		""
	],
	[
		529,
		2
	],
	[
		530,
		1,
		""
	],
	[
		531,
		2
	],
	[
		532,
		1,
		""
	],
	[
		533,
		2
	],
	[
		534,
		1,
		""
	],
	[
		535,
		2
	],
	[
		536,
		1,
		""
	],
	[
		537,
		2
	],
	[
		538,
		1,
		""
	],
	[
		539,
		2
	],
	[
		540,
		1,
		""
	],
	[
		541,
		2
	],
	[
		542,
		1,
		""
	],
	[
		543,
		2
	],
	[
		544,
		1,
		""
	],
	[
		545,
		2
	],
	[
		546,
		1,
		""
	],
	[
		547,
		2
	],
	[
		548,
		1,
		""
	],
	[
		549,
		2
	],
	[
		550,
		1,
		""
	],
	[
		551,
		2
	],
	[
		552,
		1,
		""
	],
	[
		553,
		2
	],
	[
		554,
		1,
		""
	],
	[
		555,
		2
	],
	[
		556,
		1,
		""
	],
	[
		557,
		2
	],
	[
		558,
		1,
		""
	],
	[
		559,
		2
	],
	[
		560,
		1,
		""
	],
	[
		561,
		2
	],
	[
		562,
		1,
		""
	],
	[
		563,
		2
	],
	[
		[
			564,
			566
		],
		2
	],
	[
		[
			567,
			569
		],
		2
	],
	[
		570,
		1,
		""
	],
	[
		571,
		1,
		""
	],
	[
		572,
		2
	],
	[
		573,
		1,
		""
	],
	[
		574,
		1,
		""
	],
	[
		[
			575,
			576
		],
		2
	],
	[
		577,
		1,
		""
	],
	[
		578,
		2
	],
	[
		579,
		1,
		""
	],
	[
		580,
		1,
		""
	],
	[
		581,
		1,
		""
	],
	[
		582,
		1,
		""
	],
	[
		583,
		2
	],
	[
		584,
		1,
		""
	],
	[
		585,
		2
	],
	[
		586,
		1,
		""
	],
	[
		587,
		2
	],
	[
		588,
		1,
		""
	],
	[
		589,
		2
	],
	[
		590,
		1,
		""
	],
	[
		591,
		2
	],
	[
		[
			592,
			680
		],
		2
	],
	[
		[
			681,
			685
		],
		2
	],
	[
		[
			686,
			687
		],
		2
	],
	[
		688,
		1,
		"h"
	],
	[
		689,
		1,
		""
	],
	[
		690,
		1,
		"j"
	],
	[
		691,
		1,
		"r"
	],
	[
		692,
		1,
		""
	],
	[
		693,
		1,
		""
	],
	[
		694,
		1,
		""
	],
	[
		695,
		1,
		"w"
	],
	[
		696,
		1,
		"y"
	],
	[
		[
			697,
			705
		],
		2
	],
	[
		[
			706,
			709
		],
		2
	],
	[
		[
			710,
			721
		],
		2
	],
	[
		[
			722,
			727
		],
		2
	],
	[
		728,
		5,
		" "
	],
	[
		729,
		5,
		" "
	],
	[
		730,
		5,
		" "
	],
	[
		731,
		5,
		" "
	],
	[
		732,
		5,
		" "
	],
	[
		733,
		5,
		" "
	],
	[
		734,
		2
	],
	[
		735,
		2
	],
	[
		736,
		1,
		""
	],
	[
		737,
		1,
		"l"
	],
	[
		738,
		1,
		"s"
	],
	[
		739,
		1,
		"x"
	],
	[
		740,
		1,
		""
	],
	[
		[
			741,
			745
		],
		2
	],
	[
		[
			746,
			747
		],
		2
	],
	[
		748,
		2
	],
	[
		749,
		2
	],
	[
		750,
		2
	],
	[
		[
			751,
			767
		],
		2
	],
	[
		[
			768,
			831
		],
		2
	],
	[
		832,
		1,
		""
	],
	[
		833,
		1,
		""
	],
	[
		834,
		2
	],
	[
		835,
		1,
		""
	],
	[
		836,
		1,
		""
	],
	[
		837,
		1,
		""
	],
	[
		[
			838,
			846
		],
		2
	],
	[
		847,
		7
	],
	[
		[
			848,
			855
		],
		2
	],
	[
		[
			856,
			860
		],
		2
	],
	[
		[
			861,
			863
		],
		2
	],
	[
		[
			864,
			865
		],
		2
	],
	[
		866,
		2
	],
	[
		[
			867,
			879
		],
		2
	],
	[
		880,
		1,
		""
	],
	[
		881,
		2
	],
	[
		882,
		1,
		""
	],
	[
		883,
		2
	],
	[
		884,
		1,
		""
	],
	[
		885,
		2
	],
	[
		886,
		1,
		""
	],
	[
		887,
		2
	],
	[
		[
			888,
			889
		],
		3
	],
	[
		890,
		5,
		" "
	],
	[
		[
			891,
			893
		],
		2
	],
	[
		894,
		5,
		";"
	],
	[
		895,
		1,
		""
	],
	[
		[
			896,
			899
		],
		3
	],
	[
		900,
		5,
		" "
	],
	[
		901,
		5,
		" "
	],
	[
		902,
		1,
		""
	],
	[
		903,
		1,
		""
	],
	[
		904,
		1,
		""
	],
	[
		905,
		1,
		""
	],
	[
		906,
		1,
		""
	],
	[
		907,
		3
	],
	[
		908,
		1,
		""
	],
	[
		909,
		3
	],
	[
		910,
		1,
		""
	],
	[
		911,
		1,
		""
	],
	[
		912,
		2
	],
	[
		913,
		1,
		""
	],
	[
		914,
		1,
		""
	],
	[
		915,
		1,
		""
	],
	[
		916,
		1,
		""
	],
	[
		917,
		1,
		""
	],
	[
		918,
		1,
		""
	],
	[
		919,
		1,
		""
	],
	[
		920,
		1,
		""
	],
	[
		921,
		1,
		""
	],
	[
		922,
		1,
		""
	],
	[
		923,
		1,
		""
	],
	[
		924,
		1,
		""
	],
	[
		925,
		1,
		""
	],
	[
		926,
		1,
		""
	],
	[
		927,
		1,
		""
	],
	[
		928,
		1,
		""
	],
	[
		929,
		1,
		""
	],
	[
		930,
		3
	],
	[
		931,
		1,
		""
	],
	[
		932,
		1,
		""
	],
	[
		933,
		1,
		""
	],
	[
		934,
		1,
		""
	],
	[
		935,
		1,
		""
	],
	[
		936,
		1,
		""
	],
	[
		937,
		1,
		""
	],
	[
		938,
		1,
		""
	],
	[
		939,
		1,
		""
	],
	[
		[
			940,
			961
		],
		2
	],
	[
		962,
		6,
		""
	],
	[
		[
			963,
			974
		],
		2
	],
	[
		975,
		1,
		""
	],
	[
		976,
		1,
		""
	],
	[
		977,
		1,
		""
	],
	[
		978,
		1,
		""
	],
	[
		979,
		1,
		""
	],
	[
		980,
		1,
		""
	],
	[
		981,
		1,
		""
	],
	[
		982,
		1,
		""
	],
	[
		983,
		2
	],
	[
		984,
		1,
		""
	],
	[
		985,
		2
	],
	[
		986,
		1,
		""
	],
	[
		987,
		2
	],
	[
		988,
		1,
		""
	],
	[
		989,
		2
	],
	[
		990,
		1,
		""
	],
	[
		991,
		2
	],
	[
		992,
		1,
		""
	],
	[
		993,
		2
	],
	[
		994,
		1,
		""
	],
	[
		995,
		2
	],
	[
		996,
		1,
		""
	],
	[
		997,
		2
	],
	[
		998,
		1,
		""
	],
	[
		999,
		2
	],
	[
		1000,
		1,
		""
	],
	[
		1001,
		2
	],
	[
		1002,
		1,
		""
	],
	[
		1003,
		2
	],
	[
		1004,
		1,
		""
	],
	[
		1005,
		2
	],
	[
		1006,
		1,
		""
	],
	[
		1007,
		2
	],
	[
		1008,
		1,
		""
	],
	[
		1009,
		1,
		""
	],
	[
		1010,
		1,
		""
	],
	[
		1011,
		2
	],
	[
		1012,
		1,
		""
	],
	[
		1013,
		1,
		""
	],
	[
		1014,
		2
	],
	[
		1015,
		1,
		""
	],
	[
		1016,
		2
	],
	[
		1017,
		1,
		""
	],
	[
		1018,
		1,
		""
	],
	[
		1019,
		2
	],
	[
		1020,
		2
	],
	[
		1021,
		1,
		""
	],
	[
		1022,
		1,
		""
	],
	[
		1023,
		1,
		""
	],
	[
		1024,
		1,
		""
	],
	[
		1025,
		1,
		""
	],
	[
		1026,
		1,
		""
	],
	[
		1027,
		1,
		""
	],
	[
		1028,
		1,
		""
	],
	[
		1029,
		1,
		""
	],
	[
		1030,
		1,
		""
	],
	[
		1031,
		1,
		""
	],
	[
		1032,
		1,
		""
	],
	[
		1033,
		1,
		""
	],
	[
		1034,
		1,
		""
	],
	[
		1035,
		1,
		""
	],
	[
		1036,
		1,
		""
	],
	[
		1037,
		1,
		""
	],
	[
		1038,
		1,
		""
	],
	[
		1039,
		1,
		""
	],
	[
		1040,
		1,
		""
	],
	[
		1041,
		1,
		""
	],
	[
		1042,
		1,
		""
	],
	[
		1043,
		1,
		""
	],
	[
		1044,
		1,
		""
	],
	[
		1045,
		1,
		""
	],
	[
		1046,
		1,
		""
	],
	[
		1047,
		1,
		""
	],
	[
		1048,
		1,
		""
	],
	[
		1049,
		1,
		""
	],
	[
		1050,
		1,
		""
	],
	[
		1051,
		1,
		""
	],
	[
		1052,
		1,
		""
	],
	[
		1053,
		1,
		""
	],
	[
		1054,
		1,
		""
	],
	[
		1055,
		1,
		""
	],
	[
		1056,
		1,
		""
	],
	[
		1057,
		1,
		""
	],
	[
		1058,
		1,
		""
	],
	[
		1059,
		1,
		""
	],
	[
		1060,
		1,
		""
	],
	[
		1061,
		1,
		""
	],
	[
		1062,
		1,
		""
	],
	[
		1063,
		1,
		""
	],
	[
		1064,
		1,
		""
	],
	[
		1065,
		1,
		""
	],
	[
		1066,
		1,
		""
	],
	[
		1067,
		1,
		""
	],
	[
		1068,
		1,
		""
	],
	[
		1069,
		1,
		""
	],
	[
		1070,
		1,
		""
	],
	[
		1071,
		1,
		""
	],
	[
		[
			1072,
			1103
		],
		2
	],
	[
		1104,
		2
	],
	[
		[
			1105,
			1116
		],
		2
	],
	[
		1117,
		2
	],
	[
		[
			1118,
			1119
		],
		2
	],
	[
		1120,
		1,
		""
	],
	[
		1121,
		2
	],
	[
		1122,
		1,
		""
	],
	[
		1123,
		2
	],
	[
		1124,
		1,
		""
	],
	[
		1125,
		2
	],
	[
		1126,
		1,
		""
	],
	[
		1127,
		2
	],
	[
		1128,
		1,
		""
	],
	[
		1129,
		2
	],
	[
		1130,
		1,
		""
	],
	[
		1131,
		2
	],
	[
		1132,
		1,
		""
	],
	[
		1133,
		2
	],
	[
		1134,
		1,
		""
	],
	[
		1135,
		2
	],
	[
		1136,
		1,
		""
	],
	[
		1137,
		2
	],
	[
		1138,
		1,
		""
	],
	[
		1139,
		2
	],
	[
		1140,
		1,
		""
	],
	[
		1141,
		2
	],
	[
		1142,
		1,
		""
	],
	[
		1143,
		2
	],
	[
		1144,
		1,
		""
	],
	[
		1145,
		2
	],
	[
		1146,
		1,
		""
	],
	[
		1147,
		2
	],
	[
		1148,
		1,
		""
	],
	[
		1149,
		2
	],
	[
		1150,
		1,
		""
	],
	[
		1151,
		2
	],
	[
		1152,
		1,
		""
	],
	[
		1153,
		2
	],
	[
		1154,
		2
	],
	[
		[
			1155,
			1158
		],
		2
	],
	[
		1159,
		2
	],
	[
		[
			1160,
			1161
		],
		2
	],
	[
		1162,
		1,
		""
	],
	[
		1163,
		2
	],
	[
		1164,
		1,
		""
	],
	[
		1165,
		2
	],
	[
		1166,
		1,
		""
	],
	[
		1167,
		2
	],
	[
		1168,
		1,
		""
	],
	[
		1169,
		2
	],
	[
		1170,
		1,
		""
	],
	[
		1171,
		2
	],
	[
		1172,
		1,
		""
	],
	[
		1173,
		2
	],
	[
		1174,
		1,
		""
	],
	[
		1175,
		2
	],
	[
		1176,
		1,
		""
	],
	[
		1177,
		2
	],
	[
		1178,
		1,
		""
	],
	[
		1179,
		2
	],
	[
		1180,
		1,
		""
	],
	[
		1181,
		2
	],
	[
		1182,
		1,
		""
	],
	[
		1183,
		2
	],
	[
		1184,
		1,
		""
	],
	[
		1185,
		2
	],
	[
		1186,
		1,
		""
	],
	[
		1187,
		2
	],
	[
		1188,
		1,
		""
	],
	[
		1189,
		2
	],
	[
		1190,
		1,
		""
	],
	[
		1191,
		2
	],
	[
		1192,
		1,
		""
	],
	[
		1193,
		2
	],
	[
		1194,
		1,
		""
	],
	[
		1195,
		2
	],
	[
		1196,
		1,
		""
	],
	[
		1197,
		2
	],
	[
		1198,
		1,
		""
	],
	[
		1199,
		2
	],
	[
		1200,
		1,
		""
	],
	[
		1201,
		2
	],
	[
		1202,
		1,
		""
	],
	[
		1203,
		2
	],
	[
		1204,
		1,
		""
	],
	[
		1205,
		2
	],
	[
		1206,
		1,
		""
	],
	[
		1207,
		2
	],
	[
		1208,
		1,
		""
	],
	[
		1209,
		2
	],
	[
		1210,
		1,
		""
	],
	[
		1211,
		2
	],
	[
		1212,
		1,
		""
	],
	[
		1213,
		2
	],
	[
		1214,
		1,
		""
	],
	[
		1215,
		2
	],
	[
		1216,
		3
	],
	[
		1217,
		1,
		""
	],
	[
		1218,
		2
	],
	[
		1219,
		1,
		""
	],
	[
		1220,
		2
	],
	[
		1221,
		1,
		""
	],
	[
		1222,
		2
	],
	[
		1223,
		1,
		""
	],
	[
		1224,
		2
	],
	[
		1225,
		1,
		""
	],
	[
		1226,
		2
	],
	[
		1227,
		1,
		""
	],
	[
		1228,
		2
	],
	[
		1229,
		1,
		""
	],
	[
		1230,
		2
	],
	[
		1231,
		2
	],
	[
		1232,
		1,
		""
	],
	[
		1233,
		2
	],
	[
		1234,
		1,
		""
	],
	[
		1235,
		2
	],
	[
		1236,
		1,
		""
	],
	[
		1237,
		2
	],
	[
		1238,
		1,
		""
	],
	[
		1239,
		2
	],
	[
		1240,
		1,
		""
	],
	[
		1241,
		2
	],
	[
		1242,
		1,
		""
	],
	[
		1243,
		2
	],
	[
		1244,
		1,
		""
	],
	[
		1245,
		2
	],
	[
		1246,
		1,
		""
	],
	[
		1247,
		2
	],
	[
		1248,
		1,
		""
	],
	[
		1249,
		2
	],
	[
		1250,
		1,
		""
	],
	[
		1251,
		2
	],
	[
		1252,
		1,
		""
	],
	[
		1253,
		2
	],
	[
		1254,
		1,
		""
	],
	[
		1255,
		2
	],
	[
		1256,
		1,
		""
	],
	[
		1257,
		2
	],
	[
		1258,
		1,
		""
	],
	[
		1259,
		2
	],
	[
		1260,
		1,
		""
	],
	[
		1261,
		2
	],
	[
		1262,
		1,
		""
	],
	[
		1263,
		2
	],
	[
		1264,
		1,
		""
	],
	[
		1265,
		2
	],
	[
		1266,
		1,
		""
	],
	[
		1267,
		2
	],
	[
		1268,
		1,
		""
	],
	[
		1269,
		2
	],
	[
		1270,
		1,
		""
	],
	[
		1271,
		2
	],
	[
		1272,
		1,
		""
	],
	[
		1273,
		2
	],
	[
		1274,
		1,
		""
	],
	[
		1275,
		2
	],
	[
		1276,
		1,
		""
	],
	[
		1277,
		2
	],
	[
		1278,
		1,
		""
	],
	[
		1279,
		2
	],
	[
		1280,
		1,
		""
	],
	[
		1281,
		2
	],
	[
		1282,
		1,
		""
	],
	[
		1283,
		2
	],
	[
		1284,
		1,
		""
	],
	[
		1285,
		2
	],
	[
		1286,
		1,
		""
	],
	[
		1287,
		2
	],
	[
		1288,
		1,
		""
	],
	[
		1289,
		2
	],
	[
		1290,
		1,
		""
	],
	[
		1291,
		2
	],
	[
		1292,
		1,
		""
	],
	[
		1293,
		2
	],
	[
		1294,
		1,
		""
	],
	[
		1295,
		2
	],
	[
		1296,
		1,
		""
	],
	[
		1297,
		2
	],
	[
		1298,
		1,
		""
	],
	[
		1299,
		2
	],
	[
		1300,
		1,
		""
	],
	[
		1301,
		2
	],
	[
		1302,
		1,
		""
	],
	[
		1303,
		2
	],
	[
		1304,
		1,
		""
	],
	[
		1305,
		2
	],
	[
		1306,
		1,
		""
	],
	[
		1307,
		2
	],
	[
		1308,
		1,
		""
	],
	[
		1309,
		2
	],
	[
		1310,
		1,
		""
	],
	[
		1311,
		2
	],
	[
		1312,
		1,
		""
	],
	[
		1313,
		2
	],
	[
		1314,
		1,
		""
	],
	[
		1315,
		2
	],
	[
		1316,
		1,
		""
	],
	[
		1317,
		2
	],
	[
		1318,
		1,
		""
	],
	[
		1319,
		2
	],
	[
		1320,
		1,
		""
	],
	[
		1321,
		2
	],
	[
		1322,
		1,
		""
	],
	[
		1323,
		2
	],
	[
		1324,
		1,
		""
	],
	[
		1325,
		2
	],
	[
		1326,
		1,
		""
	],
	[
		1327,
		2
	],
	[
		1328,
		3
	],
	[
		1329,
		1,
		""
	],
	[
		1330,
		1,
		""
	],
	[
		1331,
		1,
		""
	],
	[
		1332,
		1,
		""
	],
	[
		1333,
		1,
		""
	],
	[
		1334,
		1,
		""
	],
	[
		1335,
		1,
		""
	],
	[
		1336,
		1,
		""
	],
	[
		1337,
		1,
		""
	],
	[
		1338,
		1,
		""
	],
	[
		1339,
		1,
		""
	],
	[
		1340,
		1,
		""
	],
	[
		1341,
		1,
		""
	],
	[
		1342,
		1,
		""
	],
	[
		1343,
		1,
		""
	],
	[
		1344,
		1,
		""
	],
	[
		1345,
		1,
		""
	],
	[
		1346,
		1,
		""
	],
	[
		1347,
		1,
		""
	],
	[
		1348,
		1,
		""
	],
	[
		1349,
		1,
		""
	],
	[
		1350,
		1,
		""
	],
	[
		1351,
		1,
		""
	],
	[
		1352,
		1,
		""
	],
	[
		1353,
		1,
		""
	],
	[
		1354,
		1,
		""
	],
	[
		1355,
		1,
		""
	],
	[
		1356,
		1,
		""
	],
	[
		1357,
		1,
		""
	],
	[
		1358,
		1,
		""
	],
	[
		1359,
		1,
		""
	],
	[
		1360,
		1,
		""
	],
	[
		1361,
		1,
		""
	],
	[
		1362,
		1,
		""
	],
	[
		1363,
		1,
		""
	],
	[
		1364,
		1,
		""
	],
	[
		1365,
		1,
		""
	],
	[
		1366,
		1,
		""
	],
	[
		[
			1367,
			1368
		],
		3
	],
	[
		1369,
		2
	],
	[
		[
			1370,
			1375
		],
		2
	],
	[
		1376,
		2
	],
	[
		[
			1377,
			1414
		],
		2
	],
	[
		1415,
		1,
		""
	],
	[
		1416,
		2
	],
	[
		1417,
		2
	],
	[
		1418,
		2
	],
	[
		[
			1419,
			1420
		],
		3
	],
	[
		[
			1421,
			1422
		],
		2
	],
	[
		1423,
		2
	],
	[
		1424,
		3
	],
	[
		[
			1425,
			1441
		],
		2
	],
	[
		1442,
		2
	],
	[
		[
			1443,
			1455
		],
		2
	],
	[
		[
			1456,
			1465
		],
		2
	],
	[
		1466,
		2
	],
	[
		[
			1467,
			1469
		],
		2
	],
	[
		1470,
		2
	],
	[
		1471,
		2
	],
	[
		1472,
		2
	],
	[
		[
			1473,
			1474
		],
		2
	],
	[
		1475,
		2
	],
	[
		1476,
		2
	],
	[
		1477,
		2
	],
	[
		1478,
		2
	],
	[
		1479,
		2
	],
	[
		[
			1480,
			1487
		],
		3
	],
	[
		[
			1488,
			1514
		],
		2
	],
	[
		[
			1515,
			1518
		],
		3
	],
	[
		1519,
		2
	],
	[
		[
			1520,
			1524
		],
		2
	],
	[
		[
			1525,
			1535
		],
		3
	],
	[
		[
			1536,
			1539
		],
		3
	],
	[
		1540,
		3
	],
	[
		1541,
		3
	],
	[
		[
			1542,
			1546
		],
		2
	],
	[
		1547,
		2
	],
	[
		1548,
		2
	],
	[
		[
			1549,
			1551
		],
		2
	],
	[
		[
			1552,
			1557
		],
		2
	],
	[
		[
			1558,
			1562
		],
		2
	],
	[
		1563,
		2
	],
	[
		1564,
		3
	],
	[
		1565,
		2
	],
	[
		1566,
		2
	],
	[
		1567,
		2
	],
	[
		1568,
		2
	],
	[
		[
			1569,
			1594
		],
		2
	],
	[
		[
			1595,
			1599
		],
		2
	],
	[
		1600,
		2
	],
	[
		[
			1601,
			1618
		],
		2
	],
	[
		[
			1619,
			1621
		],
		2
	],
	[
		[
			1622,
			1624
		],
		2
	],
	[
		[
			1625,
			1630
		],
		2
	],
	[
		1631,
		2
	],
	[
		[
			1632,
			1641
		],
		2
	],
	[
		[
			1642,
			1645
		],
		2
	],
	[
		[
			1646,
			1647
		],
		2
	],
	[
		[
			1648,
			1652
		],
		2
	],
	[
		1653,
		1,
		""
	],
	[
		1654,
		1,
		""
	],
	[
		1655,
		1,
		""
	],
	[
		1656,
		1,
		""
	],
	[
		[
			1657,
			1719
		],
		2
	],
	[
		[
			1720,
			1721
		],
		2
	],
	[
		[
			1722,
			1726
		],
		2
	],
	[
		1727,
		2
	],
	[
		[
			1728,
			1742
		],
		2
	],
	[
		1743,
		2
	],
	[
		[
			1744,
			1747
		],
		2
	],
	[
		1748,
		2
	],
	[
		[
			1749,
			1756
		],
		2
	],
	[
		1757,
		3
	],
	[
		1758,
		2
	],
	[
		[
			1759,
			1768
		],
		2
	],
	[
		1769,
		2
	],
	[
		[
			1770,
			1773
		],
		2
	],
	[
		[
			1774,
			1775
		],
		2
	],
	[
		[
			1776,
			1785
		],
		2
	],
	[
		[
			1786,
			1790
		],
		2
	],
	[
		1791,
		2
	],
	[
		[
			1792,
			1805
		],
		2
	],
	[
		1806,
		3
	],
	[
		1807,
		3
	],
	[
		[
			1808,
			1836
		],
		2
	],
	[
		[
			1837,
			1839
		],
		2
	],
	[
		[
			1840,
			1866
		],
		2
	],
	[
		[
			1867,
			1868
		],
		3
	],
	[
		[
			1869,
			1871
		],
		2
	],
	[
		[
			1872,
			1901
		],
		2
	],
	[
		[
			1902,
			1919
		],
		2
	],
	[
		[
			1920,
			1968
		],
		2
	],
	[
		1969,
		2
	],
	[
		[
			1970,
			1983
		],
		3
	],
	[
		[
			1984,
			2037
		],
		2
	],
	[
		[
			2038,
			2042
		],
		2
	],
	[
		[
			2043,
			2044
		],
		3
	],
	[
		2045,
		2
	],
	[
		[
			2046,
			2047
		],
		2
	],
	[
		[
			2048,
			2093
		],
		2
	],
	[
		[
			2094,
			2095
		],
		3
	],
	[
		[
			2096,
			2110
		],
		2
	],
	[
		2111,
		3
	],
	[
		[
			2112,
			2139
		],
		2
	],
	[
		[
			2140,
			2141
		],
		3
	],
	[
		2142,
		2
	],
	[
		2143,
		3
	],
	[
		[
			2144,
			2154
		],
		2
	],
	[
		[
			2155,
			2159
		],
		3
	],
	[
		[
			2160,
			2183
		],
		2
	],
	[
		2184,
		2
	],
	[
		[
			2185,
			2190
		],
		2
	],
	[
		2191,
		3
	],
	[
		[
			2192,
			2193
		],
		3
	],
	[
		[
			2194,
			2199
		],
		3
	],
	[
		[
			2200,
			2207
		],
		2
	],
	[
		2208,
		2
	],
	[
		2209,
		2
	],
	[
		[
			2210,
			2220
		],
		2
	],
	[
		[
			2221,
			2226
		],
		2
	],
	[
		[
			2227,
			2228
		],
		2
	],
	[
		2229,
		2
	],
	[
		[
			2230,
			2237
		],
		2
	],
	[
		[
			2238,
			2247
		],
		2
	],
	[
		[
			2248,
			2258
		],
		2
	],
	[
		2259,
		2
	],
	[
		[
			2260,
			2273
		],
		2
	],
	[
		2274,
		3
	],
	[
		2275,
		2
	],
	[
		[
			2276,
			2302
		],
		2
	],
	[
		2303,
		2
	],
	[
		2304,
		2
	],
	[
		[
			2305,
			2307
		],
		2
	],
	[
		2308,
		2
	],
	[
		[
			2309,
			2361
		],
		2
	],
	[
		[
			2362,
			2363
		],
		2
	],
	[
		[
			2364,
			2381
		],
		2
	],
	[
		2382,
		2
	],
	[
		2383,
		2
	],
	[
		[
			2384,
			2388
		],
		2
	],
	[
		2389,
		2
	],
	[
		[
			2390,
			2391
		],
		2
	],
	[
		2392,
		1,
		""
	],
	[
		2393,
		1,
		""
	],
	[
		2394,
		1,
		""
	],
	[
		2395,
		1,
		""
	],
	[
		2396,
		1,
		""
	],
	[
		2397,
		1,
		""
	],
	[
		2398,
		1,
		""
	],
	[
		2399,
		1,
		""
	],
	[
		[
			2400,
			2403
		],
		2
	],
	[
		[
			2404,
			2405
		],
		2
	],
	[
		[
			2406,
			2415
		],
		2
	],
	[
		2416,
		2
	],
	[
		[
			2417,
			2418
		],
		2
	],
	[
		[
			2419,
			2423
		],
		2
	],
	[
		2424,
		2
	],
	[
		[
			2425,
			2426
		],
		2
	],
	[
		[
			2427,
			2428
		],
		2
	],
	[
		2429,
		2
	],
	[
		[
			2430,
			2431
		],
		2
	],
	[
		2432,
		2
	],
	[
		[
			2433,
			2435
		],
		2
	],
	[
		2436,
		3
	],
	[
		[
			2437,
			2444
		],
		2
	],
	[
		[
			2445,
			2446
		],
		3
	],
	[
		[
			2447,
			2448
		],
		2
	],
	[
		[
			2449,
			2450
		],
		3
	],
	[
		[
			2451,
			2472
		],
		2
	],
	[
		2473,
		3
	],
	[
		[
			2474,
			2480
		],
		2
	],
	[
		2481,
		3
	],
	[
		2482,
		2
	],
	[
		[
			2483,
			2485
		],
		3
	],
	[
		[
			2486,
			2489
		],
		2
	],
	[
		[
			2490,
			2491
		],
		3
	],
	[
		2492,
		2
	],
	[
		2493,
		2
	],
	[
		[
			2494,
			2500
		],
		2
	],
	[
		[
			2501,
			2502
		],
		3
	],
	[
		[
			2503,
			2504
		],
		2
	],
	[
		[
			2505,
			2506
		],
		3
	],
	[
		[
			2507,
			2509
		],
		2
	],
	[
		2510,
		2
	],
	[
		[
			2511,
			2518
		],
		3
	],
	[
		2519,
		2
	],
	[
		[
			2520,
			2523
		],
		3
	],
	[
		2524,
		1,
		""
	],
	[
		2525,
		1,
		""
	],
	[
		2526,
		3
	],
	[
		2527,
		1,
		""
	],
	[
		[
			2528,
			2531
		],
		2
	],
	[
		[
			2532,
			2533
		],
		3
	],
	[
		[
			2534,
			2545
		],
		2
	],
	[
		[
			2546,
			2554
		],
		2
	],
	[
		2555,
		2
	],
	[
		2556,
		2
	],
	[
		2557,
		2
	],
	[
		2558,
		2
	],
	[
		[
			2559,
			2560
		],
		3
	],
	[
		2561,
		2
	],
	[
		2562,
		2
	],
	[
		2563,
		2
	],
	[
		2564,
		3
	],
	[
		[
			2565,
			2570
		],
		2
	],
	[
		[
			2571,
			2574
		],
		3
	],
	[
		[
			2575,
			2576
		],
		2
	],
	[
		[
			2577,
			2578
		],
		3
	],
	[
		[
			2579,
			2600
		],
		2
	],
	[
		2601,
		3
	],
	[
		[
			2602,
			2608
		],
		2
	],
	[
		2609,
		3
	],
	[
		2610,
		2
	],
	[
		2611,
		1,
		""
	],
	[
		2612,
		3
	],
	[
		2613,
		2
	],
	[
		2614,
		1,
		""
	],
	[
		2615,
		3
	],
	[
		[
			2616,
			2617
		],
		2
	],
	[
		[
			2618,
			2619
		],
		3
	],
	[
		2620,
		2
	],
	[
		2621,
		3
	],
	[
		[
			2622,
			2626
		],
		2
	],
	[
		[
			2627,
			2630
		],
		3
	],
	[
		[
			2631,
			2632
		],
		2
	],
	[
		[
			2633,
			2634
		],
		3
	],
	[
		[
			2635,
			2637
		],
		2
	],
	[
		[
			2638,
			2640
		],
		3
	],
	[
		2641,
		2
	],
	[
		[
			2642,
			2648
		],
		3
	],
	[
		2649,
		1,
		""
	],
	[
		2650,
		1,
		""
	],
	[
		2651,
		1,
		""
	],
	[
		2652,
		2
	],
	[
		2653,
		3
	],
	[
		2654,
		1,
		""
	],
	[
		[
			2655,
			2661
		],
		3
	],
	[
		[
			2662,
			2676
		],
		2
	],
	[
		2677,
		2
	],
	[
		2678,
		2
	],
	[
		[
			2679,
			2688
		],
		3
	],
	[
		[
			2689,
			2691
		],
		2
	],
	[
		2692,
		3
	],
	[
		[
			2693,
			2699
		],
		2
	],
	[
		2700,
		2
	],
	[
		2701,
		2
	],
	[
		2702,
		3
	],
	[
		[
			2703,
			2705
		],
		2
	],
	[
		2706,
		3
	],
	[
		[
			2707,
			2728
		],
		2
	],
	[
		2729,
		3
	],
	[
		[
			2730,
			2736
		],
		2
	],
	[
		2737,
		3
	],
	[
		[
			2738,
			2739
		],
		2
	],
	[
		2740,
		3
	],
	[
		[
			2741,
			2745
		],
		2
	],
	[
		[
			2746,
			2747
		],
		3
	],
	[
		[
			2748,
			2757
		],
		2
	],
	[
		2758,
		3
	],
	[
		[
			2759,
			2761
		],
		2
	],
	[
		2762,
		3
	],
	[
		[
			2763,
			2765
		],
		2
	],
	[
		[
			2766,
			2767
		],
		3
	],
	[
		2768,
		2
	],
	[
		[
			2769,
			2783
		],
		3
	],
	[
		2784,
		2
	],
	[
		[
			2785,
			2787
		],
		2
	],
	[
		[
			2788,
			2789
		],
		3
	],
	[
		[
			2790,
			2799
		],
		2
	],
	[
		2800,
		2
	],
	[
		2801,
		2
	],
	[
		[
			2802,
			2808
		],
		3
	],
	[
		2809,
		2
	],
	[
		[
			2810,
			2815
		],
		2
	],
	[
		2816,
		3
	],
	[
		[
			2817,
			2819
		],
		2
	],
	[
		2820,
		3
	],
	[
		[
			2821,
			2828
		],
		2
	],
	[
		[
			2829,
			2830
		],
		3
	],
	[
		[
			2831,
			2832
		],
		2
	],
	[
		[
			2833,
			2834
		],
		3
	],
	[
		[
			2835,
			2856
		],
		2
	],
	[
		2857,
		3
	],
	[
		[
			2858,
			2864
		],
		2
	],
	[
		2865,
		3
	],
	[
		[
			2866,
			2867
		],
		2
	],
	[
		2868,
		3
	],
	[
		2869,
		2
	],
	[
		[
			2870,
			2873
		],
		2
	],
	[
		[
			2874,
			2875
		],
		3
	],
	[
		[
			2876,
			2883
		],
		2
	],
	[
		2884,
		2
	],
	[
		[
			2885,
			2886
		],
		3
	],
	[
		[
			2887,
			2888
		],
		2
	],
	[
		[
			2889,
			2890
		],
		3
	],
	[
		[
			2891,
			2893
		],
		2
	],
	[
		[
			2894,
			2900
		],
		3
	],
	[
		2901,
		2
	],
	[
		[
			2902,
			2903
		],
		2
	],
	[
		[
			2904,
			2907
		],
		3
	],
	[
		2908,
		1,
		""
	],
	[
		2909,
		1,
		""
	],
	[
		2910,
		3
	],
	[
		[
			2911,
			2913
		],
		2
	],
	[
		[
			2914,
			2915
		],
		2
	],
	[
		[
			2916,
			2917
		],
		3
	],
	[
		[
			2918,
			2927
		],
		2
	],
	[
		2928,
		2
	],
	[
		2929,
		2
	],
	[
		[
			2930,
			2935
		],
		2
	],
	[
		[
			2936,
			2945
		],
		3
	],
	[
		[
			2946,
			2947
		],
		2
	],
	[
		2948,
		3
	],
	[
		[
			2949,
			2954
		],
		2
	],
	[
		[
			2955,
			2957
		],
		3
	],
	[
		[
			2958,
			2960
		],
		2
	],
	[
		2961,
		3
	],
	[
		[
			2962,
			2965
		],
		2
	],
	[
		[
			2966,
			2968
		],
		3
	],
	[
		[
			2969,
			2970
		],
		2
	],
	[
		2971,
		3
	],
	[
		2972,
		2
	],
	[
		2973,
		3
	],
	[
		[
			2974,
			2975
		],
		2
	],
	[
		[
			2976,
			2978
		],
		3
	],
	[
		[
			2979,
			2980
		],
		2
	],
	[
		[
			2981,
			2983
		],
		3
	],
	[
		[
			2984,
			2986
		],
		2
	],
	[
		[
			2987,
			2989
		],
		3
	],
	[
		[
			2990,
			2997
		],
		2
	],
	[
		2998,
		2
	],
	[
		[
			2999,
			3001
		],
		2
	],
	[
		[
			3002,
			3005
		],
		3
	],
	[
		[
			3006,
			3010
		],
		2
	],
	[
		[
			3011,
			3013
		],
		3
	],
	[
		[
			3014,
			3016
		],
		2
	],
	[
		3017,
		3
	],
	[
		[
			3018,
			3021
		],
		2
	],
	[
		[
			3022,
			3023
		],
		3
	],
	[
		3024,
		2
	],
	[
		[
			3025,
			3030
		],
		3
	],
	[
		3031,
		2
	],
	[
		[
			3032,
			3045
		],
		3
	],
	[
		3046,
		2
	],
	[
		[
			3047,
			3055
		],
		2
	],
	[
		[
			3056,
			3058
		],
		2
	],
	[
		[
			3059,
			3066
		],
		2
	],
	[
		[
			3067,
			3071
		],
		3
	],
	[
		3072,
		2
	],
	[
		[
			3073,
			3075
		],
		2
	],
	[
		3076,
		2
	],
	[
		[
			3077,
			3084
		],
		2
	],
	[
		3085,
		3
	],
	[
		[
			3086,
			3088
		],
		2
	],
	[
		3089,
		3
	],
	[
		[
			3090,
			3112
		],
		2
	],
	[
		3113,
		3
	],
	[
		[
			3114,
			3123
		],
		2
	],
	[
		3124,
		2
	],
	[
		[
			3125,
			3129
		],
		2
	],
	[
		[
			3130,
			3131
		],
		3
	],
	[
		3132,
		2
	],
	[
		3133,
		2
	],
	[
		[
			3134,
			3140
		],
		2
	],
	[
		3141,
		3
	],
	[
		[
			3142,
			3144
		],
		2
	],
	[
		3145,
		3
	],
	[
		[
			3146,
			3149
		],
		2
	],
	[
		[
			3150,
			3156
		],
		3
	],
	[
		[
			3157,
			3158
		],
		2
	],
	[
		3159,
		3
	],
	[
		[
			3160,
			3161
		],
		2
	],
	[
		3162,
		2
	],
	[
		[
			3163,
			3164
		],
		3
	],
	[
		3165,
		2
	],
	[
		[
			3166,
			3167
		],
		3
	],
	[
		[
			3168,
			3169
		],
		2
	],
	[
		[
			3170,
			3171
		],
		2
	],
	[
		[
			3172,
			3173
		],
		3
	],
	[
		[
			3174,
			3183
		],
		2
	],
	[
		[
			3184,
			3190
		],
		3
	],
	[
		3191,
		2
	],
	[
		[
			3192,
			3199
		],
		2
	],
	[
		3200,
		2
	],
	[
		3201,
		2
	],
	[
		[
			3202,
			3203
		],
		2
	],
	[
		3204,
		2
	],
	[
		[
			3205,
			3212
		],
		2
	],
	[
		3213,
		3
	],
	[
		[
			3214,
			3216
		],
		2
	],
	[
		3217,
		3
	],
	[
		[
			3218,
			3240
		],
		2
	],
	[
		3241,
		3
	],
	[
		[
			3242,
			3251
		],
		2
	],
	[
		3252,
		3
	],
	[
		[
			3253,
			3257
		],
		2
	],
	[
		[
			3258,
			3259
		],
		3
	],
	[
		[
			3260,
			3261
		],
		2
	],
	[
		[
			3262,
			3268
		],
		2
	],
	[
		3269,
		3
	],
	[
		[
			3270,
			3272
		],
		2
	],
	[
		3273,
		3
	],
	[
		[
			3274,
			3277
		],
		2
	],
	[
		[
			3278,
			3284
		],
		3
	],
	[
		[
			3285,
			3286
		],
		2
	],
	[
		[
			3287,
			3292
		],
		3
	],
	[
		3293,
		2
	],
	[
		3294,
		2
	],
	[
		3295,
		3
	],
	[
		[
			3296,
			3297
		],
		2
	],
	[
		[
			3298,
			3299
		],
		2
	],
	[
		[
			3300,
			3301
		],
		3
	],
	[
		[
			3302,
			3311
		],
		2
	],
	[
		3312,
		3
	],
	[
		[
			3313,
			3314
		],
		2
	],
	[
		3315,
		2
	],
	[
		[
			3316,
			3327
		],
		3
	],
	[
		3328,
		2
	],
	[
		3329,
		2
	],
	[
		[
			3330,
			3331
		],
		2
	],
	[
		3332,
		2
	],
	[
		[
			3333,
			3340
		],
		2
	],
	[
		3341,
		3
	],
	[
		[
			3342,
			3344
		],
		2
	],
	[
		3345,
		3
	],
	[
		[
			3346,
			3368
		],
		2
	],
	[
		3369,
		2
	],
	[
		[
			3370,
			3385
		],
		2
	],
	[
		3386,
		2
	],
	[
		[
			3387,
			3388
		],
		2
	],
	[
		3389,
		2
	],
	[
		[
			3390,
			3395
		],
		2
	],
	[
		3396,
		2
	],
	[
		3397,
		3
	],
	[
		[
			3398,
			3400
		],
		2
	],
	[
		3401,
		3
	],
	[
		[
			3402,
			3405
		],
		2
	],
	[
		3406,
		2
	],
	[
		3407,
		2
	],
	[
		[
			3408,
			3411
		],
		3
	],
	[
		[
			3412,
			3414
		],
		2
	],
	[
		3415,
		2
	],
	[
		[
			3416,
			3422
		],
		2
	],
	[
		3423,
		2
	],
	[
		[
			3424,
			3425
		],
		2
	],
	[
		[
			3426,
			3427
		],
		2
	],
	[
		[
			3428,
			3429
		],
		3
	],
	[
		[
			3430,
			3439
		],
		2
	],
	[
		[
			3440,
			3445
		],
		2
	],
	[
		[
			3446,
			3448
		],
		2
	],
	[
		3449,
		2
	],
	[
		[
			3450,
			3455
		],
		2
	],
	[
		3456,
		3
	],
	[
		3457,
		2
	],
	[
		[
			3458,
			3459
		],
		2
	],
	[
		3460,
		3
	],
	[
		[
			3461,
			3478
		],
		2
	],
	[
		[
			3479,
			3481
		],
		3
	],
	[
		[
			3482,
			3505
		],
		2
	],
	[
		3506,
		3
	],
	[
		[
			3507,
			3515
		],
		2
	],
	[
		3516,
		3
	],
	[
		3517,
		2
	],
	[
		[
			3518,
			3519
		],
		3
	],
	[
		[
			3520,
			3526
		],
		2
	],
	[
		[
			3527,
			3529
		],
		3
	],
	[
		3530,
		2
	],
	[
		[
			3531,
			3534
		],
		3
	],
	[
		[
			3535,
			3540
		],
		2
	],
	[
		3541,
		3
	],
	[
		3542,
		2
	],
	[
		3543,
		3
	],
	[
		[
			3544,
			3551
		],
		2
	],
	[
		[
			3552,
			3557
		],
		3
	],
	[
		[
			3558,
			3567
		],
		2
	],
	[
		[
			3568,
			3569
		],
		3
	],
	[
		[
			3570,
			3571
		],
		2
	],
	[
		3572,
		2
	],
	[
		[
			3573,
			3584
		],
		3
	],
	[
		[
			3585,
			3634
		],
		2
	],
	[
		3635,
		1,
		""
	],
	[
		[
			3636,
			3642
		],
		2
	],
	[
		[
			3643,
			3646
		],
		3
	],
	[
		3647,
		2
	],
	[
		[
			3648,
			3662
		],
		2
	],
	[
		3663,
		2
	],
	[
		[
			3664,
			3673
		],
		2
	],
	[
		[
			3674,
			3675
		],
		2
	],
	[
		[
			3676,
			3712
		],
		3
	],
	[
		[
			3713,
			3714
		],
		2
	],
	[
		3715,
		3
	],
	[
		3716,
		2
	],
	[
		3717,
		3
	],
	[
		3718,
		2
	],
	[
		[
			3719,
			3720
		],
		2
	],
	[
		3721,
		2
	],
	[
		3722,
		2
	],
	[
		3723,
		3
	],
	[
		3724,
		2
	],
	[
		3725,
		2
	],
	[
		[
			3726,
			3731
		],
		2
	],
	[
		[
			3732,
			3735
		],
		2
	],
	[
		3736,
		2
	],
	[
		[
			3737,
			3743
		],
		2
	],
	[
		3744,
		2
	],
	[
		[
			3745,
			3747
		],
		2
	],
	[
		3748,
		3
	],
	[
		3749,
		2
	],
	[
		3750,
		3
	],
	[
		3751,
		2
	],
	[
		[
			3752,
			3753
		],
		2
	],
	[
		[
			3754,
			3755
		],
		2
	],
	[
		3756,
		2
	],
	[
		[
			3757,
			3762
		],
		2
	],
	[
		3763,
		1,
		""
	],
	[
		[
			3764,
			3769
		],
		2
	],
	[
		3770,
		2
	],
	[
		[
			3771,
			3773
		],
		2
	],
	[
		[
			3774,
			3775
		],
		3
	],
	[
		[
			3776,
			3780
		],
		2
	],
	[
		3781,
		3
	],
	[
		3782,
		2
	],
	[
		3783,
		3
	],
	[
		[
			3784,
			3789
		],
		2
	],
	[
		3790,
		2
	],
	[
		3791,
		3
	],
	[
		[
			3792,
			3801
		],
		2
	],
	[
		[
			3802,
			3803
		],
		3
	],
	[
		3804,
		1,
		""
	],
	[
		3805,
		1,
		""
	],
	[
		[
			3806,
			3807
		],
		2
	],
	[
		[
			3808,
			3839
		],
		3
	],
	[
		3840,
		2
	],
	[
		[
			3841,
			3850
		],
		2
	],
	[
		3851,
		2
	],
	[
		3852,
		1,
		""
	],
	[
		[
			3853,
			3863
		],
		2
	],
	[
		[
			3864,
			3865
		],
		2
	],
	[
		[
			3866,
			3871
		],
		2
	],
	[
		[
			3872,
			3881
		],
		2
	],
	[
		[
			3882,
			3892
		],
		2
	],
	[
		3893,
		2
	],
	[
		3894,
		2
	],
	[
		3895,
		2
	],
	[
		3896,
		2
	],
	[
		3897,
		2
	],
	[
		[
			3898,
			3901
		],
		2
	],
	[
		[
			3902,
			3906
		],
		2
	],
	[
		3907,
		1,
		""
	],
	[
		[
			3908,
			3911
		],
		2
	],
	[
		3912,
		3
	],
	[
		[
			3913,
			3916
		],
		2
	],
	[
		3917,
		1,
		""
	],
	[
		[
			3918,
			3921
		],
		2
	],
	[
		3922,
		1,
		""
	],
	[
		[
			3923,
			3926
		],
		2
	],
	[
		3927,
		1,
		""
	],
	[
		[
			3928,
			3931
		],
		2
	],
	[
		3932,
		1,
		""
	],
	[
		[
			3933,
			3944
		],
		2
	],
	[
		3945,
		1,
		""
	],
	[
		3946,
		2
	],
	[
		[
			3947,
			3948
		],
		2
	],
	[
		[
			3949,
			3952
		],
		3
	],
	[
		[
			3953,
			3954
		],
		2
	],
	[
		3955,
		1,
		""
	],
	[
		3956,
		2
	],
	[
		3957,
		1,
		""
	],
	[
		3958,
		1,
		""
	],
	[
		3959,
		1,
		""
	],
	[
		3960,
		1,
		""
	],
	[
		3961,
		1,
		""
	],
	[
		[
			3962,
			3968
		],
		2
	],
	[
		3969,
		1,
		""
	],
	[
		[
			3970,
			3972
		],
		2
	],
	[
		3973,
		2
	],
	[
		[
			3974,
			3979
		],
		2
	],
	[
		[
			3980,
			3983
		],
		2
	],
	[
		[
			3984,
			3986
		],
		2
	],
	[
		3987,
		1,
		""
	],
	[
		[
			3988,
			3989
		],
		2
	],
	[
		3990,
		2
	],
	[
		3991,
		2
	],
	[
		3992,
		3
	],
	[
		[
			3993,
			3996
		],
		2
	],
	[
		3997,
		1,
		""
	],
	[
		[
			3998,
			4001
		],
		2
	],
	[
		4002,
		1,
		""
	],
	[
		[
			4003,
			4006
		],
		2
	],
	[
		4007,
		1,
		""
	],
	[
		[
			4008,
			4011
		],
		2
	],
	[
		4012,
		1,
		""
	],
	[
		4013,
		2
	],
	[
		[
			4014,
			4016
		],
		2
	],
	[
		[
			4017,
			4023
		],
		2
	],
	[
		4024,
		2
	],
	[
		4025,
		1,
		""
	],
	[
		[
			4026,
			4028
		],
		2
	],
	[
		4029,
		3
	],
	[
		[
			4030,
			4037
		],
		2
	],
	[
		4038,
		2
	],
	[
		[
			4039,
			4044
		],
		2
	],
	[
		4045,
		3
	],
	[
		4046,
		2
	],
	[
		4047,
		2
	],
	[
		[
			4048,
			4049
		],
		2
	],
	[
		[
			4050,
			4052
		],
		2
	],
	[
		[
			4053,
			4056
		],
		2
	],
	[
		[
			4057,
			4058
		],
		2
	],
	[
		[
			4059,
			4095
		],
		3
	],
	[
		[
			4096,
			4129
		],
		2
	],
	[
		4130,
		2
	],
	[
		[
			4131,
			4135
		],
		2
	],
	[
		4136,
		2
	],
	[
		[
			4137,
			4138
		],
		2
	],
	[
		4139,
		2
	],
	[
		[
			4140,
			4146
		],
		2
	],
	[
		[
			4147,
			4149
		],
		2
	],
	[
		[
			4150,
			4153
		],
		2
	],
	[
		[
			4154,
			4159
		],
		2
	],
	[
		[
			4160,
			4169
		],
		2
	],
	[
		[
			4170,
			4175
		],
		2
	],
	[
		[
			4176,
			4185
		],
		2
	],
	[
		[
			4186,
			4249
		],
		2
	],
	[
		[
			4250,
			4253
		],
		2
	],
	[
		[
			4254,
			4255
		],
		2
	],
	[
		[
			4256,
			4293
		],
		3
	],
	[
		4294,
		3
	],
	[
		4295,
		1,
		""
	],
	[
		[
			4296,
			4300
		],
		3
	],
	[
		4301,
		1,
		""
	],
	[
		[
			4302,
			4303
		],
		3
	],
	[
		[
			4304,
			4342
		],
		2
	],
	[
		[
			4343,
			4344
		],
		2
	],
	[
		[
			4345,
			4346
		],
		2
	],
	[
		4347,
		2
	],
	[
		4348,
		1,
		""
	],
	[
		[
			4349,
			4351
		],
		2
	],
	[
		[
			4352,
			4441
		],
		2
	],
	[
		[
			4442,
			4446
		],
		2
	],
	[
		[
			4447,
			4448
		],
		3
	],
	[
		[
			4449,
			4514
		],
		2
	],
	[
		[
			4515,
			4519
		],
		2
	],
	[
		[
			4520,
			4601
		],
		2
	],
	[
		[
			4602,
			4607
		],
		2
	],
	[
		[
			4608,
			4614
		],
		2
	],
	[
		4615,
		2
	],
	[
		[
			4616,
			4678
		],
		2
	],
	[
		4679,
		2
	],
	[
		4680,
		2
	],
	[
		4681,
		3
	],
	[
		[
			4682,
			4685
		],
		2
	],
	[
		[
			4686,
			4687
		],
		3
	],
	[
		[
			4688,
			4694
		],
		2
	],
	[
		4695,
		3
	],
	[
		4696,
		2
	],
	[
		4697,
		3
	],
	[
		[
			4698,
			4701
		],
		2
	],
	[
		[
			4702,
			4703
		],
		3
	],
	[
		[
			4704,
			4742
		],
		2
	],
	[
		4743,
		2
	],
	[
		4744,
		2
	],
	[
		4745,
		3
	],
	[
		[
			4746,
			4749
		],
		2
	],
	[
		[
			4750,
			4751
		],
		3
	],
	[
		[
			4752,
			4782
		],
		2
	],
	[
		4783,
		2
	],
	[
		4784,
		2
	],
	[
		4785,
		3
	],
	[
		[
			4786,
			4789
		],
		2
	],
	[
		[
			4790,
			4791
		],
		3
	],
	[
		[
			4792,
			4798
		],
		2
	],
	[
		4799,
		3
	],
	[
		4800,
		2
	],
	[
		4801,
		3
	],
	[
		[
			4802,
			4805
		],
		2
	],
	[
		[
			4806,
			4807
		],
		3
	],
	[
		[
			4808,
			4814
		],
		2
	],
	[
		4815,
		2
	],
	[
		[
			4816,
			4822
		],
		2
	],
	[
		4823,
		3
	],
	[
		[
			4824,
			4846
		],
		2
	],
	[
		4847,
		2
	],
	[
		[
			4848,
			4878
		],
		2
	],
	[
		4879,
		2
	],
	[
		4880,
		2
	],
	[
		4881,
		3
	],
	[
		[
			4882,
			4885
		],
		2
	],
	[
		[
			4886,
			4887
		],
		3
	],
	[
		[
			4888,
			4894
		],
		2
	],
	[
		4895,
		2
	],
	[
		[
			4896,
			4934
		],
		2
	],
	[
		4935,
		2
	],
	[
		[
			4936,
			4954
		],
		2
	],
	[
		[
			4955,
			4956
		],
		3
	],
	[
		[
			4957,
			4958
		],
		2
	],
	[
		4959,
		2
	],
	[
		4960,
		2
	],
	[
		[
			4961,
			4988
		],
		2
	],
	[
		[
			4989,
			4991
		],
		3
	],
	[
		[
			4992,
			5007
		],
		2
	],
	[
		[
			5008,
			5017
		],
		2
	],
	[
		[
			5018,
			5023
		],
		3
	],
	[
		[
			5024,
			5108
		],
		2
	],
	[
		5109,
		2
	],
	[
		[
			5110,
			5111
		],
		3
	],
	[
		5112,
		1,
		""
	],
	[
		5113,
		1,
		""
	],
	[
		5114,
		1,
		""
	],
	[
		5115,
		1,
		""
	],
	[
		5116,
		1,
		""
	],
	[
		5117,
		1,
		""
	],
	[
		[
			5118,
			5119
		],
		3
	],
	[
		5120,
		2
	],
	[
		[
			5121,
			5740
		],
		2
	],
	[
		[
			5741,
			5742
		],
		2
	],
	[
		[
			5743,
			5750
		],
		2
	],
	[
		[
			5751,
			5759
		],
		2
	],
	[
		5760,
		3
	],
	[
		[
			5761,
			5786
		],
		2
	],
	[
		[
			5787,
			5788
		],
		2
	],
	[
		[
			5789,
			5791
		],
		3
	],
	[
		[
			5792,
			5866
		],
		2
	],
	[
		[
			5867,
			5872
		],
		2
	],
	[
		[
			5873,
			5880
		],
		2
	],
	[
		[
			5881,
			5887
		],
		3
	],
	[
		[
			5888,
			5900
		],
		2
	],
	[
		5901,
		2
	],
	[
		[
			5902,
			5908
		],
		2
	],
	[
		5909,
		2
	],
	[
		[
			5910,
			5918
		],
		3
	],
	[
		5919,
		2
	],
	[
		[
			5920,
			5940
		],
		2
	],
	[
		[
			5941,
			5942
		],
		2
	],
	[
		[
			5943,
			5951
		],
		3
	],
	[
		[
			5952,
			5971
		],
		2
	],
	[
		[
			5972,
			5983
		],
		3
	],
	[
		[
			5984,
			5996
		],
		2
	],
	[
		5997,
		3
	],
	[
		[
			5998,
			6000
		],
		2
	],
	[
		6001,
		3
	],
	[
		[
			6002,
			6003
		],
		2
	],
	[
		[
			6004,
			6015
		],
		3
	],
	[
		[
			6016,
			6067
		],
		2
	],
	[
		[
			6068,
			6069
		],
		3
	],
	[
		[
			6070,
			6099
		],
		2
	],
	[
		[
			6100,
			6102
		],
		2
	],
	[
		6103,
		2
	],
	[
		[
			6104,
			6107
		],
		2
	],
	[
		6108,
		2
	],
	[
		6109,
		2
	],
	[
		[
			6110,
			6111
		],
		3
	],
	[
		[
			6112,
			6121
		],
		2
	],
	[
		[
			6122,
			6127
		],
		3
	],
	[
		[
			6128,
			6137
		],
		2
	],
	[
		[
			6138,
			6143
		],
		3
	],
	[
		[
			6144,
			6149
		],
		2
	],
	[
		6150,
		3
	],
	[
		[
			6151,
			6154
		],
		2
	],
	[
		[
			6155,
			6157
		],
		7
	],
	[
		6158,
		3
	],
	[
		6159,
		7
	],
	[
		[
			6160,
			6169
		],
		2
	],
	[
		[
			6170,
			6175
		],
		3
	],
	[
		[
			6176,
			6263
		],
		2
	],
	[
		6264,
		2
	],
	[
		[
			6265,
			6271
		],
		3
	],
	[
		[
			6272,
			6313
		],
		2
	],
	[
		6314,
		2
	],
	[
		[
			6315,
			6319
		],
		3
	],
	[
		[
			6320,
			6389
		],
		2
	],
	[
		[
			6390,
			6399
		],
		3
	],
	[
		[
			6400,
			6428
		],
		2
	],
	[
		[
			6429,
			6430
		],
		2
	],
	[
		6431,
		3
	],
	[
		[
			6432,
			6443
		],
		2
	],
	[
		[
			6444,
			6447
		],
		3
	],
	[
		[
			6448,
			6459
		],
		2
	],
	[
		[
			6460,
			6463
		],
		3
	],
	[
		6464,
		2
	],
	[
		[
			6465,
			6467
		],
		3
	],
	[
		[
			6468,
			6469
		],
		2
	],
	[
		[
			6470,
			6509
		],
		2
	],
	[
		[
			6510,
			6511
		],
		3
	],
	[
		[
			6512,
			6516
		],
		2
	],
	[
		[
			6517,
			6527
		],
		3
	],
	[
		[
			6528,
			6569
		],
		2
	],
	[
		[
			6570,
			6571
		],
		2
	],
	[
		[
			6572,
			6575
		],
		3
	],
	[
		[
			6576,
			6601
		],
		2
	],
	[
		[
			6602,
			6607
		],
		3
	],
	[
		[
			6608,
			6617
		],
		2
	],
	[
		6618,
		2
	],
	[
		[
			6619,
			6621
		],
		3
	],
	[
		[
			6622,
			6623
		],
		2
	],
	[
		[
			6624,
			6655
		],
		2
	],
	[
		[
			6656,
			6683
		],
		2
	],
	[
		[
			6684,
			6685
		],
		3
	],
	[
		[
			6686,
			6687
		],
		2
	],
	[
		[
			6688,
			6750
		],
		2
	],
	[
		6751,
		3
	],
	[
		[
			6752,
			6780
		],
		2
	],
	[
		[
			6781,
			6782
		],
		3
	],
	[
		[
			6783,
			6793
		],
		2
	],
	[
		[
			6794,
			6799
		],
		3
	],
	[
		[
			6800,
			6809
		],
		2
	],
	[
		[
			6810,
			6815
		],
		3
	],
	[
		[
			6816,
			6822
		],
		2
	],
	[
		6823,
		2
	],
	[
		[
			6824,
			6829
		],
		2
	],
	[
		[
			6830,
			6831
		],
		3
	],
	[
		[
			6832,
			6845
		],
		2
	],
	[
		6846,
		2
	],
	[
		[
			6847,
			6848
		],
		2
	],
	[
		[
			6849,
			6862
		],
		2
	],
	[
		[
			6863,
			6911
		],
		3
	],
	[
		[
			6912,
			6987
		],
		2
	],
	[
		6988,
		2
	],
	[
		[
			6989,
			6991
		],
		3
	],
	[
		[
			6992,
			7001
		],
		2
	],
	[
		[
			7002,
			7018
		],
		2
	],
	[
		[
			7019,
			7027
		],
		2
	],
	[
		[
			7028,
			7036
		],
		2
	],
	[
		[
			7037,
			7038
		],
		2
	],
	[
		7039,
		3
	],
	[
		[
			7040,
			7082
		],
		2
	],
	[
		[
			7083,
			7085
		],
		2
	],
	[
		[
			7086,
			7097
		],
		2
	],
	[
		[
			7098,
			7103
		],
		2
	],
	[
		[
			7104,
			7155
		],
		2
	],
	[
		[
			7156,
			7163
		],
		3
	],
	[
		[
			7164,
			7167
		],
		2
	],
	[
		[
			7168,
			7223
		],
		2
	],
	[
		[
			7224,
			7226
		],
		3
	],
	[
		[
			7227,
			7231
		],
		2
	],
	[
		[
			7232,
			7241
		],
		2
	],
	[
		[
			7242,
			7244
		],
		3
	],
	[
		[
			7245,
			7293
		],
		2
	],
	[
		[
			7294,
			7295
		],
		2
	],
	[
		7296,
		1,
		""
	],
	[
		7297,
		1,
		""
	],
	[
		7298,
		1,
		""
	],
	[
		7299,
		1,
		""
	],
	[
		[
			7300,
			7301
		],
		1,
		""
	],
	[
		7302,
		1,
		""
	],
	[
		7303,
		1,
		""
	],
	[
		7304,
		1,
		""
	],
	[
		[
			7305,
			7311
		],
		3
	],
	[
		7312,
		1,
		""
	],
	[
		7313,
		1,
		""
	],
	[
		7314,
		1,
		""
	],
	[
		7315,
		1,
		""
	],
	[
		7316,
		1,
		""
	],
	[
		7317,
		1,
		""
	],
	[
		7318,
		1,
		""
	],
	[
		7319,
		1,
		""
	],
	[
		7320,
		1,
		""
	],
	[
		7321,
		1,
		""
	],
	[
		7322,
		1,
		""
	],
	[
		7323,
		1,
		""
	],
	[
		7324,
		1,
		""
	],
	[
		7325,
		1,
		""
	],
	[
		7326,
		1,
		""
	],
	[
		7327,
		1,
		""
	],
	[
		7328,
		1,
		""
	],
	[
		7329,
		1,
		""
	],
	[
		7330,
		1,
		""
	],
	[
		7331,
		1,
		""
	],
	[
		7332,
		1,
		""
	],
	[
		7333,
		1,
		""
	],
	[
		7334,
		1,
		""
	],
	[
		7335,
		1,
		""
	],
	[
		7336,
		1,
		""
	],
	[
		7337,
		1,
		""
	],
	[
		7338,
		1,
		""
	],
	[
		7339,
		1,
		""
	],
	[
		7340,
		1,
		""
	],
	[
		7341,
		1,
		""
	],
	[
		7342,
		1,
		""
	],
	[
		7343,
		1,
		""
	],
	[
		7344,
		1,
		""
	],
	[
		7345,
		1,
		""
	],
	[
		7346,
		1,
		""
	],
	[
		7347,
		1,
		""
	],
	[
		7348,
		1,
		""
	],
	[
		7349,
		1,
		""
	],
	[
		7350,
		1,
		""
	],
	[
		7351,
		1,
		""
	],
	[
		7352,
		1,
		""
	],
	[
		7353,
		1,
		""
	],
	[
		7354,
		1,
		""
	],
	[
		[
			7355,
			7356
		],
		3
	],
	[
		7357,
		1,
		""
	],
	[
		7358,
		1,
		""
	],
	[
		7359,
		1,
		""
	],
	[
		[
			7360,
			7367
		],
		2
	],
	[
		[
			7368,
			7375
		],
		3
	],
	[
		[
			7376,
			7378
		],
		2
	],
	[
		7379,
		2
	],
	[
		[
			7380,
			7410
		],
		2
	],
	[
		[
			7411,
			7414
		],
		2
	],
	[
		7415,
		2
	],
	[
		[
			7416,
			7417
		],
		2
	],
	[
		7418,
		2
	],
	[
		[
			7419,
			7423
		],
		3
	],
	[
		[
			7424,
			7467
		],
		2
	],
	[
		7468,
		1,
		"a"
	],
	[
		7469,
		1,
		""
	],
	[
		7470,
		1,
		"b"
	],
	[
		7471,
		2
	],
	[
		7472,
		1,
		"d"
	],
	[
		7473,
		1,
		"e"
	],
	[
		7474,
		1,
		""
	],
	[
		7475,
		1,
		"g"
	],
	[
		7476,
		1,
		"h"
	],
	[
		7477,
		1,
		"i"
	],
	[
		7478,
		1,
		"j"
	],
	[
		7479,
		1,
		"k"
	],
	[
		7480,
		1,
		"l"
	],
	[
		7481,
		1,
		"m"
	],
	[
		7482,
		1,
		"n"
	],
	[
		7483,
		2
	],
	[
		7484,
		1,
		"o"
	],
	[
		7485,
		1,
		""
	],
	[
		7486,
		1,
		"p"
	],
	[
		7487,
		1,
		"r"
	],
	[
		7488,
		1,
		"t"
	],
	[
		7489,
		1,
		"u"
	],
	[
		7490,
		1,
		"w"
	],
	[
		7491,
		1,
		"a"
	],
	[
		7492,
		1,
		""
	],
	[
		7493,
		1,
		""
	],
	[
		7494,
		1,
		""
	],
	[
		7495,
		1,
		"b"
	],
	[
		7496,
		1,
		"d"
	],
	[
		7497,
		1,
		"e"
	],
	[
		7498,
		1,
		""
	],
	[
		7499,
		1,
		""
	],
	[
		7500,
		1,
		""
	],
	[
		7501,
		1,
		"g"
	],
	[
		7502,
		2
	],
	[
		7503,
		1,
		"k"
	],
	[
		7504,
		1,
		"m"
	],
	[
		7505,
		1,
		""
	],
	[
		7506,
		1,
		"o"
	],
	[
		7507,
		1,
		""
	],
	[
		7508,
		1,
		""
	],
	[
		7509,
		1,
		""
	],
	[
		7510,
		1,
		"p"
	],
	[
		7511,
		1,
		"t"
	],
	[
		7512,
		1,
		"u"
	],
	[
		7513,
		1,
		""
	],
	[
		7514,
		1,
		""
	],
	[
		7515,
		1,
		"v"
	],
	[
		7516,
		1,
		""
	],
	[
		7517,
		1,
		""
	],
	[
		7518,
		1,
		""
	],
	[
		7519,
		1,
		""
	],
	[
		7520,
		1,
		""
	],
	[
		7521,
		1,
		""
	],
	[
		7522,
		1,
		"i"
	],
	[
		7523,
		1,
		"r"
	],
	[
		7524,
		1,
		"u"
	],
	[
		7525,
		1,
		"v"
	],
	[
		7526,
		1,
		""
	],
	[
		7527,
		1,
		""
	],
	[
		7528,
		1,
		""
	],
	[
		7529,
		1,
		""
	],
	[
		7530,
		1,
		""
	],
	[
		7531,
		2
	],
	[
		[
			7532,
			7543
		],
		2
	],
	[
		7544,
		1,
		""
	],
	[
		[
			7545,
			7578
		],
		2
	],
	[
		7579,
		1,
		""
	],
	[
		7580,
		1,
		"c"
	],
	[
		7581,
		1,
		""
	],
	[
		7582,
		1,
		""
	],
	[
		7583,
		1,
		""
	],
	[
		7584,
		1,
		"f"
	],
	[
		7585,
		1,
		""
	],
	[
		7586,
		1,
		""
	],
	[
		7587,
		1,
		""
	],
	[
		7588,
		1,
		""
	],
	[
		7589,
		1,
		""
	],
	[
		7590,
		1,
		""
	],
	[
		7591,
		1,
		""
	],
	[
		7592,
		1,
		""
	],
	[
		7593,
		1,
		""
	],
	[
		7594,
		1,
		""
	],
	[
		7595,
		1,
		""
	],
	[
		7596,
		1,
		""
	],
	[
		7597,
		1,
		""
	],
	[
		7598,
		1,
		""
	],
	[
		7599,
		1,
		""
	],
	[
		7600,
		1,
		""
	],
	[
		7601,
		1,
		""
	],
	[
		7602,
		1,
		""
	],
	[
		7603,
		1,
		""
	],
	[
		7604,
		1,
		""
	],
	[
		7605,
		1,
		""
	],
	[
		7606,
		1,
		""
	],
	[
		7607,
		1,
		""
	],
	[
		7608,
		1,
		""
	],
	[
		7609,
		1,
		""
	],
	[
		7610,
		1,
		""
	],
	[
		7611,
		1,
		"z"
	],
	[
		7612,
		1,
		""
	],
	[
		7613,
		1,
		""
	],
	[
		7614,
		1,
		""
	],
	[
		7615,
		1,
		""
	],
	[
		[
			7616,
			7619
		],
		2
	],
	[
		[
			7620,
			7626
		],
		2
	],
	[
		[
			7627,
			7654
		],
		2
	],
	[
		[
			7655,
			7669
		],
		2
	],
	[
		[
			7670,
			7673
		],
		2
	],
	[
		7674,
		2
	],
	[
		7675,
		2
	],
	[
		7676,
		2
	],
	[
		7677,
		2
	],
	[
		[
			7678,
			7679
		],
		2
	],
	[
		7680,
		1,
		""
	],
	[
		7681,
		2
	],
	[
		7682,
		1,
		""
	],
	[
		7683,
		2
	],
	[
		7684,
		1,
		""
	],
	[
		7685,
		2
	],
	[
		7686,
		1,
		""
	],
	[
		7687,
		2
	],
	[
		7688,
		1,
		""
	],
	[
		7689,
		2
	],
	[
		7690,
		1,
		""
	],
	[
		7691,
		2
	],
	[
		7692,
		1,
		""
	],
	[
		7693,
		2
	],
	[
		7694,
		1,
		""
	],
	[
		7695,
		2
	],
	[
		7696,
		1,
		""
	],
	[
		7697,
		2
	],
	[
		7698,
		1,
		""
	],
	[
		7699,
		2
	],
	[
		7700,
		1,
		""
	],
	[
		7701,
		2
	],
	[
		7702,
		1,
		""
	],
	[
		7703,
		2
	],
	[
		7704,
		1,
		""
	],
	[
		7705,
		2
	],
	[
		7706,
		1,
		""
	],
	[
		7707,
		2
	],
	[
		7708,
		1,
		""
	],
	[
		7709,
		2
	],
	[
		7710,
		1,
		""
	],
	[
		7711,
		2
	],
	[
		7712,
		1,
		""
	],
	[
		7713,
		2
	],
	[
		7714,
		1,
		""
	],
	[
		7715,
		2
	],
	[
		7716,
		1,
		""
	],
	[
		7717,
		2
	],
	[
		7718,
		1,
		""
	],
	[
		7719,
		2
	],
	[
		7720,
		1,
		""
	],
	[
		7721,
		2
	],
	[
		7722,
		1,
		""
	],
	[
		7723,
		2
	],
	[
		7724,
		1,
		""
	],
	[
		7725,
		2
	],
	[
		7726,
		1,
		""
	],
	[
		7727,
		2
	],
	[
		7728,
		1,
		""
	],
	[
		7729,
		2
	],
	[
		7730,
		1,
		""
	],
	[
		7731,
		2
	],
	[
		7732,
		1,
		""
	],
	[
		7733,
		2
	],
	[
		7734,
		1,
		""
	],
	[
		7735,
		2
	],
	[
		7736,
		1,
		""
	],
	[
		7737,
		2
	],
	[
		7738,
		1,
		""
	],
	[
		7739,
		2
	],
	[
		7740,
		1,
		""
	],
	[
		7741,
		2
	],
	[
		7742,
		1,
		""
	],
	[
		7743,
		2
	],
	[
		7744,
		1,
		""
	],
	[
		7745,
		2
	],
	[
		7746,
		1,
		""
	],
	[
		7747,
		2
	],
	[
		7748,
		1,
		""
	],
	[
		7749,
		2
	],
	[
		7750,
		1,
		""
	],
	[
		7751,
		2
	],
	[
		7752,
		1,
		""
	],
	[
		7753,
		2
	],
	[
		7754,
		1,
		""
	],
	[
		7755,
		2
	],
	[
		7756,
		1,
		""
	],
	[
		7757,
		2
	],
	[
		7758,
		1,
		""
	],
	[
		7759,
		2
	],
	[
		7760,
		1,
		""
	],
	[
		7761,
		2
	],
	[
		7762,
		1,
		""
	],
	[
		7763,
		2
	],
	[
		7764,
		1,
		""
	],
	[
		7765,
		2
	],
	[
		7766,
		1,
		""
	],
	[
		7767,
		2
	],
	[
		7768,
		1,
		""
	],
	[
		7769,
		2
	],
	[
		7770,
		1,
		""
	],
	[
		7771,
		2
	],
	[
		7772,
		1,
		""
	],
	[
		7773,
		2
	],
	[
		7774,
		1,
		""
	],
	[
		7775,
		2
	],
	[
		7776,
		1,
		""
	],
	[
		7777,
		2
	],
	[
		7778,
		1,
		""
	],
	[
		7779,
		2
	],
	[
		7780,
		1,
		""
	],
	[
		7781,
		2
	],
	[
		7782,
		1,
		""
	],
	[
		7783,
		2
	],
	[
		7784,
		1,
		""
	],
	[
		7785,
		2
	],
	[
		7786,
		1,
		""
	],
	[
		7787,
		2
	],
	[
		7788,
		1,
		""
	],
	[
		7789,
		2
	],
	[
		7790,
		1,
		""
	],
	[
		7791,
		2
	],
	[
		7792,
		1,
		""
	],
	[
		7793,
		2
	],
	[
		7794,
		1,
		""
	],
	[
		7795,
		2
	],
	[
		7796,
		1,
		""
	],
	[
		7797,
		2
	],
	[
		7798,
		1,
		""
	],
	[
		7799,
		2
	],
	[
		7800,
		1,
		""
	],
	[
		7801,
		2
	],
	[
		7802,
		1,
		""
	],
	[
		7803,
		2
	],
	[
		7804,
		1,
		""
	],
	[
		7805,
		2
	],
	[
		7806,
		1,
		""
	],
	[
		7807,
		2
	],
	[
		7808,
		1,
		""
	],
	[
		7809,
		2
	],
	[
		7810,
		1,
		""
	],
	[
		7811,
		2
	],
	[
		7812,
		1,
		""
	],
	[
		7813,
		2
	],
	[
		7814,
		1,
		""
	],
	[
		7815,
		2
	],
	[
		7816,
		1,
		""
	],
	[
		7817,
		2
	],
	[
		7818,
		1,
		""
	],
	[
		7819,
		2
	],
	[
		7820,
		1,
		""
	],
	[
		7821,
		2
	],
	[
		7822,
		1,
		""
	],
	[
		7823,
		2
	],
	[
		7824,
		1,
		""
	],
	[
		7825,
		2
	],
	[
		7826,
		1,
		""
	],
	[
		7827,
		2
	],
	[
		7828,
		1,
		""
	],
	[
		[
			7829,
			7833
		],
		2
	],
	[
		7834,
		1,
		"a"
	],
	[
		7835,
		1,
		""
	],
	[
		[
			7836,
			7837
		],
		2
	],
	[
		7838,
		1,
		"ss"
	],
	[
		7839,
		2
	],
	[
		7840,
		1,
		""
	],
	[
		7841,
		2
	],
	[
		7842,
		1,
		""
	],
	[
		7843,
		2
	],
	[
		7844,
		1,
		""
	],
	[
		7845,
		2
	],
	[
		7846,
		1,
		""
	],
	[
		7847,
		2
	],
	[
		7848,
		1,
		""
	],
	[
		7849,
		2
	],
	[
		7850,
		1,
		""
	],
	[
		7851,
		2
	],
	[
		7852,
		1,
		""
	],
	[
		7853,
		2
	],
	[
		7854,
		1,
		""
	],
	[
		7855,
		2
	],
	[
		7856,
		1,
		""
	],
	[
		7857,
		2
	],
	[
		7858,
		1,
		""
	],
	[
		7859,
		2
	],
	[
		7860,
		1,
		""
	],
	[
		7861,
		2
	],
	[
		7862,
		1,
		""
	],
	[
		7863,
		2
	],
	[
		7864,
		1,
		""
	],
	[
		7865,
		2
	],
	[
		7866,
		1,
		""
	],
	[
		7867,
		2
	],
	[
		7868,
		1,
		""
	],
	[
		7869,
		2
	],
	[
		7870,
		1,
		""
	],
	[
		7871,
		2
	],
	[
		7872,
		1,
		""
	],
	[
		7873,
		2
	],
	[
		7874,
		1,
		""
	],
	[
		7875,
		2
	],
	[
		7876,
		1,
		""
	],
	[
		7877,
		2
	],
	[
		7878,
		1,
		""
	],
	[
		7879,
		2
	],
	[
		7880,
		1,
		""
	],
	[
		7881,
		2
	],
	[
		7882,
		1,
		""
	],
	[
		7883,
		2
	],
	[
		7884,
		1,
		""
	],
	[
		7885,
		2
	],
	[
		7886,
		1,
		""
	],
	[
		7887,
		2
	],
	[
		7888,
		1,
		""
	],
	[
		7889,
		2
	],
	[
		7890,
		1,
		""
	],
	[
		7891,
		2
	],
	[
		7892,
		1,
		""
	],
	[
		7893,
		2
	],
	[
		7894,
		1,
		""
	],
	[
		7895,
		2
	],
	[
		7896,
		1,
		""
	],
	[
		7897,
		2
	],
	[
		7898,
		1,
		""
	],
	[
		7899,
		2
	],
	[
		7900,
		1,
		""
	],
	[
		7901,
		2
	],
	[
		7902,
		1,
		""
	],
	[
		7903,
		2
	],
	[
		7904,
		1,
		""
	],
	[
		7905,
		2
	],
	[
		7906,
		1,
		""
	],
	[
		7907,
		2
	],
	[
		7908,
		1,
		""
	],
	[
		7909,
		2
	],
	[
		7910,
		1,
		""
	],
	[
		7911,
		2
	],
	[
		7912,
		1,
		""
	],
	[
		7913,
		2
	],
	[
		7914,
		1,
		""
	],
	[
		7915,
		2
	],
	[
		7916,
		1,
		""
	],
	[
		7917,
		2
	],
	[
		7918,
		1,
		""
	],
	[
		7919,
		2
	],
	[
		7920,
		1,
		""
	],
	[
		7921,
		2
	],
	[
		7922,
		1,
		""
	],
	[
		7923,
		2
	],
	[
		7924,
		1,
		""
	],
	[
		7925,
		2
	],
	[
		7926,
		1,
		""
	],
	[
		7927,
		2
	],
	[
		7928,
		1,
		""
	],
	[
		7929,
		2
	],
	[
		7930,
		1,
		""
	],
	[
		7931,
		2
	],
	[
		7932,
		1,
		""
	],
	[
		7933,
		2
	],
	[
		7934,
		1,
		""
	],
	[
		7935,
		2
	],
	[
		[
			7936,
			7943
		],
		2
	],
	[
		7944,
		1,
		""
	],
	[
		7945,
		1,
		""
	],
	[
		7946,
		1,
		""
	],
	[
		7947,
		1,
		""
	],
	[
		7948,
		1,
		""
	],
	[
		7949,
		1,
		""
	],
	[
		7950,
		1,
		""
	],
	[
		7951,
		1,
		""
	],
	[
		[
			7952,
			7957
		],
		2
	],
	[
		[
			7958,
			7959
		],
		3
	],
	[
		7960,
		1,
		""
	],
	[
		7961,
		1,
		""
	],
	[
		7962,
		1,
		""
	],
	[
		7963,
		1,
		""
	],
	[
		7964,
		1,
		""
	],
	[
		7965,
		1,
		""
	],
	[
		[
			7966,
			7967
		],
		3
	],
	[
		[
			7968,
			7975
		],
		2
	],
	[
		7976,
		1,
		""
	],
	[
		7977,
		1,
		""
	],
	[
		7978,
		1,
		""
	],
	[
		7979,
		1,
		""
	],
	[
		7980,
		1,
		""
	],
	[
		7981,
		1,
		""
	],
	[
		7982,
		1,
		""
	],
	[
		7983,
		1,
		""
	],
	[
		[
			7984,
			7991
		],
		2
	],
	[
		7992,
		1,
		""
	],
	[
		7993,
		1,
		""
	],
	[
		7994,
		1,
		""
	],
	[
		7995,
		1,
		""
	],
	[
		7996,
		1,
		""
	],
	[
		7997,
		1,
		""
	],
	[
		7998,
		1,
		""
	],
	[
		7999,
		1,
		""
	],
	[
		[
			8000,
			8005
		],
		2
	],
	[
		[
			8006,
			8007
		],
		3
	],
	[
		8008,
		1,
		""
	],
	[
		8009,
		1,
		""
	],
	[
		8010,
		1,
		""
	],
	[
		8011,
		1,
		""
	],
	[
		8012,
		1,
		""
	],
	[
		8013,
		1,
		""
	],
	[
		[
			8014,
			8015
		],
		3
	],
	[
		[
			8016,
			8023
		],
		2
	],
	[
		8024,
		3
	],
	[
		8025,
		1,
		""
	],
	[
		8026,
		3
	],
	[
		8027,
		1,
		""
	],
	[
		8028,
		3
	],
	[
		8029,
		1,
		""
	],
	[
		8030,
		3
	],
	[
		8031,
		1,
		""
	],
	[
		[
			8032,
			8039
		],
		2
	],
	[
		8040,
		1,
		""
	],
	[
		8041,
		1,
		""
	],
	[
		8042,
		1,
		""
	],
	[
		8043,
		1,
		""
	],
	[
		8044,
		1,
		""
	],
	[
		8045,
		1,
		""
	],
	[
		8046,
		1,
		""
	],
	[
		8047,
		1,
		""
	],
	[
		8048,
		2
	],
	[
		8049,
		1,
		""
	],
	[
		8050,
		2
	],
	[
		8051,
		1,
		""
	],
	[
		8052,
		2
	],
	[
		8053,
		1,
		""
	],
	[
		8054,
		2
	],
	[
		8055,
		1,
		""
	],
	[
		8056,
		2
	],
	[
		8057,
		1,
		""
	],
	[
		8058,
		2
	],
	[
		8059,
		1,
		""
	],
	[
		8060,
		2
	],
	[
		8061,
		1,
		""
	],
	[
		[
			8062,
			8063
		],
		3
	],
	[
		8064,
		1,
		""
	],
	[
		8065,
		1,
		""
	],
	[
		8066,
		1,
		""
	],
	[
		8067,
		1,
		""
	],
	[
		8068,
		1,
		""
	],
	[
		8069,
		1,
		""
	],
	[
		8070,
		1,
		""
	],
	[
		8071,
		1,
		""
	],
	[
		8072,
		1,
		""
	],
	[
		8073,
		1,
		""
	],
	[
		8074,
		1,
		""
	],
	[
		8075,
		1,
		""
	],
	[
		8076,
		1,
		""
	],
	[
		8077,
		1,
		""
	],
	[
		8078,
		1,
		""
	],
	[
		8079,
		1,
		""
	],
	[
		8080,
		1,
		""
	],
	[
		8081,
		1,
		""
	],
	[
		8082,
		1,
		""
	],
	[
		8083,
		1,
		""
	],
	[
		8084,
		1,
		""
	],
	[
		8085,
		1,
		""
	],
	[
		8086,
		1,
		""
	],
	[
		8087,
		1,
		""
	],
	[
		8088,
		1,
		""
	],
	[
		8089,
		1,
		""
	],
	[
		8090,
		1,
		""
	],
	[
		8091,
		1,
		""
	],
	[
		8092,
		1,
		""
	],
	[
		8093,
		1,
		""
	],
	[
		8094,
		1,
		""
	],
	[
		8095,
		1,
		""
	],
	[
		8096,
		1,
		""
	],
	[
		8097,
		1,
		""
	],
	[
		8098,
		1,
		""
	],
	[
		8099,
		1,
		""
	],
	[
		8100,
		1,
		""
	],
	[
		8101,
		1,
		""
	],
	[
		8102,
		1,
		""
	],
	[
		8103,
		1,
		""
	],
	[
		8104,
		1,
		""
	],
	[
		8105,
		1,
		""
	],
	[
		8106,
		1,
		""
	],
	[
		8107,
		1,
		""
	],
	[
		8108,
		1,
		""
	],
	[
		8109,
		1,
		""
	],
	[
		8110,
		1,
		""
	],
	[
		8111,
		1,
		""
	],
	[
		[
			8112,
			8113
		],
		2
	],
	[
		8114,
		1,
		""
	],
	[
		8115,
		1,
		""
	],
	[
		8116,
		1,
		""
	],
	[
		8117,
		3
	],
	[
		8118,
		2
	],
	[
		8119,
		1,
		""
	],
	[
		8120,
		1,
		""
	],
	[
		8121,
		1,
		""
	],
	[
		8122,
		1,
		""
	],
	[
		8123,
		1,
		""
	],
	[
		8124,
		1,
		""
	],
	[
		8125,
		5,
		" "
	],
	[
		8126,
		1,
		""
	],
	[
		8127,
		5,
		" "
	],
	[
		8128,
		5,
		" "
	],
	[
		8129,
		5,
		" "
	],
	[
		8130,
		1,
		""
	],
	[
		8131,
		1,
		""
	],
	[
		8132,
		1,
		""
	],
	[
		8133,
		3
	],
	[
		8134,
		2
	],
	[
		8135,
		1,
		""
	],
	[
		8136,
		1,
		""
	],
	[
		8137,
		1,
		""
	],
	[
		8138,
		1,
		""
	],
	[
		8139,
		1,
		""
	],
	[
		8140,
		1,
		""
	],
	[
		8141,
		5,
		" "
	],
	[
		8142,
		5,
		" "
	],
	[
		8143,
		5,
		" "
	],
	[
		[
			8144,
			8146
		],
		2
	],
	[
		8147,
		1,
		""
	],
	[
		[
			8148,
			8149
		],
		3
	],
	[
		[
			8150,
			8151
		],
		2
	],
	[
		8152,
		1,
		""
	],
	[
		8153,
		1,
		""
	],
	[
		8154,
		1,
		""
	],
	[
		8155,
		1,
		""
	],
	[
		8156,
		3
	],
	[
		8157,
		5,
		" "
	],
	[
		8158,
		5,
		" "
	],
	[
		8159,
		5,
		" "
	],
	[
		[
			8160,
			8162
		],
		2
	],
	[
		8163,
		1,
		""
	],
	[
		[
			8164,
			8167
		],
		2
	],
	[
		8168,
		1,
		""
	],
	[
		8169,
		1,
		""
	],
	[
		8170,
		1,
		""
	],
	[
		8171,
		1,
		""
	],
	[
		8172,
		1,
		""
	],
	[
		8173,
		5,
		" "
	],
	[
		8174,
		5,
		" "
	],
	[
		8175,
		5,
		"`"
	],
	[
		[
			8176,
			8177
		],
		3
	],
	[
		8178,
		1,
		""
	],
	[
		8179,
		1,
		""
	],
	[
		8180,
		1,
		""
	],
	[
		8181,
		3
	],
	[
		8182,
		2
	],
	[
		8183,
		1,
		""
	],
	[
		8184,
		1,
		""
	],
	[
		8185,
		1,
		""
	],
	[
		8186,
		1,
		""
	],
	[
		8187,
		1,
		""
	],
	[
		8188,
		1,
		""
	],
	[
		8189,
		5,
		" "
	],
	[
		8190,
		5,
		" "
	],
	[
		8191,
		3
	],
	[
		[
			8192,
			8202
		],
		5,
		" "
	],
	[
		8203,
		7
	],
	[
		[
			8204,
			8205
		],
		6,
		""
	],
	[
		[
			8206,
			8207
		],
		3
	],
	[
		8208,
		2
	],
	[
		8209,
		1,
		""
	],
	[
		[
			8210,
			8214
		],
		2
	],
	[
		8215,
		5,
		" "
	],
	[
		[
			8216,
			8227
		],
		2
	],
	[
		[
			8228,
			8230
		],
		3
	],
	[
		8231,
		2
	],
	[
		[
			8232,
			8238
		],
		3
	],
	[
		8239,
		5,
		" "
	],
	[
		[
			8240,
			8242
		],
		2
	],
	[
		8243,
		1,
		""
	],
	[
		8244,
		1,
		""
	],
	[
		8245,
		2
	],
	[
		8246,
		1,
		""
	],
	[
		8247,
		1,
		""
	],
	[
		[
			8248,
			8251
		],
		2
	],
	[
		8252,
		5,
		"!!"
	],
	[
		8253,
		2
	],
	[
		8254,
		5,
		" "
	],
	[
		[
			8255,
			8262
		],
		2
	],
	[
		8263,
		5,
		"??"
	],
	[
		8264,
		5,
		"?!"
	],
	[
		8265,
		5,
		"!?"
	],
	[
		[
			8266,
			8269
		],
		2
	],
	[
		[
			8270,
			8274
		],
		2
	],
	[
		[
			8275,
			8276
		],
		2
	],
	[
		[
			8277,
			8278
		],
		2
	],
	[
		8279,
		1,
		""
	],
	[
		[
			8280,
			8286
		],
		2
	],
	[
		8287,
		5,
		" "
	],
	[
		8288,
		7
	],
	[
		[
			8289,
			8291
		],
		3
	],
	[
		8292,
		7
	],
	[
		8293,
		3
	],
	[
		[
			8294,
			8297
		],
		3
	],
	[
		[
			8298,
			8303
		],
		3
	],
	[
		8304,
		1,
		"0"
	],
	[
		8305,
		1,
		"i"
	],
	[
		[
			8306,
			8307
		],
		3
	],
	[
		8308,
		1,
		"4"
	],
	[
		8309,
		1,
		"5"
	],
	[
		8310,
		1,
		"6"
	],
	[
		8311,
		1,
		"7"
	],
	[
		8312,
		1,
		"8"
	],
	[
		8313,
		1,
		"9"
	],
	[
		8314,
		5,
		"+"
	],
	[
		8315,
		1,
		""
	],
	[
		8316,
		5,
		"="
	],
	[
		8317,
		5,
		"("
	],
	[
		8318,
		5,
		")"
	],
	[
		8319,
		1,
		"n"
	],
	[
		8320,
		1,
		"0"
	],
	[
		8321,
		1,
		"1"
	],
	[
		8322,
		1,
		"2"
	],
	[
		8323,
		1,
		"3"
	],
	[
		8324,
		1,
		"4"
	],
	[
		8325,
		1,
		"5"
	],
	[
		8326,
		1,
		"6"
	],
	[
		8327,
		1,
		"7"
	],
	[
		8328,
		1,
		"8"
	],
	[
		8329,
		1,
		"9"
	],
	[
		8330,
		5,
		"+"
	],
	[
		8331,
		1,
		""
	],
	[
		8332,
		5,
		"="
	],
	[
		8333,
		5,
		"("
	],
	[
		8334,
		5,
		")"
	],
	[
		8335,
		3
	],
	[
		8336,
		1,
		"a"
	],
	[
		8337,
		1,
		"e"
	],
	[
		8338,
		1,
		"o"
	],
	[
		8339,
		1,
		"x"
	],
	[
		8340,
		1,
		""
	],
	[
		8341,
		1,
		"h"
	],
	[
		8342,
		1,
		"k"
	],
	[
		8343,
		1,
		"l"
	],
	[
		8344,
		1,
		"m"
	],
	[
		8345,
		1,
		"n"
	],
	[
		8346,
		1,
		"p"
	],
	[
		8347,
		1,
		"s"
	],
	[
		8348,
		1,
		"t"
	],
	[
		[
			8349,
			8351
		],
		3
	],
	[
		[
			8352,
			8359
		],
		2
	],
	[
		8360,
		1,
		"rs"
	],
	[
		[
			8361,
			8362
		],
		2
	],
	[
		8363,
		2
	],
	[
		8364,
		2
	],
	[
		[
			8365,
			8367
		],
		2
	],
	[
		[
			8368,
			8369
		],
		2
	],
	[
		[
			8370,
			8373
		],
		2
	],
	[
		[
			8374,
			8376
		],
		2
	],
	[
		8377,
		2
	],
	[
		8378,
		2
	],
	[
		[
			8379,
			8381
		],
		2
	],
	[
		8382,
		2
	],
	[
		8383,
		2
	],
	[
		8384,
		2
	],
	[
		[
			8385,
			8399
		],
		3
	],
	[
		[
			8400,
			8417
		],
		2
	],
	[
		[
			8418,
			8419
		],
		2
	],
	[
		[
			8420,
			8426
		],
		2
	],
	[
		8427,
		2
	],
	[
		[
			8428,
			8431
		],
		2
	],
	[
		8432,
		2
	],
	[
		[
			8433,
			8447
		],
		3
	],
	[
		8448,
		5,
		"a/c"
	],
	[
		8449,
		5,
		"a/s"
	],
	[
		8450,
		1,
		"c"
	],
	[
		8451,
		1,
		"c"
	],
	[
		8452,
		2
	],
	[
		8453,
		5,
		"c/o"
	],
	[
		8454,
		5,
		"c/u"
	],
	[
		8455,
		1,
		""
	],
	[
		8456,
		2
	],
	[
		8457,
		1,
		"f"
	],
	[
		8458,
		1,
		"g"
	],
	[
		[
			8459,
			8462
		],
		1,
		"h"
	],
	[
		8463,
		1,
		""
	],
	[
		[
			8464,
			8465
		],
		1,
		"i"
	],
	[
		[
			8466,
			8467
		],
		1,
		"l"
	],
	[
		8468,
		2
	],
	[
		8469,
		1,
		"n"
	],
	[
		8470,
		1,
		"no"
	],
	[
		[
			8471,
			8472
		],
		2
	],
	[
		8473,
		1,
		"p"
	],
	[
		8474,
		1,
		"q"
	],
	[
		[
			8475,
			8477
		],
		1,
		"r"
	],
	[
		[
			8478,
			8479
		],
		2
	],
	[
		8480,
		1,
		"sm"
	],
	[
		8481,
		1,
		"tel"
	],
	[
		8482,
		1,
		"tm"
	],
	[
		8483,
		2
	],
	[
		8484,
		1,
		"z"
	],
	[
		8485,
		2
	],
	[
		8486,
		1,
		""
	],
	[
		8487,
		2
	],
	[
		8488,
		1,
		"z"
	],
	[
		8489,
		2
	],
	[
		8490,
		1,
		"k"
	],
	[
		8491,
		1,
		""
	],
	[
		8492,
		1,
		"b"
	],
	[
		8493,
		1,
		"c"
	],
	[
		8494,
		2
	],
	[
		[
			8495,
			8496
		],
		1,
		"e"
	],
	[
		8497,
		1,
		"f"
	],
	[
		8498,
		3
	],
	[
		8499,
		1,
		"m"
	],
	[
		8500,
		1,
		"o"
	],
	[
		8501,
		1,
		""
	],
	[
		8502,
		1,
		""
	],
	[
		8503,
		1,
		""
	],
	[
		8504,
		1,
		""
	],
	[
		8505,
		1,
		"i"
	],
	[
		8506,
		2
	],
	[
		8507,
		1,
		"fax"
	],
	[
		8508,
		1,
		""
	],
	[
		[
			8509,
			8510
		],
		1,
		""
	],
	[
		8511,
		1,
		""
	],
	[
		8512,
		1,
		""
	],
	[
		[
			8513,
			8516
		],
		2
	],
	[
		[
			8517,
			8518
		],
		1,
		"d"
	],
	[
		8519,
		1,
		"e"
	],
	[
		8520,
		1,
		"i"
	],
	[
		8521,
		1,
		"j"
	],
	[
		[
			8522,
			8523
		],
		2
	],
	[
		8524,
		2
	],
	[
		8525,
		2
	],
	[
		8526,
		2
	],
	[
		8527,
		2
	],
	[
		8528,
		1,
		"17"
	],
	[
		8529,
		1,
		"19"
	],
	[
		8530,
		1,
		"110"
	],
	[
		8531,
		1,
		"13"
	],
	[
		8532,
		1,
		"23"
	],
	[
		8533,
		1,
		"15"
	],
	[
		8534,
		1,
		"25"
	],
	[
		8535,
		1,
		"35"
	],
	[
		8536,
		1,
		"45"
	],
	[
		8537,
		1,
		"16"
	],
	[
		8538,
		1,
		"56"
	],
	[
		8539,
		1,
		"18"
	],
	[
		8540,
		1,
		"38"
	],
	[
		8541,
		1,
		"58"
	],
	[
		8542,
		1,
		"78"
	],
	[
		8543,
		1,
		"1"
	],
	[
		8544,
		1,
		"i"
	],
	[
		8545,
		1,
		"ii"
	],
	[
		8546,
		1,
		"iii"
	],
	[
		8547,
		1,
		"iv"
	],
	[
		8548,
		1,
		"v"
	],
	[
		8549,
		1,
		"vi"
	],
	[
		8550,
		1,
		"vii"
	],
	[
		8551,
		1,
		"viii"
	],
	[
		8552,
		1,
		"ix"
	],
	[
		8553,
		1,
		"x"
	],
	[
		8554,
		1,
		"xi"
	],
	[
		8555,
		1,
		"xii"
	],
	[
		8556,
		1,
		"l"
	],
	[
		8557,
		1,
		"c"
	],
	[
		8558,
		1,
		"d"
	],
	[
		8559,
		1,
		"m"
	],
	[
		8560,
		1,
		"i"
	],
	[
		8561,
		1,
		"ii"
	],
	[
		8562,
		1,
		"iii"
	],
	[
		8563,
		1,
		"iv"
	],
	[
		8564,
		1,
		"v"
	],
	[
		8565,
		1,
		"vi"
	],
	[
		8566,
		1,
		"vii"
	],
	[
		8567,
		1,
		"viii"
	],
	[
		8568,
		1,
		"ix"
	],
	[
		8569,
		1,
		"x"
	],
	[
		8570,
		1,
		"xi"
	],
	[
		8571,
		1,
		"xii"
	],
	[
		8572,
		1,
		"l"
	],
	[
		8573,
		1,
		"c"
	],
	[
		8574,
		1,
		"d"
	],
	[
		8575,
		1,
		"m"
	],
	[
		[
			8576,
			8578
		],
		2
	],
	[
		8579,
		3
	],
	[
		8580,
		2
	],
	[
		[
			8581,
			8584
		],
		2
	],
	[
		8585,
		1,
		"03"
	],
	[
		[
			8586,
			8587
		],
		2
	],
	[
		[
			8588,
			8591
		],
		3
	],
	[
		[
			8592,
			8682
		],
		2
	],
	[
		[
			8683,
			8691
		],
		2
	],
	[
		[
			8692,
			8703
		],
		2
	],
	[
		[
			8704,
			8747
		],
		2
	],
	[
		8748,
		1,
		""
	],
	[
		8749,
		1,
		""
	],
	[
		8750,
		2
	],
	[
		8751,
		1,
		""
	],
	[
		8752,
		1,
		""
	],
	[
		[
			8753,
			8799
		],
		2
	],
	[
		8800,
		4
	],
	[
		[
			8801,
			8813
		],
		2
	],
	[
		[
			8814,
			8815
		],
		4
	],
	[
		[
			8816,
			8945
		],
		2
	],
	[
		[
			8946,
			8959
		],
		2
	],
	[
		8960,
		2
	],
	[
		8961,
		2
	],
	[
		[
			8962,
			9000
		],
		2
	],
	[
		9001,
		1,
		""
	],
	[
		9002,
		1,
		""
	],
	[
		[
			9003,
			9082
		],
		2
	],
	[
		9083,
		2
	],
	[
		9084,
		2
	],
	[
		[
			9085,
			9114
		],
		2
	],
	[
		[
			9115,
			9166
		],
		2
	],
	[
		[
			9167,
			9168
		],
		2
	],
	[
		[
			9169,
			9179
		],
		2
	],
	[
		[
			9180,
			9191
		],
		2
	],
	[
		9192,
		2
	],
	[
		[
			9193,
			9203
		],
		2
	],
	[
		[
			9204,
			9210
		],
		2
	],
	[
		[
			9211,
			9214
		],
		2
	],
	[
		9215,
		2
	],
	[
		[
			9216,
			9252
		],
		2
	],
	[
		[
			9253,
			9254
		],
		2
	],
	[
		[
			9255,
			9279
		],
		3
	],
	[
		[
			9280,
			9290
		],
		2
	],
	[
		[
			9291,
			9311
		],
		3
	],
	[
		9312,
		1,
		"1"
	],
	[
		9313,
		1,
		"2"
	],
	[
		9314,
		1,
		"3"
	],
	[
		9315,
		1,
		"4"
	],
	[
		9316,
		1,
		"5"
	],
	[
		9317,
		1,
		"6"
	],
	[
		9318,
		1,
		"7"
	],
	[
		9319,
		1,
		"8"
	],
	[
		9320,
		1,
		"9"
	],
	[
		9321,
		1,
		"10"
	],
	[
		9322,
		1,
		"11"
	],
	[
		9323,
		1,
		"12"
	],
	[
		9324,
		1,
		"13"
	],
	[
		9325,
		1,
		"14"
	],
	[
		9326,
		1,
		"15"
	],
	[
		9327,
		1,
		"16"
	],
	[
		9328,
		1,
		"17"
	],
	[
		9329,
		1,
		"18"
	],
	[
		9330,
		1,
		"19"
	],
	[
		9331,
		1,
		"20"
	],
	[
		9332,
		5,
		"(1)"
	],
	[
		9333,
		5,
		"(2)"
	],
	[
		9334,
		5,
		"(3)"
	],
	[
		9335,
		5,
		"(4)"
	],
	[
		9336,
		5,
		"(5)"
	],
	[
		9337,
		5,
		"(6)"
	],
	[
		9338,
		5,
		"(7)"
	],
	[
		9339,
		5,
		"(8)"
	],
	[
		9340,
		5,
		"(9)"
	],
	[
		9341,
		5,
		"(10)"
	],
	[
		9342,
		5,
		"(11)"
	],
	[
		9343,
		5,
		"(12)"
	],
	[
		9344,
		5,
		"(13)"
	],
	[
		9345,
		5,
		"(14)"
	],
	[
		9346,
		5,
		"(15)"
	],
	[
		9347,
		5,
		"(16)"
	],
	[
		9348,
		5,
		"(17)"
	],
	[
		9349,
		5,
		"(18)"
	],
	[
		9350,
		5,
		"(19)"
	],
	[
		9351,
		5,
		"(20)"
	],
	[
		[
			9352,
			9371
		],
		3
	],
	[
		9372,
		5,
		"(a)"
	],
	[
		9373,
		5,
		"(b)"
	],
	[
		9374,
		5,
		"(c)"
	],
	[
		9375,
		5,
		"(d)"
	],
	[
		9376,
		5,
		"(e)"
	],
	[
		9377,
		5,
		"(f)"
	],
	[
		9378,
		5,
		"(g)"
	],
	[
		9379,
		5,
		"(h)"
	],
	[
		9380,
		5,
		"(i)"
	],
	[
		9381,
		5,
		"(j)"
	],
	[
		9382,
		5,
		"(k)"
	],
	[
		9383,
		5,
		"(l)"
	],
	[
		9384,
		5,
		"(m)"
	],
	[
		9385,
		5,
		"(n)"
	],
	[
		9386,
		5,
		"(o)"
	],
	[
		9387,
		5,
		"(p)"
	],
	[
		9388,
		5,
		"(q)"
	],
	[
		9389,
		5,
		"(r)"
	],
	[
		9390,
		5,
		"(s)"
	],
	[
		9391,
		5,
		"(t)"
	],
	[
		9392,
		5,
		"(u)"
	],
	[
		9393,
		5,
		"(v)"
	],
	[
		9394,
		5,
		"(w)"
	],
	[
		9395,
		5,
		"(x)"
	],
	[
		9396,
		5,
		"(y)"
	],
	[
		9397,
		5,
		"(z)"
	],
	[
		9398,
		1,
		"a"
	],
	[
		9399,
		1,
		"b"
	],
	[
		9400,
		1,
		"c"
	],
	[
		9401,
		1,
		"d"
	],
	[
		9402,
		1,
		"e"
	],
	[
		9403,
		1,
		"f"
	],
	[
		9404,
		1,
		"g"
	],
	[
		9405,
		1,
		"h"
	],
	[
		9406,
		1,
		"i"
	],
	[
		9407,
		1,
		"j"
	],
	[
		9408,
		1,
		"k"
	],
	[
		9409,
		1,
		"l"
	],
	[
		9410,
		1,
		"m"
	],
	[
		9411,
		1,
		"n"
	],
	[
		9412,
		1,
		"o"
	],
	[
		9413,
		1,
		"p"
	],
	[
		9414,
		1,
		"q"
	],
	[
		9415,
		1,
		"r"
	],
	[
		9416,
		1,
		"s"
	],
	[
		9417,
		1,
		"t"
	],
	[
		9418,
		1,
		"u"
	],
	[
		9419,
		1,
		"v"
	],
	[
		9420,
		1,
		"w"
	],
	[
		9421,
		1,
		"x"
	],
	[
		9422,
		1,
		"y"
	],
	[
		9423,
		1,
		"z"
	],
	[
		9424,
		1,
		"a"
	],
	[
		9425,
		1,
		"b"
	],
	[
		9426,
		1,
		"c"
	],
	[
		9427,
		1,
		"d"
	],
	[
		9428,
		1,
		"e"
	],
	[
		9429,
		1,
		"f"
	],
	[
		9430,
		1,
		"g"
	],
	[
		9431,
		1,
		"h"
	],
	[
		9432,
		1,
		"i"
	],
	[
		9433,
		1,
		"j"
	],
	[
		9434,
		1,
		"k"
	],
	[
		9435,
		1,
		"l"
	],
	[
		9436,
		1,
		"m"
	],
	[
		9437,
		1,
		"n"
	],
	[
		9438,
		1,
		"o"
	],
	[
		9439,
		1,
		"p"
	],
	[
		9440,
		1,
		"q"
	],
	[
		9441,
		1,
		"r"
	],
	[
		9442,
		1,
		"s"
	],
	[
		9443,
		1,
		"t"
	],
	[
		9444,
		1,
		"u"
	],
	[
		9445,
		1,
		"v"
	],
	[
		9446,
		1,
		"w"
	],
	[
		9447,
		1,
		"x"
	],
	[
		9448,
		1,
		"y"
	],
	[
		9449,
		1,
		"z"
	],
	[
		9450,
		1,
		"0"
	],
	[
		[
			9451,
			9470
		],
		2
	],
	[
		9471,
		2
	],
	[
		[
			9472,
			9621
		],
		2
	],
	[
		[
			9622,
			9631
		],
		2
	],
	[
		[
			9632,
			9711
		],
		2
	],
	[
		[
			9712,
			9719
		],
		2
	],
	[
		[
			9720,
			9727
		],
		2
	],
	[
		[
			9728,
			9747
		],
		2
	],
	[
		[
			9748,
			9749
		],
		2
	],
	[
		[
			9750,
			9751
		],
		2
	],
	[
		9752,
		2
	],
	[
		9753,
		2
	],
	[
		[
			9754,
			9839
		],
		2
	],
	[
		[
			9840,
			9841
		],
		2
	],
	[
		[
			9842,
			9853
		],
		2
	],
	[
		[
			9854,
			9855
		],
		2
	],
	[
		[
			9856,
			9865
		],
		2
	],
	[
		[
			9866,
			9873
		],
		2
	],
	[
		[
			9874,
			9884
		],
		2
	],
	[
		9885,
		2
	],
	[
		[
			9886,
			9887
		],
		2
	],
	[
		[
			9888,
			9889
		],
		2
	],
	[
		[
			9890,
			9905
		],
		2
	],
	[
		9906,
		2
	],
	[
		[
			9907,
			9916
		],
		2
	],
	[
		[
			9917,
			9919
		],
		2
	],
	[
		[
			9920,
			9923
		],
		2
	],
	[
		[
			9924,
			9933
		],
		2
	],
	[
		9934,
		2
	],
	[
		[
			9935,
			9953
		],
		2
	],
	[
		9954,
		2
	],
	[
		9955,
		2
	],
	[
		[
			9956,
			9959
		],
		2
	],
	[
		[
			9960,
			9983
		],
		2
	],
	[
		9984,
		2
	],
	[
		[
			9985,
			9988
		],
		2
	],
	[
		9989,
		2
	],
	[
		[
			9990,
			9993
		],
		2
	],
	[
		[
			9994,
			9995
		],
		2
	],
	[
		[
			9996,
			10023
		],
		2
	],
	[
		10024,
		2
	],
	[
		[
			10025,
			10059
		],
		2
	],
	[
		10060,
		2
	],
	[
		10061,
		2
	],
	[
		10062,
		2
	],
	[
		[
			10063,
			10066
		],
		2
	],
	[
		[
			10067,
			10069
		],
		2
	],
	[
		10070,
		2
	],
	[
		10071,
		2
	],
	[
		[
			10072,
			10078
		],
		2
	],
	[
		[
			10079,
			10080
		],
		2
	],
	[
		[
			10081,
			10087
		],
		2
	],
	[
		[
			10088,
			10101
		],
		2
	],
	[
		[
			10102,
			10132
		],
		2
	],
	[
		[
			10133,
			10135
		],
		2
	],
	[
		[
			10136,
			10159
		],
		2
	],
	[
		10160,
		2
	],
	[
		[
			10161,
			10174
		],
		2
	],
	[
		10175,
		2
	],
	[
		[
			10176,
			10182
		],
		2
	],
	[
		[
			10183,
			10186
		],
		2
	],
	[
		10187,
		2
	],
	[
		10188,
		2
	],
	[
		10189,
		2
	],
	[
		[
			10190,
			10191
		],
		2
	],
	[
		[
			10192,
			10219
		],
		2
	],
	[
		[
			10220,
			10223
		],
		2
	],
	[
		[
			10224,
			10239
		],
		2
	],
	[
		[
			10240,
			10495
		],
		2
	],
	[
		[
			10496,
			10763
		],
		2
	],
	[
		10764,
		1,
		""
	],
	[
		[
			10765,
			10867
		],
		2
	],
	[
		10868,
		5,
		"::="
	],
	[
		10869,
		5,
		"=="
	],
	[
		10870,
		5,
		"==="
	],
	[
		[
			10871,
			10971
		],
		2
	],
	[
		10972,
		1,
		""
	],
	[
		[
			10973,
			11007
		],
		2
	],
	[
		[
			11008,
			11021
		],
		2
	],
	[
		[
			11022,
			11027
		],
		2
	],
	[
		[
			11028,
			11034
		],
		2
	],
	[
		[
			11035,
			11039
		],
		2
	],
	[
		[
			11040,
			11043
		],
		2
	],
	[
		[
			11044,
			11084
		],
		2
	],
	[
		[
			11085,
			11087
		],
		2
	],
	[
		[
			11088,
			11092
		],
		2
	],
	[
		[
			11093,
			11097
		],
		2
	],
	[
		[
			11098,
			11123
		],
		2
	],
	[
		[
			11124,
			11125
		],
		3
	],
	[
		[
			11126,
			11157
		],
		2
	],
	[
		11158,
		3
	],
	[
		11159,
		2
	],
	[
		[
			11160,
			11193
		],
		2
	],
	[
		[
			11194,
			11196
		],
		2
	],
	[
		[
			11197,
			11208
		],
		2
	],
	[
		11209,
		2
	],
	[
		[
			11210,
			11217
		],
		2
	],
	[
		11218,
		2
	],
	[
		[
			11219,
			11243
		],
		2
	],
	[
		[
			11244,
			11247
		],
		2
	],
	[
		[
			11248,
			11262
		],
		2
	],
	[
		11263,
		2
	],
	[
		11264,
		1,
		""
	],
	[
		11265,
		1,
		""
	],
	[
		11266,
		1,
		""
	],
	[
		11267,
		1,
		""
	],
	[
		11268,
		1,
		""
	],
	[
		11269,
		1,
		""
	],
	[
		11270,
		1,
		""
	],
	[
		11271,
		1,
		""
	],
	[
		11272,
		1,
		""
	],
	[
		11273,
		1,
		""
	],
	[
		11274,
		1,
		""
	],
	[
		11275,
		1,
		""
	],
	[
		11276,
		1,
		""
	],
	[
		11277,
		1,
		""
	],
	[
		11278,
		1,
		""
	],
	[
		11279,
		1,
		""
	],
	[
		11280,
		1,
		""
	],
	[
		11281,
		1,
		""
	],
	[
		11282,
		1,
		""
	],
	[
		11283,
		1,
		""
	],
	[
		11284,
		1,
		""
	],
	[
		11285,
		1,
		""
	],
	[
		11286,
		1,
		""
	],
	[
		11287,
		1,
		""
	],
	[
		11288,
		1,
		""
	],
	[
		11289,
		1,
		""
	],
	[
		11290,
		1,
		""
	],
	[
		11291,
		1,
		""
	],
	[
		11292,
		1,
		""
	],
	[
		11293,
		1,
		""
	],
	[
		11294,
		1,
		""
	],
	[
		11295,
		1,
		""
	],
	[
		11296,
		1,
		""
	],
	[
		11297,
		1,
		""
	],
	[
		11298,
		1,
		""
	],
	[
		11299,
		1,
		""
	],
	[
		11300,
		1,
		""
	],
	[
		11301,
		1,
		""
	],
	[
		11302,
		1,
		""
	],
	[
		11303,
		1,
		""
	],
	[
		11304,
		1,
		""
	],
	[
		11305,
		1,
		""
	],
	[
		11306,
		1,
		""
	],
	[
		11307,
		1,
		""
	],
	[
		11308,
		1,
		""
	],
	[
		11309,
		1,
		""
	],
	[
		11310,
		1,
		""
	],
	[
		11311,
		1,
		""
	],
	[
		[
			11312,
			11358
		],
		2
	],
	[
		11359,
		2
	],
	[
		11360,
		1,
		""
	],
	[
		11361,
		2
	],
	[
		11362,
		1,
		""
	],
	[
		11363,
		1,
		""
	],
	[
		11364,
		1,
		""
	],
	[
		[
			11365,
			11366
		],
		2
	],
	[
		11367,
		1,
		""
	],
	[
		11368,
		2
	],
	[
		11369,
		1,
		""
	],
	[
		11370,
		2
	],
	[
		11371,
		1,
		""
	],
	[
		11372,
		2
	],
	[
		11373,
		1,
		""
	],
	[
		11374,
		1,
		""
	],
	[
		11375,
		1,
		""
	],
	[
		11376,
		1,
		""
	],
	[
		11377,
		2
	],
	[
		11378,
		1,
		""
	],
	[
		11379,
		2
	],
	[
		11380,
		2
	],
	[
		11381,
		1,
		""
	],
	[
		[
			11382,
			11383
		],
		2
	],
	[
		[
			11384,
			11387
		],
		2
	],
	[
		11388,
		1,
		"j"
	],
	[
		11389,
		1,
		"v"
	],
	[
		11390,
		1,
		""
	],
	[
		11391,
		1,
		""
	],
	[
		11392,
		1,
		""
	],
	[
		11393,
		2
	],
	[
		11394,
		1,
		""
	],
	[
		11395,
		2
	],
	[
		11396,
		1,
		""
	],
	[
		11397,
		2
	],
	[
		11398,
		1,
		""
	],
	[
		11399,
		2
	],
	[
		11400,
		1,
		""
	],
	[
		11401,
		2
	],
	[
		11402,
		1,
		""
	],
	[
		11403,
		2
	],
	[
		11404,
		1,
		""
	],
	[
		11405,
		2
	],
	[
		11406,
		1,
		""
	],
	[
		11407,
		2
	],
	[
		11408,
		1,
		""
	],
	[
		11409,
		2
	],
	[
		11410,
		1,
		""
	],
	[
		11411,
		2
	],
	[
		11412,
		1,
		""
	],
	[
		11413,
		2
	],
	[
		11414,
		1,
		""
	],
	[
		11415,
		2
	],
	[
		11416,
		1,
		""
	],
	[
		11417,
		2
	],
	[
		11418,
		1,
		""
	],
	[
		11419,
		2
	],
	[
		11420,
		1,
		""
	],
	[
		11421,
		2
	],
	[
		11422,
		1,
		""
	],
	[
		11423,
		2
	],
	[
		11424,
		1,
		""
	],
	[
		11425,
		2
	],
	[
		11426,
		1,
		""
	],
	[
		11427,
		2
	],
	[
		11428,
		1,
		""
	],
	[
		11429,
		2
	],
	[
		11430,
		1,
		""
	],
	[
		11431,
		2
	],
	[
		11432,
		1,
		""
	],
	[
		11433,
		2
	],
	[
		11434,
		1,
		""
	],
	[
		11435,
		2
	],
	[
		11436,
		1,
		""
	],
	[
		11437,
		2
	],
	[
		11438,
		1,
		""
	],
	[
		11439,
		2
	],
	[
		11440,
		1,
		""
	],
	[
		11441,
		2
	],
	[
		11442,
		1,
		""
	],
	[
		11443,
		2
	],
	[
		11444,
		1,
		""
	],
	[
		11445,
		2
	],
	[
		11446,
		1,
		""
	],
	[
		11447,
		2
	],
	[
		11448,
		1,
		""
	],
	[
		11449,
		2
	],
	[
		11450,
		1,
		""
	],
	[
		11451,
		2
	],
	[
		11452,
		1,
		""
	],
	[
		11453,
		2
	],
	[
		11454,
		1,
		""
	],
	[
		11455,
		2
	],
	[
		11456,
		1,
		""
	],
	[
		11457,
		2
	],
	[
		11458,
		1,
		""
	],
	[
		11459,
		2
	],
	[
		11460,
		1,
		""
	],
	[
		11461,
		2
	],
	[
		11462,
		1,
		""
	],
	[
		11463,
		2
	],
	[
		11464,
		1,
		""
	],
	[
		11465,
		2
	],
	[
		11466,
		1,
		""
	],
	[
		11467,
		2
	],
	[
		11468,
		1,
		""
	],
	[
		11469,
		2
	],
	[
		11470,
		1,
		""
	],
	[
		11471,
		2
	],
	[
		11472,
		1,
		""
	],
	[
		11473,
		2
	],
	[
		11474,
		1,
		""
	],
	[
		11475,
		2
	],
	[
		11476,
		1,
		""
	],
	[
		11477,
		2
	],
	[
		11478,
		1,
		""
	],
	[
		11479,
		2
	],
	[
		11480,
		1,
		""
	],
	[
		11481,
		2
	],
	[
		11482,
		1,
		""
	],
	[
		11483,
		2
	],
	[
		11484,
		1,
		""
	],
	[
		11485,
		2
	],
	[
		11486,
		1,
		""
	],
	[
		11487,
		2
	],
	[
		11488,
		1,
		""
	],
	[
		11489,
		2
	],
	[
		11490,
		1,
		""
	],
	[
		[
			11491,
			11492
		],
		2
	],
	[
		[
			11493,
			11498
		],
		2
	],
	[
		11499,
		1,
		""
	],
	[
		11500,
		2
	],
	[
		11501,
		1,
		""
	],
	[
		[
			11502,
			11505
		],
		2
	],
	[
		11506,
		1,
		""
	],
	[
		11507,
		2
	],
	[
		[
			11508,
			11512
		],
		3
	],
	[
		[
			11513,
			11519
		],
		2
	],
	[
		[
			11520,
			11557
		],
		2
	],
	[
		11558,
		3
	],
	[
		11559,
		2
	],
	[
		[
			11560,
			11564
		],
		3
	],
	[
		11565,
		2
	],
	[
		[
			11566,
			11567
		],
		3
	],
	[
		[
			11568,
			11621
		],
		2
	],
	[
		[
			11622,
			11623
		],
		2
	],
	[
		[
			11624,
			11630
		],
		3
	],
	[
		11631,
		1,
		""
	],
	[
		11632,
		2
	],
	[
		[
			11633,
			11646
		],
		3
	],
	[
		11647,
		2
	],
	[
		[
			11648,
			11670
		],
		2
	],
	[
		[
			11671,
			11679
		],
		3
	],
	[
		[
			11680,
			11686
		],
		2
	],
	[
		11687,
		3
	],
	[
		[
			11688,
			11694
		],
		2
	],
	[
		11695,
		3
	],
	[
		[
			11696,
			11702
		],
		2
	],
	[
		11703,
		3
	],
	[
		[
			11704,
			11710
		],
		2
	],
	[
		11711,
		3
	],
	[
		[
			11712,
			11718
		],
		2
	],
	[
		11719,
		3
	],
	[
		[
			11720,
			11726
		],
		2
	],
	[
		11727,
		3
	],
	[
		[
			11728,
			11734
		],
		2
	],
	[
		11735,
		3
	],
	[
		[
			11736,
			11742
		],
		2
	],
	[
		11743,
		3
	],
	[
		[
			11744,
			11775
		],
		2
	],
	[
		[
			11776,
			11799
		],
		2
	],
	[
		[
			11800,
			11803
		],
		2
	],
	[
		[
			11804,
			11805
		],
		2
	],
	[
		[
			11806,
			11822
		],
		2
	],
	[
		11823,
		2
	],
	[
		11824,
		2
	],
	[
		11825,
		2
	],
	[
		[
			11826,
			11835
		],
		2
	],
	[
		[
			11836,
			11842
		],
		2
	],
	[
		[
			11843,
			11844
		],
		2
	],
	[
		[
			11845,
			11849
		],
		2
	],
	[
		[
			11850,
			11854
		],
		2
	],
	[
		11855,
		2
	],
	[
		[
			11856,
			11858
		],
		2
	],
	[
		[
			11859,
			11869
		],
		2
	],
	[
		[
			11870,
			11903
		],
		3
	],
	[
		[
			11904,
			11929
		],
		2
	],
	[
		11930,
		3
	],
	[
		[
			11931,
			11934
		],
		2
	],
	[
		11935,
		1,
		""
	],
	[
		[
			11936,
			12018
		],
		2
	],
	[
		12019,
		1,
		""
	],
	[
		[
			12020,
			12031
		],
		3
	],
	[
		12032,
		1,
		""
	],
	[
		12033,
		1,
		""
	],
	[
		12034,
		1,
		""
	],
	[
		12035,
		1,
		""
	],
	[
		12036,
		1,
		""
	],
	[
		12037,
		1,
		""
	],
	[
		12038,
		1,
		""
	],
	[
		12039,
		1,
		""
	],
	[
		12040,
		1,
		""
	],
	[
		12041,
		1,
		""
	],
	[
		12042,
		1,
		""
	],
	[
		12043,
		1,
		""
	],
	[
		12044,
		1,
		""
	],
	[
		12045,
		1,
		""
	],
	[
		12046,
		1,
		""
	],
	[
		12047,
		1,
		""
	],
	[
		12048,
		1,
		""
	],
	[
		12049,
		1,
		""
	],
	[
		12050,
		1,
		""
	],
	[
		12051,
		1,
		""
	],
	[
		12052,
		1,
		""
	],
	[
		12053,
		1,
		""
	],
	[
		12054,
		1,
		""
	],
	[
		12055,
		1,
		""
	],
	[
		12056,
		1,
		""
	],
	[
		12057,
		1,
		""
	],
	[
		12058,
		1,
		""
	],
	[
		12059,
		1,
		""
	],
	[
		12060,
		1,
		""
	],
	[
		12061,
		1,
		""
	],
	[
		12062,
		1,
		""
	],
	[
		12063,
		1,
		""
	],
	[
		12064,
		1,
		""
	],
	[
		12065,
		1,
		""
	],
	[
		12066,
		1,
		""
	],
	[
		12067,
		1,
		""
	],
	[
		12068,
		1,
		""
	],
	[
		12069,
		1,
		""
	],
	[
		12070,
		1,
		""
	],
	[
		12071,
		1,
		""
	],
	[
		12072,
		1,
		""
	],
	[
		12073,
		1,
		""
	],
	[
		12074,
		1,
		""
	],
	[
		12075,
		1,
		""
	],
	[
		12076,
		1,
		""
	],
	[
		12077,
		1,
		""
	],
	[
		12078,
		1,
		""
	],
	[
		12079,
		1,
		""
	],
	[
		12080,
		1,
		""
	],
	[
		12081,
		1,
		""
	],
	[
		12082,
		1,
		""
	],
	[
		12083,
		1,
		""
	],
	[
		12084,
		1,
		""
	],
	[
		12085,
		1,
		""
	],
	[
		12086,
		1,
		""
	],
	[
		12087,
		1,
		""
	],
	[
		12088,
		1,
		""
	],
	[
		12089,
		1,
		""
	],
	[
		12090,
		1,
		""
	],
	[
		12091,
		1,
		""
	],
	[
		12092,
		1,
		""
	],
	[
		12093,
		1,
		""
	],
	[
		12094,
		1,
		""
	],
	[
		12095,
		1,
		""
	],
	[
		12096,
		1,
		""
	],
	[
		12097,
		1,
		""
	],
	[
		12098,
		1,
		""
	],
	[
		12099,
		1,
		""
	],
	[
		12100,
		1,
		""
	],
	[
		12101,
		1,
		""
	],
	[
		12102,
		1,
		""
	],
	[
		12103,
		1,
		""
	],
	[
		12104,
		1,
		""
	],
	[
		12105,
		1,
		""
	],
	[
		12106,
		1,
		""
	],
	[
		12107,
		1,
		""
	],
	[
		12108,
		1,
		""
	],
	[
		12109,
		1,
		""
	],
	[
		12110,
		1,
		""
	],
	[
		12111,
		1,
		""
	],
	[
		12112,
		1,
		""
	],
	[
		12113,
		1,
		""
	],
	[
		12114,
		1,
		""
	],
	[
		12115,
		1,
		""
	],
	[
		12116,
		1,
		""
	],
	[
		12117,
		1,
		""
	],
	[
		12118,
		1,
		""
	],
	[
		12119,
		1,
		""
	],
	[
		12120,
		1,
		""
	],
	[
		12121,
		1,
		""
	],
	[
		12122,
		1,
		""
	],
	[
		12123,
		1,
		""
	],
	[
		12124,
		1,
		""
	],
	[
		12125,
		1,
		""
	],
	[
		12126,
		1,
		""
	],
	[
		12127,
		1,
		""
	],
	[
		12128,
		1,
		""
	],
	[
		12129,
		1,
		""
	],
	[
		12130,
		1,
		""
	],
	[
		12131,
		1,
		""
	],
	[
		12132,
		1,
		""
	],
	[
		12133,
		1,
		""
	],
	[
		12134,
		1,
		""
	],
	[
		12135,
		1,
		""
	],
	[
		12136,
		1,
		""
	],
	[
		12137,
		1,
		""
	],
	[
		12138,
		1,
		""
	],
	[
		12139,
		1,
		""
	],
	[
		12140,
		1,
		""
	],
	[
		12141,
		1,
		""
	],
	[
		12142,
		1,
		""
	],
	[
		12143,
		1,
		""
	],
	[
		12144,
		1,
		""
	],
	[
		12145,
		1,
		""
	],
	[
		12146,
		1,
		""
	],
	[
		12147,
		1,
		""
	],
	[
		12148,
		1,
		""
	],
	[
		12149,
		1,
		""
	],
	[
		12150,
		1,
		""
	],
	[
		12151,
		1,
		""
	],
	[
		12152,
		1,
		""
	],
	[
		12153,
		1,
		""
	],
	[
		12154,
		1,
		""
	],
	[
		12155,
		1,
		""
	],
	[
		12156,
		1,
		""
	],
	[
		12157,
		1,
		""
	],
	[
		12158,
		1,
		""
	],
	[
		12159,
		1,
		""
	],
	[
		12160,
		1,
		""
	],
	[
		12161,
		1,
		""
	],
	[
		12162,
		1,
		""
	],
	[
		12163,
		1,
		""
	],
	[
		12164,
		1,
		""
	],
	[
		12165,
		1,
		""
	],
	[
		12166,
		1,
		""
	],
	[
		12167,
		1,
		""
	],
	[
		12168,
		1,
		""
	],
	[
		12169,
		1,
		""
	],
	[
		12170,
		1,
		""
	],
	[
		12171,
		1,
		""
	],
	[
		12172,
		1,
		""
	],
	[
		12173,
		1,
		""
	],
	[
		12174,
		1,
		""
	],
	[
		12175,
		1,
		""
	],
	[
		12176,
		1,
		""
	],
	[
		12177,
		1,
		""
	],
	[
		12178,
		1,
		""
	],
	[
		12179,
		1,
		""
	],
	[
		12180,
		1,
		""
	],
	[
		12181,
		1,
		""
	],
	[
		12182,
		1,
		""
	],
	[
		12183,
		1,
		""
	],
	[
		12184,
		1,
		""
	],
	[
		12185,
		1,
		""
	],
	[
		12186,
		1,
		""
	],
	[
		12187,
		1,
		""
	],
	[
		12188,
		1,
		""
	],
	[
		12189,
		1,
		""
	],
	[
		12190,
		1,
		""
	],
	[
		12191,
		1,
		""
	],
	[
		12192,
		1,
		""
	],
	[
		12193,
		1,
		""
	],
	[
		12194,
		1,
		""
	],
	[
		12195,
		1,
		""
	],
	[
		12196,
		1,
		""
	],
	[
		12197,
		1,
		""
	],
	[
		12198,
		1,
		""
	],
	[
		12199,
		1,
		""
	],
	[
		12200,
		1,
		""
	],
	[
		12201,
		1,
		""
	],
	[
		12202,
		1,
		""
	],
	[
		12203,
		1,
		""
	],
	[
		12204,
		1,
		""
	],
	[
		12205,
		1,
		""
	],
	[
		12206,
		1,
		""
	],
	[
		12207,
		1,
		""
	],
	[
		12208,
		1,
		""
	],
	[
		12209,
		1,
		""
	],
	[
		12210,
		1,
		""
	],
	[
		12211,
		1,
		""
	],
	[
		12212,
		1,
		""
	],
	[
		12213,
		1,
		""
	],
	[
		12214,
		1,
		""
	],
	[
		12215,
		1,
		""
	],
	[
		12216,
		1,
		""
	],
	[
		12217,
		1,
		""
	],
	[
		12218,
		1,
		""
	],
	[
		12219,
		1,
		""
	],
	[
		12220,
		1,
		""
	],
	[
		12221,
		1,
		""
	],
	[
		12222,
		1,
		""
	],
	[
		12223,
		1,
		""
	],
	[
		12224,
		1,
		""
	],
	[
		12225,
		1,
		""
	],
	[
		12226,
		1,
		""
	],
	[
		12227,
		1,
		""
	],
	[
		12228,
		1,
		""
	],
	[
		12229,
		1,
		""
	],
	[
		12230,
		1,
		""
	],
	[
		12231,
		1,
		""
	],
	[
		12232,
		1,
		""
	],
	[
		12233,
		1,
		""
	],
	[
		12234,
		1,
		""
	],
	[
		12235,
		1,
		""
	],
	[
		12236,
		1,
		""
	],
	[
		12237,
		1,
		""
	],
	[
		12238,
		1,
		""
	],
	[
		12239,
		1,
		""
	],
	[
		12240,
		1,
		""
	],
	[
		12241,
		1,
		""
	],
	[
		12242,
		1,
		""
	],
	[
		12243,
		1,
		""
	],
	[
		12244,
		1,
		""
	],
	[
		12245,
		1,
		""
	],
	[
		[
			12246,
			12271
		],
		3
	],
	[
		[
			12272,
			12283
		],
		3
	],
	[
		[
			12284,
			12287
		],
		3
	],
	[
		12288,
		5,
		" "
	],
	[
		12289,
		2
	],
	[
		12290,
		1,
		"."
	],
	[
		[
			12291,
			12292
		],
		2
	],
	[
		[
			12293,
			12295
		],
		2
	],
	[
		[
			12296,
			12329
		],
		2
	],
	[
		[
			12330,
			12333
		],
		2
	],
	[
		[
			12334,
			12341
		],
		2
	],
	[
		12342,
		1,
		""
	],
	[
		12343,
		2
	],
	[
		12344,
		1,
		""
	],
	[
		12345,
		1,
		""
	],
	[
		12346,
		1,
		""
	],
	[
		12347,
		2
	],
	[
		12348,
		2
	],
	[
		12349,
		2
	],
	[
		12350,
		2
	],
	[
		12351,
		2
	],
	[
		12352,
		3
	],
	[
		[
			12353,
			12436
		],
		2
	],
	[
		[
			12437,
			12438
		],
		2
	],
	[
		[
			12439,
			12440
		],
		3
	],
	[
		[
			12441,
			12442
		],
		2
	],
	[
		12443,
		5,
		" "
	],
	[
		12444,
		5,
		" "
	],
	[
		[
			12445,
			12446
		],
		2
	],
	[
		12447,
		1,
		""
	],
	[
		12448,
		2
	],
	[
		[
			12449,
			12542
		],
		2
	],
	[
		12543,
		1,
		""
	],
	[
		[
			12544,
			12548
		],
		3
	],
	[
		[
			12549,
			12588
		],
		2
	],
	[
		12589,
		2
	],
	[
		12590,
		2
	],
	[
		12591,
		2
	],
	[
		12592,
		3
	],
	[
		12593,
		1,
		""
	],
	[
		12594,
		1,
		""
	],
	[
		12595,
		1,
		""
	],
	[
		12596,
		1,
		""
	],
	[
		12597,
		1,
		""
	],
	[
		12598,
		1,
		""
	],
	[
		12599,
		1,
		""
	],
	[
		12600,
		1,
		""
	],
	[
		12601,
		1,
		""
	],
	[
		12602,
		1,
		""
	],
	[
		12603,
		1,
		""
	],
	[
		12604,
		1,
		""
	],
	[
		12605,
		1,
		""
	],
	[
		12606,
		1,
		""
	],
	[
		12607,
		1,
		""
	],
	[
		12608,
		1,
		""
	],
	[
		12609,
		1,
		""
	],
	[
		12610,
		1,
		""
	],
	[
		12611,
		1,
		""
	],
	[
		12612,
		1,
		""
	],
	[
		12613,
		1,
		""
	],
	[
		12614,
		1,
		""
	],
	[
		12615,
		1,
		""
	],
	[
		12616,
		1,
		""
	],
	[
		12617,
		1,
		""
	],
	[
		12618,
		1,
		""
	],
	[
		12619,
		1,
		""
	],
	[
		12620,
		1,
		""
	],
	[
		12621,
		1,
		""
	],
	[
		12622,
		1,
		""
	],
	[
		12623,
		1,
		""
	],
	[
		12624,
		1,
		""
	],
	[
		12625,
		1,
		""
	],
	[
		12626,
		1,
		""
	],
	[
		12627,
		1,
		""
	],
	[
		12628,
		1,
		""
	],
	[
		12629,
		1,
		""
	],
	[
		12630,
		1,
		""
	],
	[
		12631,
		1,
		""
	],
	[
		12632,
		1,
		""
	],
	[
		12633,
		1,
		""
	],
	[
		12634,
		1,
		""
	],
	[
		12635,
		1,
		""
	],
	[
		12636,
		1,
		""
	],
	[
		12637,
		1,
		""
	],
	[
		12638,
		1,
		""
	],
	[
		12639,
		1,
		""
	],
	[
		12640,
		1,
		""
	],
	[
		12641,
		1,
		""
	],
	[
		12642,
		1,
		""
	],
	[
		12643,
		1,
		""
	],
	[
		12644,
		3
	],
	[
		12645,
		1,
		""
	],
	[
		12646,
		1,
		""
	],
	[
		12647,
		1,
		""
	],
	[
		12648,
		1,
		""
	],
	[
		12649,
		1,
		""
	],
	[
		12650,
		1,
		""
	],
	[
		12651,
		1,
		""
	],
	[
		12652,
		1,
		""
	],
	[
		12653,
		1,
		""
	],
	[
		12654,
		1,
		""
	],
	[
		12655,
		1,
		""
	],
	[
		12656,
		1,
		""
	],
	[
		12657,
		1,
		""
	],
	[
		12658,
		1,
		""
	],
	[
		12659,
		1,
		""
	],
	[
		12660,
		1,
		""
	],
	[
		12661,
		1,
		""
	],
	[
		12662,
		1,
		""
	],
	[
		12663,
		1,
		""
	],
	[
		12664,
		1,
		""
	],
	[
		12665,
		1,
		""
	],
	[
		12666,
		1,
		""
	],
	[
		12667,
		1,
		""
	],
	[
		12668,
		1,
		""
	],
	[
		12669,
		1,
		""
	],
	[
		12670,
		1,
		""
	],
	[
		12671,
		1,
		""
	],
	[
		12672,
		1,
		""
	],
	[
		12673,
		1,
		""
	],
	[
		12674,
		1,
		""
	],
	[
		12675,
		1,
		""
	],
	[
		12676,
		1,
		""
	],
	[
		12677,
		1,
		""
	],
	[
		12678,
		1,
		""
	],
	[
		12679,
		1,
		""
	],
	[
		12680,
		1,
		""
	],
	[
		12681,
		1,
		""
	],
	[
		12682,
		1,
		""
	],
	[
		12683,
		1,
		""
	],
	[
		12684,
		1,
		""
	],
	[
		12685,
		1,
		""
	],
	[
		12686,
		1,
		""
	],
	[
		12687,
		3
	],
	[
		[
			12688,
			12689
		],
		2
	],
	[
		12690,
		1,
		""
	],
	[
		12691,
		1,
		""
	],
	[
		12692,
		1,
		""
	],
	[
		12693,
		1,
		""
	],
	[
		12694,
		1,
		""
	],
	[
		12695,
		1,
		""
	],
	[
		12696,
		1,
		""
	],
	[
		12697,
		1,
		""
	],
	[
		12698,
		1,
		""
	],
	[
		12699,
		1,
		""
	],
	[
		12700,
		1,
		""
	],
	[
		12701,
		1,
		""
	],
	[
		12702,
		1,
		""
	],
	[
		12703,
		1,
		""
	],
	[
		[
			12704,
			12727
		],
		2
	],
	[
		[
			12728,
			12730
		],
		2
	],
	[
		[
			12731,
			12735
		],
		2
	],
	[
		[
			12736,
			12751
		],
		2
	],
	[
		[
			12752,
			12771
		],
		2
	],
	[
		[
			12772,
			12783
		],
		3
	],
	[
		[
			12784,
			12799
		],
		2
	],
	[
		12800,
		5,
		"()"
	],
	[
		12801,
		5,
		"()"
	],
	[
		12802,
		5,
		"()"
	],
	[
		12803,
		5,
		"()"
	],
	[
		12804,
		5,
		"()"
	],
	[
		12805,
		5,
		"()"
	],
	[
		12806,
		5,
		"()"
	],
	[
		12807,
		5,
		"()"
	],
	[
		12808,
		5,
		"()"
	],
	[
		12809,
		5,
		"()"
	],
	[
		12810,
		5,
		"()"
	],
	[
		12811,
		5,
		"()"
	],
	[
		12812,
		5,
		"()"
	],
	[
		12813,
		5,
		"()"
	],
	[
		12814,
		5,
		"()"
	],
	[
		12815,
		5,
		"()"
	],
	[
		12816,
		5,
		"()"
	],
	[
		12817,
		5,
		"()"
	],
	[
		12818,
		5,
		"()"
	],
	[
		12819,
		5,
		"()"
	],
	[
		12820,
		5,
		"()"
	],
	[
		12821,
		5,
		"()"
	],
	[
		12822,
		5,
		"()"
	],
	[
		12823,
		5,
		"()"
	],
	[
		12824,
		5,
		"()"
	],
	[
		12825,
		5,
		"()"
	],
	[
		12826,
		5,
		"()"
	],
	[
		12827,
		5,
		"()"
	],
	[
		12828,
		5,
		"()"
	],
	[
		12829,
		5,
		"()"
	],
	[
		12830,
		5,
		"()"
	],
	[
		12831,
		3
	],
	[
		12832,
		5,
		"()"
	],
	[
		12833,
		5,
		"()"
	],
	[
		12834,
		5,
		"()"
	],
	[
		12835,
		5,
		"()"
	],
	[
		12836,
		5,
		"()"
	],
	[
		12837,
		5,
		"()"
	],
	[
		12838,
		5,
		"()"
	],
	[
		12839,
		5,
		"()"
	],
	[
		12840,
		5,
		"()"
	],
	[
		12841,
		5,
		"()"
	],
	[
		12842,
		5,
		"()"
	],
	[
		12843,
		5,
		"()"
	],
	[
		12844,
		5,
		"()"
	],
	[
		12845,
		5,
		"()"
	],
	[
		12846,
		5,
		"()"
	],
	[
		12847,
		5,
		"()"
	],
	[
		12848,
		5,
		"()"
	],
	[
		12849,
		5,
		"()"
	],
	[
		12850,
		5,
		"()"
	],
	[
		12851,
		5,
		"()"
	],
	[
		12852,
		5,
		"()"
	],
	[
		12853,
		5,
		"()"
	],
	[
		12854,
		5,
		"()"
	],
	[
		12855,
		5,
		"()"
	],
	[
		12856,
		5,
		"()"
	],
	[
		12857,
		5,
		"()"
	],
	[
		12858,
		5,
		"()"
	],
	[
		12859,
		5,
		"()"
	],
	[
		12860,
		5,
		"()"
	],
	[
		12861,
		5,
		"()"
	],
	[
		12862,
		5,
		"()"
	],
	[
		12863,
		5,
		"()"
	],
	[
		12864,
		5,
		"()"
	],
	[
		12865,
		5,
		"()"
	],
	[
		12866,
		5,
		"()"
	],
	[
		12867,
		5,
		"()"
	],
	[
		12868,
		1,
		""
	],
	[
		12869,
		1,
		""
	],
	[
		12870,
		1,
		""
	],
	[
		12871,
		1,
		""
	],
	[
		[
			12872,
			12879
		],
		2
	],
	[
		12880,
		1,
		"pte"
	],
	[
		12881,
		1,
		"21"
	],
	[
		12882,
		1,
		"22"
	],
	[
		12883,
		1,
		"23"
	],
	[
		12884,
		1,
		"24"
	],
	[
		12885,
		1,
		"25"
	],
	[
		12886,
		1,
		"26"
	],
	[
		12887,
		1,
		"27"
	],
	[
		12888,
		1,
		"28"
	],
	[
		12889,
		1,
		"29"
	],
	[
		12890,
		1,
		"30"
	],
	[
		12891,
		1,
		"31"
	],
	[
		12892,
		1,
		"32"
	],
	[
		12893,
		1,
		"33"
	],
	[
		12894,
		1,
		"34"
	],
	[
		12895,
		1,
		"35"
	],
	[
		12896,
		1,
		""
	],
	[
		12897,
		1,
		""
	],
	[
		12898,
		1,
		""
	],
	[
		12899,
		1,
		""
	],
	[
		12900,
		1,
		""
	],
	[
		12901,
		1,
		""
	],
	[
		12902,
		1,
		""
	],
	[
		12903,
		1,
		""
	],
	[
		12904,
		1,
		""
	],
	[
		12905,
		1,
		""
	],
	[
		12906,
		1,
		""
	],
	[
		12907,
		1,
		""
	],
	[
		12908,
		1,
		""
	],
	[
		12909,
		1,
		""
	],
	[
		12910,
		1,
		""
	],
	[
		12911,
		1,
		""
	],
	[
		12912,
		1,
		""
	],
	[
		12913,
		1,
		""
	],
	[
		12914,
		1,
		""
	],
	[
		12915,
		1,
		""
	],
	[
		12916,
		1,
		""
	],
	[
		12917,
		1,
		""
	],
	[
		12918,
		1,
		""
	],
	[
		12919,
		1,
		""
	],
	[
		12920,
		1,
		""
	],
	[
		12921,
		1,
		""
	],
	[
		12922,
		1,
		""
	],
	[
		12923,
		1,
		""
	],
	[
		12924,
		1,
		""
	],
	[
		12925,
		1,
		""
	],
	[
		12926,
		1,
		""
	],
	[
		12927,
		2
	],
	[
		12928,
		1,
		""
	],
	[
		12929,
		1,
		""
	],
	[
		12930,
		1,
		""
	],
	[
		12931,
		1,
		""
	],
	[
		12932,
		1,
		""
	],
	[
		12933,
		1,
		""
	],
	[
		12934,
		1,
		""
	],
	[
		12935,
		1,
		""
	],
	[
		12936,
		1,
		""
	],
	[
		12937,
		1,
		""
	],
	[
		12938,
		1,
		""
	],
	[
		12939,
		1,
		""
	],
	[
		12940,
		1,
		""
	],
	[
		12941,
		1,
		""
	],
	[
		12942,
		1,
		""
	],
	[
		12943,
		1,
		""
	],
	[
		12944,
		1,
		""
	],
	[
		12945,
		1,
		""
	],
	[
		12946,
		1,
		""
	],
	[
		12947,
		1,
		""
	],
	[
		12948,
		1,
		""
	],
	[
		12949,
		1,
		""
	],
	[
		12950,
		1,
		""
	],
	[
		12951,
		1,
		""
	],
	[
		12952,
		1,
		""
	],
	[
		12953,
		1,
		""
	],
	[
		12954,
		1,
		""
	],
	[
		12955,
		1,
		""
	],
	[
		12956,
		1,
		""
	],
	[
		12957,
		1,
		""
	],
	[
		12958,
		1,
		""
	],
	[
		12959,
		1,
		""
	],
	[
		12960,
		1,
		""
	],
	[
		12961,
		1,
		""
	],
	[
		12962,
		1,
		""
	],
	[
		12963,
		1,
		""
	],
	[
		12964,
		1,
		""
	],
	[
		12965,
		1,
		""
	],
	[
		12966,
		1,
		""
	],
	[
		12967,
		1,
		""
	],
	[
		12968,
		1,
		""
	],
	[
		12969,
		1,
		""
	],
	[
		12970,
		1,
		""
	],
	[
		12971,
		1,
		""
	],
	[
		12972,
		1,
		""
	],
	[
		12973,
		1,
		""
	],
	[
		12974,
		1,
		""
	],
	[
		12975,
		1,
		""
	],
	[
		12976,
		1,
		""
	],
	[
		12977,
		1,
		"36"
	],
	[
		12978,
		1,
		"37"
	],
	[
		12979,
		1,
		"38"
	],
	[
		12980,
		1,
		"39"
	],
	[
		12981,
		1,
		"40"
	],
	[
		12982,
		1,
		"41"
	],
	[
		12983,
		1,
		"42"
	],
	[
		12984,
		1,
		"43"
	],
	[
		12985,
		1,
		"44"
	],
	[
		12986,
		1,
		"45"
	],
	[
		12987,
		1,
		"46"
	],
	[
		12988,
		1,
		"47"
	],
	[
		12989,
		1,
		"48"
	],
	[
		12990,
		1,
		"49"
	],
	[
		12991,
		1,
		"50"
	],
	[
		12992,
		1,
		"1"
	],
	[
		12993,
		1,
		"2"
	],
	[
		12994,
		1,
		"3"
	],
	[
		12995,
		1,
		"4"
	],
	[
		12996,
		1,
		"5"
	],
	[
		12997,
		1,
		"6"
	],
	[
		12998,
		1,
		"7"
	],
	[
		12999,
		1,
		"8"
	],
	[
		13000,
		1,
		"9"
	],
	[
		13001,
		1,
		"10"
	],
	[
		13002,
		1,
		"11"
	],
	[
		13003,
		1,
		"12"
	],
	[
		13004,
		1,
		"hg"
	],
	[
		13005,
		1,
		"erg"
	],
	[
		13006,
		1,
		"ev"
	],
	[
		13007,
		1,
		"ltd"
	],
	[
		13008,
		1,
		""
	],
	[
		13009,
		1,
		""
	],
	[
		13010,
		1,
		""
	],
	[
		13011,
		1,
		""
	],
	[
		13012,
		1,
		""
	],
	[
		13013,
		1,
		""
	],
	[
		13014,
		1,
		""
	],
	[
		13015,
		1,
		""
	],
	[
		13016,
		1,
		""
	],
	[
		13017,
		1,
		""
	],
	[
		13018,
		1,
		""
	],
	[
		13019,
		1,
		""
	],
	[
		13020,
		1,
		""
	],
	[
		13021,
		1,
		""
	],
	[
		13022,
		1,
		""
	],
	[
		13023,
		1,
		""
	],
	[
		13024,
		1,
		""
	],
	[
		13025,
		1,
		""
	],
	[
		13026,
		1,
		""
	],
	[
		13027,
		1,
		""
	],
	[
		13028,
		1,
		""
	],
	[
		13029,
		1,
		""
	],
	[
		13030,
		1,
		""
	],
	[
		13031,
		1,
		""
	],
	[
		13032,
		1,
		""
	],
	[
		13033,
		1,
		""
	],
	[
		13034,
		1,
		""
	],
	[
		13035,
		1,
		""
	],
	[
		13036,
		1,
		""
	],
	[
		13037,
		1,
		""
	],
	[
		13038,
		1,
		""
	],
	[
		13039,
		1,
		""
	],
	[
		13040,
		1,
		""
	],
	[
		13041,
		1,
		""
	],
	[
		13042,
		1,
		""
	],
	[
		13043,
		1,
		""
	],
	[
		13044,
		1,
		""
	],
	[
		13045,
		1,
		""
	],
	[
		13046,
		1,
		""
	],
	[
		13047,
		1,
		""
	],
	[
		13048,
		1,
		""
	],
	[
		13049,
		1,
		""
	],
	[
		13050,
		1,
		""
	],
	[
		13051,
		1,
		""
	],
	[
		13052,
		1,
		""
	],
	[
		13053,
		1,
		""
	],
	[
		13054,
		1,
		""
	],
	[
		13055,
		1,
		""
	],
	[
		13056,
		1,
		""
	],
	[
		13057,
		1,
		""
	],
	[
		13058,
		1,
		""
	],
	[
		13059,
		1,
		""
	],
	[
		13060,
		1,
		""
	],
	[
		13061,
		1,
		""
	],
	[
		13062,
		1,
		""
	],
	[
		13063,
		1,
		""
	],
	[
		13064,
		1,
		""
	],
	[
		13065,
		1,
		""
	],
	[
		13066,
		1,
		""
	],
	[
		13067,
		1,
		""
	],
	[
		13068,
		1,
		""
	],
	[
		13069,
		1,
		""
	],
	[
		13070,
		1,
		""
	],
	[
		13071,
		1,
		""
	],
	[
		13072,
		1,
		""
	],
	[
		13073,
		1,
		""
	],
	[
		13074,
		1,
		""
	],
	[
		13075,
		1,
		""
	],
	[
		13076,
		1,
		""
	],
	[
		13077,
		1,
		""
	],
	[
		13078,
		1,
		""
	],
	[
		13079,
		1,
		""
	],
	[
		13080,
		1,
		""
	],
	[
		13081,
		1,
		""
	],
	[
		13082,
		1,
		""
	],
	[
		13083,
		1,
		""
	],
	[
		13084,
		1,
		""
	],
	[
		13085,
		1,
		""
	],
	[
		13086,
		1,
		""
	],
	[
		13087,
		1,
		""
	],
	[
		13088,
		1,
		""
	],
	[
		13089,
		1,
		""
	],
	[
		13090,
		1,
		""
	],
	[
		13091,
		1,
		""
	],
	[
		13092,
		1,
		""
	],
	[
		13093,
		1,
		""
	],
	[
		13094,
		1,
		""
	],
	[
		13095,
		1,
		""
	],
	[
		13096,
		1,
		""
	],
	[
		13097,
		1,
		""
	],
	[
		13098,
		1,
		""
	],
	[
		13099,
		1,
		""
	],
	[
		13100,
		1,
		""
	],
	[
		13101,
		1,
		""
	],
	[
		13102,
		1,
		""
	],
	[
		13103,
		1,
		""
	],
	[
		13104,
		1,
		""
	],
	[
		13105,
		1,
		""
	],
	[
		13106,
		1,
		""
	],
	[
		13107,
		1,
		""
	],
	[
		13108,
		1,
		""
	],
	[
		13109,
		1,
		""
	],
	[
		13110,
		1,
		""
	],
	[
		13111,
		1,
		""
	],
	[
		13112,
		1,
		""
	],
	[
		13113,
		1,
		""
	],
	[
		13114,
		1,
		""
	],
	[
		13115,
		1,
		""
	],
	[
		13116,
		1,
		""
	],
	[
		13117,
		1,
		""
	],
	[
		13118,
		1,
		""
	],
	[
		13119,
		1,
		""
	],
	[
		13120,
		1,
		""
	],
	[
		13121,
		1,
		""
	],
	[
		13122,
		1,
		""
	],
	[
		13123,
		1,
		""
	],
	[
		13124,
		1,
		""
	],
	[
		13125,
		1,
		""
	],
	[
		13126,
		1,
		""
	],
	[
		13127,
		1,
		""
	],
	[
		13128,
		1,
		""
	],
	[
		13129,
		1,
		""
	],
	[
		13130,
		1,
		""
	],
	[
		13131,
		1,
		""
	],
	[
		13132,
		1,
		""
	],
	[
		13133,
		1,
		""
	],
	[
		13134,
		1,
		""
	],
	[
		13135,
		1,
		""
	],
	[
		13136,
		1,
		""
	],
	[
		13137,
		1,
		""
	],
	[
		13138,
		1,
		""
	],
	[
		13139,
		1,
		""
	],
	[
		13140,
		1,
		""
	],
	[
		13141,
		1,
		""
	],
	[
		13142,
		1,
		""
	],
	[
		13143,
		1,
		""
	],
	[
		13144,
		1,
		"0"
	],
	[
		13145,
		1,
		"1"
	],
	[
		13146,
		1,
		"2"
	],
	[
		13147,
		1,
		"3"
	],
	[
		13148,
		1,
		"4"
	],
	[
		13149,
		1,
		"5"
	],
	[
		13150,
		1,
		"6"
	],
	[
		13151,
		1,
		"7"
	],
	[
		13152,
		1,
		"8"
	],
	[
		13153,
		1,
		"9"
	],
	[
		13154,
		1,
		"10"
	],
	[
		13155,
		1,
		"11"
	],
	[
		13156,
		1,
		"12"
	],
	[
		13157,
		1,
		"13"
	],
	[
		13158,
		1,
		"14"
	],
	[
		13159,
		1,
		"15"
	],
	[
		13160,
		1,
		"16"
	],
	[
		13161,
		1,
		"17"
	],
	[
		13162,
		1,
		"18"
	],
	[
		13163,
		1,
		"19"
	],
	[
		13164,
		1,
		"20"
	],
	[
		13165,
		1,
		"21"
	],
	[
		13166,
		1,
		"22"
	],
	[
		13167,
		1,
		"23"
	],
	[
		13168,
		1,
		"24"
	],
	[
		13169,
		1,
		"hpa"
	],
	[
		13170,
		1,
		"da"
	],
	[
		13171,
		1,
		"au"
	],
	[
		13172,
		1,
		"bar"
	],
	[
		13173,
		1,
		"ov"
	],
	[
		13174,
		1,
		"pc"
	],
	[
		13175,
		1,
		"dm"
	],
	[
		13176,
		1,
		"dm2"
	],
	[
		13177,
		1,
		"dm3"
	],
	[
		13178,
		1,
		"iu"
	],
	[
		13179,
		1,
		""
	],
	[
		13180,
		1,
		""
	],
	[
		13181,
		1,
		""
	],
	[
		13182,
		1,
		""
	],
	[
		13183,
		1,
		""
	],
	[
		13184,
		1,
		"pa"
	],
	[
		13185,
		1,
		"na"
	],
	[
		13186,
		1,
		"a"
	],
	[
		13187,
		1,
		"ma"
	],
	[
		13188,
		1,
		"ka"
	],
	[
		13189,
		1,
		"kb"
	],
	[
		13190,
		1,
		"mb"
	],
	[
		13191,
		1,
		"gb"
	],
	[
		13192,
		1,
		"cal"
	],
	[
		13193,
		1,
		"kcal"
	],
	[
		13194,
		1,
		"pf"
	],
	[
		13195,
		1,
		"nf"
	],
	[
		13196,
		1,
		"f"
	],
	[
		13197,
		1,
		"g"
	],
	[
		13198,
		1,
		"mg"
	],
	[
		13199,
		1,
		"kg"
	],
	[
		13200,
		1,
		"hz"
	],
	[
		13201,
		1,
		"khz"
	],
	[
		13202,
		1,
		"mhz"
	],
	[
		13203,
		1,
		"ghz"
	],
	[
		13204,
		1,
		"thz"
	],
	[
		13205,
		1,
		"l"
	],
	[
		13206,
		1,
		"ml"
	],
	[
		13207,
		1,
		"dl"
	],
	[
		13208,
		1,
		"kl"
	],
	[
		13209,
		1,
		"fm"
	],
	[
		13210,
		1,
		"nm"
	],
	[
		13211,
		1,
		"m"
	],
	[
		13212,
		1,
		"mm"
	],
	[
		13213,
		1,
		"cm"
	],
	[
		13214,
		1,
		"km"
	],
	[
		13215,
		1,
		"mm2"
	],
	[
		13216,
		1,
		"cm2"
	],
	[
		13217,
		1,
		"m2"
	],
	[
		13218,
		1,
		"km2"
	],
	[
		13219,
		1,
		"mm3"
	],
	[
		13220,
		1,
		"cm3"
	],
	[
		13221,
		1,
		"m3"
	],
	[
		13222,
		1,
		"km3"
	],
	[
		13223,
		1,
		"ms"
	],
	[
		13224,
		1,
		"ms2"
	],
	[
		13225,
		1,
		"pa"
	],
	[
		13226,
		1,
		"kpa"
	],
	[
		13227,
		1,
		"mpa"
	],
	[
		13228,
		1,
		"gpa"
	],
	[
		13229,
		1,
		"rad"
	],
	[
		13230,
		1,
		"rads"
	],
	[
		13231,
		1,
		"rads2"
	],
	[
		13232,
		1,
		"ps"
	],
	[
		13233,
		1,
		"ns"
	],
	[
		13234,
		1,
		"s"
	],
	[
		13235,
		1,
		"ms"
	],
	[
		13236,
		1,
		"pv"
	],
	[
		13237,
		1,
		"nv"
	],
	[
		13238,
		1,
		"v"
	],
	[
		13239,
		1,
		"mv"
	],
	[
		13240,
		1,
		"kv"
	],
	[
		13241,
		1,
		"mv"
	],
	[
		13242,
		1,
		"pw"
	],
	[
		13243,
		1,
		"nw"
	],
	[
		13244,
		1,
		"w"
	],
	[
		13245,
		1,
		"mw"
	],
	[
		13246,
		1,
		"kw"
	],
	[
		13247,
		1,
		"mw"
	],
	[
		13248,
		1,
		"k"
	],
	[
		13249,
		1,
		"m"
	],
	[
		13250,
		3
	],
	[
		13251,
		1,
		"bq"
	],
	[
		13252,
		1,
		"cc"
	],
	[
		13253,
		1,
		"cd"
	],
	[
		13254,
		1,
		"ckg"
	],
	[
		13255,
		3
	],
	[
		13256,
		1,
		"db"
	],
	[
		13257,
		1,
		"gy"
	],
	[
		13258,
		1,
		"ha"
	],
	[
		13259,
		1,
		"hp"
	],
	[
		13260,
		1,
		"in"
	],
	[
		13261,
		1,
		"kk"
	],
	[
		13262,
		1,
		"km"
	],
	[
		13263,
		1,
		"kt"
	],
	[
		13264,
		1,
		"lm"
	],
	[
		13265,
		1,
		"ln"
	],
	[
		13266,
		1,
		"log"
	],
	[
		13267,
		1,
		"lx"
	],
	[
		13268,
		1,
		"mb"
	],
	[
		13269,
		1,
		"mil"
	],
	[
		13270,
		1,
		"mol"
	],
	[
		13271,
		1,
		"ph"
	],
	[
		13272,
		3
	],
	[
		13273,
		1,
		"ppm"
	],
	[
		13274,
		1,
		"pr"
	],
	[
		13275,
		1,
		"sr"
	],
	[
		13276,
		1,
		"sv"
	],
	[
		13277,
		1,
		"wb"
	],
	[
		13278,
		1,
		"vm"
	],
	[
		13279,
		1,
		"am"
	],
	[
		13280,
		1,
		"1"
	],
	[
		13281,
		1,
		"2"
	],
	[
		13282,
		1,
		"3"
	],
	[
		13283,
		1,
		"4"
	],
	[
		13284,
		1,
		"5"
	],
	[
		13285,
		1,
		"6"
	],
	[
		13286,
		1,
		"7"
	],
	[
		13287,
		1,
		"8"
	],
	[
		13288,
		1,
		"9"
	],
	[
		13289,
		1,
		"10"
	],
	[
		13290,
		1,
		"11"
	],
	[
		13291,
		1,
		"12"
	],
	[
		13292,
		1,
		"13"
	],
	[
		13293,
		1,
		"14"
	],
	[
		13294,
		1,
		"15"
	],
	[
		13295,
		1,
		"16"
	],
	[
		13296,
		1,
		"17"
	],
	[
		13297,
		1,
		"18"
	],
	[
		13298,
		1,
		"19"
	],
	[
		13299,
		1,
		"20"
	],
	[
		13300,
		1,
		"21"
	],
	[
		13301,
		1,
		"22"
	],
	[
		13302,
		1,
		"23"
	],
	[
		13303,
		1,
		"24"
	],
	[
		13304,
		1,
		"25"
	],
	[
		13305,
		1,
		"26"
	],
	[
		13306,
		1,
		"27"
	],
	[
		13307,
		1,
		"28"
	],
	[
		13308,
		1,
		"29"
	],
	[
		13309,
		1,
		"30"
	],
	[
		13310,
		1,
		"31"
	],
	[
		13311,
		1,
		"gal"
	],
	[
		[
			13312,
			19893
		],
		2
	],
	[
		[
			19894,
			19903
		],
		2
	],
	[
		[
			19904,
			19967
		],
		2
	],
	[
		[
			19968,
			40869
		],
		2
	],
	[
		[
			40870,
			40891
		],
		2
	],
	[
		[
			40892,
			40899
		],
		2
	],
	[
		[
			40900,
			40907
		],
		2
	],
	[
		40908,
		2
	],
	[
		[
			40909,
			40917
		],
		2
	],
	[
		[
			40918,
			40938
		],
		2
	],
	[
		[
			40939,
			40943
		],
		2
	],
	[
		[
			40944,
			40956
		],
		2
	],
	[
		[
			40957,
			40959
		],
		2
	],
	[
		[
			40960,
			42124
		],
		2
	],
	[
		[
			42125,
			42127
		],
		3
	],
	[
		[
			42128,
			42145
		],
		2
	],
	[
		[
			42146,
			42147
		],
		2
	],
	[
		[
			42148,
			42163
		],
		2
	],
	[
		42164,
		2
	],
	[
		[
			42165,
			42176
		],
		2
	],
	[
		42177,
		2
	],
	[
		[
			42178,
			42180
		],
		2
	],
	[
		42181,
		2
	],
	[
		42182,
		2
	],
	[
		[
			42183,
			42191
		],
		3
	],
	[
		[
			42192,
			42237
		],
		2
	],
	[
		[
			42238,
			42239
		],
		2
	],
	[
		[
			42240,
			42508
		],
		2
	],
	[
		[
			42509,
			42511
		],
		2
	],
	[
		[
			42512,
			42539
		],
		2
	],
	[
		[
			42540,
			42559
		],
		3
	],
	[
		42560,
		1,
		""
	],
	[
		42561,
		2
	],
	[
		42562,
		1,
		""
	],
	[
		42563,
		2
	],
	[
		42564,
		1,
		""
	],
	[
		42565,
		2
	],
	[
		42566,
		1,
		""
	],
	[
		42567,
		2
	],
	[
		42568,
		1,
		""
	],
	[
		42569,
		2
	],
	[
		42570,
		1,
		""
	],
	[
		42571,
		2
	],
	[
		42572,
		1,
		""
	],
	[
		42573,
		2
	],
	[
		42574,
		1,
		""
	],
	[
		42575,
		2
	],
	[
		42576,
		1,
		""
	],
	[
		42577,
		2
	],
	[
		42578,
		1,
		""
	],
	[
		42579,
		2
	],
	[
		42580,
		1,
		""
	],
	[
		42581,
		2
	],
	[
		42582,
		1,
		""
	],
	[
		42583,
		2
	],
	[
		42584,
		1,
		""
	],
	[
		42585,
		2
	],
	[
		42586,
		1,
		""
	],
	[
		42587,
		2
	],
	[
		42588,
		1,
		""
	],
	[
		42589,
		2
	],
	[
		42590,
		1,
		""
	],
	[
		42591,
		2
	],
	[
		42592,
		1,
		""
	],
	[
		42593,
		2
	],
	[
		42594,
		1,
		""
	],
	[
		42595,
		2
	],
	[
		42596,
		1,
		""
	],
	[
		42597,
		2
	],
	[
		42598,
		1,
		""
	],
	[
		42599,
		2
	],
	[
		42600,
		1,
		""
	],
	[
		42601,
		2
	],
	[
		42602,
		1,
		""
	],
	[
		42603,
		2
	],
	[
		42604,
		1,
		""
	],
	[
		[
			42605,
			42607
		],
		2
	],
	[
		[
			42608,
			42611
		],
		2
	],
	[
		[
			42612,
			42619
		],
		2
	],
	[
		[
			42620,
			42621
		],
		2
	],
	[
		42622,
		2
	],
	[
		42623,
		2
	],
	[
		42624,
		1,
		""
	],
	[
		42625,
		2
	],
	[
		42626,
		1,
		""
	],
	[
		42627,
		2
	],
	[
		42628,
		1,
		""
	],
	[
		42629,
		2
	],
	[
		42630,
		1,
		""
	],
	[
		42631,
		2
	],
	[
		42632,
		1,
		""
	],
	[
		42633,
		2
	],
	[
		42634,
		1,
		""
	],
	[
		42635,
		2
	],
	[
		42636,
		1,
		""
	],
	[
		42637,
		2
	],
	[
		42638,
		1,
		""
	],
	[
		42639,
		2
	],
	[
		42640,
		1,
		""
	],
	[
		42641,
		2
	],
	[
		42642,
		1,
		""
	],
	[
		42643,
		2
	],
	[
		42644,
		1,
		""
	],
	[
		42645,
		2
	],
	[
		42646,
		1,
		""
	],
	[
		42647,
		2
	],
	[
		42648,
		1,
		""
	],
	[
		42649,
		2
	],
	[
		42650,
		1,
		""
	],
	[
		42651,
		2
	],
	[
		42652,
		1,
		""
	],
	[
		42653,
		1,
		""
	],
	[
		42654,
		2
	],
	[
		42655,
		2
	],
	[
		[
			42656,
			42725
		],
		2
	],
	[
		[
			42726,
			42735
		],
		2
	],
	[
		[
			42736,
			42737
		],
		2
	],
	[
		[
			42738,
			42743
		],
		2
	],
	[
		[
			42744,
			42751
		],
		3
	],
	[
		[
			42752,
			42774
		],
		2
	],
	[
		[
			42775,
			42778
		],
		2
	],
	[
		[
			42779,
			42783
		],
		2
	],
	[
		[
			42784,
			42785
		],
		2
	],
	[
		42786,
		1,
		""
	],
	[
		42787,
		2
	],
	[
		42788,
		1,
		""
	],
	[
		42789,
		2
	],
	[
		42790,
		1,
		""
	],
	[
		42791,
		2
	],
	[
		42792,
		1,
		""
	],
	[
		42793,
		2
	],
	[
		42794,
		1,
		""
	],
	[
		42795,
		2
	],
	[
		42796,
		1,
		""
	],
	[
		42797,
		2
	],
	[
		42798,
		1,
		""
	],
	[
		[
			42799,
			42801
		],
		2
	],
	[
		42802,
		1,
		""
	],
	[
		42803,
		2
	],
	[
		42804,
		1,
		""
	],
	[
		42805,
		2
	],
	[
		42806,
		1,
		""
	],
	[
		42807,
		2
	],
	[
		42808,
		1,
		""
	],
	[
		42809,
		2
	],
	[
		42810,
		1,
		""
	],
	[
		42811,
		2
	],
	[
		42812,
		1,
		""
	],
	[
		42813,
		2
	],
	[
		42814,
		1,
		""
	],
	[
		42815,
		2
	],
	[
		42816,
		1,
		""
	],
	[
		42817,
		2
	],
	[
		42818,
		1,
		""
	],
	[
		42819,
		2
	],
	[
		42820,
		1,
		""
	],
	[
		42821,
		2
	],
	[
		42822,
		1,
		""
	],
	[
		42823,
		2
	],
	[
		42824,
		1,
		""
	],
	[
		42825,
		2
	],
	[
		42826,
		1,
		""
	],
	[
		42827,
		2
	],
	[
		42828,
		1,
		""
	],
	[
		42829,
		2
	],
	[
		42830,
		1,
		""
	],
	[
		42831,
		2
	],
	[
		42832,
		1,
		""
	],
	[
		42833,
		2
	],
	[
		42834,
		1,
		""
	],
	[
		42835,
		2
	],
	[
		42836,
		1,
		""
	],
	[
		42837,
		2
	],
	[
		42838,
		1,
		""
	],
	[
		42839,
		2
	],
	[
		42840,
		1,
		""
	],
	[
		42841,
		2
	],
	[
		42842,
		1,
		""
	],
	[
		42843,
		2
	],
	[
		42844,
		1,
		""
	],
	[
		42845,
		2
	],
	[
		42846,
		1,
		""
	],
	[
		42847,
		2
	],
	[
		42848,
		1,
		""
	],
	[
		42849,
		2
	],
	[
		42850,
		1,
		""
	],
	[
		42851,
		2
	],
	[
		42852,
		1,
		""
	],
	[
		42853,
		2
	],
	[
		42854,
		1,
		""
	],
	[
		42855,
		2
	],
	[
		42856,
		1,
		""
	],
	[
		42857,
		2
	],
	[
		42858,
		1,
		""
	],
	[
		42859,
		2
	],
	[
		42860,
		1,
		""
	],
	[
		42861,
		2
	],
	[
		42862,
		1,
		""
	],
	[
		42863,
		2
	],
	[
		42864,
		1,
		""
	],
	[
		[
			42865,
			42872
		],
		2
	],
	[
		42873,
		1,
		""
	],
	[
		42874,
		2
	],
	[
		42875,
		1,
		""
	],
	[
		42876,
		2
	],
	[
		42877,
		1,
		""
	],
	[
		42878,
		1,
		""
	],
	[
		42879,
		2
	],
	[
		42880,
		1,
		""
	],
	[
		42881,
		2
	],
	[
		42882,
		1,
		""
	],
	[
		42883,
		2
	],
	[
		42884,
		1,
		""
	],
	[
		42885,
		2
	],
	[
		42886,
		1,
		""
	],
	[
		[
			42887,
			42888
		],
		2
	],
	[
		[
			42889,
			42890
		],
		2
	],
	[
		42891,
		1,
		""
	],
	[
		42892,
		2
	],
	[
		42893,
		1,
		""
	],
	[
		42894,
		2
	],
	[
		42895,
		2
	],
	[
		42896,
		1,
		""
	],
	[
		42897,
		2
	],
	[
		42898,
		1,
		""
	],
	[
		42899,
		2
	],
	[
		[
			42900,
			42901
		],
		2
	],
	[
		42902,
		1,
		""
	],
	[
		42903,
		2
	],
	[
		42904,
		1,
		""
	],
	[
		42905,
		2
	],
	[
		42906,
		1,
		""
	],
	[
		42907,
		2
	],
	[
		42908,
		1,
		""
	],
	[
		42909,
		2
	],
	[
		42910,
		1,
		""
	],
	[
		42911,
		2
	],
	[
		42912,
		1,
		""
	],
	[
		42913,
		2
	],
	[
		42914,
		1,
		""
	],
	[
		42915,
		2
	],
	[
		42916,
		1,
		""
	],
	[
		42917,
		2
	],
	[
		42918,
		1,
		""
	],
	[
		42919,
		2
	],
	[
		42920,
		1,
		""
	],
	[
		42921,
		2
	],
	[
		42922,
		1,
		""
	],
	[
		42923,
		1,
		""
	],
	[
		42924,
		1,
		""
	],
	[
		42925,
		1,
		""
	],
	[
		42926,
		1,
		""
	],
	[
		42927,
		2
	],
	[
		42928,
		1,
		""
	],
	[
		42929,
		1,
		""
	],
	[
		42930,
		1,
		""
	],
	[
		42931,
		1,
		""
	],
	[
		42932,
		1,
		""
	],
	[
		42933,
		2
	],
	[
		42934,
		1,
		""
	],
	[
		42935,
		2
	],
	[
		42936,
		1,
		""
	],
	[
		42937,
		2
	],
	[
		42938,
		1,
		""
	],
	[
		42939,
		2
	],
	[
		42940,
		1,
		""
	],
	[
		42941,
		2
	],
	[
		42942,
		1,
		""
	],
	[
		42943,
		2
	],
	[
		42944,
		1,
		""
	],
	[
		42945,
		2
	],
	[
		42946,
		1,
		""
	],
	[
		42947,
		2
	],
	[
		42948,
		1,
		""
	],
	[
		42949,
		1,
		""
	],
	[
		42950,
		1,
		""
	],
	[
		42951,
		1,
		""
	],
	[
		42952,
		2
	],
	[
		42953,
		1,
		""
	],
	[
		42954,
		2
	],
	[
		[
			42955,
			42959
		],
		3
	],
	[
		42960,
		1,
		""
	],
	[
		42961,
		2
	],
	[
		42962,
		3
	],
	[
		42963,
		2
	],
	[
		42964,
		3
	],
	[
		42965,
		2
	],
	[
		42966,
		1,
		""
	],
	[
		42967,
		2
	],
	[
		42968,
		1,
		""
	],
	[
		42969,
		2
	],
	[
		[
			42970,
			42993
		],
		3
	],
	[
		42994,
		1,
		"c"
	],
	[
		42995,
		1,
		"f"
	],
	[
		42996,
		1,
		"q"
	],
	[
		42997,
		1,
		""
	],
	[
		42998,
		2
	],
	[
		42999,
		2
	],
	[
		43000,
		1,
		""
	],
	[
		43001,
		1,
		""
	],
	[
		43002,
		2
	],
	[
		[
			43003,
			43007
		],
		2
	],
	[
		[
			43008,
			43047
		],
		2
	],
	[
		[
			43048,
			43051
		],
		2
	],
	[
		43052,
		2
	],
	[
		[
			43053,
			43055
		],
		3
	],
	[
		[
			43056,
			43065
		],
		2
	],
	[
		[
			43066,
			43071
		],
		3
	],
	[
		[
			43072,
			43123
		],
		2
	],
	[
		[
			43124,
			43127
		],
		2
	],
	[
		[
			43128,
			43135
		],
		3
	],
	[
		[
			43136,
			43204
		],
		2
	],
	[
		43205,
		2
	],
	[
		[
			43206,
			43213
		],
		3
	],
	[
		[
			43214,
			43215
		],
		2
	],
	[
		[
			43216,
			43225
		],
		2
	],
	[
		[
			43226,
			43231
		],
		3
	],
	[
		[
			43232,
			43255
		],
		2
	],
	[
		[
			43256,
			43258
		],
		2
	],
	[
		43259,
		2
	],
	[
		43260,
		2
	],
	[
		43261,
		2
	],
	[
		[
			43262,
			43263
		],
		2
	],
	[
		[
			43264,
			43309
		],
		2
	],
	[
		[
			43310,
			43311
		],
		2
	],
	[
		[
			43312,
			43347
		],
		2
	],
	[
		[
			43348,
			43358
		],
		3
	],
	[
		43359,
		2
	],
	[
		[
			43360,
			43388
		],
		2
	],
	[
		[
			43389,
			43391
		],
		3
	],
	[
		[
			43392,
			43456
		],
		2
	],
	[
		[
			43457,
			43469
		],
		2
	],
	[
		43470,
		3
	],
	[
		[
			43471,
			43481
		],
		2
	],
	[
		[
			43482,
			43485
		],
		3
	],
	[
		[
			43486,
			43487
		],
		2
	],
	[
		[
			43488,
			43518
		],
		2
	],
	[
		43519,
		3
	],
	[
		[
			43520,
			43574
		],
		2
	],
	[
		[
			43575,
			43583
		],
		3
	],
	[
		[
			43584,
			43597
		],
		2
	],
	[
		[
			43598,
			43599
		],
		3
	],
	[
		[
			43600,
			43609
		],
		2
	],
	[
		[
			43610,
			43611
		],
		3
	],
	[
		[
			43612,
			43615
		],
		2
	],
	[
		[
			43616,
			43638
		],
		2
	],
	[
		[
			43639,
			43641
		],
		2
	],
	[
		[
			43642,
			43643
		],
		2
	],
	[
		[
			43644,
			43647
		],
		2
	],
	[
		[
			43648,
			43714
		],
		2
	],
	[
		[
			43715,
			43738
		],
		3
	],
	[
		[
			43739,
			43741
		],
		2
	],
	[
		[
			43742,
			43743
		],
		2
	],
	[
		[
			43744,
			43759
		],
		2
	],
	[
		[
			43760,
			43761
		],
		2
	],
	[
		[
			43762,
			43766
		],
		2
	],
	[
		[
			43767,
			43776
		],
		3
	],
	[
		[
			43777,
			43782
		],
		2
	],
	[
		[
			43783,
			43784
		],
		3
	],
	[
		[
			43785,
			43790
		],
		2
	],
	[
		[
			43791,
			43792
		],
		3
	],
	[
		[
			43793,
			43798
		],
		2
	],
	[
		[
			43799,
			43807
		],
		3
	],
	[
		[
			43808,
			43814
		],
		2
	],
	[
		43815,
		3
	],
	[
		[
			43816,
			43822
		],
		2
	],
	[
		43823,
		3
	],
	[
		[
			43824,
			43866
		],
		2
	],
	[
		43867,
		2
	],
	[
		43868,
		1,
		""
	],
	[
		43869,
		1,
		""
	],
	[
		43870,
		1,
		""
	],
	[
		43871,
		1,
		""
	],
	[
		[
			43872,
			43875
		],
		2
	],
	[
		[
			43876,
			43877
		],
		2
	],
	[
		[
			43878,
			43879
		],
		2
	],
	[
		43880,
		2
	],
	[
		43881,
		1,
		""
	],
	[
		[
			43882,
			43883
		],
		2
	],
	[
		[
			43884,
			43887
		],
		3
	],
	[
		43888,
		1,
		""
	],
	[
		43889,
		1,
		""
	],
	[
		43890,
		1,
		""
	],
	[
		43891,
		1,
		""
	],
	[
		43892,
		1,
		""
	],
	[
		43893,
		1,
		""
	],
	[
		43894,
		1,
		""
	],
	[
		43895,
		1,
		""
	],
	[
		43896,
		1,
		""
	],
	[
		43897,
		1,
		""
	],
	[
		43898,
		1,
		""
	],
	[
		43899,
		1,
		""
	],
	[
		43900,
		1,
		""
	],
	[
		43901,
		1,
		""
	],
	[
		43902,
		1,
		""
	],
	[
		43903,
		1,
		""
	],
	[
		43904,
		1,
		""
	],
	[
		43905,
		1,
		""
	],
	[
		43906,
		1,
		""
	],
	[
		43907,
		1,
		""
	],
	[
		43908,
		1,
		""
	],
	[
		43909,
		1,
		""
	],
	[
		43910,
		1,
		""
	],
	[
		43911,
		1,
		""
	],
	[
		43912,
		1,
		""
	],
	[
		43913,
		1,
		""
	],
	[
		43914,
		1,
		""
	],
	[
		43915,
		1,
		""
	],
	[
		43916,
		1,
		""
	],
	[
		43917,
		1,
		""
	],
	[
		43918,
		1,
		""
	],
	[
		43919,
		1,
		""
	],
	[
		43920,
		1,
		""
	],
	[
		43921,
		1,
		""
	],
	[
		43922,
		1,
		""
	],
	[
		43923,
		1,
		""
	],
	[
		43924,
		1,
		""
	],
	[
		43925,
		1,
		""
	],
	[
		43926,
		1,
		""
	],
	[
		43927,
		1,
		""
	],
	[
		43928,
		1,
		""
	],
	[
		43929,
		1,
		""
	],
	[
		43930,
		1,
		""
	],
	[
		43931,
		1,
		""
	],
	[
		43932,
		1,
		""
	],
	[
		43933,
		1,
		""
	],
	[
		43934,
		1,
		""
	],
	[
		43935,
		1,
		""
	],
	[
		43936,
		1,
		""
	],
	[
		43937,
		1,
		""
	],
	[
		43938,
		1,
		""
	],
	[
		43939,
		1,
		""
	],
	[
		43940,
		1,
		""
	],
	[
		43941,
		1,
		""
	],
	[
		43942,
		1,
		""
	],
	[
		43943,
		1,
		""
	],
	[
		43944,
		1,
		""
	],
	[
		43945,
		1,
		""
	],
	[
		43946,
		1,
		""
	],
	[
		43947,
		1,
		""
	],
	[
		43948,
		1,
		""
	],
	[
		43949,
		1,
		""
	],
	[
		43950,
		1,
		""
	],
	[
		43951,
		1,
		""
	],
	[
		43952,
		1,
		""
	],
	[
		43953,
		1,
		""
	],
	[
		43954,
		1,
		""
	],
	[
		43955,
		1,
		""
	],
	[
		43956,
		1,
		""
	],
	[
		43957,
		1,
		""
	],
	[
		43958,
		1,
		""
	],
	[
		43959,
		1,
		""
	],
	[
		43960,
		1,
		""
	],
	[
		43961,
		1,
		""
	],
	[
		43962,
		1,
		""
	],
	[
		43963,
		1,
		""
	],
	[
		43964,
		1,
		""
	],
	[
		43965,
		1,
		""
	],
	[
		43966,
		1,
		""
	],
	[
		43967,
		1,
		""
	],
	[
		[
			43968,
			44010
		],
		2
	],
	[
		44011,
		2
	],
	[
		[
			44012,
			44013
		],
		2
	],
	[
		[
			44014,
			44015
		],
		3
	],
	[
		[
			44016,
			44025
		],
		2
	],
	[
		[
			44026,
			44031
		],
		3
	],
	[
		[
			44032,
			55203
		],
		2
	],
	[
		[
			55204,
			55215
		],
		3
	],
	[
		[
			55216,
			55238
		],
		2
	],
	[
		[
			55239,
			55242
		],
		3
	],
	[
		[
			55243,
			55291
		],
		2
	],
	[
		[
			55292,
			55295
		],
		3
	],
	[
		[
			55296,
			57343
		],
		3
	],
	[
		[
			57344,
			63743
		],
		3
	],
	[
		63744,
		1,
		""
	],
	[
		63745,
		1,
		""
	],
	[
		63746,
		1,
		""
	],
	[
		63747,
		1,
		""
	],
	[
		63748,
		1,
		""
	],
	[
		63749,
		1,
		""
	],
	[
		63750,
		1,
		""
	],
	[
		[
			63751,
			63752
		],
		1,
		""
	],
	[
		63753,
		1,
		""
	],
	[
		63754,
		1,
		""
	],
	[
		63755,
		1,
		""
	],
	[
		63756,
		1,
		""
	],
	[
		63757,
		1,
		""
	],
	[
		63758,
		1,
		""
	],
	[
		63759,
		1,
		""
	],
	[
		63760,
		1,
		""
	],
	[
		63761,
		1,
		""
	],
	[
		63762,
		1,
		""
	],
	[
		63763,
		1,
		""
	],
	[
		63764,
		1,
		""
	],
	[
		63765,
		1,
		""
	],
	[
		63766,
		1,
		""
	],
	[
		63767,
		1,
		""
	],
	[
		63768,
		1,
		""
	],
	[
		63769,
		1,
		""
	],
	[
		63770,
		1,
		""
	],
	[
		63771,
		1,
		""
	],
	[
		63772,
		1,
		""
	],
	[
		63773,
		1,
		""
	],
	[
		63774,
		1,
		""
	],
	[
		63775,
		1,
		""
	],
	[
		63776,
		1,
		""
	],
	[
		63777,
		1,
		""
	],
	[
		63778,
		1,
		""
	],
	[
		63779,
		1,
		""
	],
	[
		63780,
		1,
		""
	],
	[
		63781,
		1,
		""
	],
	[
		63782,
		1,
		""
	],
	[
		63783,
		1,
		""
	],
	[
		63784,
		1,
		""
	],
	[
		63785,
		1,
		""
	],
	[
		63786,
		1,
		""
	],
	[
		63787,
		1,
		""
	],
	[
		63788,
		1,
		""
	],
	[
		63789,
		1,
		""
	],
	[
		63790,
		1,
		""
	],
	[
		63791,
		1,
		""
	],
	[
		63792,
		1,
		""
	],
	[
		63793,
		1,
		""
	],
	[
		63794,
		1,
		""
	],
	[
		63795,
		1,
		""
	],
	[
		63796,
		1,
		""
	],
	[
		63797,
		1,
		""
	],
	[
		63798,
		1,
		""
	],
	[
		63799,
		1,
		""
	],
	[
		63800,
		1,
		""
	],
	[
		63801,
		1,
		""
	],
	[
		63802,
		1,
		""
	],
	[
		63803,
		1,
		""
	],
	[
		63804,
		1,
		""
	],
	[
		63805,
		1,
		""
	],
	[
		63806,
		1,
		""
	],
	[
		63807,
		1,
		""
	],
	[
		63808,
		1,
		""
	],
	[
		63809,
		1,
		""
	],
	[
		63810,
		1,
		""
	],
	[
		63811,
		1,
		""
	],
	[
		63812,
		1,
		""
	],
	[
		63813,
		1,
		""
	],
	[
		63814,
		1,
		""
	],
	[
		63815,
		1,
		""
	],
	[
		63816,
		1,
		""
	],
	[
		63817,
		1,
		""
	],
	[
		63818,
		1,
		""
	],
	[
		63819,
		1,
		""
	],
	[
		63820,
		1,
		""
	],
	[
		63821,
		1,
		""
	],
	[
		63822,
		1,
		""
	],
	[
		63823,
		1,
		""
	],
	[
		63824,
		1,
		""
	],
	[
		63825,
		1,
		""
	],
	[
		63826,
		1,
		""
	],
	[
		63827,
		1,
		""
	],
	[
		63828,
		1,
		""
	],
	[
		63829,
		1,
		""
	],
	[
		63830,
		1,
		""
	],
	[
		63831,
		1,
		""
	],
	[
		63832,
		1,
		""
	],
	[
		63833,
		1,
		""
	],
	[
		63834,
		1,
		""
	],
	[
		63835,
		1,
		""
	],
	[
		63836,
		1,
		""
	],
	[
		63837,
		1,
		""
	],
	[
		63838,
		1,
		""
	],
	[
		63839,
		1,
		""
	],
	[
		63840,
		1,
		""
	],
	[
		63841,
		1,
		""
	],
	[
		63842,
		1,
		""
	],
	[
		63843,
		1,
		""
	],
	[
		63844,
		1,
		""
	],
	[
		63845,
		1,
		""
	],
	[
		63846,
		1,
		""
	],
	[
		63847,
		1,
		""
	],
	[
		63848,
		1,
		""
	],
	[
		63849,
		1,
		""
	],
	[
		63850,
		1,
		""
	],
	[
		63851,
		1,
		""
	],
	[
		63852,
		1,
		""
	],
	[
		63853,
		1,
		""
	],
	[
		63854,
		1,
		""
	],
	[
		63855,
		1,
		""
	],
	[
		63856,
		1,
		""
	],
	[
		63857,
		1,
		""
	],
	[
		63858,
		1,
		""
	],
	[
		63859,
		1,
		""
	],
	[
		63860,
		1,
		""
	],
	[
		63861,
		1,
		""
	],
	[
		63862,
		1,
		""
	],
	[
		63863,
		1,
		""
	],
	[
		63864,
		1,
		""
	],
	[
		63865,
		1,
		""
	],
	[
		63866,
		1,
		""
	],
	[
		63867,
		1,
		""
	],
	[
		63868,
		1,
		""
	],
	[
		63869,
		1,
		""
	],
	[
		63870,
		1,
		""
	],
	[
		63871,
		1,
		""
	],
	[
		63872,
		1,
		""
	],
	[
		63873,
		1,
		""
	],
	[
		63874,
		1,
		""
	],
	[
		63875,
		1,
		""
	],
	[
		63876,
		1,
		""
	],
	[
		63877,
		1,
		""
	],
	[
		63878,
		1,
		""
	],
	[
		63879,
		1,
		""
	],
	[
		63880,
		1,
		""
	],
	[
		63881,
		1,
		""
	],
	[
		63882,
		1,
		""
	],
	[
		63883,
		1,
		""
	],
	[
		63884,
		1,
		""
	],
	[
		63885,
		1,
		""
	],
	[
		63886,
		1,
		""
	],
	[
		63887,
		1,
		""
	],
	[
		63888,
		1,
		""
	],
	[
		63889,
		1,
		""
	],
	[
		63890,
		1,
		""
	],
	[
		63891,
		1,
		""
	],
	[
		63892,
		1,
		""
	],
	[
		63893,
		1,
		""
	],
	[
		63894,
		1,
		""
	],
	[
		63895,
		1,
		""
	],
	[
		63896,
		1,
		""
	],
	[
		63897,
		1,
		""
	],
	[
		63898,
		1,
		""
	],
	[
		63899,
		1,
		""
	],
	[
		63900,
		1,
		""
	],
	[
		63901,
		1,
		""
	],
	[
		63902,
		1,
		""
	],
	[
		63903,
		1,
		""
	],
	[
		63904,
		1,
		""
	],
	[
		63905,
		1,
		""
	],
	[
		63906,
		1,
		""
	],
	[
		63907,
		1,
		""
	],
	[
		63908,
		1,
		""
	],
	[
		63909,
		1,
		""
	],
	[
		63910,
		1,
		""
	],
	[
		63911,
		1,
		""
	],
	[
		63912,
		1,
		""
	],
	[
		63913,
		1,
		""
	],
	[
		63914,
		1,
		""
	],
	[
		63915,
		1,
		""
	],
	[
		63916,
		1,
		""
	],
	[
		63917,
		1,
		""
	],
	[
		63918,
		1,
		""
	],
	[
		63919,
		1,
		""
	],
	[
		63920,
		1,
		""
	],
	[
		63921,
		1,
		""
	],
	[
		63922,
		1,
		""
	],
	[
		63923,
		1,
		""
	],
	[
		63924,
		1,
		""
	],
	[
		63925,
		1,
		""
	],
	[
		63926,
		1,
		""
	],
	[
		63927,
		1,
		""
	],
	[
		63928,
		1,
		""
	],
	[
		63929,
		1,
		""
	],
	[
		63930,
		1,
		""
	],
	[
		63931,
		1,
		""
	],
	[
		63932,
		1,
		""
	],
	[
		63933,
		1,
		""
	],
	[
		63934,
		1,
		""
	],
	[
		63935,
		1,
		""
	],
	[
		63936,
		1,
		""
	],
	[
		63937,
		1,
		""
	],
	[
		63938,
		1,
		""
	],
	[
		63939,
		1,
		""
	],
	[
		63940,
		1,
		""
	],
	[
		63941,
		1,
		""
	],
	[
		63942,
		1,
		""
	],
	[
		63943,
		1,
		""
	],
	[
		63944,
		1,
		""
	],
	[
		63945,
		1,
		""
	],
	[
		63946,
		1,
		""
	],
	[
		63947,
		1,
		""
	],
	[
		63948,
		1,
		""
	],
	[
		63949,
		1,
		""
	],
	[
		63950,
		1,
		""
	],
	[
		63951,
		1,
		""
	],
	[
		63952,
		1,
		""
	],
	[
		63953,
		1,
		""
	],
	[
		63954,
		1,
		""
	],
	[
		63955,
		1,
		""
	],
	[
		63956,
		1,
		""
	],
	[
		63957,
		1,
		""
	],
	[
		63958,
		1,
		""
	],
	[
		63959,
		1,
		""
	],
	[
		63960,
		1,
		""
	],
	[
		63961,
		1,
		""
	],
	[
		63962,
		1,
		""
	],
	[
		63963,
		1,
		""
	],
	[
		63964,
		1,
		""
	],
	[
		63965,
		1,
		""
	],
	[
		63966,
		1,
		""
	],
	[
		63967,
		1,
		""
	],
	[
		63968,
		1,
		""
	],
	[
		63969,
		1,
		""
	],
	[
		63970,
		1,
		""
	],
	[
		63971,
		1,
		""
	],
	[
		63972,
		1,
		""
	],
	[
		63973,
		1,
		""
	],
	[
		63974,
		1,
		""
	],
	[
		63975,
		1,
		""
	],
	[
		63976,
		1,
		""
	],
	[
		63977,
		1,
		""
	],
	[
		63978,
		1,
		""
	],
	[
		63979,
		1,
		""
	],
	[
		63980,
		1,
		""
	],
	[
		63981,
		1,
		""
	],
	[
		63982,
		1,
		""
	],
	[
		63983,
		1,
		""
	],
	[
		63984,
		1,
		""
	],
	[
		63985,
		1,
		""
	],
	[
		63986,
		1,
		""
	],
	[
		63987,
		1,
		""
	],
	[
		63988,
		1,
		""
	],
	[
		63989,
		1,
		""
	],
	[
		63990,
		1,
		""
	],
	[
		63991,
		1,
		""
	],
	[
		63992,
		1,
		""
	],
	[
		63993,
		1,
		""
	],
	[
		63994,
		1,
		""
	],
	[
		63995,
		1,
		""
	],
	[
		63996,
		1,
		""
	],
	[
		63997,
		1,
		""
	],
	[
		63998,
		1,
		""
	],
	[
		63999,
		1,
		""
	],
	[
		64000,
		1,
		""
	],
	[
		64001,
		1,
		""
	],
	[
		64002,
		1,
		""
	],
	[
		64003,
		1,
		""
	],
	[
		64004,
		1,
		""
	],
	[
		64005,
		1,
		""
	],
	[
		64006,
		1,
		""
	],
	[
		64007,
		1,
		""
	],
	[
		64008,
		1,
		""
	],
	[
		64009,
		1,
		""
	],
	[
		64010,
		1,
		""
	],
	[
		64011,
		1,
		""
	],
	[
		64012,
		1,
		""
	],
	[
		64013,
		1,
		""
	],
	[
		[
			64014,
			64015
		],
		2
	],
	[
		64016,
		1,
		""
	],
	[
		64017,
		2
	],
	[
		64018,
		1,
		""
	],
	[
		[
			64019,
			64020
		],
		2
	],
	[
		64021,
		1,
		""
	],
	[
		64022,
		1,
		""
	],
	[
		64023,
		1,
		""
	],
	[
		64024,
		1,
		""
	],
	[
		64025,
		1,
		""
	],
	[
		64026,
		1,
		""
	],
	[
		64027,
		1,
		""
	],
	[
		64028,
		1,
		""
	],
	[
		64029,
		1,
		""
	],
	[
		64030,
		1,
		""
	],
	[
		64031,
		2
	],
	[
		64032,
		1,
		""
	],
	[
		64033,
		2
	],
	[
		64034,
		1,
		""
	],
	[
		[
			64035,
			64036
		],
		2
	],
	[
		64037,
		1,
		""
	],
	[
		64038,
		1,
		""
	],
	[
		[
			64039,
			64041
		],
		2
	],
	[
		64042,
		1,
		""
	],
	[
		64043,
		1,
		""
	],
	[
		64044,
		1,
		""
	],
	[
		64045,
		1,
		""
	],
	[
		64046,
		1,
		""
	],
	[
		64047,
		1,
		""
	],
	[
		64048,
		1,
		""
	],
	[
		64049,
		1,
		""
	],
	[
		64050,
		1,
		""
	],
	[
		64051,
		1,
		""
	],
	[
		64052,
		1,
		""
	],
	[
		64053,
		1,
		""
	],
	[
		64054,
		1,
		""
	],
	[
		64055,
		1,
		""
	],
	[
		64056,
		1,
		""
	],
	[
		64057,
		1,
		""
	],
	[
		64058,
		1,
		""
	],
	[
		64059,
		1,
		""
	],
	[
		64060,
		1,
		""
	],
	[
		64061,
		1,
		""
	],
	[
		64062,
		1,
		""
	],
	[
		64063,
		1,
		""
	],
	[
		64064,
		1,
		""
	],
	[
		64065,
		1,
		""
	],
	[
		64066,
		1,
		""
	],
	[
		64067,
		1,
		""
	],
	[
		64068,
		1,
		""
	],
	[
		64069,
		1,
		""
	],
	[
		64070,
		1,
		""
	],
	[
		64071,
		1,
		""
	],
	[
		64072,
		1,
		""
	],
	[
		64073,
		1,
		""
	],
	[
		64074,
		1,
		""
	],
	[
		64075,
		1,
		""
	],
	[
		64076,
		1,
		""
	],
	[
		64077,
		1,
		""
	],
	[
		64078,
		1,
		""
	],
	[
		64079,
		1,
		""
	],
	[
		64080,
		1,
		""
	],
	[
		64081,
		1,
		""
	],
	[
		64082,
		1,
		""
	],
	[
		64083,
		1,
		""
	],
	[
		64084,
		1,
		""
	],
	[
		64085,
		1,
		""
	],
	[
		64086,
		1,
		""
	],
	[
		64087,
		1,
		""
	],
	[
		64088,
		1,
		""
	],
	[
		64089,
		1,
		""
	],
	[
		64090,
		1,
		""
	],
	[
		64091,
		1,
		""
	],
	[
		64092,
		1,
		""
	],
	[
		[
			64093,
			64094
		],
		1,
		""
	],
	[
		64095,
		1,
		""
	],
	[
		64096,
		1,
		""
	],
	[
		64097,
		1,
		""
	],
	[
		64098,
		1,
		""
	],
	[
		64099,
		1,
		""
	],
	[
		64100,
		1,
		""
	],
	[
		64101,
		1,
		""
	],
	[
		64102,
		1,
		""
	],
	[
		64103,
		1,
		""
	],
	[
		64104,
		1,
		""
	],
	[
		64105,
		1,
		""
	],
	[
		64106,
		1,
		""
	],
	[
		64107,
		1,
		""
	],
	[
		64108,
		1,
		""
	],
	[
		64109,
		1,
		""
	],
	[
		[
			64110,
			64111
		],
		3
	],
	[
		64112,
		1,
		""
	],
	[
		64113,
		1,
		""
	],
	[
		64114,
		1,
		""
	],
	[
		64115,
		1,
		""
	],
	[
		64116,
		1,
		""
	],
	[
		64117,
		1,
		""
	],
	[
		64118,
		1,
		""
	],
	[
		64119,
		1,
		""
	],
	[
		64120,
		1,
		""
	],
	[
		64121,
		1,
		""
	],
	[
		64122,
		1,
		""
	],
	[
		64123,
		1,
		""
	],
	[
		64124,
		1,
		""
	],
	[
		64125,
		1,
		""
	],
	[
		64126,
		1,
		""
	],
	[
		64127,
		1,
		""
	],
	[
		64128,
		1,
		""
	],
	[
		64129,
		1,
		""
	],
	[
		64130,
		1,
		""
	],
	[
		64131,
		1,
		""
	],
	[
		64132,
		1,
		""
	],
	[
		64133,
		1,
		""
	],
	[
		64134,
		1,
		""
	],
	[
		64135,
		1,
		""
	],
	[
		64136,
		1,
		""
	],
	[
		64137,
		1,
		""
	],
	[
		64138,
		1,
		""
	],
	[
		64139,
		1,
		""
	],
	[
		64140,
		1,
		""
	],
	[
		64141,
		1,
		""
	],
	[
		64142,
		1,
		""
	],
	[
		64143,
		1,
		""
	],
	[
		64144,
		1,
		""
	],
	[
		64145,
		1,
		""
	],
	[
		64146,
		1,
		""
	],
	[
		64147,
		1,
		""
	],
	[
		64148,
		1,
		""
	],
	[
		64149,
		1,
		""
	],
	[
		64150,
		1,
		""
	],
	[
		64151,
		1,
		""
	],
	[
		64152,
		1,
		""
	],
	[
		64153,
		1,
		""
	],
	[
		64154,
		1,
		""
	],
	[
		64155,
		1,
		""
	],
	[
		64156,
		1,
		""
	],
	[
		64157,
		1,
		""
	],
	[
		64158,
		1,
		""
	],
	[
		64159,
		1,
		""
	],
	[
		64160,
		1,
		""
	],
	[
		64161,
		1,
		""
	],
	[
		64162,
		1,
		""
	],
	[
		64163,
		1,
		""
	],
	[
		64164,
		1,
		""
	],
	[
		64165,
		1,
		""
	],
	[
		64166,
		1,
		""
	],
	[
		64167,
		1,
		""
	],
	[
		64168,
		1,
		""
	],
	[
		64169,
		1,
		""
	],
	[
		64170,
		1,
		""
	],
	[
		64171,
		1,
		""
	],
	[
		64172,
		1,
		""
	],
	[
		64173,
		1,
		""
	],
	[
		64174,
		1,
		""
	],
	[
		64175,
		1,
		""
	],
	[
		64176,
		1,
		""
	],
	[
		64177,
		1,
		""
	],
	[
		64178,
		1,
		""
	],
	[
		64179,
		1,
		""
	],
	[
		64180,
		1,
		""
	],
	[
		64181,
		1,
		""
	],
	[
		64182,
		1,
		""
	],
	[
		64183,
		1,
		""
	],
	[
		64184,
		1,
		""
	],
	[
		64185,
		1,
		""
	],
	[
		64186,
		1,
		""
	],
	[
		64187,
		1,
		""
	],
	[
		64188,
		1,
		""
	],
	[
		64189,
		1,
		""
	],
	[
		64190,
		1,
		""
	],
	[
		64191,
		1,
		""
	],
	[
		64192,
		1,
		""
	],
	[
		64193,
		1,
		""
	],
	[
		64194,
		1,
		""
	],
	[
		64195,
		1,
		""
	],
	[
		64196,
		1,
		""
	],
	[
		64197,
		1,
		""
	],
	[
		64198,
		1,
		""
	],
	[
		64199,
		1,
		""
	],
	[
		64200,
		1,
		""
	],
	[
		64201,
		1,
		""
	],
	[
		64202,
		1,
		""
	],
	[
		64203,
		1,
		""
	],
	[
		64204,
		1,
		""
	],
	[
		64205,
		1,
		""
	],
	[
		64206,
		1,
		""
	],
	[
		64207,
		1,
		""
	],
	[
		64208,
		1,
		""
	],
	[
		64209,
		1,
		""
	],
	[
		64210,
		1,
		""
	],
	[
		64211,
		1,
		""
	],
	[
		64212,
		1,
		""
	],
	[
		64213,
		1,
		""
	],
	[
		64214,
		1,
		""
	],
	[
		64215,
		1,
		""
	],
	[
		64216,
		1,
		""
	],
	[
		64217,
		1,
		""
	],
	[
		[
			64218,
			64255
		],
		3
	],
	[
		64256,
		1,
		"ff"
	],
	[
		64257,
		1,
		"fi"
	],
	[
		64258,
		1,
		"fl"
	],
	[
		64259,
		1,
		"ffi"
	],
	[
		64260,
		1,
		"ffl"
	],
	[
		[
			64261,
			64262
		],
		1,
		"st"
	],
	[
		[
			64263,
			64274
		],
		3
	],
	[
		64275,
		1,
		""
	],
	[
		64276,
		1,
		""
	],
	[
		64277,
		1,
		""
	],
	[
		64278,
		1,
		""
	],
	[
		64279,
		1,
		""
	],
	[
		[
			64280,
			64284
		],
		3
	],
	[
		64285,
		1,
		""
	],
	[
		64286,
		2
	],
	[
		64287,
		1,
		""
	],
	[
		64288,
		1,
		""
	],
	[
		64289,
		1,
		""
	],
	[
		64290,
		1,
		""
	],
	[
		64291,
		1,
		""
	],
	[
		64292,
		1,
		""
	],
	[
		64293,
		1,
		""
	],
	[
		64294,
		1,
		""
	],
	[
		64295,
		1,
		""
	],
	[
		64296,
		1,
		""
	],
	[
		64297,
		5,
		"+"
	],
	[
		64298,
		1,
		""
	],
	[
		64299,
		1,
		""
	],
	[
		64300,
		1,
		""
	],
	[
		64301,
		1,
		""
	],
	[
		64302,
		1,
		""
	],
	[
		64303,
		1,
		""
	],
	[
		64304,
		1,
		""
	],
	[
		64305,
		1,
		""
	],
	[
		64306,
		1,
		""
	],
	[
		64307,
		1,
		""
	],
	[
		64308,
		1,
		""
	],
	[
		64309,
		1,
		""
	],
	[
		64310,
		1,
		""
	],
	[
		64311,
		3
	],
	[
		64312,
		1,
		""
	],
	[
		64313,
		1,
		""
	],
	[
		64314,
		1,
		""
	],
	[
		64315,
		1,
		""
	],
	[
		64316,
		1,
		""
	],
	[
		64317,
		3
	],
	[
		64318,
		1,
		""
	],
	[
		64319,
		3
	],
	[
		64320,
		1,
		""
	],
	[
		64321,
		1,
		""
	],
	[
		64322,
		3
	],
	[
		64323,
		1,
		""
	],
	[
		64324,
		1,
		""
	],
	[
		64325,
		3
	],
	[
		64326,
		1,
		""
	],
	[
		64327,
		1,
		""
	],
	[
		64328,
		1,
		""
	],
	[
		64329,
		1,
		""
	],
	[
		64330,
		1,
		""
	],
	[
		64331,
		1,
		""
	],
	[
		64332,
		1,
		""
	],
	[
		64333,
		1,
		""
	],
	[
		64334,
		1,
		""
	],
	[
		64335,
		1,
		""
	],
	[
		[
			64336,
			64337
		],
		1,
		""
	],
	[
		[
			64338,
			64341
		],
		1,
		""
	],
	[
		[
			64342,
			64345
		],
		1,
		""
	],
	[
		[
			64346,
			64349
		],
		1,
		""
	],
	[
		[
			64350,
			64353
		],
		1,
		""
	],
	[
		[
			64354,
			64357
		],
		1,
		""
	],
	[
		[
			64358,
			64361
		],
		1,
		""
	],
	[
		[
			64362,
			64365
		],
		1,
		""
	],
	[
		[
			64366,
			64369
		],
		1,
		""
	],
	[
		[
			64370,
			64373
		],
		1,
		""
	],
	[
		[
			64374,
			64377
		],
		1,
		""
	],
	[
		[
			64378,
			64381
		],
		1,
		""
	],
	[
		[
			64382,
			64385
		],
		1,
		""
	],
	[
		[
			64386,
			64387
		],
		1,
		""
	],
	[
		[
			64388,
			64389
		],
		1,
		""
	],
	[
		[
			64390,
			64391
		],
		1,
		""
	],
	[
		[
			64392,
			64393
		],
		1,
		""
	],
	[
		[
			64394,
			64395
		],
		1,
		""
	],
	[
		[
			64396,
			64397
		],
		1,
		""
	],
	[
		[
			64398,
			64401
		],
		1,
		""
	],
	[
		[
			64402,
			64405
		],
		1,
		""
	],
	[
		[
			64406,
			64409
		],
		1,
		""
	],
	[
		[
			64410,
			64413
		],
		1,
		""
	],
	[
		[
			64414,
			64415
		],
		1,
		""
	],
	[
		[
			64416,
			64419
		],
		1,
		""
	],
	[
		[
			64420,
			64421
		],
		1,
		""
	],
	[
		[
			64422,
			64425
		],
		1,
		""
	],
	[
		[
			64426,
			64429
		],
		1,
		""
	],
	[
		[
			64430,
			64431
		],
		1,
		""
	],
	[
		[
			64432,
			64433
		],
		1,
		""
	],
	[
		[
			64434,
			64449
		],
		2
	],
	[
		64450,
		2
	],
	[
		[
			64451,
			64466
		],
		3
	],
	[
		[
			64467,
			64470
		],
		1,
		""
	],
	[
		[
			64471,
			64472
		],
		1,
		""
	],
	[
		[
			64473,
			64474
		],
		1,
		""
	],
	[
		[
			64475,
			64476
		],
		1,
		""
	],
	[
		64477,
		1,
		""
	],
	[
		[
			64478,
			64479
		],
		1,
		""
	],
	[
		[
			64480,
			64481
		],
		1,
		""
	],
	[
		[
			64482,
			64483
		],
		1,
		""
	],
	[
		[
			64484,
			64487
		],
		1,
		""
	],
	[
		[
			64488,
			64489
		],
		1,
		""
	],
	[
		[
			64490,
			64491
		],
		1,
		""
	],
	[
		[
			64492,
			64493
		],
		1,
		""
	],
	[
		[
			64494,
			64495
		],
		1,
		""
	],
	[
		[
			64496,
			64497
		],
		1,
		""
	],
	[
		[
			64498,
			64499
		],
		1,
		""
	],
	[
		[
			64500,
			64501
		],
		1,
		""
	],
	[
		[
			64502,
			64504
		],
		1,
		""
	],
	[
		[
			64505,
			64507
		],
		1,
		""
	],
	[
		[
			64508,
			64511
		],
		1,
		""
	],
	[
		64512,
		1,
		""
	],
	[
		64513,
		1,
		""
	],
	[
		64514,
		1,
		""
	],
	[
		64515,
		1,
		""
	],
	[
		64516,
		1,
		""
	],
	[
		64517,
		1,
		""
	],
	[
		64518,
		1,
		""
	],
	[
		64519,
		1,
		""
	],
	[
		64520,
		1,
		""
	],
	[
		64521,
		1,
		""
	],
	[
		64522,
		1,
		""
	],
	[
		64523,
		1,
		""
	],
	[
		64524,
		1,
		""
	],
	[
		64525,
		1,
		""
	],
	[
		64526,
		1,
		""
	],
	[
		64527,
		1,
		""
	],
	[
		64528,
		1,
		""
	],
	[
		64529,
		1,
		""
	],
	[
		64530,
		1,
		""
	],
	[
		64531,
		1,
		""
	],
	[
		64532,
		1,
		""
	],
	[
		64533,
		1,
		""
	],
	[
		64534,
		1,
		""
	],
	[
		64535,
		1,
		""
	],
	[
		64536,
		1,
		""
	],
	[
		64537,
		1,
		""
	],
	[
		64538,
		1,
		""
	],
	[
		64539,
		1,
		""
	],
	[
		64540,
		1,
		""
	],
	[
		64541,
		1,
		""
	],
	[
		64542,
		1,
		""
	],
	[
		64543,
		1,
		""
	],
	[
		64544,
		1,
		""
	],
	[
		64545,
		1,
		""
	],
	[
		64546,
		1,
		""
	],
	[
		64547,
		1,
		""
	],
	[
		64548,
		1,
		""
	],
	[
		64549,
		1,
		""
	],
	[
		64550,
		1,
		""
	],
	[
		64551,
		1,
		""
	],
	[
		64552,
		1,
		""
	],
	[
		64553,
		1,
		""
	],
	[
		64554,
		1,
		""
	],
	[
		64555,
		1,
		""
	],
	[
		64556,
		1,
		""
	],
	[
		64557,
		1,
		""
	],
	[
		64558,
		1,
		""
	],
	[
		64559,
		1,
		""
	],
	[
		64560,
		1,
		""
	],
	[
		64561,
		1,
		""
	],
	[
		64562,
		1,
		""
	],
	[
		64563,
		1,
		""
	],
	[
		64564,
		1,
		""
	],
	[
		64565,
		1,
		""
	],
	[
		64566,
		1,
		""
	],
	[
		64567,
		1,
		""
	],
	[
		64568,
		1,
		""
	],
	[
		64569,
		1,
		""
	],
	[
		64570,
		1,
		""
	],
	[
		64571,
		1,
		""
	],
	[
		64572,
		1,
		""
	],
	[
		64573,
		1,
		""
	],
	[
		64574,
		1,
		""
	],
	[
		64575,
		1,
		""
	],
	[
		64576,
		1,
		""
	],
	[
		64577,
		1,
		""
	],
	[
		64578,
		1,
		""
	],
	[
		64579,
		1,
		""
	],
	[
		64580,
		1,
		""
	],
	[
		64581,
		1,
		""
	],
	[
		64582,
		1,
		""
	],
	[
		64583,
		1,
		""
	],
	[
		64584,
		1,
		""
	],
	[
		64585,
		1,
		""
	],
	[
		64586,
		1,
		""
	],
	[
		64587,
		1,
		""
	],
	[
		64588,
		1,
		""
	],
	[
		64589,
		1,
		""
	],
	[
		64590,
		1,
		""
	],
	[
		64591,
		1,
		""
	],
	[
		64592,
		1,
		""
	],
	[
		64593,
		1,
		""
	],
	[
		64594,
		1,
		""
	],
	[
		64595,
		1,
		""
	],
	[
		64596,
		1,
		""
	],
	[
		64597,
		1,
		""
	],
	[
		64598,
		1,
		""
	],
	[
		64599,
		1,
		""
	],
	[
		64600,
		1,
		""
	],
	[
		64601,
		1,
		""
	],
	[
		64602,
		1,
		""
	],
	[
		64603,
		1,
		""
	],
	[
		64604,
		1,
		""
	],
	[
		64605,
		1,
		""
	],
	[
		64606,
		5,
		" "
	],
	[
		64607,
		5,
		" "
	],
	[
		64608,
		5,
		" "
	],
	[
		64609,
		5,
		" "
	],
	[
		64610,
		5,
		" "
	],
	[
		64611,
		5,
		" "
	],
	[
		64612,
		1,
		""
	],
	[
		64613,
		1,
		""
	],
	[
		64614,
		1,
		""
	],
	[
		64615,
		1,
		""
	],
	[
		64616,
		1,
		""
	],
	[
		64617,
		1,
		""
	],
	[
		64618,
		1,
		""
	],
	[
		64619,
		1,
		""
	],
	[
		64620,
		1,
		""
	],
	[
		64621,
		1,
		""
	],
	[
		64622,
		1,
		""
	],
	[
		64623,
		1,
		""
	],
	[
		64624,
		1,
		""
	],
	[
		64625,
		1,
		""
	],
	[
		64626,
		1,
		""
	],
	[
		64627,
		1,
		""
	],
	[
		64628,
		1,
		""
	],
	[
		64629,
		1,
		""
	],
	[
		64630,
		1,
		""
	],
	[
		64631,
		1,
		""
	],
	[
		64632,
		1,
		""
	],
	[
		64633,
		1,
		""
	],
	[
		64634,
		1,
		""
	],
	[
		64635,
		1,
		""
	],
	[
		64636,
		1,
		""
	],
	[
		64637,
		1,
		""
	],
	[
		64638,
		1,
		""
	],
	[
		64639,
		1,
		""
	],
	[
		64640,
		1,
		""
	],
	[
		64641,
		1,
		""
	],
	[
		64642,
		1,
		""
	],
	[
		64643,
		1,
		""
	],
	[
		64644,
		1,
		""
	],
	[
		64645,
		1,
		""
	],
	[
		64646,
		1,
		""
	],
	[
		64647,
		1,
		""
	],
	[
		64648,
		1,
		""
	],
	[
		64649,
		1,
		""
	],
	[
		64650,
		1,
		""
	],
	[
		64651,
		1,
		""
	],
	[
		64652,
		1,
		""
	],
	[
		64653,
		1,
		""
	],
	[
		64654,
		1,
		""
	],
	[
		64655,
		1,
		""
	],
	[
		64656,
		1,
		""
	],
	[
		64657,
		1,
		""
	],
	[
		64658,
		1,
		""
	],
	[
		64659,
		1,
		""
	],
	[
		64660,
		1,
		""
	],
	[
		64661,
		1,
		""
	],
	[
		64662,
		1,
		""
	],
	[
		64663,
		1,
		""
	],
	[
		64664,
		1,
		""
	],
	[
		64665,
		1,
		""
	],
	[
		64666,
		1,
		""
	],
	[
		64667,
		1,
		""
	],
	[
		64668,
		1,
		""
	],
	[
		64669,
		1,
		""
	],
	[
		64670,
		1,
		""
	],
	[
		64671,
		1,
		""
	],
	[
		64672,
		1,
		""
	],
	[
		64673,
		1,
		""
	],
	[
		64674,
		1,
		""
	],
	[
		64675,
		1,
		""
	],
	[
		64676,
		1,
		""
	],
	[
		64677,
		1,
		""
	],
	[
		64678,
		1,
		""
	],
	[
		64679,
		1,
		""
	],
	[
		64680,
		1,
		""
	],
	[
		64681,
		1,
		""
	],
	[
		64682,
		1,
		""
	],
	[
		64683,
		1,
		""
	],
	[
		64684,
		1,
		""
	],
	[
		64685,
		1,
		""
	],
	[
		64686,
		1,
		""
	],
	[
		64687,
		1,
		""
	],
	[
		64688,
		1,
		""
	],
	[
		64689,
		1,
		""
	],
	[
		64690,
		1,
		""
	],
	[
		64691,
		1,
		""
	],
	[
		64692,
		1,
		""
	],
	[
		64693,
		1,
		""
	],
	[
		64694,
		1,
		""
	],
	[
		64695,
		1,
		""
	],
	[
		64696,
		1,
		""
	],
	[
		64697,
		1,
		""
	],
	[
		64698,
		1,
		""
	],
	[
		64699,
		1,
		""
	],
	[
		64700,
		1,
		""
	],
	[
		64701,
		1,
		""
	],
	[
		64702,
		1,
		""
	],
	[
		64703,
		1,
		""
	],
	[
		64704,
		1,
		""
	],
	[
		64705,
		1,
		""
	],
	[
		64706,
		1,
		""
	],
	[
		64707,
		1,
		""
	],
	[
		64708,
		1,
		""
	],
	[
		64709,
		1,
		""
	],
	[
		64710,
		1,
		""
	],
	[
		64711,
		1,
		""
	],
	[
		64712,
		1,
		""
	],
	[
		64713,
		1,
		""
	],
	[
		64714,
		1,
		""
	],
	[
		64715,
		1,
		""
	],
	[
		64716,
		1,
		""
	],
	[
		64717,
		1,
		""
	],
	[
		64718,
		1,
		""
	],
	[
		64719,
		1,
		""
	],
	[
		64720,
		1,
		""
	],
	[
		64721,
		1,
		""
	],
	[
		64722,
		1,
		""
	],
	[
		64723,
		1,
		""
	],
	[
		64724,
		1,
		""
	],
	[
		64725,
		1,
		""
	],
	[
		64726,
		1,
		""
	],
	[
		64727,
		1,
		""
	],
	[
		64728,
		1,
		""
	],
	[
		64729,
		1,
		""
	],
	[
		64730,
		1,
		""
	],
	[
		64731,
		1,
		""
	],
	[
		64732,
		1,
		""
	],
	[
		64733,
		1,
		""
	],
	[
		64734,
		1,
		""
	],
	[
		64735,
		1,
		""
	],
	[
		64736,
		1,
		""
	],
	[
		64737,
		1,
		""
	],
	[
		64738,
		1,
		""
	],
	[
		64739,
		1,
		""
	],
	[
		64740,
		1,
		""
	],
	[
		64741,
		1,
		""
	],
	[
		64742,
		1,
		""
	],
	[
		64743,
		1,
		""
	],
	[
		64744,
		1,
		""
	],
	[
		64745,
		1,
		""
	],
	[
		64746,
		1,
		""
	],
	[
		64747,
		1,
		""
	],
	[
		64748,
		1,
		""
	],
	[
		64749,
		1,
		""
	],
	[
		64750,
		1,
		""
	],
	[
		64751,
		1,
		""
	],
	[
		64752,
		1,
		""
	],
	[
		64753,
		1,
		""
	],
	[
		64754,
		1,
		""
	],
	[
		64755,
		1,
		""
	],
	[
		64756,
		1,
		""
	],
	[
		64757,
		1,
		""
	],
	[
		64758,
		1,
		""
	],
	[
		64759,
		1,
		""
	],
	[
		64760,
		1,
		""
	],
	[
		64761,
		1,
		""
	],
	[
		64762,
		1,
		""
	],
	[
		64763,
		1,
		""
	],
	[
		64764,
		1,
		""
	],
	[
		64765,
		1,
		""
	],
	[
		64766,
		1,
		""
	],
	[
		64767,
		1,
		""
	],
	[
		64768,
		1,
		""
	],
	[
		64769,
		1,
		""
	],
	[
		64770,
		1,
		""
	],
	[
		64771,
		1,
		""
	],
	[
		64772,
		1,
		""
	],
	[
		64773,
		1,
		""
	],
	[
		64774,
		1,
		""
	],
	[
		64775,
		1,
		""
	],
	[
		64776,
		1,
		""
	],
	[
		64777,
		1,
		""
	],
	[
		64778,
		1,
		""
	],
	[
		64779,
		1,
		""
	],
	[
		64780,
		1,
		""
	],
	[
		64781,
		1,
		""
	],
	[
		64782,
		1,
		""
	],
	[
		64783,
		1,
		""
	],
	[
		64784,
		1,
		""
	],
	[
		64785,
		1,
		""
	],
	[
		64786,
		1,
		""
	],
	[
		64787,
		1,
		""
	],
	[
		64788,
		1,
		""
	],
	[
		64789,
		1,
		""
	],
	[
		64790,
		1,
		""
	],
	[
		64791,
		1,
		""
	],
	[
		64792,
		1,
		""
	],
	[
		64793,
		1,
		""
	],
	[
		64794,
		1,
		""
	],
	[
		64795,
		1,
		""
	],
	[
		64796,
		1,
		""
	],
	[
		64797,
		1,
		""
	],
	[
		64798,
		1,
		""
	],
	[
		64799,
		1,
		""
	],
	[
		64800,
		1,
		""
	],
	[
		64801,
		1,
		""
	],
	[
		64802,
		1,
		""
	],
	[
		64803,
		1,
		""
	],
	[
		64804,
		1,
		""
	],
	[
		64805,
		1,
		""
	],
	[
		64806,
		1,
		""
	],
	[
		64807,
		1,
		""
	],
	[
		64808,
		1,
		""
	],
	[
		64809,
		1,
		""
	],
	[
		64810,
		1,
		""
	],
	[
		64811,
		1,
		""
	],
	[
		64812,
		1,
		""
	],
	[
		64813,
		1,
		""
	],
	[
		64814,
		1,
		""
	],
	[
		64815,
		1,
		""
	],
	[
		64816,
		1,
		""
	],
	[
		64817,
		1,
		""
	],
	[
		64818,
		1,
		""
	],
	[
		64819,
		1,
		""
	],
	[
		64820,
		1,
		""
	],
	[
		64821,
		1,
		""
	],
	[
		64822,
		1,
		""
	],
	[
		64823,
		1,
		""
	],
	[
		64824,
		1,
		""
	],
	[
		64825,
		1,
		""
	],
	[
		64826,
		1,
		""
	],
	[
		64827,
		1,
		""
	],
	[
		[
			64828,
			64829
		],
		1,
		""
	],
	[
		[
			64830,
			64831
		],
		2
	],
	[
		[
			64832,
			64847
		],
		2
	],
	[
		64848,
		1,
		""
	],
	[
		[
			64849,
			64850
		],
		1,
		""
	],
	[
		64851,
		1,
		""
	],
	[
		64852,
		1,
		""
	],
	[
		64853,
		1,
		""
	],
	[
		64854,
		1,
		""
	],
	[
		64855,
		1,
		""
	],
	[
		[
			64856,
			64857
		],
		1,
		""
	],
	[
		64858,
		1,
		""
	],
	[
		64859,
		1,
		""
	],
	[
		64860,
		1,
		""
	],
	[
		64861,
		1,
		""
	],
	[
		64862,
		1,
		""
	],
	[
		[
			64863,
			64864
		],
		1,
		""
	],
	[
		64865,
		1,
		""
	],
	[
		[
			64866,
			64867
		],
		1,
		""
	],
	[
		[
			64868,
			64869
		],
		1,
		""
	],
	[
		64870,
		1,
		""
	],
	[
		[
			64871,
			64872
		],
		1,
		""
	],
	[
		64873,
		1,
		""
	],
	[
		[
			64874,
			64875
		],
		1,
		""
	],
	[
		[
			64876,
			64877
		],
		1,
		""
	],
	[
		64878,
		1,
		""
	],
	[
		[
			64879,
			64880
		],
		1,
		""
	],
	[
		[
			64881,
			64882
		],
		1,
		""
	],
	[
		64883,
		1,
		""
	],
	[
		64884,
		1,
		""
	],
	[
		64885,
		1,
		""
	],
	[
		[
			64886,
			64887
		],
		1,
		""
	],
	[
		64888,
		1,
		""
	],
	[
		64889,
		1,
		""
	],
	[
		64890,
		1,
		""
	],
	[
		64891,
		1,
		""
	],
	[
		[
			64892,
			64893
		],
		1,
		""
	],
	[
		64894,
		1,
		""
	],
	[
		64895,
		1,
		""
	],
	[
		64896,
		1,
		""
	],
	[
		64897,
		1,
		""
	],
	[
		64898,
		1,
		""
	],
	[
		[
			64899,
			64900
		],
		1,
		""
	],
	[
		[
			64901,
			64902
		],
		1,
		""
	],
	[
		[
			64903,
			64904
		],
		1,
		""
	],
	[
		64905,
		1,
		""
	],
	[
		64906,
		1,
		""
	],
	[
		64907,
		1,
		""
	],
	[
		64908,
		1,
		""
	],
	[
		64909,
		1,
		""
	],
	[
		64910,
		1,
		""
	],
	[
		64911,
		1,
		""
	],
	[
		[
			64912,
			64913
		],
		3
	],
	[
		64914,
		1,
		""
	],
	[
		64915,
		1,
		""
	],
	[
		64916,
		1,
		""
	],
	[
		64917,
		1,
		""
	],
	[
		64918,
		1,
		""
	],
	[
		[
			64919,
			64920
		],
		1,
		""
	],
	[
		64921,
		1,
		""
	],
	[
		64922,
		1,
		""
	],
	[
		64923,
		1,
		""
	],
	[
		[
			64924,
			64925
		],
		1,
		""
	],
	[
		64926,
		1,
		""
	],
	[
		64927,
		1,
		""
	],
	[
		64928,
		1,
		""
	],
	[
		64929,
		1,
		""
	],
	[
		64930,
		1,
		""
	],
	[
		64931,
		1,
		""
	],
	[
		64932,
		1,
		""
	],
	[
		64933,
		1,
		""
	],
	[
		64934,
		1,
		""
	],
	[
		64935,
		1,
		""
	],
	[
		64936,
		1,
		""
	],
	[
		64937,
		1,
		""
	],
	[
		64938,
		1,
		""
	],
	[
		64939,
		1,
		""
	],
	[
		64940,
		1,
		""
	],
	[
		64941,
		1,
		""
	],
	[
		64942,
		1,
		""
	],
	[
		64943,
		1,
		""
	],
	[
		64944,
		1,
		""
	],
	[
		64945,
		1,
		""
	],
	[
		64946,
		1,
		""
	],
	[
		64947,
		1,
		""
	],
	[
		64948,
		1,
		""
	],
	[
		64949,
		1,
		""
	],
	[
		64950,
		1,
		""
	],
	[
		64951,
		1,
		""
	],
	[
		64952,
		1,
		""
	],
	[
		64953,
		1,
		""
	],
	[
		64954,
		1,
		""
	],
	[
		64955,
		1,
		""
	],
	[
		64956,
		1,
		""
	],
	[
		64957,
		1,
		""
	],
	[
		64958,
		1,
		""
	],
	[
		64959,
		1,
		""
	],
	[
		64960,
		1,
		""
	],
	[
		64961,
		1,
		""
	],
	[
		64962,
		1,
		""
	],
	[
		64963,
		1,
		""
	],
	[
		64964,
		1,
		""
	],
	[
		64965,
		1,
		""
	],
	[
		64966,
		1,
		""
	],
	[
		64967,
		1,
		""
	],
	[
		[
			64968,
			64974
		],
		3
	],
	[
		64975,
		2
	],
	[
		[
			64976,
			65007
		],
		3
	],
	[
		65008,
		1,
		""
	],
	[
		65009,
		1,
		""
	],
	[
		65010,
		1,
		""
	],
	[
		65011,
		1,
		""
	],
	[
		65012,
		1,
		""
	],
	[
		65013,
		1,
		""
	],
	[
		65014,
		1,
		""
	],
	[
		65015,
		1,
		""
	],
	[
		65016,
		1,
		""
	],
	[
		65017,
		1,
		""
	],
	[
		65018,
		5,
		"   "
	],
	[
		65019,
		5,
		" "
	],
	[
		65020,
		1,
		""
	],
	[
		65021,
		2
	],
	[
		[
			65022,
			65023
		],
		2
	],
	[
		[
			65024,
			65039
		],
		7
	],
	[
		65040,
		5,
		","
	],
	[
		65041,
		1,
		""
	],
	[
		65042,
		3
	],
	[
		65043,
		5,
		":"
	],
	[
		65044,
		5,
		";"
	],
	[
		65045,
		5,
		"!"
	],
	[
		65046,
		5,
		"?"
	],
	[
		65047,
		1,
		""
	],
	[
		65048,
		1,
		""
	],
	[
		65049,
		3
	],
	[
		[
			65050,
			65055
		],
		3
	],
	[
		[
			65056,
			65059
		],
		2
	],
	[
		[
			65060,
			65062
		],
		2
	],
	[
		[
			65063,
			65069
		],
		2
	],
	[
		[
			65070,
			65071
		],
		2
	],
	[
		65072,
		3
	],
	[
		65073,
		1,
		""
	],
	[
		65074,
		1,
		""
	],
	[
		[
			65075,
			65076
		],
		5,
		"_"
	],
	[
		65077,
		5,
		"("
	],
	[
		65078,
		5,
		")"
	],
	[
		65079,
		5,
		"{"
	],
	[
		65080,
		5,
		"}"
	],
	[
		65081,
		1,
		""
	],
	[
		65082,
		1,
		""
	],
	[
		65083,
		1,
		""
	],
	[
		65084,
		1,
		""
	],
	[
		65085,
		1,
		""
	],
	[
		65086,
		1,
		""
	],
	[
		65087,
		1,
		""
	],
	[
		65088,
		1,
		""
	],
	[
		65089,
		1,
		""
	],
	[
		65090,
		1,
		""
	],
	[
		65091,
		1,
		""
	],
	[
		65092,
		1,
		""
	],
	[
		[
			65093,
			65094
		],
		2
	],
	[
		65095,
		5,
		"["
	],
	[
		65096,
		5,
		"]"
	],
	[
		[
			65097,
			65100
		],
		5,
		" "
	],
	[
		[
			65101,
			65103
		],
		5,
		"_"
	],
	[
		65104,
		5,
		","
	],
	[
		65105,
		1,
		""
	],
	[
		65106,
		3
	],
	[
		65107,
		3
	],
	[
		65108,
		5,
		";"
	],
	[
		65109,
		5,
		":"
	],
	[
		65110,
		5,
		"?"
	],
	[
		65111,
		5,
		"!"
	],
	[
		65112,
		1,
		""
	],
	[
		65113,
		5,
		"("
	],
	[
		65114,
		5,
		")"
	],
	[
		65115,
		5,
		"{"
	],
	[
		65116,
		5,
		"}"
	],
	[
		65117,
		1,
		""
	],
	[
		65118,
		1,
		""
	],
	[
		65119,
		5,
		"#"
	],
	[
		65120,
		5,
		"&"
	],
	[
		65121,
		5,
		"*"
	],
	[
		65122,
		5,
		"+"
	],
	[
		65123,
		1,
		"-"
	],
	[
		65124,
		5,
		"<"
	],
	[
		65125,
		5,
		">"
	],
	[
		65126,
		5,
		"="
	],
	[
		65127,
		3
	],
	[
		65128,
		5,
		"\\"
	],
	[
		65129,
		5,
		"$"
	],
	[
		65130,
		5,
		"%"
	],
	[
		65131,
		5,
		"@"
	],
	[
		[
			65132,
			65135
		],
		3
	],
	[
		65136,
		5,
		" "
	],
	[
		65137,
		1,
		""
	],
	[
		65138,
		5,
		" "
	],
	[
		65139,
		2
	],
	[
		65140,
		5,
		" "
	],
	[
		65141,
		3
	],
	[
		65142,
		5,
		" "
	],
	[
		65143,
		1,
		""
	],
	[
		65144,
		5,
		" "
	],
	[
		65145,
		1,
		""
	],
	[
		65146,
		5,
		" "
	],
	[
		65147,
		1,
		""
	],
	[
		65148,
		5,
		" "
	],
	[
		65149,
		1,
		""
	],
	[
		65150,
		5,
		" "
	],
	[
		65151,
		1,
		""
	],
	[
		65152,
		1,
		""
	],
	[
		[
			65153,
			65154
		],
		1,
		""
	],
	[
		[
			65155,
			65156
		],
		1,
		""
	],
	[
		[
			65157,
			65158
		],
		1,
		""
	],
	[
		[
			65159,
			65160
		],
		1,
		""
	],
	[
		[
			65161,
			65164
		],
		1,
		""
	],
	[
		[
			65165,
			65166
		],
		1,
		""
	],
	[
		[
			65167,
			65170
		],
		1,
		""
	],
	[
		[
			65171,
			65172
		],
		1,
		""
	],
	[
		[
			65173,
			65176
		],
		1,
		""
	],
	[
		[
			65177,
			65180
		],
		1,
		""
	],
	[
		[
			65181,
			65184
		],
		1,
		""
	],
	[
		[
			65185,
			65188
		],
		1,
		""
	],
	[
		[
			65189,
			65192
		],
		1,
		""
	],
	[
		[
			65193,
			65194
		],
		1,
		""
	],
	[
		[
			65195,
			65196
		],
		1,
		""
	],
	[
		[
			65197,
			65198
		],
		1,
		""
	],
	[
		[
			65199,
			65200
		],
		1,
		""
	],
	[
		[
			65201,
			65204
		],
		1,
		""
	],
	[
		[
			65205,
			65208
		],
		1,
		""
	],
	[
		[
			65209,
			65212
		],
		1,
		""
	],
	[
		[
			65213,
			65216
		],
		1,
		""
	],
	[
		[
			65217,
			65220
		],
		1,
		""
	],
	[
		[
			65221,
			65224
		],
		1,
		""
	],
	[
		[
			65225,
			65228
		],
		1,
		""
	],
	[
		[
			65229,
			65232
		],
		1,
		""
	],
	[
		[
			65233,
			65236
		],
		1,
		""
	],
	[
		[
			65237,
			65240
		],
		1,
		""
	],
	[
		[
			65241,
			65244
		],
		1,
		""
	],
	[
		[
			65245,
			65248
		],
		1,
		""
	],
	[
		[
			65249,
			65252
		],
		1,
		""
	],
	[
		[
			65253,
			65256
		],
		1,
		""
	],
	[
		[
			65257,
			65260
		],
		1,
		""
	],
	[
		[
			65261,
			65262
		],
		1,
		""
	],
	[
		[
			65263,
			65264
		],
		1,
		""
	],
	[
		[
			65265,
			65268
		],
		1,
		""
	],
	[
		[
			65269,
			65270
		],
		1,
		""
	],
	[
		[
			65271,
			65272
		],
		1,
		""
	],
	[
		[
			65273,
			65274
		],
		1,
		""
	],
	[
		[
			65275,
			65276
		],
		1,
		""
	],
	[
		[
			65277,
			65278
		],
		3
	],
	[
		65279,
		7
	],
	[
		65280,
		3
	],
	[
		65281,
		5,
		"!"
	],
	[
		65282,
		5,
		"\""
	],
	[
		65283,
		5,
		"#"
	],
	[
		65284,
		5,
		"$"
	],
	[
		65285,
		5,
		"%"
	],
	[
		65286,
		5,
		"&"
	],
	[
		65287,
		5,
		"'"
	],
	[
		65288,
		5,
		"("
	],
	[
		65289,
		5,
		")"
	],
	[
		65290,
		5,
		"*"
	],
	[
		65291,
		5,
		"+"
	],
	[
		65292,
		5,
		","
	],
	[
		65293,
		1,
		"-"
	],
	[
		65294,
		1,
		"."
	],
	[
		65295,
		5,
		"/"
	],
	[
		65296,
		1,
		"0"
	],
	[
		65297,
		1,
		"1"
	],
	[
		65298,
		1,
		"2"
	],
	[
		65299,
		1,
		"3"
	],
	[
		65300,
		1,
		"4"
	],
	[
		65301,
		1,
		"5"
	],
	[
		65302,
		1,
		"6"
	],
	[
		65303,
		1,
		"7"
	],
	[
		65304,
		1,
		"8"
	],
	[
		65305,
		1,
		"9"
	],
	[
		65306,
		5,
		":"
	],
	[
		65307,
		5,
		";"
	],
	[
		65308,
		5,
		"<"
	],
	[
		65309,
		5,
		"="
	],
	[
		65310,
		5,
		">"
	],
	[
		65311,
		5,
		"?"
	],
	[
		65312,
		5,
		"@"
	],
	[
		65313,
		1,
		"a"
	],
	[
		65314,
		1,
		"b"
	],
	[
		65315,
		1,
		"c"
	],
	[
		65316,
		1,
		"d"
	],
	[
		65317,
		1,
		"e"
	],
	[
		65318,
		1,
		"f"
	],
	[
		65319,
		1,
		"g"
	],
	[
		65320,
		1,
		"h"
	],
	[
		65321,
		1,
		"i"
	],
	[
		65322,
		1,
		"j"
	],
	[
		65323,
		1,
		"k"
	],
	[
		65324,
		1,
		"l"
	],
	[
		65325,
		1,
		"m"
	],
	[
		65326,
		1,
		"n"
	],
	[
		65327,
		1,
		"o"
	],
	[
		65328,
		1,
		"p"
	],
	[
		65329,
		1,
		"q"
	],
	[
		65330,
		1,
		"r"
	],
	[
		65331,
		1,
		"s"
	],
	[
		65332,
		1,
		"t"
	],
	[
		65333,
		1,
		"u"
	],
	[
		65334,
		1,
		"v"
	],
	[
		65335,
		1,
		"w"
	],
	[
		65336,
		1,
		"x"
	],
	[
		65337,
		1,
		"y"
	],
	[
		65338,
		1,
		"z"
	],
	[
		65339,
		5,
		"["
	],
	[
		65340,
		5,
		"\\"
	],
	[
		65341,
		5,
		"]"
	],
	[
		65342,
		5,
		"^"
	],
	[
		65343,
		5,
		"_"
	],
	[
		65344,
		5,
		"`"
	],
	[
		65345,
		1,
		"a"
	],
	[
		65346,
		1,
		"b"
	],
	[
		65347,
		1,
		"c"
	],
	[
		65348,
		1,
		"d"
	],
	[
		65349,
		1,
		"e"
	],
	[
		65350,
		1,
		"f"
	],
	[
		65351,
		1,
		"g"
	],
	[
		65352,
		1,
		"h"
	],
	[
		65353,
		1,
		"i"
	],
	[
		65354,
		1,
		"j"
	],
	[
		65355,
		1,
		"k"
	],
	[
		65356,
		1,
		"l"
	],
	[
		65357,
		1,
		"m"
	],
	[
		65358,
		1,
		"n"
	],
	[
		65359,
		1,
		"o"
	],
	[
		65360,
		1,
		"p"
	],
	[
		65361,
		1,
		"q"
	],
	[
		65362,
		1,
		"r"
	],
	[
		65363,
		1,
		"s"
	],
	[
		65364,
		1,
		"t"
	],
	[
		65365,
		1,
		"u"
	],
	[
		65366,
		1,
		"v"
	],
	[
		65367,
		1,
		"w"
	],
	[
		65368,
		1,
		"x"
	],
	[
		65369,
		1,
		"y"
	],
	[
		65370,
		1,
		"z"
	],
	[
		65371,
		5,
		"{"
	],
	[
		65372,
		5,
		"|"
	],
	[
		65373,
		5,
		"}"
	],
	[
		65374,
		5,
		"~"
	],
	[
		65375,
		1,
		""
	],
	[
		65376,
		1,
		""
	],
	[
		65377,
		1,
		"."
	],
	[
		65378,
		1,
		""
	],
	[
		65379,
		1,
		""
	],
	[
		65380,
		1,
		""
	],
	[
		65381,
		1,
		""
	],
	[
		65382,
		1,
		""
	],
	[
		65383,
		1,
		""
	],
	[
		65384,
		1,
		""
	],
	[
		65385,
		1,
		""
	],
	[
		65386,
		1,
		""
	],
	[
		65387,
		1,
		""
	],
	[
		65388,
		1,
		""
	],
	[
		65389,
		1,
		""
	],
	[
		65390,
		1,
		""
	],
	[
		65391,
		1,
		""
	],
	[
		65392,
		1,
		""
	],
	[
		65393,
		1,
		""
	],
	[
		65394,
		1,
		""
	],
	[
		65395,
		1,
		""
	],
	[
		65396,
		1,
		""
	],
	[
		65397,
		1,
		""
	],
	[
		65398,
		1,
		""
	],
	[
		65399,
		1,
		""
	],
	[
		65400,
		1,
		""
	],
	[
		65401,
		1,
		""
	],
	[
		65402,
		1,
		""
	],
	[
		65403,
		1,
		""
	],
	[
		65404,
		1,
		""
	],
	[
		65405,
		1,
		""
	],
	[
		65406,
		1,
		""
	],
	[
		65407,
		1,
		""
	],
	[
		65408,
		1,
		""
	],
	[
		65409,
		1,
		""
	],
	[
		65410,
		1,
		""
	],
	[
		65411,
		1,
		""
	],
	[
		65412,
		1,
		""
	],
	[
		65413,
		1,
		""
	],
	[
		65414,
		1,
		""
	],
	[
		65415,
		1,
		""
	],
	[
		65416,
		1,
		""
	],
	[
		65417,
		1,
		""
	],
	[
		65418,
		1,
		""
	],
	[
		65419,
		1,
		""
	],
	[
		65420,
		1,
		""
	],
	[
		65421,
		1,
		""
	],
	[
		65422,
		1,
		""
	],
	[
		65423,
		1,
		""
	],
	[
		65424,
		1,
		""
	],
	[
		65425,
		1,
		""
	],
	[
		65426,
		1,
		""
	],
	[
		65427,
		1,
		""
	],
	[
		65428,
		1,
		""
	],
	[
		65429,
		1,
		""
	],
	[
		65430,
		1,
		""
	],
	[
		65431,
		1,
		""
	],
	[
		65432,
		1,
		""
	],
	[
		65433,
		1,
		""
	],
	[
		65434,
		1,
		""
	],
	[
		65435,
		1,
		""
	],
	[
		65436,
		1,
		""
	],
	[
		65437,
		1,
		""
	],
	[
		65438,
		1,
		""
	],
	[
		65439,
		1,
		""
	],
	[
		65440,
		3
	],
	[
		65441,
		1,
		""
	],
	[
		65442,
		1,
		""
	],
	[
		65443,
		1,
		""
	],
	[
		65444,
		1,
		""
	],
	[
		65445,
		1,
		""
	],
	[
		65446,
		1,
		""
	],
	[
		65447,
		1,
		""
	],
	[
		65448,
		1,
		""
	],
	[
		65449,
		1,
		""
	],
	[
		65450,
		1,
		""
	],
	[
		65451,
		1,
		""
	],
	[
		65452,
		1,
		""
	],
	[
		65453,
		1,
		""
	],
	[
		65454,
		1,
		""
	],
	[
		65455,
		1,
		""
	],
	[
		65456,
		1,
		""
	],
	[
		65457,
		1,
		""
	],
	[
		65458,
		1,
		""
	],
	[
		65459,
		1,
		""
	],
	[
		65460,
		1,
		""
	],
	[
		65461,
		1,
		""
	],
	[
		65462,
		1,
		""
	],
	[
		65463,
		1,
		""
	],
	[
		65464,
		1,
		""
	],
	[
		65465,
		1,
		""
	],
	[
		65466,
		1,
		""
	],
	[
		65467,
		1,
		""
	],
	[
		65468,
		1,
		""
	],
	[
		65469,
		1,
		""
	],
	[
		65470,
		1,
		""
	],
	[
		[
			65471,
			65473
		],
		3
	],
	[
		65474,
		1,
		""
	],
	[
		65475,
		1,
		""
	],
	[
		65476,
		1,
		""
	],
	[
		65477,
		1,
		""
	],
	[
		65478,
		1,
		""
	],
	[
		65479,
		1,
		""
	],
	[
		[
			65480,
			65481
		],
		3
	],
	[
		65482,
		1,
		""
	],
	[
		65483,
		1,
		""
	],
	[
		65484,
		1,
		""
	],
	[
		65485,
		1,
		""
	],
	[
		65486,
		1,
		""
	],
	[
		65487,
		1,
		""
	],
	[
		[
			65488,
			65489
		],
		3
	],
	[
		65490,
		1,
		""
	],
	[
		65491,
		1,
		""
	],
	[
		65492,
		1,
		""
	],
	[
		65493,
		1,
		""
	],
	[
		65494,
		1,
		""
	],
	[
		65495,
		1,
		""
	],
	[
		[
			65496,
			65497
		],
		3
	],
	[
		65498,
		1,
		""
	],
	[
		65499,
		1,
		""
	],
	[
		65500,
		1,
		""
	],
	[
		[
			65501,
			65503
		],
		3
	],
	[
		65504,
		1,
		""
	],
	[
		65505,
		1,
		""
	],
	[
		65506,
		1,
		""
	],
	[
		65507,
		5,
		" "
	],
	[
		65508,
		1,
		""
	],
	[
		65509,
		1,
		""
	],
	[
		65510,
		1,
		""
	],
	[
		65511,
		3
	],
	[
		65512,
		1,
		""
	],
	[
		65513,
		1,
		""
	],
	[
		65514,
		1,
		""
	],
	[
		65515,
		1,
		""
	],
	[
		65516,
		1,
		""
	],
	[
		65517,
		1,
		""
	],
	[
		65518,
		1,
		""
	],
	[
		[
			65519,
			65528
		],
		3
	],
	[
		[
			65529,
			65531
		],
		3
	],
	[
		65532,
		3
	],
	[
		65533,
		3
	],
	[
		[
			65534,
			65535
		],
		3
	],
	[
		[
			65536,
			65547
		],
		2
	],
	[
		65548,
		3
	],
	[
		[
			65549,
			65574
		],
		2
	],
	[
		65575,
		3
	],
	[
		[
			65576,
			65594
		],
		2
	],
	[
		65595,
		3
	],
	[
		[
			65596,
			65597
		],
		2
	],
	[
		65598,
		3
	],
	[
		[
			65599,
			65613
		],
		2
	],
	[
		[
			65614,
			65615
		],
		3
	],
	[
		[
			65616,
			65629
		],
		2
	],
	[
		[
			65630,
			65663
		],
		3
	],
	[
		[
			65664,
			65786
		],
		2
	],
	[
		[
			65787,
			65791
		],
		3
	],
	[
		[
			65792,
			65794
		],
		2
	],
	[
		[
			65795,
			65798
		],
		3
	],
	[
		[
			65799,
			65843
		],
		2
	],
	[
		[
			65844,
			65846
		],
		3
	],
	[
		[
			65847,
			65855
		],
		2
	],
	[
		[
			65856,
			65930
		],
		2
	],
	[
		[
			65931,
			65932
		],
		2
	],
	[
		[
			65933,
			65934
		],
		2
	],
	[
		65935,
		3
	],
	[
		[
			65936,
			65947
		],
		2
	],
	[
		65948,
		2
	],
	[
		[
			65949,
			65951
		],
		3
	],
	[
		65952,
		2
	],
	[
		[
			65953,
			65999
		],
		3
	],
	[
		[
			66000,
			66044
		],
		2
	],
	[
		66045,
		2
	],
	[
		[
			66046,
			66175
		],
		3
	],
	[
		[
			66176,
			66204
		],
		2
	],
	[
		[
			66205,
			66207
		],
		3
	],
	[
		[
			66208,
			66256
		],
		2
	],
	[
		[
			66257,
			66271
		],
		3
	],
	[
		66272,
		2
	],
	[
		[
			66273,
			66299
		],
		2
	],
	[
		[
			66300,
			66303
		],
		3
	],
	[
		[
			66304,
			66334
		],
		2
	],
	[
		66335,
		2
	],
	[
		[
			66336,
			66339
		],
		2
	],
	[
		[
			66340,
			66348
		],
		3
	],
	[
		[
			66349,
			66351
		],
		2
	],
	[
		[
			66352,
			66368
		],
		2
	],
	[
		66369,
		2
	],
	[
		[
			66370,
			66377
		],
		2
	],
	[
		66378,
		2
	],
	[
		[
			66379,
			66383
		],
		3
	],
	[
		[
			66384,
			66426
		],
		2
	],
	[
		[
			66427,
			66431
		],
		3
	],
	[
		[
			66432,
			66461
		],
		2
	],
	[
		66462,
		3
	],
	[
		66463,
		2
	],
	[
		[
			66464,
			66499
		],
		2
	],
	[
		[
			66500,
			66503
		],
		3
	],
	[
		[
			66504,
			66511
		],
		2
	],
	[
		[
			66512,
			66517
		],
		2
	],
	[
		[
			66518,
			66559
		],
		3
	],
	[
		66560,
		1,
		""
	],
	[
		66561,
		1,
		""
	],
	[
		66562,
		1,
		""
	],
	[
		66563,
		1,
		""
	],
	[
		66564,
		1,
		""
	],
	[
		66565,
		1,
		""
	],
	[
		66566,
		1,
		""
	],
	[
		66567,
		1,
		""
	],
	[
		66568,
		1,
		""
	],
	[
		66569,
		1,
		""
	],
	[
		66570,
		1,
		""
	],
	[
		66571,
		1,
		""
	],
	[
		66572,
		1,
		""
	],
	[
		66573,
		1,
		""
	],
	[
		66574,
		1,
		""
	],
	[
		66575,
		1,
		""
	],
	[
		66576,
		1,
		""
	],
	[
		66577,
		1,
		""
	],
	[
		66578,
		1,
		""
	],
	[
		66579,
		1,
		""
	],
	[
		66580,
		1,
		""
	],
	[
		66581,
		1,
		""
	],
	[
		66582,
		1,
		""
	],
	[
		66583,
		1,
		""
	],
	[
		66584,
		1,
		""
	],
	[
		66585,
		1,
		""
	],
	[
		66586,
		1,
		""
	],
	[
		66587,
		1,
		""
	],
	[
		66588,
		1,
		""
	],
	[
		66589,
		1,
		""
	],
	[
		66590,
		1,
		""
	],
	[
		66591,
		1,
		""
	],
	[
		66592,
		1,
		""
	],
	[
		66593,
		1,
		""
	],
	[
		66594,
		1,
		""
	],
	[
		66595,
		1,
		""
	],
	[
		66596,
		1,
		""
	],
	[
		66597,
		1,
		""
	],
	[
		66598,
		1,
		""
	],
	[
		66599,
		1,
		""
	],
	[
		[
			66600,
			66637
		],
		2
	],
	[
		[
			66638,
			66717
		],
		2
	],
	[
		[
			66718,
			66719
		],
		3
	],
	[
		[
			66720,
			66729
		],
		2
	],
	[
		[
			66730,
			66735
		],
		3
	],
	[
		66736,
		1,
		""
	],
	[
		66737,
		1,
		""
	],
	[
		66738,
		1,
		""
	],
	[
		66739,
		1,
		""
	],
	[
		66740,
		1,
		""
	],
	[
		66741,
		1,
		""
	],
	[
		66742,
		1,
		""
	],
	[
		66743,
		1,
		""
	],
	[
		66744,
		1,
		""
	],
	[
		66745,
		1,
		""
	],
	[
		66746,
		1,
		""
	],
	[
		66747,
		1,
		""
	],
	[
		66748,
		1,
		""
	],
	[
		66749,
		1,
		""
	],
	[
		66750,
		1,
		""
	],
	[
		66751,
		1,
		""
	],
	[
		66752,
		1,
		""
	],
	[
		66753,
		1,
		""
	],
	[
		66754,
		1,
		""
	],
	[
		66755,
		1,
		""
	],
	[
		66756,
		1,
		""
	],
	[
		66757,
		1,
		""
	],
	[
		66758,
		1,
		""
	],
	[
		66759,
		1,
		""
	],
	[
		66760,
		1,
		""
	],
	[
		66761,
		1,
		""
	],
	[
		66762,
		1,
		""
	],
	[
		66763,
		1,
		""
	],
	[
		66764,
		1,
		""
	],
	[
		66765,
		1,
		""
	],
	[
		66766,
		1,
		""
	],
	[
		66767,
		1,
		""
	],
	[
		66768,
		1,
		""
	],
	[
		66769,
		1,
		""
	],
	[
		66770,
		1,
		""
	],
	[
		66771,
		1,
		""
	],
	[
		[
			66772,
			66775
		],
		3
	],
	[
		[
			66776,
			66811
		],
		2
	],
	[
		[
			66812,
			66815
		],
		3
	],
	[
		[
			66816,
			66855
		],
		2
	],
	[
		[
			66856,
			66863
		],
		3
	],
	[
		[
			66864,
			66915
		],
		2
	],
	[
		[
			66916,
			66926
		],
		3
	],
	[
		66927,
		2
	],
	[
		66928,
		1,
		""
	],
	[
		66929,
		1,
		""
	],
	[
		66930,
		1,
		""
	],
	[
		66931,
		1,
		""
	],
	[
		66932,
		1,
		""
	],
	[
		66933,
		1,
		""
	],
	[
		66934,
		1,
		""
	],
	[
		66935,
		1,
		""
	],
	[
		66936,
		1,
		""
	],
	[
		66937,
		1,
		""
	],
	[
		66938,
		1,
		""
	],
	[
		66939,
		3
	],
	[
		66940,
		1,
		""
	],
	[
		66941,
		1,
		""
	],
	[
		66942,
		1,
		""
	],
	[
		66943,
		1,
		""
	],
	[
		66944,
		1,
		""
	],
	[
		66945,
		1,
		""
	],
	[
		66946,
		1,
		""
	],
	[
		66947,
		1,
		""
	],
	[
		66948,
		1,
		""
	],
	[
		66949,
		1,
		""
	],
	[
		66950,
		1,
		""
	],
	[
		66951,
		1,
		""
	],
	[
		66952,
		1,
		""
	],
	[
		66953,
		1,
		""
	],
	[
		66954,
		1,
		""
	],
	[
		66955,
		3
	],
	[
		66956,
		1,
		""
	],
	[
		66957,
		1,
		""
	],
	[
		66958,
		1,
		""
	],
	[
		66959,
		1,
		""
	],
	[
		66960,
		1,
		""
	],
	[
		66961,
		1,
		""
	],
	[
		66962,
		1,
		""
	],
	[
		66963,
		3
	],
	[
		66964,
		1,
		""
	],
	[
		66965,
		1,
		""
	],
	[
		66966,
		3
	],
	[
		[
			66967,
			66977
		],
		2
	],
	[
		66978,
		3
	],
	[
		[
			66979,
			66993
		],
		2
	],
	[
		66994,
		3
	],
	[
		[
			66995,
			67001
		],
		2
	],
	[
		67002,
		3
	],
	[
		[
			67003,
			67004
		],
		2
	],
	[
		[
			67005,
			67071
		],
		3
	],
	[
		[
			67072,
			67382
		],
		2
	],
	[
		[
			67383,
			67391
		],
		3
	],
	[
		[
			67392,
			67413
		],
		2
	],
	[
		[
			67414,
			67423
		],
		3
	],
	[
		[
			67424,
			67431
		],
		2
	],
	[
		[
			67432,
			67455
		],
		3
	],
	[
		67456,
		2
	],
	[
		67457,
		1,
		""
	],
	[
		67458,
		1,
		""
	],
	[
		67459,
		1,
		""
	],
	[
		67460,
		1,
		""
	],
	[
		67461,
		1,
		""
	],
	[
		67462,
		3
	],
	[
		67463,
		1,
		""
	],
	[
		67464,
		1,
		""
	],
	[
		67465,
		1,
		""
	],
	[
		67466,
		1,
		""
	],
	[
		67467,
		1,
		""
	],
	[
		67468,
		1,
		""
	],
	[
		67469,
		1,
		""
	],
	[
		67470,
		1,
		""
	],
	[
		67471,
		1,
		""
	],
	[
		67472,
		1,
		""
	],
	[
		67473,
		1,
		""
	],
	[
		67474,
		1,
		""
	],
	[
		67475,
		1,
		""
	],
	[
		67476,
		1,
		""
	],
	[
		67477,
		1,
		""
	],
	[
		67478,
		1,
		""
	],
	[
		67479,
		1,
		""
	],
	[
		67480,
		1,
		""
	],
	[
		67481,
		1,
		""
	],
	[
		67482,
		1,
		""
	],
	[
		67483,
		1,
		""
	],
	[
		67484,
		1,
		""
	],
	[
		67485,
		1,
		""
	],
	[
		67486,
		1,
		""
	],
	[
		67487,
		1,
		""
	],
	[
		67488,
		1,
		""
	],
	[
		67489,
		1,
		""
	],
	[
		67490,
		1,
		""
	],
	[
		67491,
		1,
		""
	],
	[
		67492,
		1,
		""
	],
	[
		67493,
		1,
		"q"
	],
	[
		67494,
		1,
		""
	],
	[
		67495,
		1,
		""
	],
	[
		67496,
		1,
		""
	],
	[
		67497,
		1,
		""
	],
	[
		67498,
		1,
		""
	],
	[
		67499,
		1,
		""
	],
	[
		67500,
		1,
		""
	],
	[
		67501,
		1,
		""
	],
	[
		67502,
		1,
		""
	],
	[
		67503,
		1,
		""
	],
	[
		67504,
		1,
		""
	],
	[
		67505,
		3
	],
	[
		67506,
		1,
		""
	],
	[
		67507,
		1,
		""
	],
	[
		67508,
		1,
		""
	],
	[
		67509,
		1,
		""
	],
	[
		67510,
		1,
		""
	],
	[
		67511,
		1,
		""
	],
	[
		67512,
		1,
		""
	],
	[
		67513,
		1,
		""
	],
	[
		67514,
		1,
		""
	],
	[
		[
			67515,
			67583
		],
		3
	],
	[
		[
			67584,
			67589
		],
		2
	],
	[
		[
			67590,
			67591
		],
		3
	],
	[
		67592,
		2
	],
	[
		67593,
		3
	],
	[
		[
			67594,
			67637
		],
		2
	],
	[
		67638,
		3
	],
	[
		[
			67639,
			67640
		],
		2
	],
	[
		[
			67641,
			67643
		],
		3
	],
	[
		67644,
		2
	],
	[
		[
			67645,
			67646
		],
		3
	],
	[
		67647,
		2
	],
	[
		[
			67648,
			67669
		],
		2
	],
	[
		67670,
		3
	],
	[
		[
			67671,
			67679
		],
		2
	],
	[
		[
			67680,
			67702
		],
		2
	],
	[
		[
			67703,
			67711
		],
		2
	],
	[
		[
			67712,
			67742
		],
		2
	],
	[
		[
			67743,
			67750
		],
		3
	],
	[
		[
			67751,
			67759
		],
		2
	],
	[
		[
			67760,
			67807
		],
		3
	],
	[
		[
			67808,
			67826
		],
		2
	],
	[
		67827,
		3
	],
	[
		[
			67828,
			67829
		],
		2
	],
	[
		[
			67830,
			67834
		],
		3
	],
	[
		[
			67835,
			67839
		],
		2
	],
	[
		[
			67840,
			67861
		],
		2
	],
	[
		[
			67862,
			67865
		],
		2
	],
	[
		[
			67866,
			67867
		],
		2
	],
	[
		[
			67868,
			67870
		],
		3
	],
	[
		67871,
		2
	],
	[
		[
			67872,
			67897
		],
		2
	],
	[
		[
			67898,
			67902
		],
		3
	],
	[
		67903,
		2
	],
	[
		[
			67904,
			67967
		],
		3
	],
	[
		[
			67968,
			68023
		],
		2
	],
	[
		[
			68024,
			68027
		],
		3
	],
	[
		[
			68028,
			68029
		],
		2
	],
	[
		[
			68030,
			68031
		],
		2
	],
	[
		[
			68032,
			68047
		],
		2
	],
	[
		[
			68048,
			68049
		],
		3
	],
	[
		[
			68050,
			68095
		],
		2
	],
	[
		[
			68096,
			68099
		],
		2
	],
	[
		68100,
		3
	],
	[
		[
			68101,
			68102
		],
		2
	],
	[
		[
			68103,
			68107
		],
		3
	],
	[
		[
			68108,
			68115
		],
		2
	],
	[
		68116,
		3
	],
	[
		[
			68117,
			68119
		],
		2
	],
	[
		68120,
		3
	],
	[
		[
			68121,
			68147
		],
		2
	],
	[
		[
			68148,
			68149
		],
		2
	],
	[
		[
			68150,
			68151
		],
		3
	],
	[
		[
			68152,
			68154
		],
		2
	],
	[
		[
			68155,
			68158
		],
		3
	],
	[
		68159,
		2
	],
	[
		[
			68160,
			68167
		],
		2
	],
	[
		68168,
		2
	],
	[
		[
			68169,
			68175
		],
		3
	],
	[
		[
			68176,
			68184
		],
		2
	],
	[
		[
			68185,
			68191
		],
		3
	],
	[
		[
			68192,
			68220
		],
		2
	],
	[
		[
			68221,
			68223
		],
		2
	],
	[
		[
			68224,
			68252
		],
		2
	],
	[
		[
			68253,
			68255
		],
		2
	],
	[
		[
			68256,
			68287
		],
		3
	],
	[
		[
			68288,
			68295
		],
		2
	],
	[
		68296,
		2
	],
	[
		[
			68297,
			68326
		],
		2
	],
	[
		[
			68327,
			68330
		],
		3
	],
	[
		[
			68331,
			68342
		],
		2
	],
	[
		[
			68343,
			68351
		],
		3
	],
	[
		[
			68352,
			68405
		],
		2
	],
	[
		[
			68406,
			68408
		],
		3
	],
	[
		[
			68409,
			68415
		],
		2
	],
	[
		[
			68416,
			68437
		],
		2
	],
	[
		[
			68438,
			68439
		],
		3
	],
	[
		[
			68440,
			68447
		],
		2
	],
	[
		[
			68448,
			68466
		],
		2
	],
	[
		[
			68467,
			68471
		],
		3
	],
	[
		[
			68472,
			68479
		],
		2
	],
	[
		[
			68480,
			68497
		],
		2
	],
	[
		[
			68498,
			68504
		],
		3
	],
	[
		[
			68505,
			68508
		],
		2
	],
	[
		[
			68509,
			68520
		],
		3
	],
	[
		[
			68521,
			68527
		],
		2
	],
	[
		[
			68528,
			68607
		],
		3
	],
	[
		[
			68608,
			68680
		],
		2
	],
	[
		[
			68681,
			68735
		],
		3
	],
	[
		68736,
		1,
		""
	],
	[
		68737,
		1,
		""
	],
	[
		68738,
		1,
		""
	],
	[
		68739,
		1,
		""
	],
	[
		68740,
		1,
		""
	],
	[
		68741,
		1,
		""
	],
	[
		68742,
		1,
		""
	],
	[
		68743,
		1,
		""
	],
	[
		68744,
		1,
		""
	],
	[
		68745,
		1,
		""
	],
	[
		68746,
		1,
		""
	],
	[
		68747,
		1,
		""
	],
	[
		68748,
		1,
		""
	],
	[
		68749,
		1,
		""
	],
	[
		68750,
		1,
		""
	],
	[
		68751,
		1,
		""
	],
	[
		68752,
		1,
		""
	],
	[
		68753,
		1,
		""
	],
	[
		68754,
		1,
		""
	],
	[
		68755,
		1,
		""
	],
	[
		68756,
		1,
		""
	],
	[
		68757,
		1,
		""
	],
	[
		68758,
		1,
		""
	],
	[
		68759,
		1,
		""
	],
	[
		68760,
		1,
		""
	],
	[
		68761,
		1,
		""
	],
	[
		68762,
		1,
		""
	],
	[
		68763,
		1,
		""
	],
	[
		68764,
		1,
		""
	],
	[
		68765,
		1,
		""
	],
	[
		68766,
		1,
		""
	],
	[
		68767,
		1,
		""
	],
	[
		68768,
		1,
		""
	],
	[
		68769,
		1,
		""
	],
	[
		68770,
		1,
		""
	],
	[
		68771,
		1,
		""
	],
	[
		68772,
		1,
		""
	],
	[
		68773,
		1,
		""
	],
	[
		68774,
		1,
		""
	],
	[
		68775,
		1,
		""
	],
	[
		68776,
		1,
		""
	],
	[
		68777,
		1,
		""
	],
	[
		68778,
		1,
		""
	],
	[
		68779,
		1,
		""
	],
	[
		68780,
		1,
		""
	],
	[
		68781,
		1,
		""
	],
	[
		68782,
		1,
		""
	],
	[
		68783,
		1,
		""
	],
	[
		68784,
		1,
		""
	],
	[
		68785,
		1,
		""
	],
	[
		68786,
		1,
		""
	],
	[
		[
			68787,
			68799
		],
		3
	],
	[
		[
			68800,
			68850
		],
		2
	],
	[
		[
			68851,
			68857
		],
		3
	],
	[
		[
			68858,
			68863
		],
		2
	],
	[
		[
			68864,
			68903
		],
		2
	],
	[
		[
			68904,
			68911
		],
		3
	],
	[
		[
			68912,
			68921
		],
		2
	],
	[
		[
			68922,
			69215
		],
		3
	],
	[
		[
			69216,
			69246
		],
		2
	],
	[
		69247,
		3
	],
	[
		[
			69248,
			69289
		],
		2
	],
	[
		69290,
		3
	],
	[
		[
			69291,
			69292
		],
		2
	],
	[
		69293,
		2
	],
	[
		[
			69294,
			69295
		],
		3
	],
	[
		[
			69296,
			69297
		],
		2
	],
	[
		[
			69298,
			69372
		],
		3
	],
	[
		[
			69373,
			69375
		],
		2
	],
	[
		[
			69376,
			69404
		],
		2
	],
	[
		[
			69405,
			69414
		],
		2
	],
	[
		69415,
		2
	],
	[
		[
			69416,
			69423
		],
		3
	],
	[
		[
			69424,
			69456
		],
		2
	],
	[
		[
			69457,
			69465
		],
		2
	],
	[
		[
			69466,
			69487
		],
		3
	],
	[
		[
			69488,
			69509
		],
		2
	],
	[
		[
			69510,
			69513
		],
		2
	],
	[
		[
			69514,
			69551
		],
		3
	],
	[
		[
			69552,
			69572
		],
		2
	],
	[
		[
			69573,
			69579
		],
		2
	],
	[
		[
			69580,
			69599
		],
		3
	],
	[
		[
			69600,
			69622
		],
		2
	],
	[
		[
			69623,
			69631
		],
		3
	],
	[
		[
			69632,
			69702
		],
		2
	],
	[
		[
			69703,
			69709
		],
		2
	],
	[
		[
			69710,
			69713
		],
		3
	],
	[
		[
			69714,
			69733
		],
		2
	],
	[
		[
			69734,
			69743
		],
		2
	],
	[
		[
			69744,
			69749
		],
		2
	],
	[
		[
			69750,
			69758
		],
		3
	],
	[
		69759,
		2
	],
	[
		[
			69760,
			69818
		],
		2
	],
	[
		[
			69819,
			69820
		],
		2
	],
	[
		69821,
		3
	],
	[
		[
			69822,
			69825
		],
		2
	],
	[
		69826,
		2
	],
	[
		[
			69827,
			69836
		],
		3
	],
	[
		69837,
		3
	],
	[
		[
			69838,
			69839
		],
		3
	],
	[
		[
			69840,
			69864
		],
		2
	],
	[
		[
			69865,
			69871
		],
		3
	],
	[
		[
			69872,
			69881
		],
		2
	],
	[
		[
			69882,
			69887
		],
		3
	],
	[
		[
			69888,
			69940
		],
		2
	],
	[
		69941,
		3
	],
	[
		[
			69942,
			69951
		],
		2
	],
	[
		[
			69952,
			69955
		],
		2
	],
	[
		[
			69956,
			69958
		],
		2
	],
	[
		69959,
		2
	],
	[
		[
			69960,
			69967
		],
		3
	],
	[
		[
			69968,
			70003
		],
		2
	],
	[
		[
			70004,
			70005
		],
		2
	],
	[
		70006,
		2
	],
	[
		[
			70007,
			70015
		],
		3
	],
	[
		[
			70016,
			70084
		],
		2
	],
	[
		[
			70085,
			70088
		],
		2
	],
	[
		[
			70089,
			70092
		],
		2
	],
	[
		70093,
		2
	],
	[
		[
			70094,
			70095
		],
		2
	],
	[
		[
			70096,
			70105
		],
		2
	],
	[
		70106,
		2
	],
	[
		70107,
		2
	],
	[
		70108,
		2
	],
	[
		[
			70109,
			70111
		],
		2
	],
	[
		70112,
		3
	],
	[
		[
			70113,
			70132
		],
		2
	],
	[
		[
			70133,
			70143
		],
		3
	],
	[
		[
			70144,
			70161
		],
		2
	],
	[
		70162,
		3
	],
	[
		[
			70163,
			70199
		],
		2
	],
	[
		[
			70200,
			70205
		],
		2
	],
	[
		70206,
		2
	],
	[
		[
			70207,
			70209
		],
		2
	],
	[
		[
			70210,
			70271
		],
		3
	],
	[
		[
			70272,
			70278
		],
		2
	],
	[
		70279,
		3
	],
	[
		70280,
		2
	],
	[
		70281,
		3
	],
	[
		[
			70282,
			70285
		],
		2
	],
	[
		70286,
		3
	],
	[
		[
			70287,
			70301
		],
		2
	],
	[
		70302,
		3
	],
	[
		[
			70303,
			70312
		],
		2
	],
	[
		70313,
		2
	],
	[
		[
			70314,
			70319
		],
		3
	],
	[
		[
			70320,
			70378
		],
		2
	],
	[
		[
			70379,
			70383
		],
		3
	],
	[
		[
			70384,
			70393
		],
		2
	],
	[
		[
			70394,
			70399
		],
		3
	],
	[
		70400,
		2
	],
	[
		[
			70401,
			70403
		],
		2
	],
	[
		70404,
		3
	],
	[
		[
			70405,
			70412
		],
		2
	],
	[
		[
			70413,
			70414
		],
		3
	],
	[
		[
			70415,
			70416
		],
		2
	],
	[
		[
			70417,
			70418
		],
		3
	],
	[
		[
			70419,
			70440
		],
		2
	],
	[
		70441,
		3
	],
	[
		[
			70442,
			70448
		],
		2
	],
	[
		70449,
		3
	],
	[
		[
			70450,
			70451
		],
		2
	],
	[
		70452,
		3
	],
	[
		[
			70453,
			70457
		],
		2
	],
	[
		70458,
		3
	],
	[
		70459,
		2
	],
	[
		[
			70460,
			70468
		],
		2
	],
	[
		[
			70469,
			70470
		],
		3
	],
	[
		[
			70471,
			70472
		],
		2
	],
	[
		[
			70473,
			70474
		],
		3
	],
	[
		[
			70475,
			70477
		],
		2
	],
	[
		[
			70478,
			70479
		],
		3
	],
	[
		70480,
		2
	],
	[
		[
			70481,
			70486
		],
		3
	],
	[
		70487,
		2
	],
	[
		[
			70488,
			70492
		],
		3
	],
	[
		[
			70493,
			70499
		],
		2
	],
	[
		[
			70500,
			70501
		],
		3
	],
	[
		[
			70502,
			70508
		],
		2
	],
	[
		[
			70509,
			70511
		],
		3
	],
	[
		[
			70512,
			70516
		],
		2
	],
	[
		[
			70517,
			70655
		],
		3
	],
	[
		[
			70656,
			70730
		],
		2
	],
	[
		[
			70731,
			70735
		],
		2
	],
	[
		[
			70736,
			70745
		],
		2
	],
	[
		70746,
		2
	],
	[
		70747,
		2
	],
	[
		70748,
		3
	],
	[
		70749,
		2
	],
	[
		70750,
		2
	],
	[
		70751,
		2
	],
	[
		[
			70752,
			70753
		],
		2
	],
	[
		[
			70754,
			70783
		],
		3
	],
	[
		[
			70784,
			70853
		],
		2
	],
	[
		70854,
		2
	],
	[
		70855,
		2
	],
	[
		[
			70856,
			70863
		],
		3
	],
	[
		[
			70864,
			70873
		],
		2
	],
	[
		[
			70874,
			71039
		],
		3
	],
	[
		[
			71040,
			71093
		],
		2
	],
	[
		[
			71094,
			71095
		],
		3
	],
	[
		[
			71096,
			71104
		],
		2
	],
	[
		[
			71105,
			71113
		],
		2
	],
	[
		[
			71114,
			71127
		],
		2
	],
	[
		[
			71128,
			71133
		],
		2
	],
	[
		[
			71134,
			71167
		],
		3
	],
	[
		[
			71168,
			71232
		],
		2
	],
	[
		[
			71233,
			71235
		],
		2
	],
	[
		71236,
		2
	],
	[
		[
			71237,
			71247
		],
		3
	],
	[
		[
			71248,
			71257
		],
		2
	],
	[
		[
			71258,
			71263
		],
		3
	],
	[
		[
			71264,
			71276
		],
		2
	],
	[
		[
			71277,
			71295
		],
		3
	],
	[
		[
			71296,
			71351
		],
		2
	],
	[
		71352,
		2
	],
	[
		71353,
		2
	],
	[
		[
			71354,
			71359
		],
		3
	],
	[
		[
			71360,
			71369
		],
		2
	],
	[
		[
			71370,
			71423
		],
		3
	],
	[
		[
			71424,
			71449
		],
		2
	],
	[
		71450,
		2
	],
	[
		[
			71451,
			71452
		],
		3
	],
	[
		[
			71453,
			71467
		],
		2
	],
	[
		[
			71468,
			71471
		],
		3
	],
	[
		[
			71472,
			71481
		],
		2
	],
	[
		[
			71482,
			71487
		],
		2
	],
	[
		[
			71488,
			71494
		],
		2
	],
	[
		[
			71495,
			71679
		],
		3
	],
	[
		[
			71680,
			71738
		],
		2
	],
	[
		71739,
		2
	],
	[
		[
			71740,
			71839
		],
		3
	],
	[
		71840,
		1,
		""
	],
	[
		71841,
		1,
		""
	],
	[
		71842,
		1,
		""
	],
	[
		71843,
		1,
		""
	],
	[
		71844,
		1,
		""
	],
	[
		71845,
		1,
		""
	],
	[
		71846,
		1,
		""
	],
	[
		71847,
		1,
		""
	],
	[
		71848,
		1,
		""
	],
	[
		71849,
		1,
		""
	],
	[
		71850,
		1,
		""
	],
	[
		71851,
		1,
		""
	],
	[
		71852,
		1,
		""
	],
	[
		71853,
		1,
		""
	],
	[
		71854,
		1,
		""
	],
	[
		71855,
		1,
		""
	],
	[
		71856,
		1,
		""
	],
	[
		71857,
		1,
		""
	],
	[
		71858,
		1,
		""
	],
	[
		71859,
		1,
		""
	],
	[
		71860,
		1,
		""
	],
	[
		71861,
		1,
		""
	],
	[
		71862,
		1,
		""
	],
	[
		71863,
		1,
		""
	],
	[
		71864,
		1,
		""
	],
	[
		71865,
		1,
		""
	],
	[
		71866,
		1,
		""
	],
	[
		71867,
		1,
		""
	],
	[
		71868,
		1,
		""
	],
	[
		71869,
		1,
		""
	],
	[
		71870,
		1,
		""
	],
	[
		71871,
		1,
		""
	],
	[
		[
			71872,
			71913
		],
		2
	],
	[
		[
			71914,
			71922
		],
		2
	],
	[
		[
			71923,
			71934
		],
		3
	],
	[
		71935,
		2
	],
	[
		[
			71936,
			71942
		],
		2
	],
	[
		[
			71943,
			71944
		],
		3
	],
	[
		71945,
		2
	],
	[
		[
			71946,
			71947
		],
		3
	],
	[
		[
			71948,
			71955
		],
		2
	],
	[
		71956,
		3
	],
	[
		[
			71957,
			71958
		],
		2
	],
	[
		71959,
		3
	],
	[
		[
			71960,
			71989
		],
		2
	],
	[
		71990,
		3
	],
	[
		[
			71991,
			71992
		],
		2
	],
	[
		[
			71993,
			71994
		],
		3
	],
	[
		[
			71995,
			72003
		],
		2
	],
	[
		[
			72004,
			72006
		],
		2
	],
	[
		[
			72007,
			72015
		],
		3
	],
	[
		[
			72016,
			72025
		],
		2
	],
	[
		[
			72026,
			72095
		],
		3
	],
	[
		[
			72096,
			72103
		],
		2
	],
	[
		[
			72104,
			72105
		],
		3
	],
	[
		[
			72106,
			72151
		],
		2
	],
	[
		[
			72152,
			72153
		],
		3
	],
	[
		[
			72154,
			72161
		],
		2
	],
	[
		72162,
		2
	],
	[
		[
			72163,
			72164
		],
		2
	],
	[
		[
			72165,
			72191
		],
		3
	],
	[
		[
			72192,
			72254
		],
		2
	],
	[
		[
			72255,
			72262
		],
		2
	],
	[
		72263,
		2
	],
	[
		[
			72264,
			72271
		],
		3
	],
	[
		[
			72272,
			72323
		],
		2
	],
	[
		[
			72324,
			72325
		],
		2
	],
	[
		[
			72326,
			72345
		],
		2
	],
	[
		[
			72346,
			72348
		],
		2
	],
	[
		72349,
		2
	],
	[
		[
			72350,
			72354
		],
		2
	],
	[
		[
			72355,
			72367
		],
		3
	],
	[
		[
			72368,
			72383
		],
		2
	],
	[
		[
			72384,
			72440
		],
		2
	],
	[
		[
			72441,
			72447
		],
		3
	],
	[
		[
			72448,
			72457
		],
		2
	],
	[
		[
			72458,
			72703
		],
		3
	],
	[
		[
			72704,
			72712
		],
		2
	],
	[
		72713,
		3
	],
	[
		[
			72714,
			72758
		],
		2
	],
	[
		72759,
		3
	],
	[
		[
			72760,
			72768
		],
		2
	],
	[
		[
			72769,
			72773
		],
		2
	],
	[
		[
			72774,
			72783
		],
		3
	],
	[
		[
			72784,
			72793
		],
		2
	],
	[
		[
			72794,
			72812
		],
		2
	],
	[
		[
			72813,
			72815
		],
		3
	],
	[
		[
			72816,
			72817
		],
		2
	],
	[
		[
			72818,
			72847
		],
		2
	],
	[
		[
			72848,
			72849
		],
		3
	],
	[
		[
			72850,
			72871
		],
		2
	],
	[
		72872,
		3
	],
	[
		[
			72873,
			72886
		],
		2
	],
	[
		[
			72887,
			72959
		],
		3
	],
	[
		[
			72960,
			72966
		],
		2
	],
	[
		72967,
		3
	],
	[
		[
			72968,
			72969
		],
		2
	],
	[
		72970,
		3
	],
	[
		[
			72971,
			73014
		],
		2
	],
	[
		[
			73015,
			73017
		],
		3
	],
	[
		73018,
		2
	],
	[
		73019,
		3
	],
	[
		[
			73020,
			73021
		],
		2
	],
	[
		73022,
		3
	],
	[
		[
			73023,
			73031
		],
		2
	],
	[
		[
			73032,
			73039
		],
		3
	],
	[
		[
			73040,
			73049
		],
		2
	],
	[
		[
			73050,
			73055
		],
		3
	],
	[
		[
			73056,
			73061
		],
		2
	],
	[
		73062,
		3
	],
	[
		[
			73063,
			73064
		],
		2
	],
	[
		73065,
		3
	],
	[
		[
			73066,
			73102
		],
		2
	],
	[
		73103,
		3
	],
	[
		[
			73104,
			73105
		],
		2
	],
	[
		73106,
		3
	],
	[
		[
			73107,
			73112
		],
		2
	],
	[
		[
			73113,
			73119
		],
		3
	],
	[
		[
			73120,
			73129
		],
		2
	],
	[
		[
			73130,
			73439
		],
		3
	],
	[
		[
			73440,
			73462
		],
		2
	],
	[
		[
			73463,
			73464
		],
		2
	],
	[
		[
			73465,
			73471
		],
		3
	],
	[
		[
			73472,
			73488
		],
		2
	],
	[
		73489,
		3
	],
	[
		[
			73490,
			73530
		],
		2
	],
	[
		[
			73531,
			73533
		],
		3
	],
	[
		[
			73534,
			73538
		],
		2
	],
	[
		[
			73539,
			73551
		],
		2
	],
	[
		[
			73552,
			73561
		],
		2
	],
	[
		[
			73562,
			73647
		],
		3
	],
	[
		73648,
		2
	],
	[
		[
			73649,
			73663
		],
		3
	],
	[
		[
			73664,
			73713
		],
		2
	],
	[
		[
			73714,
			73726
		],
		3
	],
	[
		73727,
		2
	],
	[
		[
			73728,
			74606
		],
		2
	],
	[
		[
			74607,
			74648
		],
		2
	],
	[
		74649,
		2
	],
	[
		[
			74650,
			74751
		],
		3
	],
	[
		[
			74752,
			74850
		],
		2
	],
	[
		[
			74851,
			74862
		],
		2
	],
	[
		74863,
		3
	],
	[
		[
			74864,
			74867
		],
		2
	],
	[
		74868,
		2
	],
	[
		[
			74869,
			74879
		],
		3
	],
	[
		[
			74880,
			75075
		],
		2
	],
	[
		[
			75076,
			77711
		],
		3
	],
	[
		[
			77712,
			77808
		],
		2
	],
	[
		[
			77809,
			77810
		],
		2
	],
	[
		[
			77811,
			77823
		],
		3
	],
	[
		[
			77824,
			78894
		],
		2
	],
	[
		78895,
		2
	],
	[
		[
			78896,
			78904
		],
		3
	],
	[
		[
			78905,
			78911
		],
		3
	],
	[
		[
			78912,
			78933
		],
		2
	],
	[
		[
			78934,
			82943
		],
		3
	],
	[
		[
			82944,
			83526
		],
		2
	],
	[
		[
			83527,
			92159
		],
		3
	],
	[
		[
			92160,
			92728
		],
		2
	],
	[
		[
			92729,
			92735
		],
		3
	],
	[
		[
			92736,
			92766
		],
		2
	],
	[
		92767,
		3
	],
	[
		[
			92768,
			92777
		],
		2
	],
	[
		[
			92778,
			92781
		],
		3
	],
	[
		[
			92782,
			92783
		],
		2
	],
	[
		[
			92784,
			92862
		],
		2
	],
	[
		92863,
		3
	],
	[
		[
			92864,
			92873
		],
		2
	],
	[
		[
			92874,
			92879
		],
		3
	],
	[
		[
			92880,
			92909
		],
		2
	],
	[
		[
			92910,
			92911
		],
		3
	],
	[
		[
			92912,
			92916
		],
		2
	],
	[
		92917,
		2
	],
	[
		[
			92918,
			92927
		],
		3
	],
	[
		[
			92928,
			92982
		],
		2
	],
	[
		[
			92983,
			92991
		],
		2
	],
	[
		[
			92992,
			92995
		],
		2
	],
	[
		[
			92996,
			92997
		],
		2
	],
	[
		[
			92998,
			93007
		],
		3
	],
	[
		[
			93008,
			93017
		],
		2
	],
	[
		93018,
		3
	],
	[
		[
			93019,
			93025
		],
		2
	],
	[
		93026,
		3
	],
	[
		[
			93027,
			93047
		],
		2
	],
	[
		[
			93048,
			93052
		],
		3
	],
	[
		[
			93053,
			93071
		],
		2
	],
	[
		[
			93072,
			93759
		],
		3
	],
	[
		93760,
		1,
		""
	],
	[
		93761,
		1,
		""
	],
	[
		93762,
		1,
		""
	],
	[
		93763,
		1,
		""
	],
	[
		93764,
		1,
		""
	],
	[
		93765,
		1,
		""
	],
	[
		93766,
		1,
		""
	],
	[
		93767,
		1,
		""
	],
	[
		93768,
		1,
		""
	],
	[
		93769,
		1,
		""
	],
	[
		93770,
		1,
		""
	],
	[
		93771,
		1,
		""
	],
	[
		93772,
		1,
		""
	],
	[
		93773,
		1,
		""
	],
	[
		93774,
		1,
		""
	],
	[
		93775,
		1,
		""
	],
	[
		93776,
		1,
		""
	],
	[
		93777,
		1,
		""
	],
	[
		93778,
		1,
		""
	],
	[
		93779,
		1,
		""
	],
	[
		93780,
		1,
		""
	],
	[
		93781,
		1,
		""
	],
	[
		93782,
		1,
		""
	],
	[
		93783,
		1,
		""
	],
	[
		93784,
		1,
		""
	],
	[
		93785,
		1,
		""
	],
	[
		93786,
		1,
		""
	],
	[
		93787,
		1,
		""
	],
	[
		93788,
		1,
		""
	],
	[
		93789,
		1,
		""
	],
	[
		93790,
		1,
		""
	],
	[
		93791,
		1,
		""
	],
	[
		[
			93792,
			93823
		],
		2
	],
	[
		[
			93824,
			93850
		],
		2
	],
	[
		[
			93851,
			93951
		],
		3
	],
	[
		[
			93952,
			94020
		],
		2
	],
	[
		[
			94021,
			94026
		],
		2
	],
	[
		[
			94027,
			94030
		],
		3
	],
	[
		94031,
		2
	],
	[
		[
			94032,
			94078
		],
		2
	],
	[
		[
			94079,
			94087
		],
		2
	],
	[
		[
			94088,
			94094
		],
		3
	],
	[
		[
			94095,
			94111
		],
		2
	],
	[
		[
			94112,
			94175
		],
		3
	],
	[
		94176,
		2
	],
	[
		94177,
		2
	],
	[
		94178,
		2
	],
	[
		94179,
		2
	],
	[
		94180,
		2
	],
	[
		[
			94181,
			94191
		],
		3
	],
	[
		[
			94192,
			94193
		],
		2
	],
	[
		[
			94194,
			94207
		],
		3
	],
	[
		[
			94208,
			100332
		],
		2
	],
	[
		[
			100333,
			100337
		],
		2
	],
	[
		[
			100338,
			100343
		],
		2
	],
	[
		[
			100344,
			100351
		],
		3
	],
	[
		[
			100352,
			101106
		],
		2
	],
	[
		[
			101107,
			101589
		],
		2
	],
	[
		[
			101590,
			101631
		],
		3
	],
	[
		[
			101632,
			101640
		],
		2
	],
	[
		[
			101641,
			110575
		],
		3
	],
	[
		[
			110576,
			110579
		],
		2
	],
	[
		110580,
		3
	],
	[
		[
			110581,
			110587
		],
		2
	],
	[
		110588,
		3
	],
	[
		[
			110589,
			110590
		],
		2
	],
	[
		110591,
		3
	],
	[
		[
			110592,
			110593
		],
		2
	],
	[
		[
			110594,
			110878
		],
		2
	],
	[
		[
			110879,
			110882
		],
		2
	],
	[
		[
			110883,
			110897
		],
		3
	],
	[
		110898,
		2
	],
	[
		[
			110899,
			110927
		],
		3
	],
	[
		[
			110928,
			110930
		],
		2
	],
	[
		[
			110931,
			110932
		],
		3
	],
	[
		110933,
		2
	],
	[
		[
			110934,
			110947
		],
		3
	],
	[
		[
			110948,
			110951
		],
		2
	],
	[
		[
			110952,
			110959
		],
		3
	],
	[
		[
			110960,
			111355
		],
		2
	],
	[
		[
			111356,
			113663
		],
		3
	],
	[
		[
			113664,
			113770
		],
		2
	],
	[
		[
			113771,
			113775
		],
		3
	],
	[
		[
			113776,
			113788
		],
		2
	],
	[
		[
			113789,
			113791
		],
		3
	],
	[
		[
			113792,
			113800
		],
		2
	],
	[
		[
			113801,
			113807
		],
		3
	],
	[
		[
			113808,
			113817
		],
		2
	],
	[
		[
			113818,
			113819
		],
		3
	],
	[
		113820,
		2
	],
	[
		[
			113821,
			113822
		],
		2
	],
	[
		113823,
		2
	],
	[
		[
			113824,
			113827
		],
		7
	],
	[
		[
			113828,
			118527
		],
		3
	],
	[
		[
			118528,
			118573
		],
		2
	],
	[
		[
			118574,
			118575
		],
		3
	],
	[
		[
			118576,
			118598
		],
		2
	],
	[
		[
			118599,
			118607
		],
		3
	],
	[
		[
			118608,
			118723
		],
		2
	],
	[
		[
			118724,
			118783
		],
		3
	],
	[
		[
			118784,
			119029
		],
		2
	],
	[
		[
			119030,
			119039
		],
		3
	],
	[
		[
			119040,
			119078
		],
		2
	],
	[
		[
			119079,
			119080
		],
		3
	],
	[
		119081,
		2
	],
	[
		[
			119082,
			119133
		],
		2
	],
	[
		119134,
		1,
		""
	],
	[
		119135,
		1,
		""
	],
	[
		119136,
		1,
		""
	],
	[
		119137,
		1,
		""
	],
	[
		119138,
		1,
		""
	],
	[
		119139,
		1,
		""
	],
	[
		119140,
		1,
		""
	],
	[
		[
			119141,
			119154
		],
		2
	],
	[
		[
			119155,
			119162
		],
		3
	],
	[
		[
			119163,
			119226
		],
		2
	],
	[
		119227,
		1,
		""
	],
	[
		119228,
		1,
		""
	],
	[
		119229,
		1,
		""
	],
	[
		119230,
		1,
		""
	],
	[
		119231,
		1,
		""
	],
	[
		119232,
		1,
		""
	],
	[
		[
			119233,
			119261
		],
		2
	],
	[
		[
			119262,
			119272
		],
		2
	],
	[
		[
			119273,
			119274
		],
		2
	],
	[
		[
			119275,
			119295
		],
		3
	],
	[
		[
			119296,
			119365
		],
		2
	],
	[
		[
			119366,
			119487
		],
		3
	],
	[
		[
			119488,
			119507
		],
		2
	],
	[
		[
			119508,
			119519
		],
		3
	],
	[
		[
			119520,
			119539
		],
		2
	],
	[
		[
			119540,
			119551
		],
		3
	],
	[
		[
			119552,
			119638
		],
		2
	],
	[
		[
			119639,
			119647
		],
		3
	],
	[
		[
			119648,
			119665
		],
		2
	],
	[
		[
			119666,
			119672
		],
		2
	],
	[
		[
			119673,
			119807
		],
		3
	],
	[
		119808,
		1,
		"a"
	],
	[
		119809,
		1,
		"b"
	],
	[
		119810,
		1,
		"c"
	],
	[
		119811,
		1,
		"d"
	],
	[
		119812,
		1,
		"e"
	],
	[
		119813,
		1,
		"f"
	],
	[
		119814,
		1,
		"g"
	],
	[
		119815,
		1,
		"h"
	],
	[
		119816,
		1,
		"i"
	],
	[
		119817,
		1,
		"j"
	],
	[
		119818,
		1,
		"k"
	],
	[
		119819,
		1,
		"l"
	],
	[
		119820,
		1,
		"m"
	],
	[
		119821,
		1,
		"n"
	],
	[
		119822,
		1,
		"o"
	],
	[
		119823,
		1,
		"p"
	],
	[
		119824,
		1,
		"q"
	],
	[
		119825,
		1,
		"r"
	],
	[
		119826,
		1,
		"s"
	],
	[
		119827,
		1,
		"t"
	],
	[
		119828,
		1,
		"u"
	],
	[
		119829,
		1,
		"v"
	],
	[
		119830,
		1,
		"w"
	],
	[
		119831,
		1,
		"x"
	],
	[
		119832,
		1,
		"y"
	],
	[
		119833,
		1,
		"z"
	],
	[
		119834,
		1,
		"a"
	],
	[
		119835,
		1,
		"b"
	],
	[
		119836,
		1,
		"c"
	],
	[
		119837,
		1,
		"d"
	],
	[
		119838,
		1,
		"e"
	],
	[
		119839,
		1,
		"f"
	],
	[
		119840,
		1,
		"g"
	],
	[
		119841,
		1,
		"h"
	],
	[
		119842,
		1,
		"i"
	],
	[
		119843,
		1,
		"j"
	],
	[
		119844,
		1,
		"k"
	],
	[
		119845,
		1,
		"l"
	],
	[
		119846,
		1,
		"m"
	],
	[
		119847,
		1,
		"n"
	],
	[
		119848,
		1,
		"o"
	],
	[
		119849,
		1,
		"p"
	],
	[
		119850,
		1,
		"q"
	],
	[
		119851,
		1,
		"r"
	],
	[
		119852,
		1,
		"s"
	],
	[
		119853,
		1,
		"t"
	],
	[
		119854,
		1,
		"u"
	],
	[
		119855,
		1,
		"v"
	],
	[
		119856,
		1,
		"w"
	],
	[
		119857,
		1,
		"x"
	],
	[
		119858,
		1,
		"y"
	],
	[
		119859,
		1,
		"z"
	],
	[
		119860,
		1,
		"a"
	],
	[
		119861,
		1,
		"b"
	],
	[
		119862,
		1,
		"c"
	],
	[
		119863,
		1,
		"d"
	],
	[
		119864,
		1,
		"e"
	],
	[
		119865,
		1,
		"f"
	],
	[
		119866,
		1,
		"g"
	],
	[
		119867,
		1,
		"h"
	],
	[
		119868,
		1,
		"i"
	],
	[
		119869,
		1,
		"j"
	],
	[
		119870,
		1,
		"k"
	],
	[
		119871,
		1,
		"l"
	],
	[
		119872,
		1,
		"m"
	],
	[
		119873,
		1,
		"n"
	],
	[
		119874,
		1,
		"o"
	],
	[
		119875,
		1,
		"p"
	],
	[
		119876,
		1,
		"q"
	],
	[
		119877,
		1,
		"r"
	],
	[
		119878,
		1,
		"s"
	],
	[
		119879,
		1,
		"t"
	],
	[
		119880,
		1,
		"u"
	],
	[
		119881,
		1,
		"v"
	],
	[
		119882,
		1,
		"w"
	],
	[
		119883,
		1,
		"x"
	],
	[
		119884,
		1,
		"y"
	],
	[
		119885,
		1,
		"z"
	],
	[
		119886,
		1,
		"a"
	],
	[
		119887,
		1,
		"b"
	],
	[
		119888,
		1,
		"c"
	],
	[
		119889,
		1,
		"d"
	],
	[
		119890,
		1,
		"e"
	],
	[
		119891,
		1,
		"f"
	],
	[
		119892,
		1,
		"g"
	],
	[
		119893,
		3
	],
	[
		119894,
		1,
		"i"
	],
	[
		119895,
		1,
		"j"
	],
	[
		119896,
		1,
		"k"
	],
	[
		119897,
		1,
		"l"
	],
	[
		119898,
		1,
		"m"
	],
	[
		119899,
		1,
		"n"
	],
	[
		119900,
		1,
		"o"
	],
	[
		119901,
		1,
		"p"
	],
	[
		119902,
		1,
		"q"
	],
	[
		119903,
		1,
		"r"
	],
	[
		119904,
		1,
		"s"
	],
	[
		119905,
		1,
		"t"
	],
	[
		119906,
		1,
		"u"
	],
	[
		119907,
		1,
		"v"
	],
	[
		119908,
		1,
		"w"
	],
	[
		119909,
		1,
		"x"
	],
	[
		119910,
		1,
		"y"
	],
	[
		119911,
		1,
		"z"
	],
	[
		119912,
		1,
		"a"
	],
	[
		119913,
		1,
		"b"
	],
	[
		119914,
		1,
		"c"
	],
	[
		119915,
		1,
		"d"
	],
	[
		119916,
		1,
		"e"
	],
	[
		119917,
		1,
		"f"
	],
	[
		119918,
		1,
		"g"
	],
	[
		119919,
		1,
		"h"
	],
	[
		119920,
		1,
		"i"
	],
	[
		119921,
		1,
		"j"
	],
	[
		119922,
		1,
		"k"
	],
	[
		119923,
		1,
		"l"
	],
	[
		119924,
		1,
		"m"
	],
	[
		119925,
		1,
		"n"
	],
	[
		119926,
		1,
		"o"
	],
	[
		119927,
		1,
		"p"
	],
	[
		119928,
		1,
		"q"
	],
	[
		119929,
		1,
		"r"
	],
	[
		119930,
		1,
		"s"
	],
	[
		119931,
		1,
		"t"
	],
	[
		119932,
		1,
		"u"
	],
	[
		119933,
		1,
		"v"
	],
	[
		119934,
		1,
		"w"
	],
	[
		119935,
		1,
		"x"
	],
	[
		119936,
		1,
		"y"
	],
	[
		119937,
		1,
		"z"
	],
	[
		119938,
		1,
		"a"
	],
	[
		119939,
		1,
		"b"
	],
	[
		119940,
		1,
		"c"
	],
	[
		119941,
		1,
		"d"
	],
	[
		119942,
		1,
		"e"
	],
	[
		119943,
		1,
		"f"
	],
	[
		119944,
		1,
		"g"
	],
	[
		119945,
		1,
		"h"
	],
	[
		119946,
		1,
		"i"
	],
	[
		119947,
		1,
		"j"
	],
	[
		119948,
		1,
		"k"
	],
	[
		119949,
		1,
		"l"
	],
	[
		119950,
		1,
		"m"
	],
	[
		119951,
		1,
		"n"
	],
	[
		119952,
		1,
		"o"
	],
	[
		119953,
		1,
		"p"
	],
	[
		119954,
		1,
		"q"
	],
	[
		119955,
		1,
		"r"
	],
	[
		119956,
		1,
		"s"
	],
	[
		119957,
		1,
		"t"
	],
	[
		119958,
		1,
		"u"
	],
	[
		119959,
		1,
		"v"
	],
	[
		119960,
		1,
		"w"
	],
	[
		119961,
		1,
		"x"
	],
	[
		119962,
		1,
		"y"
	],
	[
		119963,
		1,
		"z"
	],
	[
		119964,
		1,
		"a"
	],
	[
		119965,
		3
	],
	[
		119966,
		1,
		"c"
	],
	[
		119967,
		1,
		"d"
	],
	[
		[
			119968,
			119969
		],
		3
	],
	[
		119970,
		1,
		"g"
	],
	[
		[
			119971,
			119972
		],
		3
	],
	[
		119973,
		1,
		"j"
	],
	[
		119974,
		1,
		"k"
	],
	[
		[
			119975,
			119976
		],
		3
	],
	[
		119977,
		1,
		"n"
	],
	[
		119978,
		1,
		"o"
	],
	[
		119979,
		1,
		"p"
	],
	[
		119980,
		1,
		"q"
	],
	[
		119981,
		3
	],
	[
		119982,
		1,
		"s"
	],
	[
		119983,
		1,
		"t"
	],
	[
		119984,
		1,
		"u"
	],
	[
		119985,
		1,
		"v"
	],
	[
		119986,
		1,
		"w"
	],
	[
		119987,
		1,
		"x"
	],
	[
		119988,
		1,
		"y"
	],
	[
		119989,
		1,
		"z"
	],
	[
		119990,
		1,
		"a"
	],
	[
		119991,
		1,
		"b"
	],
	[
		119992,
		1,
		"c"
	],
	[
		119993,
		1,
		"d"
	],
	[
		119994,
		3
	],
	[
		119995,
		1,
		"f"
	],
	[
		119996,
		3
	],
	[
		119997,
		1,
		"h"
	],
	[
		119998,
		1,
		"i"
	],
	[
		119999,
		1,
		"j"
	],
	[
		120000,
		1,
		"k"
	],
	[
		120001,
		1,
		"l"
	],
	[
		120002,
		1,
		"m"
	],
	[
		120003,
		1,
		"n"
	],
	[
		120004,
		3
	],
	[
		120005,
		1,
		"p"
	],
	[
		120006,
		1,
		"q"
	],
	[
		120007,
		1,
		"r"
	],
	[
		120008,
		1,
		"s"
	],
	[
		120009,
		1,
		"t"
	],
	[
		120010,
		1,
		"u"
	],
	[
		120011,
		1,
		"v"
	],
	[
		120012,
		1,
		"w"
	],
	[
		120013,
		1,
		"x"
	],
	[
		120014,
		1,
		"y"
	],
	[
		120015,
		1,
		"z"
	],
	[
		120016,
		1,
		"a"
	],
	[
		120017,
		1,
		"b"
	],
	[
		120018,
		1,
		"c"
	],
	[
		120019,
		1,
		"d"
	],
	[
		120020,
		1,
		"e"
	],
	[
		120021,
		1,
		"f"
	],
	[
		120022,
		1,
		"g"
	],
	[
		120023,
		1,
		"h"
	],
	[
		120024,
		1,
		"i"
	],
	[
		120025,
		1,
		"j"
	],
	[
		120026,
		1,
		"k"
	],
	[
		120027,
		1,
		"l"
	],
	[
		120028,
		1,
		"m"
	],
	[
		120029,
		1,
		"n"
	],
	[
		120030,
		1,
		"o"
	],
	[
		120031,
		1,
		"p"
	],
	[
		120032,
		1,
		"q"
	],
	[
		120033,
		1,
		"r"
	],
	[
		120034,
		1,
		"s"
	],
	[
		120035,
		1,
		"t"
	],
	[
		120036,
		1,
		"u"
	],
	[
		120037,
		1,
		"v"
	],
	[
		120038,
		1,
		"w"
	],
	[
		120039,
		1,
		"x"
	],
	[
		120040,
		1,
		"y"
	],
	[
		120041,
		1,
		"z"
	],
	[
		120042,
		1,
		"a"
	],
	[
		120043,
		1,
		"b"
	],
	[
		120044,
		1,
		"c"
	],
	[
		120045,
		1,
		"d"
	],
	[
		120046,
		1,
		"e"
	],
	[
		120047,
		1,
		"f"
	],
	[
		120048,
		1,
		"g"
	],
	[
		120049,
		1,
		"h"
	],
	[
		120050,
		1,
		"i"
	],
	[
		120051,
		1,
		"j"
	],
	[
		120052,
		1,
		"k"
	],
	[
		120053,
		1,
		"l"
	],
	[
		120054,
		1,
		"m"
	],
	[
		120055,
		1,
		"n"
	],
	[
		120056,
		1,
		"o"
	],
	[
		120057,
		1,
		"p"
	],
	[
		120058,
		1,
		"q"
	],
	[
		120059,
		1,
		"r"
	],
	[
		120060,
		1,
		"s"
	],
	[
		120061,
		1,
		"t"
	],
	[
		120062,
		1,
		"u"
	],
	[
		120063,
		1,
		"v"
	],
	[
		120064,
		1,
		"w"
	],
	[
		120065,
		1,
		"x"
	],
	[
		120066,
		1,
		"y"
	],
	[
		120067,
		1,
		"z"
	],
	[
		120068,
		1,
		"a"
	],
	[
		120069,
		1,
		"b"
	],
	[
		120070,
		3
	],
	[
		120071,
		1,
		"d"
	],
	[
		120072,
		1,
		"e"
	],
	[
		120073,
		1,
		"f"
	],
	[
		120074,
		1,
		"g"
	],
	[
		[
			120075,
			120076
		],
		3
	],
	[
		120077,
		1,
		"j"
	],
	[
		120078,
		1,
		"k"
	],
	[
		120079,
		1,
		"l"
	],
	[
		120080,
		1,
		"m"
	],
	[
		120081,
		1,
		"n"
	],
	[
		120082,
		1,
		"o"
	],
	[
		120083,
		1,
		"p"
	],
	[
		120084,
		1,
		"q"
	],
	[
		120085,
		3
	],
	[
		120086,
		1,
		"s"
	],
	[
		120087,
		1,
		"t"
	],
	[
		120088,
		1,
		"u"
	],
	[
		120089,
		1,
		"v"
	],
	[
		120090,
		1,
		"w"
	],
	[
		120091,
		1,
		"x"
	],
	[
		120092,
		1,
		"y"
	],
	[
		120093,
		3
	],
	[
		120094,
		1,
		"a"
	],
	[
		120095,
		1,
		"b"
	],
	[
		120096,
		1,
		"c"
	],
	[
		120097,
		1,
		"d"
	],
	[
		120098,
		1,
		"e"
	],
	[
		120099,
		1,
		"f"
	],
	[
		120100,
		1,
		"g"
	],
	[
		120101,
		1,
		"h"
	],
	[
		120102,
		1,
		"i"
	],
	[
		120103,
		1,
		"j"
	],
	[
		120104,
		1,
		"k"
	],
	[
		120105,
		1,
		"l"
	],
	[
		120106,
		1,
		"m"
	],
	[
		120107,
		1,
		"n"
	],
	[
		120108,
		1,
		"o"
	],
	[
		120109,
		1,
		"p"
	],
	[
		120110,
		1,
		"q"
	],
	[
		120111,
		1,
		"r"
	],
	[
		120112,
		1,
		"s"
	],
	[
		120113,
		1,
		"t"
	],
	[
		120114,
		1,
		"u"
	],
	[
		120115,
		1,
		"v"
	],
	[
		120116,
		1,
		"w"
	],
	[
		120117,
		1,
		"x"
	],
	[
		120118,
		1,
		"y"
	],
	[
		120119,
		1,
		"z"
	],
	[
		120120,
		1,
		"a"
	],
	[
		120121,
		1,
		"b"
	],
	[
		120122,
		3
	],
	[
		120123,
		1,
		"d"
	],
	[
		120124,
		1,
		"e"
	],
	[
		120125,
		1,
		"f"
	],
	[
		120126,
		1,
		"g"
	],
	[
		120127,
		3
	],
	[
		120128,
		1,
		"i"
	],
	[
		120129,
		1,
		"j"
	],
	[
		120130,
		1,
		"k"
	],
	[
		120131,
		1,
		"l"
	],
	[
		120132,
		1,
		"m"
	],
	[
		120133,
		3
	],
	[
		120134,
		1,
		"o"
	],
	[
		[
			120135,
			120137
		],
		3
	],
	[
		120138,
		1,
		"s"
	],
	[
		120139,
		1,
		"t"
	],
	[
		120140,
		1,
		"u"
	],
	[
		120141,
		1,
		"v"
	],
	[
		120142,
		1,
		"w"
	],
	[
		120143,
		1,
		"x"
	],
	[
		120144,
		1,
		"y"
	],
	[
		120145,
		3
	],
	[
		120146,
		1,
		"a"
	],
	[
		120147,
		1,
		"b"
	],
	[
		120148,
		1,
		"c"
	],
	[
		120149,
		1,
		"d"
	],
	[
		120150,
		1,
		"e"
	],
	[
		120151,
		1,
		"f"
	],
	[
		120152,
		1,
		"g"
	],
	[
		120153,
		1,
		"h"
	],
	[
		120154,
		1,
		"i"
	],
	[
		120155,
		1,
		"j"
	],
	[
		120156,
		1,
		"k"
	],
	[
		120157,
		1,
		"l"
	],
	[
		120158,
		1,
		"m"
	],
	[
		120159,
		1,
		"n"
	],
	[
		120160,
		1,
		"o"
	],
	[
		120161,
		1,
		"p"
	],
	[
		120162,
		1,
		"q"
	],
	[
		120163,
		1,
		"r"
	],
	[
		120164,
		1,
		"s"
	],
	[
		120165,
		1,
		"t"
	],
	[
		120166,
		1,
		"u"
	],
	[
		120167,
		1,
		"v"
	],
	[
		120168,
		1,
		"w"
	],
	[
		120169,
		1,
		"x"
	],
	[
		120170,
		1,
		"y"
	],
	[
		120171,
		1,
		"z"
	],
	[
		120172,
		1,
		"a"
	],
	[
		120173,
		1,
		"b"
	],
	[
		120174,
		1,
		"c"
	],
	[
		120175,
		1,
		"d"
	],
	[
		120176,
		1,
		"e"
	],
	[
		120177,
		1,
		"f"
	],
	[
		120178,
		1,
		"g"
	],
	[
		120179,
		1,
		"h"
	],
	[
		120180,
		1,
		"i"
	],
	[
		120181,
		1,
		"j"
	],
	[
		120182,
		1,
		"k"
	],
	[
		120183,
		1,
		"l"
	],
	[
		120184,
		1,
		"m"
	],
	[
		120185,
		1,
		"n"
	],
	[
		120186,
		1,
		"o"
	],
	[
		120187,
		1,
		"p"
	],
	[
		120188,
		1,
		"q"
	],
	[
		120189,
		1,
		"r"
	],
	[
		120190,
		1,
		"s"
	],
	[
		120191,
		1,
		"t"
	],
	[
		120192,
		1,
		"u"
	],
	[
		120193,
		1,
		"v"
	],
	[
		120194,
		1,
		"w"
	],
	[
		120195,
		1,
		"x"
	],
	[
		120196,
		1,
		"y"
	],
	[
		120197,
		1,
		"z"
	],
	[
		120198,
		1,
		"a"
	],
	[
		120199,
		1,
		"b"
	],
	[
		120200,
		1,
		"c"
	],
	[
		120201,
		1,
		"d"
	],
	[
		120202,
		1,
		"e"
	],
	[
		120203,
		1,
		"f"
	],
	[
		120204,
		1,
		"g"
	],
	[
		120205,
		1,
		"h"
	],
	[
		120206,
		1,
		"i"
	],
	[
		120207,
		1,
		"j"
	],
	[
		120208,
		1,
		"k"
	],
	[
		120209,
		1,
		"l"
	],
	[
		120210,
		1,
		"m"
	],
	[
		120211,
		1,
		"n"
	],
	[
		120212,
		1,
		"o"
	],
	[
		120213,
		1,
		"p"
	],
	[
		120214,
		1,
		"q"
	],
	[
		120215,
		1,
		"r"
	],
	[
		120216,
		1,
		"s"
	],
	[
		120217,
		1,
		"t"
	],
	[
		120218,
		1,
		"u"
	],
	[
		120219,
		1,
		"v"
	],
	[
		120220,
		1,
		"w"
	],
	[
		120221,
		1,
		"x"
	],
	[
		120222,
		1,
		"y"
	],
	[
		120223,
		1,
		"z"
	],
	[
		120224,
		1,
		"a"
	],
	[
		120225,
		1,
		"b"
	],
	[
		120226,
		1,
		"c"
	],
	[
		120227,
		1,
		"d"
	],
	[
		120228,
		1,
		"e"
	],
	[
		120229,
		1,
		"f"
	],
	[
		120230,
		1,
		"g"
	],
	[
		120231,
		1,
		"h"
	],
	[
		120232,
		1,
		"i"
	],
	[
		120233,
		1,
		"j"
	],
	[
		120234,
		1,
		"k"
	],
	[
		120235,
		1,
		"l"
	],
	[
		120236,
		1,
		"m"
	],
	[
		120237,
		1,
		"n"
	],
	[
		120238,
		1,
		"o"
	],
	[
		120239,
		1,
		"p"
	],
	[
		120240,
		1,
		"q"
	],
	[
		120241,
		1,
		"r"
	],
	[
		120242,
		1,
		"s"
	],
	[
		120243,
		1,
		"t"
	],
	[
		120244,
		1,
		"u"
	],
	[
		120245,
		1,
		"v"
	],
	[
		120246,
		1,
		"w"
	],
	[
		120247,
		1,
		"x"
	],
	[
		120248,
		1,
		"y"
	],
	[
		120249,
		1,
		"z"
	],
	[
		120250,
		1,
		"a"
	],
	[
		120251,
		1,
		"b"
	],
	[
		120252,
		1,
		"c"
	],
	[
		120253,
		1,
		"d"
	],
	[
		120254,
		1,
		"e"
	],
	[
		120255,
		1,
		"f"
	],
	[
		120256,
		1,
		"g"
	],
	[
		120257,
		1,
		"h"
	],
	[
		120258,
		1,
		"i"
	],
	[
		120259,
		1,
		"j"
	],
	[
		120260,
		1,
		"k"
	],
	[
		120261,
		1,
		"l"
	],
	[
		120262,
		1,
		"m"
	],
	[
		120263,
		1,
		"n"
	],
	[
		120264,
		1,
		"o"
	],
	[
		120265,
		1,
		"p"
	],
	[
		120266,
		1,
		"q"
	],
	[
		120267,
		1,
		"r"
	],
	[
		120268,
		1,
		"s"
	],
	[
		120269,
		1,
		"t"
	],
	[
		120270,
		1,
		"u"
	],
	[
		120271,
		1,
		"v"
	],
	[
		120272,
		1,
		"w"
	],
	[
		120273,
		1,
		"x"
	],
	[
		120274,
		1,
		"y"
	],
	[
		120275,
		1,
		"z"
	],
	[
		120276,
		1,
		"a"
	],
	[
		120277,
		1,
		"b"
	],
	[
		120278,
		1,
		"c"
	],
	[
		120279,
		1,
		"d"
	],
	[
		120280,
		1,
		"e"
	],
	[
		120281,
		1,
		"f"
	],
	[
		120282,
		1,
		"g"
	],
	[
		120283,
		1,
		"h"
	],
	[
		120284,
		1,
		"i"
	],
	[
		120285,
		1,
		"j"
	],
	[
		120286,
		1,
		"k"
	],
	[
		120287,
		1,
		"l"
	],
	[
		120288,
		1,
		"m"
	],
	[
		120289,
		1,
		"n"
	],
	[
		120290,
		1,
		"o"
	],
	[
		120291,
		1,
		"p"
	],
	[
		120292,
		1,
		"q"
	],
	[
		120293,
		1,
		"r"
	],
	[
		120294,
		1,
		"s"
	],
	[
		120295,
		1,
		"t"
	],
	[
		120296,
		1,
		"u"
	],
	[
		120297,
		1,
		"v"
	],
	[
		120298,
		1,
		"w"
	],
	[
		120299,
		1,
		"x"
	],
	[
		120300,
		1,
		"y"
	],
	[
		120301,
		1,
		"z"
	],
	[
		120302,
		1,
		"a"
	],
	[
		120303,
		1,
		"b"
	],
	[
		120304,
		1,
		"c"
	],
	[
		120305,
		1,
		"d"
	],
	[
		120306,
		1,
		"e"
	],
	[
		120307,
		1,
		"f"
	],
	[
		120308,
		1,
		"g"
	],
	[
		120309,
		1,
		"h"
	],
	[
		120310,
		1,
		"i"
	],
	[
		120311,
		1,
		"j"
	],
	[
		120312,
		1,
		"k"
	],
	[
		120313,
		1,
		"l"
	],
	[
		120314,
		1,
		"m"
	],
	[
		120315,
		1,
		"n"
	],
	[
		120316,
		1,
		"o"
	],
	[
		120317,
		1,
		"p"
	],
	[
		120318,
		1,
		"q"
	],
	[
		120319,
		1,
		"r"
	],
	[
		120320,
		1,
		"s"
	],
	[
		120321,
		1,
		"t"
	],
	[
		120322,
		1,
		"u"
	],
	[
		120323,
		1,
		"v"
	],
	[
		120324,
		1,
		"w"
	],
	[
		120325,
		1,
		"x"
	],
	[
		120326,
		1,
		"y"
	],
	[
		120327,
		1,
		"z"
	],
	[
		120328,
		1,
		"a"
	],
	[
		120329,
		1,
		"b"
	],
	[
		120330,
		1,
		"c"
	],
	[
		120331,
		1,
		"d"
	],
	[
		120332,
		1,
		"e"
	],
	[
		120333,
		1,
		"f"
	],
	[
		120334,
		1,
		"g"
	],
	[
		120335,
		1,
		"h"
	],
	[
		120336,
		1,
		"i"
	],
	[
		120337,
		1,
		"j"
	],
	[
		120338,
		1,
		"k"
	],
	[
		120339,
		1,
		"l"
	],
	[
		120340,
		1,
		"m"
	],
	[
		120341,
		1,
		"n"
	],
	[
		120342,
		1,
		"o"
	],
	[
		120343,
		1,
		"p"
	],
	[
		120344,
		1,
		"q"
	],
	[
		120345,
		1,
		"r"
	],
	[
		120346,
		1,
		"s"
	],
	[
		120347,
		1,
		"t"
	],
	[
		120348,
		1,
		"u"
	],
	[
		120349,
		1,
		"v"
	],
	[
		120350,
		1,
		"w"
	],
	[
		120351,
		1,
		"x"
	],
	[
		120352,
		1,
		"y"
	],
	[
		120353,
		1,
		"z"
	],
	[
		120354,
		1,
		"a"
	],
	[
		120355,
		1,
		"b"
	],
	[
		120356,
		1,
		"c"
	],
	[
		120357,
		1,
		"d"
	],
	[
		120358,
		1,
		"e"
	],
	[
		120359,
		1,
		"f"
	],
	[
		120360,
		1,
		"g"
	],
	[
		120361,
		1,
		"h"
	],
	[
		120362,
		1,
		"i"
	],
	[
		120363,
		1,
		"j"
	],
	[
		120364,
		1,
		"k"
	],
	[
		120365,
		1,
		"l"
	],
	[
		120366,
		1,
		"m"
	],
	[
		120367,
		1,
		"n"
	],
	[
		120368,
		1,
		"o"
	],
	[
		120369,
		1,
		"p"
	],
	[
		120370,
		1,
		"q"
	],
	[
		120371,
		1,
		"r"
	],
	[
		120372,
		1,
		"s"
	],
	[
		120373,
		1,
		"t"
	],
	[
		120374,
		1,
		"u"
	],
	[
		120375,
		1,
		"v"
	],
	[
		120376,
		1,
		"w"
	],
	[
		120377,
		1,
		"x"
	],
	[
		120378,
		1,
		"y"
	],
	[
		120379,
		1,
		"z"
	],
	[
		120380,
		1,
		"a"
	],
	[
		120381,
		1,
		"b"
	],
	[
		120382,
		1,
		"c"
	],
	[
		120383,
		1,
		"d"
	],
	[
		120384,
		1,
		"e"
	],
	[
		120385,
		1,
		"f"
	],
	[
		120386,
		1,
		"g"
	],
	[
		120387,
		1,
		"h"
	],
	[
		120388,
		1,
		"i"
	],
	[
		120389,
		1,
		"j"
	],
	[
		120390,
		1,
		"k"
	],
	[
		120391,
		1,
		"l"
	],
	[
		120392,
		1,
		"m"
	],
	[
		120393,
		1,
		"n"
	],
	[
		120394,
		1,
		"o"
	],
	[
		120395,
		1,
		"p"
	],
	[
		120396,
		1,
		"q"
	],
	[
		120397,
		1,
		"r"
	],
	[
		120398,
		1,
		"s"
	],
	[
		120399,
		1,
		"t"
	],
	[
		120400,
		1,
		"u"
	],
	[
		120401,
		1,
		"v"
	],
	[
		120402,
		1,
		"w"
	],
	[
		120403,
		1,
		"x"
	],
	[
		120404,
		1,
		"y"
	],
	[
		120405,
		1,
		"z"
	],
	[
		120406,
		1,
		"a"
	],
	[
		120407,
		1,
		"b"
	],
	[
		120408,
		1,
		"c"
	],
	[
		120409,
		1,
		"d"
	],
	[
		120410,
		1,
		"e"
	],
	[
		120411,
		1,
		"f"
	],
	[
		120412,
		1,
		"g"
	],
	[
		120413,
		1,
		"h"
	],
	[
		120414,
		1,
		"i"
	],
	[
		120415,
		1,
		"j"
	],
	[
		120416,
		1,
		"k"
	],
	[
		120417,
		1,
		"l"
	],
	[
		120418,
		1,
		"m"
	],
	[
		120419,
		1,
		"n"
	],
	[
		120420,
		1,
		"o"
	],
	[
		120421,
		1,
		"p"
	],
	[
		120422,
		1,
		"q"
	],
	[
		120423,
		1,
		"r"
	],
	[
		120424,
		1,
		"s"
	],
	[
		120425,
		1,
		"t"
	],
	[
		120426,
		1,
		"u"
	],
	[
		120427,
		1,
		"v"
	],
	[
		120428,
		1,
		"w"
	],
	[
		120429,
		1,
		"x"
	],
	[
		120430,
		1,
		"y"
	],
	[
		120431,
		1,
		"z"
	],
	[
		120432,
		1,
		"a"
	],
	[
		120433,
		1,
		"b"
	],
	[
		120434,
		1,
		"c"
	],
	[
		120435,
		1,
		"d"
	],
	[
		120436,
		1,
		"e"
	],
	[
		120437,
		1,
		"f"
	],
	[
		120438,
		1,
		"g"
	],
	[
		120439,
		1,
		"h"
	],
	[
		120440,
		1,
		"i"
	],
	[
		120441,
		1,
		"j"
	],
	[
		120442,
		1,
		"k"
	],
	[
		120443,
		1,
		"l"
	],
	[
		120444,
		1,
		"m"
	],
	[
		120445,
		1,
		"n"
	],
	[
		120446,
		1,
		"o"
	],
	[
		120447,
		1,
		"p"
	],
	[
		120448,
		1,
		"q"
	],
	[
		120449,
		1,
		"r"
	],
	[
		120450,
		1,
		"s"
	],
	[
		120451,
		1,
		"t"
	],
	[
		120452,
		1,
		"u"
	],
	[
		120453,
		1,
		"v"
	],
	[
		120454,
		1,
		"w"
	],
	[
		120455,
		1,
		"x"
	],
	[
		120456,
		1,
		"y"
	],
	[
		120457,
		1,
		"z"
	],
	[
		120458,
		1,
		"a"
	],
	[
		120459,
		1,
		"b"
	],
	[
		120460,
		1,
		"c"
	],
	[
		120461,
		1,
		"d"
	],
	[
		120462,
		1,
		"e"
	],
	[
		120463,
		1,
		"f"
	],
	[
		120464,
		1,
		"g"
	],
	[
		120465,
		1,
		"h"
	],
	[
		120466,
		1,
		"i"
	],
	[
		120467,
		1,
		"j"
	],
	[
		120468,
		1,
		"k"
	],
	[
		120469,
		1,
		"l"
	],
	[
		120470,
		1,
		"m"
	],
	[
		120471,
		1,
		"n"
	],
	[
		120472,
		1,
		"o"
	],
	[
		120473,
		1,
		"p"
	],
	[
		120474,
		1,
		"q"
	],
	[
		120475,
		1,
		"r"
	],
	[
		120476,
		1,
		"s"
	],
	[
		120477,
		1,
		"t"
	],
	[
		120478,
		1,
		"u"
	],
	[
		120479,
		1,
		"v"
	],
	[
		120480,
		1,
		"w"
	],
	[
		120481,
		1,
		"x"
	],
	[
		120482,
		1,
		"y"
	],
	[
		120483,
		1,
		"z"
	],
	[
		120484,
		1,
		""
	],
	[
		120485,
		1,
		""
	],
	[
		[
			120486,
			120487
		],
		3
	],
	[
		120488,
		1,
		""
	],
	[
		120489,
		1,
		""
	],
	[
		120490,
		1,
		""
	],
	[
		120491,
		1,
		""
	],
	[
		120492,
		1,
		""
	],
	[
		120493,
		1,
		""
	],
	[
		120494,
		1,
		""
	],
	[
		120495,
		1,
		""
	],
	[
		120496,
		1,
		""
	],
	[
		120497,
		1,
		""
	],
	[
		120498,
		1,
		""
	],
	[
		120499,
		1,
		""
	],
	[
		120500,
		1,
		""
	],
	[
		120501,
		1,
		""
	],
	[
		120502,
		1,
		""
	],
	[
		120503,
		1,
		""
	],
	[
		120504,
		1,
		""
	],
	[
		120505,
		1,
		""
	],
	[
		120506,
		1,
		""
	],
	[
		120507,
		1,
		""
	],
	[
		120508,
		1,
		""
	],
	[
		120509,
		1,
		""
	],
	[
		120510,
		1,
		""
	],
	[
		120511,
		1,
		""
	],
	[
		120512,
		1,
		""
	],
	[
		120513,
		1,
		""
	],
	[
		120514,
		1,
		""
	],
	[
		120515,
		1,
		""
	],
	[
		120516,
		1,
		""
	],
	[
		120517,
		1,
		""
	],
	[
		120518,
		1,
		""
	],
	[
		120519,
		1,
		""
	],
	[
		120520,
		1,
		""
	],
	[
		120521,
		1,
		""
	],
	[
		120522,
		1,
		""
	],
	[
		120523,
		1,
		""
	],
	[
		120524,
		1,
		""
	],
	[
		120525,
		1,
		""
	],
	[
		120526,
		1,
		""
	],
	[
		120527,
		1,
		""
	],
	[
		120528,
		1,
		""
	],
	[
		120529,
		1,
		""
	],
	[
		120530,
		1,
		""
	],
	[
		[
			120531,
			120532
		],
		1,
		""
	],
	[
		120533,
		1,
		""
	],
	[
		120534,
		1,
		""
	],
	[
		120535,
		1,
		""
	],
	[
		120536,
		1,
		""
	],
	[
		120537,
		1,
		""
	],
	[
		120538,
		1,
		""
	],
	[
		120539,
		1,
		""
	],
	[
		120540,
		1,
		""
	],
	[
		120541,
		1,
		""
	],
	[
		120542,
		1,
		""
	],
	[
		120543,
		1,
		""
	],
	[
		120544,
		1,
		""
	],
	[
		120545,
		1,
		""
	],
	[
		120546,
		1,
		""
	],
	[
		120547,
		1,
		""
	],
	[
		120548,
		1,
		""
	],
	[
		120549,
		1,
		""
	],
	[
		120550,
		1,
		""
	],
	[
		120551,
		1,
		""
	],
	[
		120552,
		1,
		""
	],
	[
		120553,
		1,
		""
	],
	[
		120554,
		1,
		""
	],
	[
		120555,
		1,
		""
	],
	[
		120556,
		1,
		""
	],
	[
		120557,
		1,
		""
	],
	[
		120558,
		1,
		""
	],
	[
		120559,
		1,
		""
	],
	[
		120560,
		1,
		""
	],
	[
		120561,
		1,
		""
	],
	[
		120562,
		1,
		""
	],
	[
		120563,
		1,
		""
	],
	[
		120564,
		1,
		""
	],
	[
		120565,
		1,
		""
	],
	[
		120566,
		1,
		""
	],
	[
		120567,
		1,
		""
	],
	[
		120568,
		1,
		""
	],
	[
		120569,
		1,
		""
	],
	[
		120570,
		1,
		""
	],
	[
		120571,
		1,
		""
	],
	[
		120572,
		1,
		""
	],
	[
		120573,
		1,
		""
	],
	[
		120574,
		1,
		""
	],
	[
		120575,
		1,
		""
	],
	[
		120576,
		1,
		""
	],
	[
		120577,
		1,
		""
	],
	[
		120578,
		1,
		""
	],
	[
		120579,
		1,
		""
	],
	[
		120580,
		1,
		""
	],
	[
		120581,
		1,
		""
	],
	[
		120582,
		1,
		""
	],
	[
		120583,
		1,
		""
	],
	[
		120584,
		1,
		""
	],
	[
		120585,
		1,
		""
	],
	[
		120586,
		1,
		""
	],
	[
		120587,
		1,
		""
	],
	[
		120588,
		1,
		""
	],
	[
		[
			120589,
			120590
		],
		1,
		""
	],
	[
		120591,
		1,
		""
	],
	[
		120592,
		1,
		""
	],
	[
		120593,
		1,
		""
	],
	[
		120594,
		1,
		""
	],
	[
		120595,
		1,
		""
	],
	[
		120596,
		1,
		""
	],
	[
		120597,
		1,
		""
	],
	[
		120598,
		1,
		""
	],
	[
		120599,
		1,
		""
	],
	[
		120600,
		1,
		""
	],
	[
		120601,
		1,
		""
	],
	[
		120602,
		1,
		""
	],
	[
		120603,
		1,
		""
	],
	[
		120604,
		1,
		""
	],
	[
		120605,
		1,
		""
	],
	[
		120606,
		1,
		""
	],
	[
		120607,
		1,
		""
	],
	[
		120608,
		1,
		""
	],
	[
		120609,
		1,
		""
	],
	[
		120610,
		1,
		""
	],
	[
		120611,
		1,
		""
	],
	[
		120612,
		1,
		""
	],
	[
		120613,
		1,
		""
	],
	[
		120614,
		1,
		""
	],
	[
		120615,
		1,
		""
	],
	[
		120616,
		1,
		""
	],
	[
		120617,
		1,
		""
	],
	[
		120618,
		1,
		""
	],
	[
		120619,
		1,
		""
	],
	[
		120620,
		1,
		""
	],
	[
		120621,
		1,
		""
	],
	[
		120622,
		1,
		""
	],
	[
		120623,
		1,
		""
	],
	[
		120624,
		1,
		""
	],
	[
		120625,
		1,
		""
	],
	[
		120626,
		1,
		""
	],
	[
		120627,
		1,
		""
	],
	[
		120628,
		1,
		""
	],
	[
		120629,
		1,
		""
	],
	[
		120630,
		1,
		""
	],
	[
		120631,
		1,
		""
	],
	[
		120632,
		1,
		""
	],
	[
		120633,
		1,
		""
	],
	[
		120634,
		1,
		""
	],
	[
		120635,
		1,
		""
	],
	[
		120636,
		1,
		""
	],
	[
		120637,
		1,
		""
	],
	[
		120638,
		1,
		""
	],
	[
		120639,
		1,
		""
	],
	[
		120640,
		1,
		""
	],
	[
		120641,
		1,
		""
	],
	[
		120642,
		1,
		""
	],
	[
		120643,
		1,
		""
	],
	[
		120644,
		1,
		""
	],
	[
		120645,
		1,
		""
	],
	[
		120646,
		1,
		""
	],
	[
		[
			120647,
			120648
		],
		1,
		""
	],
	[
		120649,
		1,
		""
	],
	[
		120650,
		1,
		""
	],
	[
		120651,
		1,
		""
	],
	[
		120652,
		1,
		""
	],
	[
		120653,
		1,
		""
	],
	[
		120654,
		1,
		""
	],
	[
		120655,
		1,
		""
	],
	[
		120656,
		1,
		""
	],
	[
		120657,
		1,
		""
	],
	[
		120658,
		1,
		""
	],
	[
		120659,
		1,
		""
	],
	[
		120660,
		1,
		""
	],
	[
		120661,
		1,
		""
	],
	[
		120662,
		1,
		""
	],
	[
		120663,
		1,
		""
	],
	[
		120664,
		1,
		""
	],
	[
		120665,
		1,
		""
	],
	[
		120666,
		1,
		""
	],
	[
		120667,
		1,
		""
	],
	[
		120668,
		1,
		""
	],
	[
		120669,
		1,
		""
	],
	[
		120670,
		1,
		""
	],
	[
		120671,
		1,
		""
	],
	[
		120672,
		1,
		""
	],
	[
		120673,
		1,
		""
	],
	[
		120674,
		1,
		""
	],
	[
		120675,
		1,
		""
	],
	[
		120676,
		1,
		""
	],
	[
		120677,
		1,
		""
	],
	[
		120678,
		1,
		""
	],
	[
		120679,
		1,
		""
	],
	[
		120680,
		1,
		""
	],
	[
		120681,
		1,
		""
	],
	[
		120682,
		1,
		""
	],
	[
		120683,
		1,
		""
	],
	[
		120684,
		1,
		""
	],
	[
		120685,
		1,
		""
	],
	[
		120686,
		1,
		""
	],
	[
		120687,
		1,
		""
	],
	[
		120688,
		1,
		""
	],
	[
		120689,
		1,
		""
	],
	[
		120690,
		1,
		""
	],
	[
		120691,
		1,
		""
	],
	[
		120692,
		1,
		""
	],
	[
		120693,
		1,
		""
	],
	[
		120694,
		1,
		""
	],
	[
		120695,
		1,
		""
	],
	[
		120696,
		1,
		""
	],
	[
		120697,
		1,
		""
	],
	[
		120698,
		1,
		""
	],
	[
		120699,
		1,
		""
	],
	[
		120700,
		1,
		""
	],
	[
		120701,
		1,
		""
	],
	[
		120702,
		1,
		""
	],
	[
		120703,
		1,
		""
	],
	[
		120704,
		1,
		""
	],
	[
		[
			120705,
			120706
		],
		1,
		""
	],
	[
		120707,
		1,
		""
	],
	[
		120708,
		1,
		""
	],
	[
		120709,
		1,
		""
	],
	[
		120710,
		1,
		""
	],
	[
		120711,
		1,
		""
	],
	[
		120712,
		1,
		""
	],
	[
		120713,
		1,
		""
	],
	[
		120714,
		1,
		""
	],
	[
		120715,
		1,
		""
	],
	[
		120716,
		1,
		""
	],
	[
		120717,
		1,
		""
	],
	[
		120718,
		1,
		""
	],
	[
		120719,
		1,
		""
	],
	[
		120720,
		1,
		""
	],
	[
		120721,
		1,
		""
	],
	[
		120722,
		1,
		""
	],
	[
		120723,
		1,
		""
	],
	[
		120724,
		1,
		""
	],
	[
		120725,
		1,
		""
	],
	[
		120726,
		1,
		""
	],
	[
		120727,
		1,
		""
	],
	[
		120728,
		1,
		""
	],
	[
		120729,
		1,
		""
	],
	[
		120730,
		1,
		""
	],
	[
		120731,
		1,
		""
	],
	[
		120732,
		1,
		""
	],
	[
		120733,
		1,
		""
	],
	[
		120734,
		1,
		""
	],
	[
		120735,
		1,
		""
	],
	[
		120736,
		1,
		""
	],
	[
		120737,
		1,
		""
	],
	[
		120738,
		1,
		""
	],
	[
		120739,
		1,
		""
	],
	[
		120740,
		1,
		""
	],
	[
		120741,
		1,
		""
	],
	[
		120742,
		1,
		""
	],
	[
		120743,
		1,
		""
	],
	[
		120744,
		1,
		""
	],
	[
		120745,
		1,
		""
	],
	[
		120746,
		1,
		""
	],
	[
		120747,
		1,
		""
	],
	[
		120748,
		1,
		""
	],
	[
		120749,
		1,
		""
	],
	[
		120750,
		1,
		""
	],
	[
		120751,
		1,
		""
	],
	[
		120752,
		1,
		""
	],
	[
		120753,
		1,
		""
	],
	[
		120754,
		1,
		""
	],
	[
		120755,
		1,
		""
	],
	[
		120756,
		1,
		""
	],
	[
		120757,
		1,
		""
	],
	[
		120758,
		1,
		""
	],
	[
		120759,
		1,
		""
	],
	[
		120760,
		1,
		""
	],
	[
		120761,
		1,
		""
	],
	[
		120762,
		1,
		""
	],
	[
		[
			120763,
			120764
		],
		1,
		""
	],
	[
		120765,
		1,
		""
	],
	[
		120766,
		1,
		""
	],
	[
		120767,
		1,
		""
	],
	[
		120768,
		1,
		""
	],
	[
		120769,
		1,
		""
	],
	[
		120770,
		1,
		""
	],
	[
		120771,
		1,
		""
	],
	[
		120772,
		1,
		""
	],
	[
		120773,
		1,
		""
	],
	[
		120774,
		1,
		""
	],
	[
		120775,
		1,
		""
	],
	[
		120776,
		1,
		""
	],
	[
		120777,
		1,
		""
	],
	[
		[
			120778,
			120779
		],
		1,
		""
	],
	[
		[
			120780,
			120781
		],
		3
	],
	[
		120782,
		1,
		"0"
	],
	[
		120783,
		1,
		"1"
	],
	[
		120784,
		1,
		"2"
	],
	[
		120785,
		1,
		"3"
	],
	[
		120786,
		1,
		"4"
	],
	[
		120787,
		1,
		"5"
	],
	[
		120788,
		1,
		"6"
	],
	[
		120789,
		1,
		"7"
	],
	[
		120790,
		1,
		"8"
	],
	[
		120791,
		1,
		"9"
	],
	[
		120792,
		1,
		"0"
	],
	[
		120793,
		1,
		"1"
	],
	[
		120794,
		1,
		"2"
	],
	[
		120795,
		1,
		"3"
	],
	[
		120796,
		1,
		"4"
	],
	[
		120797,
		1,
		"5"
	],
	[
		120798,
		1,
		"6"
	],
	[
		120799,
		1,
		"7"
	],
	[
		120800,
		1,
		"8"
	],
	[
		120801,
		1,
		"9"
	],
	[
		120802,
		1,
		"0"
	],
	[
		120803,
		1,
		"1"
	],
	[
		120804,
		1,
		"2"
	],
	[
		120805,
		1,
		"3"
	],
	[
		120806,
		1,
		"4"
	],
	[
		120807,
		1,
		"5"
	],
	[
		120808,
		1,
		"6"
	],
	[
		120809,
		1,
		"7"
	],
	[
		120810,
		1,
		"8"
	],
	[
		120811,
		1,
		"9"
	],
	[
		120812,
		1,
		"0"
	],
	[
		120813,
		1,
		"1"
	],
	[
		120814,
		1,
		"2"
	],
	[
		120815,
		1,
		"3"
	],
	[
		120816,
		1,
		"4"
	],
	[
		120817,
		1,
		"5"
	],
	[
		120818,
		1,
		"6"
	],
	[
		120819,
		1,
		"7"
	],
	[
		120820,
		1,
		"8"
	],
	[
		120821,
		1,
		"9"
	],
	[
		120822,
		1,
		"0"
	],
	[
		120823,
		1,
		"1"
	],
	[
		120824,
		1,
		"2"
	],
	[
		120825,
		1,
		"3"
	],
	[
		120826,
		1,
		"4"
	],
	[
		120827,
		1,
		"5"
	],
	[
		120828,
		1,
		"6"
	],
	[
		120829,
		1,
		"7"
	],
	[
		120830,
		1,
		"8"
	],
	[
		120831,
		1,
		"9"
	],
	[
		[
			120832,
			121343
		],
		2
	],
	[
		[
			121344,
			121398
		],
		2
	],
	[
		[
			121399,
			121402
		],
		2
	],
	[
		[
			121403,
			121452
		],
		2
	],
	[
		[
			121453,
			121460
		],
		2
	],
	[
		121461,
		2
	],
	[
		[
			121462,
			121475
		],
		2
	],
	[
		121476,
		2
	],
	[
		[
			121477,
			121483
		],
		2
	],
	[
		[
			121484,
			121498
		],
		3
	],
	[
		[
			121499,
			121503
		],
		2
	],
	[
		121504,
		3
	],
	[
		[
			121505,
			121519
		],
		2
	],
	[
		[
			121520,
			122623
		],
		3
	],
	[
		[
			122624,
			122654
		],
		2
	],
	[
		[
			122655,
			122660
		],
		3
	],
	[
		[
			122661,
			122666
		],
		2
	],
	[
		[
			122667,
			122879
		],
		3
	],
	[
		[
			122880,
			122886
		],
		2
	],
	[
		122887,
		3
	],
	[
		[
			122888,
			122904
		],
		2
	],
	[
		[
			122905,
			122906
		],
		3
	],
	[
		[
			122907,
			122913
		],
		2
	],
	[
		122914,
		3
	],
	[
		[
			122915,
			122916
		],
		2
	],
	[
		122917,
		3
	],
	[
		[
			122918,
			122922
		],
		2
	],
	[
		[
			122923,
			122927
		],
		3
	],
	[
		122928,
		1,
		""
	],
	[
		122929,
		1,
		""
	],
	[
		122930,
		1,
		""
	],
	[
		122931,
		1,
		""
	],
	[
		122932,
		1,
		""
	],
	[
		122933,
		1,
		""
	],
	[
		122934,
		1,
		""
	],
	[
		122935,
		1,
		""
	],
	[
		122936,
		1,
		""
	],
	[
		122937,
		1,
		""
	],
	[
		122938,
		1,
		""
	],
	[
		122939,
		1,
		""
	],
	[
		122940,
		1,
		""
	],
	[
		122941,
		1,
		""
	],
	[
		122942,
		1,
		""
	],
	[
		122943,
		1,
		""
	],
	[
		122944,
		1,
		""
	],
	[
		122945,
		1,
		""
	],
	[
		122946,
		1,
		""
	],
	[
		122947,
		1,
		""
	],
	[
		122948,
		1,
		""
	],
	[
		122949,
		1,
		""
	],
	[
		122950,
		1,
		""
	],
	[
		122951,
		1,
		""
	],
	[
		122952,
		1,
		""
	],
	[
		122953,
		1,
		""
	],
	[
		122954,
		1,
		""
	],
	[
		122955,
		1,
		""
	],
	[
		122956,
		1,
		""
	],
	[
		122957,
		1,
		""
	],
	[
		122958,
		1,
		""
	],
	[
		122959,
		1,
		""
	],
	[
		122960,
		1,
		""
	],
	[
		122961,
		1,
		""
	],
	[
		122962,
		1,
		""
	],
	[
		122963,
		1,
		""
	],
	[
		122964,
		1,
		""
	],
	[
		122965,
		1,
		""
	],
	[
		122966,
		1,
		""
	],
	[
		122967,
		1,
		""
	],
	[
		122968,
		1,
		""
	],
	[
		122969,
		1,
		""
	],
	[
		122970,
		1,
		""
	],
	[
		122971,
		1,
		""
	],
	[
		122972,
		1,
		""
	],
	[
		122973,
		1,
		""
	],
	[
		122974,
		1,
		""
	],
	[
		122975,
		1,
		""
	],
	[
		122976,
		1,
		""
	],
	[
		122977,
		1,
		""
	],
	[
		122978,
		1,
		""
	],
	[
		122979,
		1,
		""
	],
	[
		122980,
		1,
		""
	],
	[
		122981,
		1,
		""
	],
	[
		122982,
		1,
		""
	],
	[
		122983,
		1,
		""
	],
	[
		122984,
		1,
		""
	],
	[
		122985,
		1,
		""
	],
	[
		122986,
		1,
		""
	],
	[
		122987,
		1,
		""
	],
	[
		122988,
		1,
		""
	],
	[
		122989,
		1,
		""
	],
	[
		[
			122990,
			123022
		],
		3
	],
	[
		123023,
		2
	],
	[
		[
			123024,
			123135
		],
		3
	],
	[
		[
			123136,
			123180
		],
		2
	],
	[
		[
			123181,
			123183
		],
		3
	],
	[
		[
			123184,
			123197
		],
		2
	],
	[
		[
			123198,
			123199
		],
		3
	],
	[
		[
			123200,
			123209
		],
		2
	],
	[
		[
			123210,
			123213
		],
		3
	],
	[
		123214,
		2
	],
	[
		123215,
		2
	],
	[
		[
			123216,
			123535
		],
		3
	],
	[
		[
			123536,
			123566
		],
		2
	],
	[
		[
			123567,
			123583
		],
		3
	],
	[
		[
			123584,
			123641
		],
		2
	],
	[
		[
			123642,
			123646
		],
		3
	],
	[
		123647,
		2
	],
	[
		[
			123648,
			124111
		],
		3
	],
	[
		[
			124112,
			124153
		],
		2
	],
	[
		[
			124154,
			124895
		],
		3
	],
	[
		[
			124896,
			124902
		],
		2
	],
	[
		124903,
		3
	],
	[
		[
			124904,
			124907
		],
		2
	],
	[
		124908,
		3
	],
	[
		[
			124909,
			124910
		],
		2
	],
	[
		124911,
		3
	],
	[
		[
			124912,
			124926
		],
		2
	],
	[
		124927,
		3
	],
	[
		[
			124928,
			125124
		],
		2
	],
	[
		[
			125125,
			125126
		],
		3
	],
	[
		[
			125127,
			125135
		],
		2
	],
	[
		[
			125136,
			125142
		],
		2
	],
	[
		[
			125143,
			125183
		],
		3
	],
	[
		125184,
		1,
		""
	],
	[
		125185,
		1,
		""
	],
	[
		125186,
		1,
		""
	],
	[
		125187,
		1,
		""
	],
	[
		125188,
		1,
		""
	],
	[
		125189,
		1,
		""
	],
	[
		125190,
		1,
		""
	],
	[
		125191,
		1,
		""
	],
	[
		125192,
		1,
		""
	],
	[
		125193,
		1,
		""
	],
	[
		125194,
		1,
		""
	],
	[
		125195,
		1,
		""
	],
	[
		125196,
		1,
		""
	],
	[
		125197,
		1,
		""
	],
	[
		125198,
		1,
		""
	],
	[
		125199,
		1,
		""
	],
	[
		125200,
		1,
		""
	],
	[
		125201,
		1,
		""
	],
	[
		125202,
		1,
		""
	],
	[
		125203,
		1,
		""
	],
	[
		125204,
		1,
		""
	],
	[
		125205,
		1,
		""
	],
	[
		125206,
		1,
		""
	],
	[
		125207,
		1,
		""
	],
	[
		125208,
		1,
		""
	],
	[
		125209,
		1,
		""
	],
	[
		125210,
		1,
		""
	],
	[
		125211,
		1,
		""
	],
	[
		125212,
		1,
		""
	],
	[
		125213,
		1,
		""
	],
	[
		125214,
		1,
		""
	],
	[
		125215,
		1,
		""
	],
	[
		125216,
		1,
		""
	],
	[
		125217,
		1,
		""
	],
	[
		[
			125218,
			125258
		],
		2
	],
	[
		125259,
		2
	],
	[
		[
			125260,
			125263
		],
		3
	],
	[
		[
			125264,
			125273
		],
		2
	],
	[
		[
			125274,
			125277
		],
		3
	],
	[
		[
			125278,
			125279
		],
		2
	],
	[
		[
			125280,
			126064
		],
		3
	],
	[
		[
			126065,
			126132
		],
		2
	],
	[
		[
			126133,
			126208
		],
		3
	],
	[
		[
			126209,
			126269
		],
		2
	],
	[
		[
			126270,
			126463
		],
		3
	],
	[
		126464,
		1,
		""
	],
	[
		126465,
		1,
		""
	],
	[
		126466,
		1,
		""
	],
	[
		126467,
		1,
		""
	],
	[
		126468,
		3
	],
	[
		126469,
		1,
		""
	],
	[
		126470,
		1,
		""
	],
	[
		126471,
		1,
		""
	],
	[
		126472,
		1,
		""
	],
	[
		126473,
		1,
		""
	],
	[
		126474,
		1,
		""
	],
	[
		126475,
		1,
		""
	],
	[
		126476,
		1,
		""
	],
	[
		126477,
		1,
		""
	],
	[
		126478,
		1,
		""
	],
	[
		126479,
		1,
		""
	],
	[
		126480,
		1,
		""
	],
	[
		126481,
		1,
		""
	],
	[
		126482,
		1,
		""
	],
	[
		126483,
		1,
		""
	],
	[
		126484,
		1,
		""
	],
	[
		126485,
		1,
		""
	],
	[
		126486,
		1,
		""
	],
	[
		126487,
		1,
		""
	],
	[
		126488,
		1,
		""
	],
	[
		126489,
		1,
		""
	],
	[
		126490,
		1,
		""
	],
	[
		126491,
		1,
		""
	],
	[
		126492,
		1,
		""
	],
	[
		126493,
		1,
		""
	],
	[
		126494,
		1,
		""
	],
	[
		126495,
		1,
		""
	],
	[
		126496,
		3
	],
	[
		126497,
		1,
		""
	],
	[
		126498,
		1,
		""
	],
	[
		126499,
		3
	],
	[
		126500,
		1,
		""
	],
	[
		[
			126501,
			126502
		],
		3
	],
	[
		126503,
		1,
		""
	],
	[
		126504,
		3
	],
	[
		126505,
		1,
		""
	],
	[
		126506,
		1,
		""
	],
	[
		126507,
		1,
		""
	],
	[
		126508,
		1,
		""
	],
	[
		126509,
		1,
		""
	],
	[
		126510,
		1,
		""
	],
	[
		126511,
		1,
		""
	],
	[
		126512,
		1,
		""
	],
	[
		126513,
		1,
		""
	],
	[
		126514,
		1,
		""
	],
	[
		126515,
		3
	],
	[
		126516,
		1,
		""
	],
	[
		126517,
		1,
		""
	],
	[
		126518,
		1,
		""
	],
	[
		126519,
		1,
		""
	],
	[
		126520,
		3
	],
	[
		126521,
		1,
		""
	],
	[
		126522,
		3
	],
	[
		126523,
		1,
		""
	],
	[
		[
			126524,
			126529
		],
		3
	],
	[
		126530,
		1,
		""
	],
	[
		[
			126531,
			126534
		],
		3
	],
	[
		126535,
		1,
		""
	],
	[
		126536,
		3
	],
	[
		126537,
		1,
		""
	],
	[
		126538,
		3
	],
	[
		126539,
		1,
		""
	],
	[
		126540,
		3
	],
	[
		126541,
		1,
		""
	],
	[
		126542,
		1,
		""
	],
	[
		126543,
		1,
		""
	],
	[
		126544,
		3
	],
	[
		126545,
		1,
		""
	],
	[
		126546,
		1,
		""
	],
	[
		126547,
		3
	],
	[
		126548,
		1,
		""
	],
	[
		[
			126549,
			126550
		],
		3
	],
	[
		126551,
		1,
		""
	],
	[
		126552,
		3
	],
	[
		126553,
		1,
		""
	],
	[
		126554,
		3
	],
	[
		126555,
		1,
		""
	],
	[
		126556,
		3
	],
	[
		126557,
		1,
		""
	],
	[
		126558,
		3
	],
	[
		126559,
		1,
		""
	],
	[
		126560,
		3
	],
	[
		126561,
		1,
		""
	],
	[
		126562,
		1,
		""
	],
	[
		126563,
		3
	],
	[
		126564,
		1,
		""
	],
	[
		[
			126565,
			126566
		],
		3
	],
	[
		126567,
		1,
		""
	],
	[
		126568,
		1,
		""
	],
	[
		126569,
		1,
		""
	],
	[
		126570,
		1,
		""
	],
	[
		126571,
		3
	],
	[
		126572,
		1,
		""
	],
	[
		126573,
		1,
		""
	],
	[
		126574,
		1,
		""
	],
	[
		126575,
		1,
		""
	],
	[
		126576,
		1,
		""
	],
	[
		126577,
		1,
		""
	],
	[
		126578,
		1,
		""
	],
	[
		126579,
		3
	],
	[
		126580,
		1,
		""
	],
	[
		126581,
		1,
		""
	],
	[
		126582,
		1,
		""
	],
	[
		126583,
		1,
		""
	],
	[
		126584,
		3
	],
	[
		126585,
		1,
		""
	],
	[
		126586,
		1,
		""
	],
	[
		126587,
		1,
		""
	],
	[
		126588,
		1,
		""
	],
	[
		126589,
		3
	],
	[
		126590,
		1,
		""
	],
	[
		126591,
		3
	],
	[
		126592,
		1,
		""
	],
	[
		126593,
		1,
		""
	],
	[
		126594,
		1,
		""
	],
	[
		126595,
		1,
		""
	],
	[
		126596,
		1,
		""
	],
	[
		126597,
		1,
		""
	],
	[
		126598,
		1,
		""
	],
	[
		126599,
		1,
		""
	],
	[
		126600,
		1,
		""
	],
	[
		126601,
		1,
		""
	],
	[
		126602,
		3
	],
	[
		126603,
		1,
		""
	],
	[
		126604,
		1,
		""
	],
	[
		126605,
		1,
		""
	],
	[
		126606,
		1,
		""
	],
	[
		126607,
		1,
		""
	],
	[
		126608,
		1,
		""
	],
	[
		126609,
		1,
		""
	],
	[
		126610,
		1,
		""
	],
	[
		126611,
		1,
		""
	],
	[
		126612,
		1,
		""
	],
	[
		126613,
		1,
		""
	],
	[
		126614,
		1,
		""
	],
	[
		126615,
		1,
		""
	],
	[
		126616,
		1,
		""
	],
	[
		126617,
		1,
		""
	],
	[
		126618,
		1,
		""
	],
	[
		126619,
		1,
		""
	],
	[
		[
			126620,
			126624
		],
		3
	],
	[
		126625,
		1,
		""
	],
	[
		126626,
		1,
		""
	],
	[
		126627,
		1,
		""
	],
	[
		126628,
		3
	],
	[
		126629,
		1,
		""
	],
	[
		126630,
		1,
		""
	],
	[
		126631,
		1,
		""
	],
	[
		126632,
		1,
		""
	],
	[
		126633,
		1,
		""
	],
	[
		126634,
		3
	],
	[
		126635,
		1,
		""
	],
	[
		126636,
		1,
		""
	],
	[
		126637,
		1,
		""
	],
	[
		126638,
		1,
		""
	],
	[
		126639,
		1,
		""
	],
	[
		126640,
		1,
		""
	],
	[
		126641,
		1,
		""
	],
	[
		126642,
		1,
		""
	],
	[
		126643,
		1,
		""
	],
	[
		126644,
		1,
		""
	],
	[
		126645,
		1,
		""
	],
	[
		126646,
		1,
		""
	],
	[
		126647,
		1,
		""
	],
	[
		126648,
		1,
		""
	],
	[
		126649,
		1,
		""
	],
	[
		126650,
		1,
		""
	],
	[
		126651,
		1,
		""
	],
	[
		[
			126652,
			126703
		],
		3
	],
	[
		[
			126704,
			126705
		],
		2
	],
	[
		[
			126706,
			126975
		],
		3
	],
	[
		[
			126976,
			127019
		],
		2
	],
	[
		[
			127020,
			127023
		],
		3
	],
	[
		[
			127024,
			127123
		],
		2
	],
	[
		[
			127124,
			127135
		],
		3
	],
	[
		[
			127136,
			127150
		],
		2
	],
	[
		[
			127151,
			127152
		],
		3
	],
	[
		[
			127153,
			127166
		],
		2
	],
	[
		127167,
		2
	],
	[
		127168,
		3
	],
	[
		[
			127169,
			127183
		],
		2
	],
	[
		127184,
		3
	],
	[
		[
			127185,
			127199
		],
		2
	],
	[
		[
			127200,
			127221
		],
		2
	],
	[
		[
			127222,
			127231
		],
		3
	],
	[
		127232,
		3
	],
	[
		127233,
		5,
		"0,"
	],
	[
		127234,
		5,
		"1,"
	],
	[
		127235,
		5,
		"2,"
	],
	[
		127236,
		5,
		"3,"
	],
	[
		127237,
		5,
		"4,"
	],
	[
		127238,
		5,
		"5,"
	],
	[
		127239,
		5,
		"6,"
	],
	[
		127240,
		5,
		"7,"
	],
	[
		127241,
		5,
		"8,"
	],
	[
		127242,
		5,
		"9,"
	],
	[
		[
			127243,
			127244
		],
		2
	],
	[
		[
			127245,
			127247
		],
		2
	],
	[
		127248,
		5,
		"(a)"
	],
	[
		127249,
		5,
		"(b)"
	],
	[
		127250,
		5,
		"(c)"
	],
	[
		127251,
		5,
		"(d)"
	],
	[
		127252,
		5,
		"(e)"
	],
	[
		127253,
		5,
		"(f)"
	],
	[
		127254,
		5,
		"(g)"
	],
	[
		127255,
		5,
		"(h)"
	],
	[
		127256,
		5,
		"(i)"
	],
	[
		127257,
		5,
		"(j)"
	],
	[
		127258,
		5,
		"(k)"
	],
	[
		127259,
		5,
		"(l)"
	],
	[
		127260,
		5,
		"(m)"
	],
	[
		127261,
		5,
		"(n)"
	],
	[
		127262,
		5,
		"(o)"
	],
	[
		127263,
		5,
		"(p)"
	],
	[
		127264,
		5,
		"(q)"
	],
	[
		127265,
		5,
		"(r)"
	],
	[
		127266,
		5,
		"(s)"
	],
	[
		127267,
		5,
		"(t)"
	],
	[
		127268,
		5,
		"(u)"
	],
	[
		127269,
		5,
		"(v)"
	],
	[
		127270,
		5,
		"(w)"
	],
	[
		127271,
		5,
		"(x)"
	],
	[
		127272,
		5,
		"(y)"
	],
	[
		127273,
		5,
		"(z)"
	],
	[
		127274,
		1,
		"s"
	],
	[
		127275,
		1,
		"c"
	],
	[
		127276,
		1,
		"r"
	],
	[
		127277,
		1,
		"cd"
	],
	[
		127278,
		1,
		"wz"
	],
	[
		127279,
		2
	],
	[
		127280,
		1,
		"a"
	],
	[
		127281,
		1,
		"b"
	],
	[
		127282,
		1,
		"c"
	],
	[
		127283,
		1,
		"d"
	],
	[
		127284,
		1,
		"e"
	],
	[
		127285,
		1,
		"f"
	],
	[
		127286,
		1,
		"g"
	],
	[
		127287,
		1,
		"h"
	],
	[
		127288,
		1,
		"i"
	],
	[
		127289,
		1,
		"j"
	],
	[
		127290,
		1,
		"k"
	],
	[
		127291,
		1,
		"l"
	],
	[
		127292,
		1,
		"m"
	],
	[
		127293,
		1,
		"n"
	],
	[
		127294,
		1,
		"o"
	],
	[
		127295,
		1,
		"p"
	],
	[
		127296,
		1,
		"q"
	],
	[
		127297,
		1,
		"r"
	],
	[
		127298,
		1,
		"s"
	],
	[
		127299,
		1,
		"t"
	],
	[
		127300,
		1,
		"u"
	],
	[
		127301,
		1,
		"v"
	],
	[
		127302,
		1,
		"w"
	],
	[
		127303,
		1,
		"x"
	],
	[
		127304,
		1,
		"y"
	],
	[
		127305,
		1,
		"z"
	],
	[
		127306,
		1,
		"hv"
	],
	[
		127307,
		1,
		"mv"
	],
	[
		127308,
		1,
		"sd"
	],
	[
		127309,
		1,
		"ss"
	],
	[
		127310,
		1,
		"ppv"
	],
	[
		127311,
		1,
		"wc"
	],
	[
		[
			127312,
			127318
		],
		2
	],
	[
		127319,
		2
	],
	[
		[
			127320,
			127326
		],
		2
	],
	[
		127327,
		2
	],
	[
		[
			127328,
			127337
		],
		2
	],
	[
		127338,
		1,
		"mc"
	],
	[
		127339,
		1,
		"md"
	],
	[
		127340,
		1,
		"mr"
	],
	[
		[
			127341,
			127343
		],
		2
	],
	[
		[
			127344,
			127352
		],
		2
	],
	[
		127353,
		2
	],
	[
		127354,
		2
	],
	[
		[
			127355,
			127356
		],
		2
	],
	[
		[
			127357,
			127358
		],
		2
	],
	[
		127359,
		2
	],
	[
		[
			127360,
			127369
		],
		2
	],
	[
		[
			127370,
			127373
		],
		2
	],
	[
		[
			127374,
			127375
		],
		2
	],
	[
		127376,
		1,
		"dj"
	],
	[
		[
			127377,
			127386
		],
		2
	],
	[
		[
			127387,
			127404
		],
		2
	],
	[
		127405,
		2
	],
	[
		[
			127406,
			127461
		],
		3
	],
	[
		[
			127462,
			127487
		],
		2
	],
	[
		127488,
		1,
		""
	],
	[
		127489,
		1,
		""
	],
	[
		127490,
		1,
		""
	],
	[
		[
			127491,
			127503
		],
		3
	],
	[
		127504,
		1,
		""
	],
	[
		127505,
		1,
		""
	],
	[
		127506,
		1,
		""
	],
	[
		127507,
		1,
		""
	],
	[
		127508,
		1,
		""
	],
	[
		127509,
		1,
		""
	],
	[
		127510,
		1,
		""
	],
	[
		127511,
		1,
		""
	],
	[
		127512,
		1,
		""
	],
	[
		127513,
		1,
		""
	],
	[
		127514,
		1,
		""
	],
	[
		127515,
		1,
		""
	],
	[
		127516,
		1,
		""
	],
	[
		127517,
		1,
		""
	],
	[
		127518,
		1,
		""
	],
	[
		127519,
		1,
		""
	],
	[
		127520,
		1,
		""
	],
	[
		127521,
		1,
		""
	],
	[
		127522,
		1,
		""
	],
	[
		127523,
		1,
		""
	],
	[
		127524,
		1,
		""
	],
	[
		127525,
		1,
		""
	],
	[
		127526,
		1,
		""
	],
	[
		127527,
		1,
		""
	],
	[
		127528,
		1,
		""
	],
	[
		127529,
		1,
		""
	],
	[
		127530,
		1,
		""
	],
	[
		127531,
		1,
		""
	],
	[
		127532,
		1,
		""
	],
	[
		127533,
		1,
		""
	],
	[
		127534,
		1,
		""
	],
	[
		127535,
		1,
		""
	],
	[
		127536,
		1,
		""
	],
	[
		127537,
		1,
		""
	],
	[
		127538,
		1,
		""
	],
	[
		127539,
		1,
		""
	],
	[
		127540,
		1,
		""
	],
	[
		127541,
		1,
		""
	],
	[
		127542,
		1,
		""
	],
	[
		127543,
		1,
		""
	],
	[
		127544,
		1,
		""
	],
	[
		127545,
		1,
		""
	],
	[
		127546,
		1,
		""
	],
	[
		127547,
		1,
		""
	],
	[
		[
			127548,
			127551
		],
		3
	],
	[
		127552,
		1,
		""
	],
	[
		127553,
		1,
		""
	],
	[
		127554,
		1,
		""
	],
	[
		127555,
		1,
		""
	],
	[
		127556,
		1,
		""
	],
	[
		127557,
		1,
		""
	],
	[
		127558,
		1,
		""
	],
	[
		127559,
		1,
		""
	],
	[
		127560,
		1,
		""
	],
	[
		[
			127561,
			127567
		],
		3
	],
	[
		127568,
		1,
		""
	],
	[
		127569,
		1,
		""
	],
	[
		[
			127570,
			127583
		],
		3
	],
	[
		[
			127584,
			127589
		],
		2
	],
	[
		[
			127590,
			127743
		],
		3
	],
	[
		[
			127744,
			127776
		],
		2
	],
	[
		[
			127777,
			127788
		],
		2
	],
	[
		[
			127789,
			127791
		],
		2
	],
	[
		[
			127792,
			127797
		],
		2
	],
	[
		127798,
		2
	],
	[
		[
			127799,
			127868
		],
		2
	],
	[
		127869,
		2
	],
	[
		[
			127870,
			127871
		],
		2
	],
	[
		[
			127872,
			127891
		],
		2
	],
	[
		[
			127892,
			127903
		],
		2
	],
	[
		[
			127904,
			127940
		],
		2
	],
	[
		127941,
		2
	],
	[
		[
			127942,
			127946
		],
		2
	],
	[
		[
			127947,
			127950
		],
		2
	],
	[
		[
			127951,
			127955
		],
		2
	],
	[
		[
			127956,
			127967
		],
		2
	],
	[
		[
			127968,
			127984
		],
		2
	],
	[
		[
			127985,
			127991
		],
		2
	],
	[
		[
			127992,
			127999
		],
		2
	],
	[
		[
			128000,
			128062
		],
		2
	],
	[
		128063,
		2
	],
	[
		128064,
		2
	],
	[
		128065,
		2
	],
	[
		[
			128066,
			128247
		],
		2
	],
	[
		128248,
		2
	],
	[
		[
			128249,
			128252
		],
		2
	],
	[
		[
			128253,
			128254
		],
		2
	],
	[
		128255,
		2
	],
	[
		[
			128256,
			128317
		],
		2
	],
	[
		[
			128318,
			128319
		],
		2
	],
	[
		[
			128320,
			128323
		],
		2
	],
	[
		[
			128324,
			128330
		],
		2
	],
	[
		[
			128331,
			128335
		],
		2
	],
	[
		[
			128336,
			128359
		],
		2
	],
	[
		[
			128360,
			128377
		],
		2
	],
	[
		128378,
		2
	],
	[
		[
			128379,
			128419
		],
		2
	],
	[
		128420,
		2
	],
	[
		[
			128421,
			128506
		],
		2
	],
	[
		[
			128507,
			128511
		],
		2
	],
	[
		128512,
		2
	],
	[
		[
			128513,
			128528
		],
		2
	],
	[
		128529,
		2
	],
	[
		[
			128530,
			128532
		],
		2
	],
	[
		128533,
		2
	],
	[
		128534,
		2
	],
	[
		128535,
		2
	],
	[
		128536,
		2
	],
	[
		128537,
		2
	],
	[
		128538,
		2
	],
	[
		128539,
		2
	],
	[
		[
			128540,
			128542
		],
		2
	],
	[
		128543,
		2
	],
	[
		[
			128544,
			128549
		],
		2
	],
	[
		[
			128550,
			128551
		],
		2
	],
	[
		[
			128552,
			128555
		],
		2
	],
	[
		128556,
		2
	],
	[
		128557,
		2
	],
	[
		[
			128558,
			128559
		],
		2
	],
	[
		[
			128560,
			128563
		],
		2
	],
	[
		128564,
		2
	],
	[
		[
			128565,
			128576
		],
		2
	],
	[
		[
			128577,
			128578
		],
		2
	],
	[
		[
			128579,
			128580
		],
		2
	],
	[
		[
			128581,
			128591
		],
		2
	],
	[
		[
			128592,
			128639
		],
		2
	],
	[
		[
			128640,
			128709
		],
		2
	],
	[
		[
			128710,
			128719
		],
		2
	],
	[
		128720,
		2
	],
	[
		[
			128721,
			128722
		],
		2
	],
	[
		[
			128723,
			128724
		],
		2
	],
	[
		128725,
		2
	],
	[
		[
			128726,
			128727
		],
		2
	],
	[
		[
			128728,
			128731
		],
		3
	],
	[
		128732,
		2
	],
	[
		[
			128733,
			128735
		],
		2
	],
	[
		[
			128736,
			128748
		],
		2
	],
	[
		[
			128749,
			128751
		],
		3
	],
	[
		[
			128752,
			128755
		],
		2
	],
	[
		[
			128756,
			128758
		],
		2
	],
	[
		[
			128759,
			128760
		],
		2
	],
	[
		128761,
		2
	],
	[
		128762,
		2
	],
	[
		[
			128763,
			128764
		],
		2
	],
	[
		[
			128765,
			128767
		],
		3
	],
	[
		[
			128768,
			128883
		],
		2
	],
	[
		[
			128884,
			128886
		],
		2
	],
	[
		[
			128887,
			128890
		],
		3
	],
	[
		[
			128891,
			128895
		],
		2
	],
	[
		[
			128896,
			128980
		],
		2
	],
	[
		[
			128981,
			128984
		],
		2
	],
	[
		128985,
		2
	],
	[
		[
			128986,
			128991
		],
		3
	],
	[
		[
			128992,
			129003
		],
		2
	],
	[
		[
			129004,
			129007
		],
		3
	],
	[
		129008,
		2
	],
	[
		[
			129009,
			129023
		],
		3
	],
	[
		[
			129024,
			129035
		],
		2
	],
	[
		[
			129036,
			129039
		],
		3
	],
	[
		[
			129040,
			129095
		],
		2
	],
	[
		[
			129096,
			129103
		],
		3
	],
	[
		[
			129104,
			129113
		],
		2
	],
	[
		[
			129114,
			129119
		],
		3
	],
	[
		[
			129120,
			129159
		],
		2
	],
	[
		[
			129160,
			129167
		],
		3
	],
	[
		[
			129168,
			129197
		],
		2
	],
	[
		[
			129198,
			129199
		],
		3
	],
	[
		[
			129200,
			129201
		],
		2
	],
	[
		[
			129202,
			129279
		],
		3
	],
	[
		[
			129280,
			129291
		],
		2
	],
	[
		129292,
		2
	],
	[
		[
			129293,
			129295
		],
		2
	],
	[
		[
			129296,
			129304
		],
		2
	],
	[
		[
			129305,
			129310
		],
		2
	],
	[
		129311,
		2
	],
	[
		[
			129312,
			129319
		],
		2
	],
	[
		[
			129320,
			129327
		],
		2
	],
	[
		129328,
		2
	],
	[
		[
			129329,
			129330
		],
		2
	],
	[
		[
			129331,
			129342
		],
		2
	],
	[
		129343,
		2
	],
	[
		[
			129344,
			129355
		],
		2
	],
	[
		129356,
		2
	],
	[
		[
			129357,
			129359
		],
		2
	],
	[
		[
			129360,
			129374
		],
		2
	],
	[
		[
			129375,
			129387
		],
		2
	],
	[
		[
			129388,
			129392
		],
		2
	],
	[
		129393,
		2
	],
	[
		129394,
		2
	],
	[
		[
			129395,
			129398
		],
		2
	],
	[
		[
			129399,
			129400
		],
		2
	],
	[
		129401,
		2
	],
	[
		129402,
		2
	],
	[
		129403,
		2
	],
	[
		[
			129404,
			129407
		],
		2
	],
	[
		[
			129408,
			129412
		],
		2
	],
	[
		[
			129413,
			129425
		],
		2
	],
	[
		[
			129426,
			129431
		],
		2
	],
	[
		[
			129432,
			129442
		],
		2
	],
	[
		[
			129443,
			129444
		],
		2
	],
	[
		[
			129445,
			129450
		],
		2
	],
	[
		[
			129451,
			129453
		],
		2
	],
	[
		[
			129454,
			129455
		],
		2
	],
	[
		[
			129456,
			129465
		],
		2
	],
	[
		[
			129466,
			129471
		],
		2
	],
	[
		129472,
		2
	],
	[
		[
			129473,
			129474
		],
		2
	],
	[
		[
			129475,
			129482
		],
		2
	],
	[
		129483,
		2
	],
	[
		129484,
		2
	],
	[
		[
			129485,
			129487
		],
		2
	],
	[
		[
			129488,
			129510
		],
		2
	],
	[
		[
			129511,
			129535
		],
		2
	],
	[
		[
			129536,
			129619
		],
		2
	],
	[
		[
			129620,
			129631
		],
		3
	],
	[
		[
			129632,
			129645
		],
		2
	],
	[
		[
			129646,
			129647
		],
		3
	],
	[
		[
			129648,
			129651
		],
		2
	],
	[
		129652,
		2
	],
	[
		[
			129653,
			129655
		],
		2
	],
	[
		[
			129656,
			129658
		],
		2
	],
	[
		[
			129659,
			129660
		],
		2
	],
	[
		[
			129661,
			129663
		],
		3
	],
	[
		[
			129664,
			129666
		],
		2
	],
	[
		[
			129667,
			129670
		],
		2
	],
	[
		[
			129671,
			129672
		],
		2
	],
	[
		[
			129673,
			129679
		],
		3
	],
	[
		[
			129680,
			129685
		],
		2
	],
	[
		[
			129686,
			129704
		],
		2
	],
	[
		[
			129705,
			129708
		],
		2
	],
	[
		[
			129709,
			129711
		],
		2
	],
	[
		[
			129712,
			129718
		],
		2
	],
	[
		[
			129719,
			129722
		],
		2
	],
	[
		[
			129723,
			129725
		],
		2
	],
	[
		129726,
		3
	],
	[
		129727,
		2
	],
	[
		[
			129728,
			129730
		],
		2
	],
	[
		[
			129731,
			129733
		],
		2
	],
	[
		[
			129734,
			129741
		],
		3
	],
	[
		[
			129742,
			129743
		],
		2
	],
	[
		[
			129744,
			129750
		],
		2
	],
	[
		[
			129751,
			129753
		],
		2
	],
	[
		[
			129754,
			129755
		],
		2
	],
	[
		[
			129756,
			129759
		],
		3
	],
	[
		[
			129760,
			129767
		],
		2
	],
	[
		129768,
		2
	],
	[
		[
			129769,
			129775
		],
		3
	],
	[
		[
			129776,
			129782
		],
		2
	],
	[
		[
			129783,
			129784
		],
		2
	],
	[
		[
			129785,
			129791
		],
		3
	],
	[
		[
			129792,
			129938
		],
		2
	],
	[
		129939,
		3
	],
	[
		[
			129940,
			129994
		],
		2
	],
	[
		[
			129995,
			130031
		],
		3
	],
	[
		130032,
		1,
		"0"
	],
	[
		130033,
		1,
		"1"
	],
	[
		130034,
		1,
		"2"
	],
	[
		130035,
		1,
		"3"
	],
	[
		130036,
		1,
		"4"
	],
	[
		130037,
		1,
		"5"
	],
	[
		130038,
		1,
		"6"
	],
	[
		130039,
		1,
		"7"
	],
	[
		130040,
		1,
		"8"
	],
	[
		130041,
		1,
		"9"
	],
	[
		[
			130042,
			131069
		],
		3
	],
	[
		[
			131070,
			131071
		],
		3
	],
	[
		[
			131072,
			173782
		],
		2
	],
	[
		[
			173783,
			173789
		],
		2
	],
	[
		[
			173790,
			173791
		],
		2
	],
	[
		[
			173792,
			173823
		],
		3
	],
	[
		[
			173824,
			177972
		],
		2
	],
	[
		[
			177973,
			177976
		],
		2
	],
	[
		177977,
		2
	],
	[
		[
			177978,
			177983
		],
		3
	],
	[
		[
			177984,
			178205
		],
		2
	],
	[
		[
			178206,
			178207
		],
		3
	],
	[
		[
			178208,
			183969
		],
		2
	],
	[
		[
			183970,
			183983
		],
		3
	],
	[
		[
			183984,
			191456
		],
		2
	],
	[
		[
			191457,
			194559
		],
		3
	],
	[
		194560,
		1,
		""
	],
	[
		194561,
		1,
		""
	],
	[
		194562,
		1,
		""
	],
	[
		194563,
		1,
		""
	],
	[
		194564,
		1,
		""
	],
	[
		194565,
		1,
		""
	],
	[
		194566,
		1,
		""
	],
	[
		194567,
		1,
		""
	],
	[
		194568,
		1,
		""
	],
	[
		194569,
		1,
		""
	],
	[
		194570,
		1,
		""
	],
	[
		194571,
		1,
		""
	],
	[
		194572,
		1,
		""
	],
	[
		194573,
		1,
		""
	],
	[
		194574,
		1,
		""
	],
	[
		194575,
		1,
		""
	],
	[
		194576,
		1,
		""
	],
	[
		194577,
		1,
		""
	],
	[
		194578,
		1,
		""
	],
	[
		194579,
		1,
		""
	],
	[
		194580,
		1,
		""
	],
	[
		194581,
		1,
		""
	],
	[
		194582,
		1,
		""
	],
	[
		194583,
		1,
		""
	],
	[
		194584,
		1,
		""
	],
	[
		194585,
		1,
		""
	],
	[
		194586,
		1,
		""
	],
	[
		194587,
		1,
		""
	],
	[
		194588,
		1,
		""
	],
	[
		194589,
		1,
		""
	],
	[
		194590,
		1,
		""
	],
	[
		194591,
		1,
		""
	],
	[
		194592,
		1,
		""
	],
	[
		194593,
		1,
		""
	],
	[
		194594,
		1,
		""
	],
	[
		194595,
		1,
		""
	],
	[
		194596,
		1,
		""
	],
	[
		194597,
		1,
		""
	],
	[
		194598,
		1,
		""
	],
	[
		194599,
		1,
		""
	],
	[
		194600,
		1,
		""
	],
	[
		194601,
		1,
		""
	],
	[
		194602,
		1,
		""
	],
	[
		194603,
		1,
		""
	],
	[
		194604,
		1,
		""
	],
	[
		194605,
		1,
		""
	],
	[
		194606,
		1,
		""
	],
	[
		194607,
		1,
		""
	],
	[
		194608,
		1,
		""
	],
	[
		[
			194609,
			194611
		],
		1,
		""
	],
	[
		194612,
		1,
		""
	],
	[
		194613,
		1,
		""
	],
	[
		194614,
		1,
		""
	],
	[
		194615,
		1,
		""
	],
	[
		194616,
		1,
		""
	],
	[
		194617,
		1,
		""
	],
	[
		194618,
		1,
		""
	],
	[
		194619,
		1,
		""
	],
	[
		194620,
		1,
		""
	],
	[
		194621,
		1,
		""
	],
	[
		194622,
		1,
		""
	],
	[
		194623,
		1,
		""
	],
	[
		194624,
		1,
		""
	],
	[
		194625,
		1,
		""
	],
	[
		194626,
		1,
		""
	],
	[
		194627,
		1,
		""
	],
	[
		194628,
		1,
		""
	],
	[
		[
			194629,
			194630
		],
		1,
		""
	],
	[
		194631,
		1,
		""
	],
	[
		194632,
		1,
		""
	],
	[
		194633,
		1,
		""
	],
	[
		194634,
		1,
		""
	],
	[
		194635,
		1,
		""
	],
	[
		194636,
		1,
		""
	],
	[
		194637,
		1,
		""
	],
	[
		194638,
		1,
		""
	],
	[
		194639,
		1,
		""
	],
	[
		194640,
		1,
		""
	],
	[
		194641,
		1,
		""
	],
	[
		194642,
		1,
		""
	],
	[
		194643,
		1,
		""
	],
	[
		194644,
		1,
		""
	],
	[
		194645,
		1,
		""
	],
	[
		194646,
		1,
		""
	],
	[
		194647,
		1,
		""
	],
	[
		194648,
		1,
		""
	],
	[
		194649,
		1,
		""
	],
	[
		194650,
		1,
		""
	],
	[
		194651,
		1,
		""
	],
	[
		194652,
		1,
		""
	],
	[
		194653,
		1,
		""
	],
	[
		194654,
		1,
		""
	],
	[
		194655,
		1,
		""
	],
	[
		194656,
		1,
		""
	],
	[
		194657,
		1,
		""
	],
	[
		194658,
		1,
		""
	],
	[
		194659,
		1,
		""
	],
	[
		194660,
		1,
		""
	],
	[
		194661,
		1,
		""
	],
	[
		194662,
		1,
		""
	],
	[
		194663,
		1,
		""
	],
	[
		194664,
		3
	],
	[
		194665,
		1,
		""
	],
	[
		[
			194666,
			194667
		],
		1,
		""
	],
	[
		194668,
		1,
		""
	],
	[
		194669,
		1,
		""
	],
	[
		194670,
		1,
		""
	],
	[
		194671,
		1,
		""
	],
	[
		194672,
		1,
		""
	],
	[
		194673,
		1,
		""
	],
	[
		194674,
		1,
		""
	],
	[
		194675,
		1,
		""
	],
	[
		194676,
		3
	],
	[
		194677,
		1,
		""
	],
	[
		194678,
		1,
		""
	],
	[
		194679,
		1,
		""
	],
	[
		194680,
		1,
		""
	],
	[
		194681,
		1,
		""
	],
	[
		194682,
		1,
		""
	],
	[
		194683,
		1,
		""
	],
	[
		194684,
		1,
		""
	],
	[
		194685,
		1,
		""
	],
	[
		194686,
		1,
		""
	],
	[
		194687,
		1,
		""
	],
	[
		194688,
		1,
		""
	],
	[
		194689,
		1,
		""
	],
	[
		194690,
		1,
		""
	],
	[
		194691,
		1,
		""
	],
	[
		194692,
		1,
		""
	],
	[
		194693,
		1,
		""
	],
	[
		194694,
		1,
		""
	],
	[
		194695,
		1,
		""
	],
	[
		194696,
		1,
		""
	],
	[
		194697,
		1,
		""
	],
	[
		194698,
		1,
		""
	],
	[
		194699,
		1,
		""
	],
	[
		194700,
		1,
		""
	],
	[
		194701,
		1,
		""
	],
	[
		194702,
		1,
		""
	],
	[
		194703,
		1,
		""
	],
	[
		194704,
		1,
		""
	],
	[
		[
			194705,
			194706
		],
		1,
		""
	],
	[
		194707,
		1,
		""
	],
	[
		[
			194708,
			194709
		],
		1,
		""
	],
	[
		194710,
		1,
		""
	],
	[
		194711,
		1,
		""
	],
	[
		194712,
		1,
		""
	],
	[
		194713,
		1,
		""
	],
	[
		194714,
		1,
		""
	],
	[
		194715,
		1,
		""
	],
	[
		194716,
		1,
		""
	],
	[
		194717,
		1,
		""
	],
	[
		194718,
		1,
		""
	],
	[
		194719,
		1,
		""
	],
	[
		194720,
		1,
		""
	],
	[
		194721,
		1,
		""
	],
	[
		194722,
		1,
		""
	],
	[
		194723,
		1,
		""
	],
	[
		194724,
		1,
		""
	],
	[
		194725,
		1,
		""
	],
	[
		194726,
		1,
		""
	],
	[
		194727,
		1,
		""
	],
	[
		194728,
		1,
		""
	],
	[
		194729,
		1,
		""
	],
	[
		194730,
		1,
		""
	],
	[
		194731,
		1,
		""
	],
	[
		194732,
		1,
		""
	],
	[
		194733,
		1,
		""
	],
	[
		194734,
		1,
		""
	],
	[
		194735,
		1,
		""
	],
	[
		194736,
		1,
		""
	],
	[
		194737,
		1,
		""
	],
	[
		194738,
		1,
		""
	],
	[
		194739,
		1,
		""
	],
	[
		194740,
		1,
		""
	],
	[
		194741,
		1,
		""
	],
	[
		194742,
		1,
		""
	],
	[
		194743,
		1,
		""
	],
	[
		194744,
		1,
		""
	],
	[
		194745,
		1,
		""
	],
	[
		194746,
		1,
		""
	],
	[
		194747,
		1,
		""
	],
	[
		194748,
		1,
		""
	],
	[
		194749,
		1,
		""
	],
	[
		194750,
		1,
		""
	],
	[
		194751,
		1,
		""
	],
	[
		194752,
		1,
		""
	],
	[
		194753,
		1,
		""
	],
	[
		194754,
		1,
		""
	],
	[
		194755,
		1,
		""
	],
	[
		194756,
		1,
		""
	],
	[
		194757,
		1,
		""
	],
	[
		194758,
		1,
		""
	],
	[
		194759,
		1,
		""
	],
	[
		194760,
		1,
		""
	],
	[
		194761,
		1,
		""
	],
	[
		194762,
		1,
		""
	],
	[
		194763,
		1,
		""
	],
	[
		194764,
		1,
		""
	],
	[
		194765,
		1,
		""
	],
	[
		194766,
		1,
		""
	],
	[
		194767,
		1,
		""
	],
	[
		194768,
		1,
		""
	],
	[
		194769,
		1,
		""
	],
	[
		194770,
		1,
		""
	],
	[
		194771,
		1,
		""
	],
	[
		194772,
		1,
		""
	],
	[
		194773,
		1,
		""
	],
	[
		194774,
		1,
		""
	],
	[
		194775,
		1,
		""
	],
	[
		194776,
		1,
		""
	],
	[
		194777,
		1,
		""
	],
	[
		194778,
		1,
		""
	],
	[
		194779,
		1,
		""
	],
	[
		194780,
		1,
		""
	],
	[
		194781,
		1,
		""
	],
	[
		194782,
		1,
		""
	],
	[
		194783,
		1,
		""
	],
	[
		194784,
		1,
		""
	],
	[
		194785,
		1,
		""
	],
	[
		194786,
		1,
		""
	],
	[
		194787,
		1,
		""
	],
	[
		194788,
		1,
		""
	],
	[
		194789,
		1,
		""
	],
	[
		194790,
		1,
		""
	],
	[
		194791,
		1,
		""
	],
	[
		194792,
		1,
		""
	],
	[
		194793,
		1,
		""
	],
	[
		194794,
		1,
		""
	],
	[
		194795,
		1,
		""
	],
	[
		194796,
		1,
		""
	],
	[
		194797,
		1,
		""
	],
	[
		194798,
		1,
		""
	],
	[
		194799,
		1,
		""
	],
	[
		194800,
		1,
		""
	],
	[
		194801,
		1,
		""
	],
	[
		194802,
		1,
		""
	],
	[
		194803,
		1,
		""
	],
	[
		194804,
		1,
		""
	],
	[
		194805,
		1,
		""
	],
	[
		194806,
		1,
		""
	],
	[
		194807,
		1,
		""
	],
	[
		194808,
		1,
		""
	],
	[
		194809,
		1,
		""
	],
	[
		194810,
		1,
		""
	],
	[
		194811,
		1,
		""
	],
	[
		194812,
		1,
		""
	],
	[
		194813,
		1,
		""
	],
	[
		194814,
		1,
		""
	],
	[
		194815,
		1,
		""
	],
	[
		194816,
		1,
		""
	],
	[
		194817,
		1,
		""
	],
	[
		194818,
		1,
		""
	],
	[
		194819,
		1,
		""
	],
	[
		194820,
		1,
		""
	],
	[
		194821,
		1,
		""
	],
	[
		194822,
		1,
		""
	],
	[
		194823,
		1,
		""
	],
	[
		194824,
		1,
		""
	],
	[
		194825,
		1,
		""
	],
	[
		194826,
		1,
		""
	],
	[
		194827,
		1,
		""
	],
	[
		194828,
		1,
		""
	],
	[
		194829,
		1,
		""
	],
	[
		194830,
		1,
		""
	],
	[
		194831,
		1,
		""
	],
	[
		194832,
		1,
		""
	],
	[
		194833,
		1,
		""
	],
	[
		194834,
		1,
		""
	],
	[
		194835,
		1,
		""
	],
	[
		194836,
		1,
		""
	],
	[
		194837,
		1,
		""
	],
	[
		194838,
		1,
		""
	],
	[
		194839,
		1,
		""
	],
	[
		194840,
		1,
		""
	],
	[
		194841,
		1,
		""
	],
	[
		194842,
		1,
		""
	],
	[
		194843,
		1,
		""
	],
	[
		194844,
		1,
		""
	],
	[
		194845,
		1,
		""
	],
	[
		194846,
		1,
		""
	],
	[
		194847,
		3
	],
	[
		194848,
		1,
		""
	],
	[
		194849,
		1,
		""
	],
	[
		194850,
		1,
		""
	],
	[
		194851,
		1,
		""
	],
	[
		194852,
		1,
		""
	],
	[
		194853,
		1,
		""
	],
	[
		194854,
		1,
		""
	],
	[
		194855,
		1,
		""
	],
	[
		194856,
		1,
		""
	],
	[
		194857,
		1,
		""
	],
	[
		194858,
		1,
		""
	],
	[
		194859,
		1,
		""
	],
	[
		[
			194860,
			194861
		],
		1,
		""
	],
	[
		194862,
		1,
		""
	],
	[
		194863,
		1,
		""
	],
	[
		194864,
		1,
		""
	],
	[
		194865,
		1,
		""
	],
	[
		194866,
		1,
		""
	],
	[
		194867,
		1,
		""
	],
	[
		194868,
		1,
		""
	],
	[
		194869,
		1,
		""
	],
	[
		194870,
		1,
		""
	],
	[
		194871,
		1,
		""
	],
	[
		194872,
		1,
		""
	],
	[
		194873,
		1,
		""
	],
	[
		194874,
		1,
		""
	],
	[
		194875,
		1,
		""
	],
	[
		194876,
		1,
		""
	],
	[
		194877,
		1,
		""
	],
	[
		194878,
		1,
		""
	],
	[
		194879,
		1,
		""
	],
	[
		194880,
		1,
		""
	],
	[
		194881,
		1,
		""
	],
	[
		194882,
		1,
		""
	],
	[
		194883,
		1,
		""
	],
	[
		194884,
		1,
		""
	],
	[
		194885,
		1,
		""
	],
	[
		[
			194886,
			194887
		],
		1,
		""
	],
	[
		194888,
		1,
		""
	],
	[
		194889,
		1,
		""
	],
	[
		194890,
		1,
		""
	],
	[
		194891,
		1,
		""
	],
	[
		194892,
		1,
		""
	],
	[
		194893,
		1,
		""
	],
	[
		194894,
		1,
		""
	],
	[
		194895,
		1,
		""
	],
	[
		194896,
		1,
		""
	],
	[
		194897,
		1,
		""
	],
	[
		194898,
		1,
		""
	],
	[
		194899,
		1,
		""
	],
	[
		194900,
		1,
		""
	],
	[
		194901,
		1,
		""
	],
	[
		194902,
		1,
		""
	],
	[
		194903,
		1,
		""
	],
	[
		194904,
		1,
		""
	],
	[
		194905,
		1,
		""
	],
	[
		194906,
		1,
		""
	],
	[
		194907,
		1,
		""
	],
	[
		194908,
		1,
		""
	],
	[
		[
			194909,
			194910
		],
		1,
		""
	],
	[
		194911,
		3
	],
	[
		194912,
		1,
		""
	],
	[
		194913,
		1,
		""
	],
	[
		194914,
		1,
		""
	],
	[
		194915,
		1,
		""
	],
	[
		194916,
		1,
		""
	],
	[
		194917,
		1,
		""
	],
	[
		194918,
		1,
		""
	],
	[
		194919,
		1,
		""
	],
	[
		194920,
		1,
		""
	],
	[
		194921,
		1,
		""
	],
	[
		194922,
		1,
		""
	],
	[
		194923,
		1,
		""
	],
	[
		194924,
		1,
		""
	],
	[
		194925,
		1,
		""
	],
	[
		194926,
		1,
		""
	],
	[
		194927,
		1,
		""
	],
	[
		194928,
		1,
		""
	],
	[
		194929,
		1,
		""
	],
	[
		194930,
		1,
		""
	],
	[
		194931,
		1,
		""
	],
	[
		194932,
		1,
		""
	],
	[
		194933,
		1,
		""
	],
	[
		194934,
		1,
		""
	],
	[
		194935,
		1,
		""
	],
	[
		194936,
		1,
		""
	],
	[
		194937,
		1,
		""
	],
	[
		194938,
		1,
		""
	],
	[
		194939,
		1,
		""
	],
	[
		194940,
		1,
		""
	],
	[
		194941,
		1,
		""
	],
	[
		194942,
		1,
		""
	],
	[
		194943,
		1,
		""
	],
	[
		194944,
		1,
		""
	],
	[
		194945,
		1,
		""
	],
	[
		194946,
		1,
		""
	],
	[
		194947,
		1,
		""
	],
	[
		194948,
		1,
		""
	],
	[
		194949,
		1,
		""
	],
	[
		194950,
		1,
		""
	],
	[
		194951,
		1,
		""
	],
	[
		194952,
		1,
		""
	],
	[
		194953,
		1,
		""
	],
	[
		194954,
		1,
		""
	],
	[
		194955,
		1,
		""
	],
	[
		194956,
		1,
		""
	],
	[
		194957,
		1,
		""
	],
	[
		194958,
		1,
		""
	],
	[
		194959,
		1,
		""
	],
	[
		194960,
		1,
		""
	],
	[
		194961,
		1,
		""
	],
	[
		194962,
		1,
		""
	],
	[
		194963,
		1,
		""
	],
	[
		194964,
		1,
		""
	],
	[
		194965,
		1,
		""
	],
	[
		194966,
		1,
		""
	],
	[
		194967,
		1,
		""
	],
	[
		194968,
		1,
		""
	],
	[
		194969,
		1,
		""
	],
	[
		194970,
		1,
		""
	],
	[
		194971,
		1,
		""
	],
	[
		194972,
		1,
		""
	],
	[
		194973,
		1,
		""
	],
	[
		194974,
		1,
		""
	],
	[
		194975,
		1,
		""
	],
	[
		194976,
		1,
		""
	],
	[
		194977,
		1,
		""
	],
	[
		194978,
		1,
		""
	],
	[
		194979,
		1,
		""
	],
	[
		194980,
		1,
		""
	],
	[
		194981,
		1,
		""
	],
	[
		194982,
		1,
		""
	],
	[
		194983,
		1,
		""
	],
	[
		194984,
		1,
		""
	],
	[
		194985,
		1,
		""
	],
	[
		194986,
		1,
		""
	],
	[
		194987,
		1,
		""
	],
	[
		194988,
		1,
		""
	],
	[
		194989,
		1,
		""
	],
	[
		194990,
		1,
		""
	],
	[
		194991,
		1,
		""
	],
	[
		194992,
		1,
		""
	],
	[
		194993,
		1,
		""
	],
	[
		194994,
		1,
		""
	],
	[
		194995,
		1,
		""
	],
	[
		194996,
		1,
		""
	],
	[
		194997,
		1,
		""
	],
	[
		194998,
		1,
		""
	],
	[
		194999,
		1,
		""
	],
	[
		195000,
		1,
		""
	],
	[
		195001,
		1,
		""
	],
	[
		195002,
		1,
		""
	],
	[
		195003,
		1,
		""
	],
	[
		195004,
		1,
		""
	],
	[
		195005,
		1,
		""
	],
	[
		195006,
		1,
		""
	],
	[
		195007,
		3
	],
	[
		195008,
		1,
		""
	],
	[
		195009,
		1,
		""
	],
	[
		195010,
		1,
		""
	],
	[
		195011,
		1,
		""
	],
	[
		195012,
		1,
		""
	],
	[
		195013,
		1,
		""
	],
	[
		195014,
		1,
		""
	],
	[
		195015,
		1,
		""
	],
	[
		195016,
		1,
		""
	],
	[
		195017,
		1,
		""
	],
	[
		195018,
		1,
		""
	],
	[
		195019,
		1,
		""
	],
	[
		195020,
		1,
		""
	],
	[
		195021,
		1,
		""
	],
	[
		195022,
		1,
		""
	],
	[
		195023,
		1,
		""
	],
	[
		195024,
		1,
		""
	],
	[
		195025,
		1,
		""
	],
	[
		195026,
		1,
		""
	],
	[
		195027,
		1,
		""
	],
	[
		195028,
		1,
		""
	],
	[
		195029,
		1,
		""
	],
	[
		195030,
		1,
		""
	],
	[
		195031,
		1,
		""
	],
	[
		195032,
		1,
		""
	],
	[
		195033,
		1,
		""
	],
	[
		195034,
		1,
		""
	],
	[
		195035,
		1,
		""
	],
	[
		195036,
		1,
		""
	],
	[
		195037,
		1,
		""
	],
	[
		195038,
		1,
		""
	],
	[
		195039,
		1,
		""
	],
	[
		195040,
		1,
		""
	],
	[
		195041,
		1,
		""
	],
	[
		195042,
		1,
		""
	],
	[
		195043,
		1,
		""
	],
	[
		195044,
		1,
		""
	],
	[
		195045,
		1,
		""
	],
	[
		195046,
		1,
		""
	],
	[
		195047,
		1,
		""
	],
	[
		195048,
		1,
		""
	],
	[
		195049,
		1,
		""
	],
	[
		195050,
		1,
		""
	],
	[
		195051,
		1,
		""
	],
	[
		195052,
		1,
		""
	],
	[
		195053,
		1,
		""
	],
	[
		195054,
		1,
		""
	],
	[
		195055,
		1,
		""
	],
	[
		195056,
		1,
		""
	],
	[
		195057,
		1,
		""
	],
	[
		195058,
		1,
		""
	],
	[
		195059,
		1,
		""
	],
	[
		195060,
		1,
		""
	],
	[
		195061,
		1,
		""
	],
	[
		195062,
		1,
		""
	],
	[
		195063,
		1,
		""
	],
	[
		195064,
		1,
		""
	],
	[
		195065,
		1,
		""
	],
	[
		195066,
		1,
		""
	],
	[
		195067,
		1,
		""
	],
	[
		195068,
		1,
		""
	],
	[
		195069,
		1,
		""
	],
	[
		[
			195070,
			195071
		],
		1,
		""
	],
	[
		195072,
		1,
		""
	],
	[
		195073,
		1,
		""
	],
	[
		195074,
		1,
		""
	],
	[
		195075,
		1,
		""
	],
	[
		195076,
		1,
		""
	],
	[
		195077,
		1,
		""
	],
	[
		195078,
		1,
		""
	],
	[
		195079,
		1,
		""
	],
	[
		195080,
		1,
		""
	],
	[
		195081,
		1,
		""
	],
	[
		195082,
		1,
		""
	],
	[
		195083,
		1,
		""
	],
	[
		195084,
		1,
		""
	],
	[
		195085,
		1,
		""
	],
	[
		195086,
		1,
		""
	],
	[
		195087,
		1,
		""
	],
	[
		195088,
		1,
		""
	],
	[
		195089,
		1,
		""
	],
	[
		195090,
		1,
		""
	],
	[
		195091,
		1,
		""
	],
	[
		195092,
		1,
		""
	],
	[
		195093,
		1,
		""
	],
	[
		195094,
		1,
		""
	],
	[
		195095,
		1,
		""
	],
	[
		195096,
		1,
		""
	],
	[
		195097,
		1,
		""
	],
	[
		195098,
		1,
		""
	],
	[
		195099,
		1,
		""
	],
	[
		195100,
		1,
		""
	],
	[
		195101,
		1,
		""
	],
	[
		[
			195102,
			196605
		],
		3
	],
	[
		[
			196606,
			196607
		],
		3
	],
	[
		[
			196608,
			201546
		],
		2
	],
	[
		[
			201547,
			201551
		],
		3
	],
	[
		[
			201552,
			205743
		],
		2
	],
	[
		[
			205744,
			262141
		],
		3
	],
	[
		[
			262142,
			262143
		],
		3
	],
	[
		[
			262144,
			327677
		],
		3
	],
	[
		[
			327678,
			327679
		],
		3
	],
	[
		[
			327680,
			393213
		],
		3
	],
	[
		[
			393214,
			393215
		],
		3
	],
	[
		[
			393216,
			458749
		],
		3
	],
	[
		[
			458750,
			458751
		],
		3
	],
	[
		[
			458752,
			524285
		],
		3
	],
	[
		[
			524286,
			524287
		],
		3
	],
	[
		[
			524288,
			589821
		],
		3
	],
	[
		[
			589822,
			589823
		],
		3
	],
	[
		[
			589824,
			655357
		],
		3
	],
	[
		[
			655358,
			655359
		],
		3
	],
	[
		[
			655360,
			720893
		],
		3
	],
	[
		[
			720894,
			720895
		],
		3
	],
	[
		[
			720896,
			786429
		],
		3
	],
	[
		[
			786430,
			786431
		],
		3
	],
	[
		[
			786432,
			851965
		],
		3
	],
	[
		[
			851966,
			851967
		],
		3
	],
	[
		[
			851968,
			917501
		],
		3
	],
	[
		[
			917502,
			917503
		],
		3
	],
	[
		917504,
		3
	],
	[
		917505,
		3
	],
	[
		[
			917506,
			917535
		],
		3
	],
	[
		[
			917536,
			917631
		],
		3
	],
	[
		[
			917632,
			917759
		],
		3
	],
	[
		[
			917760,
			917999
		],
		7
	],
	[
		[
			918000,
			983037
		],
		3
	],
	[
		[
			983038,
			983039
		],
		3
	],
	[
		[
			983040,
			1048573
		],
		3
	],
	[
		[
			1048574,
			1048575
		],
		3
	],
	[
		[
			1048576,
			1114109
		],
		3
	],
	[
		[
			1114110,
			1114111
		],
		3
	]
];

var statusMapping = {};

var hasRequiredStatusMapping;

function requireStatusMapping () {
	if (hasRequiredStatusMapping) return statusMapping;
	hasRequiredStatusMapping = 1;

	statusMapping.STATUS_MAPPING = {
	  mapped: 1,
	  valid: 2,
	  disallowed: 3,
	  disallowed_STD3_valid: 4,
	  disallowed_STD3_mapped: 5,
	  deviation: 6,
	  ignored: 7
	};
	return statusMapping;
}

var tr46;
var hasRequiredTr46;

function requireTr46 () {
	if (hasRequiredTr46) return tr46;
	hasRequiredTr46 = 1;

	const punycode = require$$0;
	const regexes = requireRegexes();
	const mappingTable = require$$2;
	const { STATUS_MAPPING } = requireStatusMapping();

	function containsNonASCII(str) {
	  return /[^\x00-\x7F]/u.test(str);
	}

	function findStatus(val, { useSTD3ASCIIRules }) {
	  let start = 0;
	  let end = mappingTable.length - 1;

	  while (start <= end) {
	    const mid = Math.floor((start + end) / 2);

	    const target = mappingTable[mid];
	    const min = Array.isArray(target[0]) ? target[0][0] : target[0];
	    const max = Array.isArray(target[0]) ? target[0][1] : target[0];

	    if (min <= val && max >= val) {
	      if (useSTD3ASCIIRules &&
	          (target[1] === STATUS_MAPPING.disallowed_STD3_valid || target[1] === STATUS_MAPPING.disallowed_STD3_mapped)) {
	        return [STATUS_MAPPING.disallowed, ...target.slice(2)];
	      } else if (target[1] === STATUS_MAPPING.disallowed_STD3_valid) {
	        return [STATUS_MAPPING.valid, ...target.slice(2)];
	      } else if (target[1] === STATUS_MAPPING.disallowed_STD3_mapped) {
	        return [STATUS_MAPPING.mapped, ...target.slice(2)];
	      }

	      return target.slice(1);
	    } else if (min > val) {
	      end = mid - 1;
	    } else {
	      start = mid + 1;
	    }
	  }

	  return null;
	}

	function mapChars(domainName, { useSTD3ASCIIRules, processingOption }) {
	  let hasError = false;
	  let processed = "";

	  for (const ch of domainName) {
	    const [status, mapping] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });

	    switch (status) {
	      case STATUS_MAPPING.disallowed:
	        hasError = true;
	        processed += ch;
	        break;
	      case STATUS_MAPPING.ignored:
	        break;
	      case STATUS_MAPPING.mapped:
	        processed += mapping;
	        break;
	      case STATUS_MAPPING.deviation:
	        if (processingOption === "transitional") {
	          processed += mapping;
	        } else {
	          processed += ch;
	        }
	        break;
	      case STATUS_MAPPING.valid:
	        processed += ch;
	        break;
	    }
	  }

	  return {
	    string: processed,
	    error: hasError
	  };
	}

	function validateLabel(label, { checkHyphens, checkBidi, checkJoiners, processingOption, useSTD3ASCIIRules }) {
	  if (label.normalize("NFC") !== label) {
	    return false;
	  }

	  const codePoints = Array.from(label);

	  if (checkHyphens) {
	    if ((codePoints[2] === "-" && codePoints[3] === "-") ||
	        (label.startsWith("-") || label.endsWith("-"))) {
	      return false;
	    }
	  }

	  if (label.includes(".") ||
	      (codePoints.length > 0 && regexes.combiningMarks.test(codePoints[0]))) {
	    return false;
	  }

	  for (const ch of codePoints) {
	    const [status] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });
	    if ((processingOption === "transitional" && status !== STATUS_MAPPING.valid) ||
	        (processingOption === "nontransitional" &&
	         status !== STATUS_MAPPING.valid && status !== STATUS_MAPPING.deviation)) {
	      return false;
	    }
	  }

	  // https://tools.ietf.org/html/rfc5892#appendix-A
	  if (checkJoiners) {
	    let last = 0;
	    for (const [i, ch] of codePoints.entries()) {
	      if (ch === "\u200C" || ch === "\u200D") {
	        if (i > 0) {
	          if (regexes.combiningClassVirama.test(codePoints[i - 1])) {
	            continue;
	          }
	          if (ch === "\u200C") {
	            // TODO: make this more efficient
	            const next = codePoints.indexOf("\u200C", i + 1);
	            const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);
	            if (regexes.validZWNJ.test(test.join(""))) {
	              last = i + 1;
	              continue;
	            }
	          }
	        }
	        return false;
	      }
	    }
	  }

	  // https://tools.ietf.org/html/rfc5893#section-2
	  // For the codePoints length check, see discussion in https://github.com/jsdom/whatwg-url/pull/250 and the second item
	  // in https://github.com/whatwg/url/issues/744.
	  if (checkBidi && codePoints.length > 0) {
	    let rtl;

	    // 1
	    if (regexes.bidiS1LTR.test(codePoints[0])) {
	      rtl = false;
	    } else if (regexes.bidiS1RTL.test(codePoints[0])) {
	      rtl = true;
	    } else {
	      return false;
	    }

	    if (rtl) {
	      // 2-4
	      if (!regexes.bidiS2.test(label) ||
	          !regexes.bidiS3.test(label) ||
	          (regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label))) {
	        return false;
	      }
	    } else if (!regexes.bidiS5.test(label) ||
	               !regexes.bidiS6.test(label)) { // 5-6
	      return false;
	    }
	  }

	  return true;
	}

	function isBidiDomain(labels) {
	  const domain = labels.map(label => {
	    if (label.startsWith("xn--")) {
	      try {
	        return punycode.decode(label.substring(4));
	      } catch (err) {
	        return "";
	      }
	    }
	    return label;
	  }).join(".");
	  return regexes.bidiDomain.test(domain);
	}

	function processing(domainName, options) {
	  const { processingOption } = options;

	  // 1. Map.
	  let { string, error } = mapChars(domainName, options);

	  // 2. Normalize.
	  string = string.normalize("NFC");

	  // 3. Break.
	  const labels = string.split(".");
	  const isBidi = isBidiDomain(labels);

	  // 4. Convert/Validate.
	  for (const [i, origLabel] of labels.entries()) {
	    let label = origLabel;
	    let curProcessing = processingOption;
	    if (label.startsWith("xn--")) {
	      try {
	        label = punycode.decode(label.substring(4));
	        labels[i] = label;
	      } catch (err) {
	        error = true;
	        continue;
	      }
	      curProcessing = "nontransitional";
	    }

	    // No need to validate if we already know there is an error.
	    if (error) {
	      continue;
	    }
	    const validation = validateLabel(label, {
	      ...options,
	      processingOption: curProcessing,
	      checkBidi: options.checkBidi && isBidi
	    });
	    if (!validation) {
	      error = true;
	    }
	  }

	  return {
	    string: labels.join("."),
	    error
	  };
	}

	function toASCII(domainName, {
	  checkHyphens = false,
	  checkBidi = false,
	  checkJoiners = false,
	  useSTD3ASCIIRules = false,
	  processingOption = "nontransitional",
	  verifyDNSLength = false
	} = {}) {
	  if (processingOption !== "transitional" && processingOption !== "nontransitional") {
	    throw new RangeError("processingOption must be either transitional or nontransitional");
	  }

	  const result = processing(domainName, {
	    processingOption,
	    checkHyphens,
	    checkBidi,
	    checkJoiners,
	    useSTD3ASCIIRules
	  });
	  let labels = result.string.split(".");
	  labels = labels.map(l => {
	    if (containsNonASCII(l)) {
	      try {
	        return `xn--${punycode.encode(l)}`;
	      } catch (e) {
	        result.error = true;
	      }
	    }
	    return l;
	  });

	  if (verifyDNSLength) {
	    const total = labels.join(".").length;
	    if (total > 253 || total === 0) {
	      result.error = true;
	    }

	    for (let i = 0; i < labels.length; ++i) {
	      if (labels[i].length > 63 || labels[i].length === 0) {
	        result.error = true;
	        break;
	      }
	    }
	  }

	  if (result.error) {
	    return null;
	  }
	  return labels.join(".");
	}

	function toUnicode(domainName, {
	  checkHyphens = false,
	  checkBidi = false,
	  checkJoiners = false,
	  useSTD3ASCIIRules = false,
	  processingOption = "nontransitional"
	} = {}) {
	  const result = processing(domainName, {
	    processingOption,
	    checkHyphens,
	    checkBidi,
	    checkJoiners,
	    useSTD3ASCIIRules
	  });

	  return {
	    domain: result.string,
	    error: result.error
	  };
	}

	tr46 = {
	  toASCII,
	  toUnicode
	};
	return tr46;
}

var infra;
var hasRequiredInfra;

function requireInfra () {
	if (hasRequiredInfra) return infra;
	hasRequiredInfra = 1;

	// Note that we take code points as JS numbers, not JS strings.

	function isASCIIDigit(c) {
	  return c >= 0x30 && c <= 0x39;
	}

	function isASCIIAlpha(c) {
	  return (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A);
	}

	function isASCIIAlphanumeric(c) {
	  return isASCIIAlpha(c) || isASCIIDigit(c);
	}

	function isASCIIHex(c) {
	  return isASCIIDigit(c) || (c >= 0x41 && c <= 0x46) || (c >= 0x61 && c <= 0x66);
	}

	infra = {
	  isASCIIDigit,
	  isASCIIAlpha,
	  isASCIIAlphanumeric,
	  isASCIIHex
	};
	return infra;
}

var encoding;
var hasRequiredEncoding;

function requireEncoding () {
	if (hasRequiredEncoding) return encoding;
	hasRequiredEncoding = 1;
	const utf8Encoder = new TextEncoder();
	const utf8Decoder = new TextDecoder("utf-8", { ignoreBOM: true });

	function utf8Encode(string) {
	  return utf8Encoder.encode(string);
	}

	function utf8DecodeWithoutBOM(bytes) {
	  return utf8Decoder.decode(bytes);
	}

	encoding = {
	  utf8Encode,
	  utf8DecodeWithoutBOM
	};
	return encoding;
}

var percentEncoding;
var hasRequiredPercentEncoding;

function requirePercentEncoding () {
	if (hasRequiredPercentEncoding) return percentEncoding;
	hasRequiredPercentEncoding = 1;
	const { isASCIIHex } = requireInfra();
	const { utf8Encode } = requireEncoding();

	function p(char) {
	  return char.codePointAt(0);
	}

	// https://url.spec.whatwg.org/#percent-encode
	function percentEncode(c) {
	  let hex = c.toString(16).toUpperCase();
	  if (hex.length === 1) {
	    hex = `0${hex}`;
	  }

	  return `%${hex}`;
	}

	// https://url.spec.whatwg.org/#percent-decode
	function percentDecodeBytes(input) {
	  const output = new Uint8Array(input.byteLength);
	  let outputIndex = 0;
	  for (let i = 0; i < input.byteLength; ++i) {
	    const byte = input[i];
	    if (byte !== 0x25) {
	      output[outputIndex++] = byte;
	    } else if (byte === 0x25 && (!isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2]))) {
	      output[outputIndex++] = byte;
	    } else {
	      const bytePoint = parseInt(String.fromCodePoint(input[i + 1], input[i + 2]), 16);
	      output[outputIndex++] = bytePoint;
	      i += 2;
	    }
	  }

	  return output.slice(0, outputIndex);
	}

	// https://url.spec.whatwg.org/#string-percent-decode
	function percentDecodeString(input) {
	  const bytes = utf8Encode(input);
	  return percentDecodeBytes(bytes);
	}

	// https://url.spec.whatwg.org/#c0-control-percent-encode-set
	function isC0ControlPercentEncode(c) {
	  return c <= 0x1F || c > 0x7E;
	}

	// https://url.spec.whatwg.org/#fragment-percent-encode-set
	const extraFragmentPercentEncodeSet = new Set([p(" "), p("\""), p("<"), p(">"), p("`")]);
	function isFragmentPercentEncode(c) {
	  return isC0ControlPercentEncode(c) || extraFragmentPercentEncodeSet.has(c);
	}

	// https://url.spec.whatwg.org/#query-percent-encode-set
	const extraQueryPercentEncodeSet = new Set([p(" "), p("\""), p("#"), p("<"), p(">")]);
	function isQueryPercentEncode(c) {
	  return isC0ControlPercentEncode(c) || extraQueryPercentEncodeSet.has(c);
	}

	// https://url.spec.whatwg.org/#special-query-percent-encode-set
	function isSpecialQueryPercentEncode(c) {
	  return isQueryPercentEncode(c) || c === p("'");
	}

	// https://url.spec.whatwg.org/#path-percent-encode-set
	const extraPathPercentEncodeSet = new Set([p("?"), p("`"), p("{"), p("}")]);
	function isPathPercentEncode(c) {
	  return isQueryPercentEncode(c) || extraPathPercentEncodeSet.has(c);
	}

	// https://url.spec.whatwg.org/#userinfo-percent-encode-set
	const extraUserinfoPercentEncodeSet =
	  new Set([p("/"), p(":"), p(";"), p("="), p("@"), p("["), p("\\"), p("]"), p("^"), p("|")]);
	function isUserinfoPercentEncode(c) {
	  return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
	}

	// https://url.spec.whatwg.org/#component-percent-encode-set
	const extraComponentPercentEncodeSet = new Set([p("$"), p("%"), p("&"), p("+"), p(",")]);
	function isComponentPercentEncode(c) {
	  return isUserinfoPercentEncode(c) || extraComponentPercentEncodeSet.has(c);
	}

	// https://url.spec.whatwg.org/#application-x-www-form-urlencoded-percent-encode-set
	const extraURLEncodedPercentEncodeSet = new Set([p("!"), p("'"), p("("), p(")"), p("~")]);
	function isURLEncodedPercentEncode(c) {
	  return isComponentPercentEncode(c) || extraURLEncodedPercentEncodeSet.has(c);
	}

	// https://url.spec.whatwg.org/#code-point-percent-encode-after-encoding
	// https://url.spec.whatwg.org/#utf-8-percent-encode
	// Assuming encoding is always utf-8 allows us to trim one of the logic branches. TODO: support encoding.
	// The "-Internal" variant here has code points as JS strings. The external version used by other files has code points
	// as JS numbers, like the rest of the codebase.
	function utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate) {
	  const bytes = utf8Encode(codePoint);
	  let output = "";
	  for (const byte of bytes) {
	    // Our percentEncodePredicate operates on bytes, not code points, so this is slightly different from the spec.
	    if (!percentEncodePredicate(byte)) {
	      output += String.fromCharCode(byte);
	    } else {
	      output += percentEncode(byte);
	    }
	  }

	  return output;
	}

	function utf8PercentEncodeCodePoint(codePoint, percentEncodePredicate) {
	  return utf8PercentEncodeCodePointInternal(String.fromCodePoint(codePoint), percentEncodePredicate);
	}

	// https://url.spec.whatwg.org/#string-percent-encode-after-encoding
	// https://url.spec.whatwg.org/#string-utf-8-percent-encode
	function utf8PercentEncodeString(input, percentEncodePredicate, spaceAsPlus = false) {
	  let output = "";
	  for (const codePoint of input) {
	    if (spaceAsPlus && codePoint === " ") {
	      output += "+";
	    } else {
	      output += utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate);
	    }
	  }
	  return output;
	}

	percentEncoding = {
	  isC0ControlPercentEncode,
	  isFragmentPercentEncode,
	  isQueryPercentEncode,
	  isSpecialQueryPercentEncode,
	  isPathPercentEncode,
	  isUserinfoPercentEncode,
	  isURLEncodedPercentEncode,
	  percentDecodeString,
	  percentDecodeBytes,
	  utf8PercentEncodeString,
	  utf8PercentEncodeCodePoint
	};
	return percentEncoding;
}

var hasRequiredUrlStateMachine;

function requireUrlStateMachine () {
	if (hasRequiredUrlStateMachine) return urlStateMachine.exports;
	hasRequiredUrlStateMachine = 1;
	(function (module) {
		const tr46 = requireTr46();

		const infra = requireInfra();
		const { utf8DecodeWithoutBOM } = requireEncoding();
		const { percentDecodeString, utf8PercentEncodeCodePoint, utf8PercentEncodeString, isC0ControlPercentEncode,
		  isFragmentPercentEncode, isQueryPercentEncode, isSpecialQueryPercentEncode, isPathPercentEncode,
		  isUserinfoPercentEncode } = requirePercentEncoding();

		function p(char) {
		  return char.codePointAt(0);
		}

		const specialSchemes = {
		  ftp: 21,
		  file: null,
		  http: 80,
		  https: 443,
		  ws: 80,
		  wss: 443
		};

		const failure = Symbol("failure");

		function countSymbols(str) {
		  return [...str].length;
		}

		function at(input, idx) {
		  const c = input[idx];
		  return isNaN(c) ? undefined : String.fromCodePoint(c);
		}

		function isSingleDot(buffer) {
		  return buffer === "." || buffer.toLowerCase() === "%2e";
		}

		function isDoubleDot(buffer) {
		  buffer = buffer.toLowerCase();
		  return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
		}

		function isWindowsDriveLetterCodePoints(cp1, cp2) {
		  return infra.isASCIIAlpha(cp1) && (cp2 === p(":") || cp2 === p("|"));
		}

		function isWindowsDriveLetterString(string) {
		  return string.length === 2 && infra.isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
		}

		function isNormalizedWindowsDriveLetterString(string) {
		  return string.length === 2 && infra.isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
		}

		function containsForbiddenHostCodePoint(string) {
		  return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|<|>|\?|@|\[|\\|\]|\^|\|/u) !== -1;
		}

		function containsForbiddenDomainCodePoint(string) {
		  return containsForbiddenHostCodePoint(string) || string.search(/[\u0000-\u001F]|%|\u007F/u) !== -1;
		}

		function isSpecialScheme(scheme) {
		  return specialSchemes[scheme] !== undefined;
		}

		function isSpecial(url) {
		  return isSpecialScheme(url.scheme);
		}

		function isNotSpecial(url) {
		  return !isSpecialScheme(url.scheme);
		}

		function defaultPort(scheme) {
		  return specialSchemes[scheme];
		}

		function parseIPv4Number(input) {
		  if (input === "") {
		    return failure;
		  }

		  let R = 10;

		  if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
		    input = input.substring(2);
		    R = 16;
		  } else if (input.length >= 2 && input.charAt(0) === "0") {
		    input = input.substring(1);
		    R = 8;
		  }

		  if (input === "") {
		    return 0;
		  }

		  let regex = /[^0-7]/u;
		  if (R === 10) {
		    regex = /[^0-9]/u;
		  }
		  if (R === 16) {
		    regex = /[^0-9A-Fa-f]/u;
		  }

		  if (regex.test(input)) {
		    return failure;
		  }

		  return parseInt(input, R);
		}

		function parseIPv4(input) {
		  const parts = input.split(".");
		  if (parts[parts.length - 1] === "") {
		    if (parts.length > 1) {
		      parts.pop();
		    }
		  }

		  if (parts.length > 4) {
		    return failure;
		  }

		  const numbers = [];
		  for (const part of parts) {
		    const n = parseIPv4Number(part);
		    if (n === failure) {
		      return failure;
		    }

		    numbers.push(n);
		  }

		  for (let i = 0; i < numbers.length - 1; ++i) {
		    if (numbers[i] > 255) {
		      return failure;
		    }
		  }
		  if (numbers[numbers.length - 1] >= 256 ** (5 - numbers.length)) {
		    return failure;
		  }

		  let ipv4 = numbers.pop();
		  let counter = 0;

		  for (const n of numbers) {
		    ipv4 += n * 256 ** (3 - counter);
		    ++counter;
		  }

		  return ipv4;
		}

		function serializeIPv4(address) {
		  let output = "";
		  let n = address;

		  for (let i = 1; i <= 4; ++i) {
		    output = String(n % 256) + output;
		    if (i !== 4) {
		      output = `.${output}`;
		    }
		    n = Math.floor(n / 256);
		  }

		  return output;
		}

		function parseIPv6(input) {
		  const address = [0, 0, 0, 0, 0, 0, 0, 0];
		  let pieceIndex = 0;
		  let compress = null;
		  let pointer = 0;

		  input = Array.from(input, c => c.codePointAt(0));

		  if (input[pointer] === p(":")) {
		    if (input[pointer + 1] !== p(":")) {
		      return failure;
		    }

		    pointer += 2;
		    ++pieceIndex;
		    compress = pieceIndex;
		  }

		  while (pointer < input.length) {
		    if (pieceIndex === 8) {
		      return failure;
		    }

		    if (input[pointer] === p(":")) {
		      if (compress !== null) {
		        return failure;
		      }
		      ++pointer;
		      ++pieceIndex;
		      compress = pieceIndex;
		      continue;
		    }

		    let value = 0;
		    let length = 0;

		    while (length < 4 && infra.isASCIIHex(input[pointer])) {
		      value = value * 0x10 + parseInt(at(input, pointer), 16);
		      ++pointer;
		      ++length;
		    }

		    if (input[pointer] === p(".")) {
		      if (length === 0) {
		        return failure;
		      }

		      pointer -= length;

		      if (pieceIndex > 6) {
		        return failure;
		      }

		      let numbersSeen = 0;

		      while (input[pointer] !== undefined) {
		        let ipv4Piece = null;

		        if (numbersSeen > 0) {
		          if (input[pointer] === p(".") && numbersSeen < 4) {
		            ++pointer;
		          } else {
		            return failure;
		          }
		        }

		        if (!infra.isASCIIDigit(input[pointer])) {
		          return failure;
		        }

		        while (infra.isASCIIDigit(input[pointer])) {
		          const number = parseInt(at(input, pointer));
		          if (ipv4Piece === null) {
		            ipv4Piece = number;
		          } else if (ipv4Piece === 0) {
		            return failure;
		          } else {
		            ipv4Piece = ipv4Piece * 10 + number;
		          }
		          if (ipv4Piece > 255) {
		            return failure;
		          }
		          ++pointer;
		        }

		        address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;

		        ++numbersSeen;

		        if (numbersSeen === 2 || numbersSeen === 4) {
		          ++pieceIndex;
		        }
		      }

		      if (numbersSeen !== 4) {
		        return failure;
		      }

		      break;
		    } else if (input[pointer] === p(":")) {
		      ++pointer;
		      if (input[pointer] === undefined) {
		        return failure;
		      }
		    } else if (input[pointer] !== undefined) {
		      return failure;
		    }

		    address[pieceIndex] = value;
		    ++pieceIndex;
		  }

		  if (compress !== null) {
		    let swaps = pieceIndex - compress;
		    pieceIndex = 7;
		    while (pieceIndex !== 0 && swaps > 0) {
		      const temp = address[compress + swaps - 1];
		      address[compress + swaps - 1] = address[pieceIndex];
		      address[pieceIndex] = temp;
		      --pieceIndex;
		      --swaps;
		    }
		  } else if (compress === null && pieceIndex !== 8) {
		    return failure;
		  }

		  return address;
		}

		function serializeIPv6(address) {
		  let output = "";
		  const compress = findLongestZeroSequence(address);
		  let ignore0 = false;

		  for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
		    if (ignore0 && address[pieceIndex] === 0) {
		      continue;
		    } else if (ignore0) {
		      ignore0 = false;
		    }

		    if (compress === pieceIndex) {
		      const separator = pieceIndex === 0 ? "::" : ":";
		      output += separator;
		      ignore0 = true;
		      continue;
		    }

		    output += address[pieceIndex].toString(16);

		    if (pieceIndex !== 7) {
		      output += ":";
		    }
		  }

		  return output;
		}

		function parseHost(input, isNotSpecialArg = false) {
		  if (input[0] === "[") {
		    if (input[input.length - 1] !== "]") {
		      return failure;
		    }

		    return parseIPv6(input.substring(1, input.length - 1));
		  }

		  if (isNotSpecialArg) {
		    return parseOpaqueHost(input);
		  }

		  const domain = utf8DecodeWithoutBOM(percentDecodeString(input));
		  const asciiDomain = domainToASCII(domain);
		  if (asciiDomain === failure) {
		    return failure;
		  }

		  if (containsForbiddenDomainCodePoint(asciiDomain)) {
		    return failure;
		  }

		  if (endsInANumber(asciiDomain)) {
		    return parseIPv4(asciiDomain);
		  }

		  return asciiDomain;
		}

		function endsInANumber(input) {
		  const parts = input.split(".");
		  if (parts[parts.length - 1] === "") {
		    if (parts.length === 1) {
		      return false;
		    }
		    parts.pop();
		  }

		  const last = parts[parts.length - 1];
		  if (parseIPv4Number(last) !== failure) {
		    return true;
		  }

		  if (/^[0-9]+$/u.test(last)) {
		    return true;
		  }

		  return false;
		}

		function parseOpaqueHost(input) {
		  if (containsForbiddenHostCodePoint(input)) {
		    return failure;
		  }

		  return utf8PercentEncodeString(input, isC0ControlPercentEncode);
		}

		function findLongestZeroSequence(arr) {
		  let maxIdx = null;
		  let maxLen = 1; // only find elements > 1
		  let currStart = null;
		  let currLen = 0;

		  for (let i = 0; i < arr.length; ++i) {
		    if (arr[i] !== 0) {
		      if (currLen > maxLen) {
		        maxIdx = currStart;
		        maxLen = currLen;
		      }

		      currStart = null;
		      currLen = 0;
		    } else {
		      if (currStart === null) {
		        currStart = i;
		      }
		      ++currLen;
		    }
		  }

		  // if trailing zeros
		  if (currLen > maxLen) {
		    return currStart;
		  }

		  return maxIdx;
		}

		function serializeHost(host) {
		  if (typeof host === "number") {
		    return serializeIPv4(host);
		  }

		  // IPv6 serializer
		  if (host instanceof Array) {
		    return `[${serializeIPv6(host)}]`;
		  }

		  return host;
		}

		function domainToASCII(domain, beStrict = false) {
		  const result = tr46.toASCII(domain, {
		    checkBidi: true,
		    checkHyphens: false,
		    checkJoiners: true,
		    useSTD3ASCIIRules: beStrict,
		    verifyDNSLength: beStrict
		  });
		  if (result === null || result === "") {
		    return failure;
		  }
		  return result;
		}

		function trimControlChars(url) {
		  return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/ug, "");
		}

		function trimTabAndNewline(url) {
		  return url.replace(/\u0009|\u000A|\u000D/ug, "");
		}

		function shortenPath(url) {
		  const { path } = url;
		  if (path.length === 0) {
		    return;
		  }
		  if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
		    return;
		  }

		  path.pop();
		}

		function includesCredentials(url) {
		  return url.username !== "" || url.password !== "";
		}

		function cannotHaveAUsernamePasswordPort(url) {
		  return url.host === null || url.host === "" || url.scheme === "file";
		}

		function hasAnOpaquePath(url) {
		  return typeof url.path === "string";
		}

		function isNormalizedWindowsDriveLetter(string) {
		  return /^[A-Za-z]:$/u.test(string);
		}

		function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
		  this.pointer = 0;
		  this.input = input;
		  this.base = base || null;
		  this.encodingOverride = encodingOverride || "utf-8";
		  this.stateOverride = stateOverride;
		  this.url = url;
		  this.failure = false;
		  this.parseError = false;

		  if (!this.url) {
		    this.url = {
		      scheme: "",
		      username: "",
		      password: "",
		      host: null,
		      port: null,
		      path: [],
		      query: null,
		      fragment: null
		    };

		    const res = trimControlChars(this.input);
		    if (res !== this.input) {
		      this.parseError = true;
		    }
		    this.input = res;
		  }

		  const res = trimTabAndNewline(this.input);
		  if (res !== this.input) {
		    this.parseError = true;
		  }
		  this.input = res;

		  this.state = stateOverride || "scheme start";

		  this.buffer = "";
		  this.atFlag = false;
		  this.arrFlag = false;
		  this.passwordTokenSeenFlag = false;

		  this.input = Array.from(this.input, c => c.codePointAt(0));

		  for (; this.pointer <= this.input.length; ++this.pointer) {
		    const c = this.input[this.pointer];
		    const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);

		    // exec state machine
		    const ret = this[`parse ${this.state}`](c, cStr);
		    if (!ret) {
		      break; // terminate algorithm
		    } else if (ret === failure) {
		      this.failure = true;
		      break;
		    }
		  }
		}

		URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
		  if (infra.isASCIIAlpha(c)) {
		    this.buffer += cStr.toLowerCase();
		    this.state = "scheme";
		  } else if (!this.stateOverride) {
		    this.state = "no scheme";
		    --this.pointer;
		  } else {
		    this.parseError = true;
		    return failure;
		  }

		  return true;
		};

		URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
		  if (infra.isASCIIAlphanumeric(c) || c === p("+") || c === p("-") || c === p(".")) {
		    this.buffer += cStr.toLowerCase();
		  } else if (c === p(":")) {
		    if (this.stateOverride) {
		      if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
		        return false;
		      }

		      if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
		        return false;
		      }

		      if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
		        return false;
		      }

		      if (this.url.scheme === "file" && this.url.host === "") {
		        return false;
		      }
		    }
		    this.url.scheme = this.buffer;
		    if (this.stateOverride) {
		      if (this.url.port === defaultPort(this.url.scheme)) {
		        this.url.port = null;
		      }
		      return false;
		    }
		    this.buffer = "";
		    if (this.url.scheme === "file") {
		      if (this.input[this.pointer + 1] !== p("/") || this.input[this.pointer + 2] !== p("/")) {
		        this.parseError = true;
		      }
		      this.state = "file";
		    } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
		      this.state = "special relative or authority";
		    } else if (isSpecial(this.url)) {
		      this.state = "special authority slashes";
		    } else if (this.input[this.pointer + 1] === p("/")) {
		      this.state = "path or authority";
		      ++this.pointer;
		    } else {
		      this.url.path = "";
		      this.state = "opaque path";
		    }
		  } else if (!this.stateOverride) {
		    this.buffer = "";
		    this.state = "no scheme";
		    this.pointer = -1;
		  } else {
		    this.parseError = true;
		    return failure;
		  }

		  return true;
		};

		URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
		  if (this.base === null || (hasAnOpaquePath(this.base) && c !== p("#"))) {
		    return failure;
		  } else if (hasAnOpaquePath(this.base) && c === p("#")) {
		    this.url.scheme = this.base.scheme;
		    this.url.path = this.base.path;
		    this.url.query = this.base.query;
		    this.url.fragment = "";
		    this.state = "fragment";
		  } else if (this.base.scheme === "file") {
		    this.state = "file";
		    --this.pointer;
		  } else {
		    this.state = "relative";
		    --this.pointer;
		  }

		  return true;
		};

		URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
		  if (c === p("/") && this.input[this.pointer + 1] === p("/")) {
		    this.state = "special authority ignore slashes";
		    ++this.pointer;
		  } else {
		    this.parseError = true;
		    this.state = "relative";
		    --this.pointer;
		  }

		  return true;
		};

		URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
		  if (c === p("/")) {
		    this.state = "authority";
		  } else {
		    this.state = "path";
		    --this.pointer;
		  }

		  return true;
		};

		URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
		  this.url.scheme = this.base.scheme;
		  if (c === p("/")) {
		    this.state = "relative slash";
		  } else if (isSpecial(this.url) && c === p("\\")) {
		    this.parseError = true;
		    this.state = "relative slash";
		  } else {
		    this.url.username = this.base.username;
		    this.url.password = this.base.password;
		    this.url.host = this.base.host;
		    this.url.port = this.base.port;
		    this.url.path = this.base.path.slice();
		    this.url.query = this.base.query;
		    if (c === p("?")) {
		      this.url.query = "";
		      this.state = "query";
		    } else if (c === p("#")) {
		      this.url.fragment = "";
		      this.state = "fragment";
		    } else if (!isNaN(c)) {
		      this.url.query = null;
		      this.url.path.pop();
		      this.state = "path";
		      --this.pointer;
		    }
		  }

		  return true;
		};

		URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
		  if (isSpecial(this.url) && (c === p("/") || c === p("\\"))) {
		    if (c === p("\\")) {
		      this.parseError = true;
		    }
		    this.state = "special authority ignore slashes";
		  } else if (c === p("/")) {
		    this.state = "authority";
		  } else {
		    this.url.username = this.base.username;
		    this.url.password = this.base.password;
		    this.url.host = this.base.host;
		    this.url.port = this.base.port;
		    this.state = "path";
		    --this.pointer;
		  }

		  return true;
		};

		URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
		  if (c === p("/") && this.input[this.pointer + 1] === p("/")) {
		    this.state = "special authority ignore slashes";
		    ++this.pointer;
		  } else {
		    this.parseError = true;
		    this.state = "special authority ignore slashes";
		    --this.pointer;
		  }

		  return true;
		};

		URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
		  if (c !== p("/") && c !== p("\\")) {
		    this.state = "authority";
		    --this.pointer;
		  } else {
		    this.parseError = true;
		  }

		  return true;
		};

		URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
		  if (c === p("@")) {
		    this.parseError = true;
		    if (this.atFlag) {
		      this.buffer = `%40${this.buffer}`;
		    }
		    this.atFlag = true;

		    // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars
		    const len = countSymbols(this.buffer);
		    for (let pointer = 0; pointer < len; ++pointer) {
		      const codePoint = this.buffer.codePointAt(pointer);

		      if (codePoint === p(":") && !this.passwordTokenSeenFlag) {
		        this.passwordTokenSeenFlag = true;
		        continue;
		      }
		      const encodedCodePoints = utf8PercentEncodeCodePoint(codePoint, isUserinfoPercentEncode);
		      if (this.passwordTokenSeenFlag) {
		        this.url.password += encodedCodePoints;
		      } else {
		        this.url.username += encodedCodePoints;
		      }
		    }
		    this.buffer = "";
		  } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") ||
		             (isSpecial(this.url) && c === p("\\"))) {
		    if (this.atFlag && this.buffer === "") {
		      this.parseError = true;
		      return failure;
		    }
		    this.pointer -= countSymbols(this.buffer) + 1;
		    this.buffer = "";
		    this.state = "host";
		  } else {
		    this.buffer += cStr;
		  }

		  return true;
		};

		URLStateMachine.prototype["parse hostname"] =
		URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
		  if (this.stateOverride && this.url.scheme === "file") {
		    --this.pointer;
		    this.state = "file host";
		  } else if (c === p(":") && !this.arrFlag) {
		    if (this.buffer === "") {
		      this.parseError = true;
		      return failure;
		    }

		    if (this.stateOverride === "hostname") {
		      return false;
		    }

		    const host = parseHost(this.buffer, isNotSpecial(this.url));
		    if (host === failure) {
		      return failure;
		    }

		    this.url.host = host;
		    this.buffer = "";
		    this.state = "port";
		  } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") ||
		             (isSpecial(this.url) && c === p("\\"))) {
		    --this.pointer;
		    if (isSpecial(this.url) && this.buffer === "") {
		      this.parseError = true;
		      return failure;
		    } else if (this.stateOverride && this.buffer === "" &&
		               (includesCredentials(this.url) || this.url.port !== null)) {
		      this.parseError = true;
		      return false;
		    }

		    const host = parseHost(this.buffer, isNotSpecial(this.url));
		    if (host === failure) {
		      return failure;
		    }

		    this.url.host = host;
		    this.buffer = "";
		    this.state = "path start";
		    if (this.stateOverride) {
		      return false;
		    }
		  } else {
		    if (c === p("[")) {
		      this.arrFlag = true;
		    } else if (c === p("]")) {
		      this.arrFlag = false;
		    }
		    this.buffer += cStr;
		  }

		  return true;
		};

		URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
		  if (infra.isASCIIDigit(c)) {
		    this.buffer += cStr;
		  } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") ||
		             (isSpecial(this.url) && c === p("\\")) ||
		             this.stateOverride) {
		    if (this.buffer !== "") {
		      const port = parseInt(this.buffer);
		      if (port > 2 ** 16 - 1) {
		        this.parseError = true;
		        return failure;
		      }
		      this.url.port = port === defaultPort(this.url.scheme) ? null : port;
		      this.buffer = "";
		    }
		    if (this.stateOverride) {
		      return false;
		    }
		    this.state = "path start";
		    --this.pointer;
		  } else {
		    this.parseError = true;
		    return failure;
		  }

		  return true;
		};

		const fileOtherwiseCodePoints = new Set([p("/"), p("\\"), p("?"), p("#")]);

		function startsWithWindowsDriveLetter(input, pointer) {
		  const length = input.length - pointer;
		  return length >= 2 &&
		    isWindowsDriveLetterCodePoints(input[pointer], input[pointer + 1]) &&
		    (length === 2 || fileOtherwiseCodePoints.has(input[pointer + 2]));
		}

		URLStateMachine.prototype["parse file"] = function parseFile(c) {
		  this.url.scheme = "file";
		  this.url.host = "";

		  if (c === p("/") || c === p("\\")) {
		    if (c === p("\\")) {
		      this.parseError = true;
		    }
		    this.state = "file slash";
		  } else if (this.base !== null && this.base.scheme === "file") {
		    this.url.host = this.base.host;
		    this.url.path = this.base.path.slice();
		    this.url.query = this.base.query;
		    if (c === p("?")) {
		      this.url.query = "";
		      this.state = "query";
		    } else if (c === p("#")) {
		      this.url.fragment = "";
		      this.state = "fragment";
		    } else if (!isNaN(c)) {
		      this.url.query = null;
		      if (!startsWithWindowsDriveLetter(this.input, this.pointer)) {
		        shortenPath(this.url);
		      } else {
		        this.parseError = true;
		        this.url.path = [];
		      }

		      this.state = "path";
		      --this.pointer;
		    }
		  } else {
		    this.state = "path";
		    --this.pointer;
		  }

		  return true;
		};

		URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
		  if (c === p("/") || c === p("\\")) {
		    if (c === p("\\")) {
		      this.parseError = true;
		    }
		    this.state = "file host";
		  } else {
		    if (this.base !== null && this.base.scheme === "file") {
		      if (!startsWithWindowsDriveLetter(this.input, this.pointer) &&
		          isNormalizedWindowsDriveLetterString(this.base.path[0])) {
		        this.url.path.push(this.base.path[0]);
		      }
		      this.url.host = this.base.host;
		    }
		    this.state = "path";
		    --this.pointer;
		  }

		  return true;
		};

		URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
		  if (isNaN(c) || c === p("/") || c === p("\\") || c === p("?") || c === p("#")) {
		    --this.pointer;
		    if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
		      this.parseError = true;
		      this.state = "path";
		    } else if (this.buffer === "") {
		      this.url.host = "";
		      if (this.stateOverride) {
		        return false;
		      }
		      this.state = "path start";
		    } else {
		      let host = parseHost(this.buffer, isNotSpecial(this.url));
		      if (host === failure) {
		        return failure;
		      }
		      if (host === "localhost") {
		        host = "";
		      }
		      this.url.host = host;

		      if (this.stateOverride) {
		        return false;
		      }

		      this.buffer = "";
		      this.state = "path start";
		    }
		  } else {
		    this.buffer += cStr;
		  }

		  return true;
		};

		URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
		  if (isSpecial(this.url)) {
		    if (c === p("\\")) {
		      this.parseError = true;
		    }
		    this.state = "path";

		    if (c !== p("/") && c !== p("\\")) {
		      --this.pointer;
		    }
		  } else if (!this.stateOverride && c === p("?")) {
		    this.url.query = "";
		    this.state = "query";
		  } else if (!this.stateOverride && c === p("#")) {
		    this.url.fragment = "";
		    this.state = "fragment";
		  } else if (c !== undefined) {
		    this.state = "path";
		    if (c !== p("/")) {
		      --this.pointer;
		    }
		  } else if (this.stateOverride && this.url.host === null) {
		    this.url.path.push("");
		  }

		  return true;
		};

		URLStateMachine.prototype["parse path"] = function parsePath(c) {
		  if (isNaN(c) || c === p("/") || (isSpecial(this.url) && c === p("\\")) ||
		      (!this.stateOverride && (c === p("?") || c === p("#")))) {
		    if (isSpecial(this.url) && c === p("\\")) {
		      this.parseError = true;
		    }

		    if (isDoubleDot(this.buffer)) {
		      shortenPath(this.url);
		      if (c !== p("/") && !(isSpecial(this.url) && c === p("\\"))) {
		        this.url.path.push("");
		      }
		    } else if (isSingleDot(this.buffer) && c !== p("/") &&
		               !(isSpecial(this.url) && c === p("\\"))) {
		      this.url.path.push("");
		    } else if (!isSingleDot(this.buffer)) {
		      if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
		        this.buffer = `${this.buffer[0]}:`;
		      }
		      this.url.path.push(this.buffer);
		    }
		    this.buffer = "";
		    if (c === p("?")) {
		      this.url.query = "";
		      this.state = "query";
		    }
		    if (c === p("#")) {
		      this.url.fragment = "";
		      this.state = "fragment";
		    }
		  } else {
		    // TODO: If c is not a URL code point and not "%", parse error.

		    if (c === p("%") &&
		      (!infra.isASCIIHex(this.input[this.pointer + 1]) ||
		        !infra.isASCIIHex(this.input[this.pointer + 2]))) {
		      this.parseError = true;
		    }

		    this.buffer += utf8PercentEncodeCodePoint(c, isPathPercentEncode);
		  }

		  return true;
		};

		URLStateMachine.prototype["parse opaque path"] = function parseOpaquePath(c) {
		  if (c === p("?")) {
		    this.url.query = "";
		    this.state = "query";
		  } else if (c === p("#")) {
		    this.url.fragment = "";
		    this.state = "fragment";
		  } else {
		    // TODO: Add: not a URL code point
		    if (!isNaN(c) && c !== p("%")) {
		      this.parseError = true;
		    }

		    if (c === p("%") &&
		        (!infra.isASCIIHex(this.input[this.pointer + 1]) ||
		         !infra.isASCIIHex(this.input[this.pointer + 2]))) {
		      this.parseError = true;
		    }

		    if (!isNaN(c)) {
		      this.url.path += utf8PercentEncodeCodePoint(c, isC0ControlPercentEncode);
		    }
		  }

		  return true;
		};

		URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
		  if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
		    this.encodingOverride = "utf-8";
		  }

		  if ((!this.stateOverride && c === p("#")) || isNaN(c)) {
		    const queryPercentEncodePredicate = isSpecial(this.url) ? isSpecialQueryPercentEncode : isQueryPercentEncode;
		    this.url.query += utf8PercentEncodeString(this.buffer, queryPercentEncodePredicate);

		    this.buffer = "";

		    if (c === p("#")) {
		      this.url.fragment = "";
		      this.state = "fragment";
		    }
		  } else if (!isNaN(c)) {
		    // TODO: If c is not a URL code point and not "%", parse error.

		    if (c === p("%") &&
		      (!infra.isASCIIHex(this.input[this.pointer + 1]) ||
		        !infra.isASCIIHex(this.input[this.pointer + 2]))) {
		      this.parseError = true;
		    }

		    this.buffer += cStr;
		  }

		  return true;
		};

		URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
		  if (!isNaN(c)) {
		    // TODO: If c is not a URL code point and not "%", parse error.
		    if (c === p("%") &&
		      (!infra.isASCIIHex(this.input[this.pointer + 1]) ||
		        !infra.isASCIIHex(this.input[this.pointer + 2]))) {
		      this.parseError = true;
		    }

		    this.url.fragment += utf8PercentEncodeCodePoint(c, isFragmentPercentEncode);
		  }

		  return true;
		};

		function serializeURL(url, excludeFragment) {
		  let output = `${url.scheme}:`;
		  if (url.host !== null) {
		    output += "//";

		    if (url.username !== "" || url.password !== "") {
		      output += url.username;
		      if (url.password !== "") {
		        output += `:${url.password}`;
		      }
		      output += "@";
		    }

		    output += serializeHost(url.host);

		    if (url.port !== null) {
		      output += `:${url.port}`;
		    }
		  }

		  if (url.host === null && !hasAnOpaquePath(url) && url.path.length > 1 && url.path[0] === "") {
		    output += "/.";
		  }
		  output += serializePath(url);

		  if (url.query !== null) {
		    output += `?${url.query}`;
		  }

		  if (!excludeFragment && url.fragment !== null) {
		    output += `#${url.fragment}`;
		  }

		  return output;
		}

		function serializeOrigin(tuple) {
		  let result = `${tuple.scheme}://`;
		  result += serializeHost(tuple.host);

		  if (tuple.port !== null) {
		    result += `:${tuple.port}`;
		  }

		  return result;
		}

		function serializePath(url) {
		  if (hasAnOpaquePath(url)) {
		    return url.path;
		  }

		  let output = "";
		  for (const segment of url.path) {
		    output += `/${segment}`;
		  }
		  return output;
		}

		module.exports.serializeURL = serializeURL;

		module.exports.serializePath = serializePath;

		module.exports.serializeURLOrigin = function (url) {
		  // https://url.spec.whatwg.org/#concept-url-origin
		  switch (url.scheme) {
		    case "blob": {
		      const pathURL = module.exports.parseURL(serializePath(url));
		      if (pathURL === null) {
		        return "null";
		      }
		      if (pathURL.scheme !== "http" && pathURL.scheme !== "https") {
		        return "null";
		      }
		      return module.exports.serializeURLOrigin(pathURL);
		    }
		    case "ftp":
		    case "http":
		    case "https":
		    case "ws":
		    case "wss":
		      return serializeOrigin({
		        scheme: url.scheme,
		        host: url.host,
		        port: url.port
		      });
		    case "file":
		      // The spec says:
		      // > Unfortunate as it is, this is left as an exercise to the reader. When in doubt, return a new opaque origin.
		      // Browsers tested so far:
		      // - Chrome says "file://", but treats file: URLs as cross-origin for most (all?) purposes; see e.g.
		      //   https://bugs.chromium.org/p/chromium/issues/detail?id=37586
		      // - Firefox says "null", but treats file: URLs as same-origin sometimes based on directory stuff; see
		      //   https://developer.mozilla.org/en-US/docs/Archive/Misc_top_level/Same-origin_policy_for_file:_URIs
		      return "null";
		    default:
		      // serializing an opaque origin returns "null"
		      return "null";
		  }
		};

		module.exports.basicURLParse = function (input, options) {
		  if (options === undefined) {
		    options = {};
		  }

		  const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
		  if (usm.failure) {
		    return null;
		  }

		  return usm.url;
		};

		module.exports.setTheUsername = function (url, username) {
		  url.username = utf8PercentEncodeString(username, isUserinfoPercentEncode);
		};

		module.exports.setThePassword = function (url, password) {
		  url.password = utf8PercentEncodeString(password, isUserinfoPercentEncode);
		};

		module.exports.serializeHost = serializeHost;

		module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;

		module.exports.hasAnOpaquePath = hasAnOpaquePath;

		module.exports.serializeInteger = function (integer) {
		  return String(integer);
		};

		module.exports.parseURL = function (input, options) {
		  if (options === undefined) {
		    options = {};
		  }

		  // We don't handle blobs, so this just delegates:
		  return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
		}; 
	} (urlStateMachine));
	return urlStateMachine.exports;
}

var urlencoded;
var hasRequiredUrlencoded;

function requireUrlencoded () {
	if (hasRequiredUrlencoded) return urlencoded;
	hasRequiredUrlencoded = 1;
	const { utf8Encode, utf8DecodeWithoutBOM } = requireEncoding();
	const { percentDecodeBytes, utf8PercentEncodeString, isURLEncodedPercentEncode } = requirePercentEncoding();

	function p(char) {
	  return char.codePointAt(0);
	}

	// https://url.spec.whatwg.org/#concept-urlencoded-parser
	function parseUrlencoded(input) {
	  const sequences = strictlySplitByteSequence(input, p("&"));
	  const output = [];
	  for (const bytes of sequences) {
	    if (bytes.length === 0) {
	      continue;
	    }

	    let name, value;
	    const indexOfEqual = bytes.indexOf(p("="));

	    if (indexOfEqual >= 0) {
	      name = bytes.slice(0, indexOfEqual);
	      value = bytes.slice(indexOfEqual + 1);
	    } else {
	      name = bytes;
	      value = new Uint8Array(0);
	    }

	    name = replaceByteInByteSequence(name, 0x2B, 0x20);
	    value = replaceByteInByteSequence(value, 0x2B, 0x20);

	    const nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));
	    const valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));

	    output.push([nameString, valueString]);
	  }
	  return output;
	}

	// https://url.spec.whatwg.org/#concept-urlencoded-string-parser
	function parseUrlencodedString(input) {
	  return parseUrlencoded(utf8Encode(input));
	}

	// https://url.spec.whatwg.org/#concept-urlencoded-serializer
	function serializeUrlencoded(tuples, encodingOverride = undefined) {
	  let encoding = "utf-8";
	  if (encodingOverride !== undefined) {
	    // TODO "get the output encoding", i.e. handle encoding labels vs. names.
	    encoding = encodingOverride;
	  }

	  let output = "";
	  for (const [i, tuple] of tuples.entries()) {
	    // TODO: handle encoding override

	    const name = utf8PercentEncodeString(tuple[0], isURLEncodedPercentEncode, true);

	    let value = tuple[1];
	    if (tuple.length > 2 && tuple[2] !== undefined) {
	      if (tuple[2] === "hidden" && name === "_charset_") {
	        value = encoding;
	      } else if (tuple[2] === "file") {
	        // value is a File object
	        value = value.name;
	      }
	    }

	    value = utf8PercentEncodeString(value, isURLEncodedPercentEncode, true);

	    if (i !== 0) {
	      output += "&";
	    }
	    output += `${name}=${value}`;
	  }
	  return output;
	}

	function strictlySplitByteSequence(buf, cp) {
	  const list = [];
	  let last = 0;
	  let i = buf.indexOf(cp);
	  while (i >= 0) {
	    list.push(buf.slice(last, i));
	    last = i + 1;
	    i = buf.indexOf(cp, last);
	  }
	  if (last !== buf.length) {
	    list.push(buf.slice(last));
	  }
	  return list;
	}

	function replaceByteInByteSequence(buf, from, to) {
	  let i = buf.indexOf(from);
	  while (i >= 0) {
	    buf[i] = to;
	    i = buf.indexOf(from, i + 1);
	  }
	  return buf;
	}

	urlencoded = {
	  parseUrlencodedString,
	  serializeUrlencoded
	};
	return urlencoded;
}

var URLSearchParams = {};

var _Function = {};

var hasRequired_Function;

function require_Function () {
	if (hasRequired_Function) return _Function;
	hasRequired_Function = 1;

	const conversions = requireLib$2();
	const utils = requireUtils();

	_Function.convert = (globalObject, value, { context = "The provided value" } = {}) => {
	  if (typeof value !== "function") {
	    throw new globalObject.TypeError(context + " is not a function");
	  }

	  function invokeTheCallbackFunction(...args) {
	    const thisArg = utils.tryWrapperForImpl(this);
	    let callResult;

	    for (let i = 0; i < args.length; i++) {
	      args[i] = utils.tryWrapperForImpl(args[i]);
	    }

	    callResult = Reflect.apply(value, thisArg, args);

	    callResult = conversions["any"](callResult, { context: context, globals: globalObject });

	    return callResult;
	  }

	  invokeTheCallbackFunction.construct = (...args) => {
	    for (let i = 0; i < args.length; i++) {
	      args[i] = utils.tryWrapperForImpl(args[i]);
	    }

	    let callResult = Reflect.construct(value, args);

	    callResult = conversions["any"](callResult, { context: context, globals: globalObject });

	    return callResult;
	  };

	  invokeTheCallbackFunction[utils.wrapperSymbol] = value;
	  invokeTheCallbackFunction.objectReference = value;

	  return invokeTheCallbackFunction;
	};
	return _Function;
}

var URLSearchParamsImpl = {};

var hasRequiredURLSearchParamsImpl;

function requireURLSearchParamsImpl () {
	if (hasRequiredURLSearchParamsImpl) return URLSearchParamsImpl;
	hasRequiredURLSearchParamsImpl = 1;
	const urlencoded = requireUrlencoded();

	URLSearchParamsImpl.implementation = class URLSearchParamsImpl {
	  constructor(globalObject, constructorArgs, { doNotStripQMark = false }) {
	    let init = constructorArgs[0];
	    this._list = [];
	    this._url = null;

	    if (!doNotStripQMark && typeof init === "string" && init[0] === "?") {
	      init = init.slice(1);
	    }

	    if (Array.isArray(init)) {
	      for (const pair of init) {
	        if (pair.length !== 2) {
	          throw new TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence's element does not " +
	                              "contain exactly two elements.");
	        }
	        this._list.push([pair[0], pair[1]]);
	      }
	    } else if (typeof init === "object" && Object.getPrototypeOf(init) === null) {
	      for (const name of Object.keys(init)) {
	        const value = init[name];
	        this._list.push([name, value]);
	      }
	    } else {
	      this._list = urlencoded.parseUrlencodedString(init);
	    }
	  }

	  _updateSteps() {
	    if (this._url !== null) {
	      let serializedQuery = urlencoded.serializeUrlencoded(this._list);
	      if (serializedQuery === "") {
	        serializedQuery = null;
	      }

	      this._url._url.query = serializedQuery;

	      if (serializedQuery === null) {
	        this._url._potentiallyStripTrailingSpacesFromAnOpaquePath();
	      }
	    }
	  }

	  get size() {
	    return this._list.length;
	  }

	  append(name, value) {
	    this._list.push([name, value]);
	    this._updateSteps();
	  }

	  delete(name, value) {
	    let i = 0;
	    while (i < this._list.length) {
	      if (this._list[i][0] === name && (value === undefined || this._list[i][1] === value)) {
	        this._list.splice(i, 1);
	      } else {
	        i++;
	      }
	    }
	    this._updateSteps();
	  }

	  get(name) {
	    for (const tuple of this._list) {
	      if (tuple[0] === name) {
	        return tuple[1];
	      }
	    }
	    return null;
	  }

	  getAll(name) {
	    const output = [];
	    for (const tuple of this._list) {
	      if (tuple[0] === name) {
	        output.push(tuple[1]);
	      }
	    }
	    return output;
	  }

	  has(name, value) {
	    for (const tuple of this._list) {
	      if (tuple[0] === name && (value === undefined || tuple[1] === value)) {
	        return true;
	      }
	    }
	    return false;
	  }

	  set(name, value) {
	    let found = false;
	    let i = 0;
	    while (i < this._list.length) {
	      if (this._list[i][0] === name) {
	        if (found) {
	          this._list.splice(i, 1);
	        } else {
	          found = true;
	          this._list[i][1] = value;
	          i++;
	        }
	      } else {
	        i++;
	      }
	    }
	    if (!found) {
	      this._list.push([name, value]);
	    }
	    this._updateSteps();
	  }

	  sort() {
	    this._list.sort((a, b) => {
	      if (a[0] < b[0]) {
	        return -1;
	      }
	      if (a[0] > b[0]) {
	        return 1;
	      }
	      return 0;
	    });

	    this._updateSteps();
	  }

	  [Symbol.iterator]() {
	    return this._list[Symbol.iterator]();
	  }

	  toString() {
	    return urlencoded.serializeUrlencoded(this._list);
	  }
	};
	return URLSearchParamsImpl;
}

var hasRequiredURLSearchParams;

function requireURLSearchParams () {
	if (hasRequiredURLSearchParams) return URLSearchParams;
	hasRequiredURLSearchParams = 1;
	(function (exports) {

		const conversions = requireLib$2();
		const utils = requireUtils();

		const Function = require_Function();
		const newObjectInRealm = utils.newObjectInRealm;
		const implSymbol = utils.implSymbol;
		const ctorRegistrySymbol = utils.ctorRegistrySymbol;

		const interfaceName = "URLSearchParams";

		exports.is = value => {
		  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
		};
		exports.isImpl = value => {
		  return utils.isObject(value) && value instanceof Impl.implementation;
		};
		exports.convert = (globalObject, value, { context = "The provided value" } = {}) => {
		  if (exports.is(value)) {
		    return utils.implForWrapper(value);
		  }
		  throw new globalObject.TypeError(`${context} is not of type 'URLSearchParams'.`);
		};

		exports.createDefaultIterator = (globalObject, target, kind) => {
		  const ctorRegistry = globalObject[ctorRegistrySymbol];
		  const iteratorPrototype = ctorRegistry["URLSearchParams Iterator"];
		  const iterator = Object.create(iteratorPrototype);
		  Object.defineProperty(iterator, utils.iterInternalSymbol, {
		    value: { target, kind, index: 0 },
		    configurable: true
		  });
		  return iterator;
		};

		function makeWrapper(globalObject, newTarget) {
		  let proto;
		  if (newTarget !== undefined) {
		    proto = newTarget.prototype;
		  }

		  if (!utils.isObject(proto)) {
		    proto = globalObject[ctorRegistrySymbol]["URLSearchParams"].prototype;
		  }

		  return Object.create(proto);
		}

		exports.create = (globalObject, constructorArgs, privateData) => {
		  const wrapper = makeWrapper(globalObject);
		  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
		};

		exports.createImpl = (globalObject, constructorArgs, privateData) => {
		  const wrapper = exports.create(globalObject, constructorArgs, privateData);
		  return utils.implForWrapper(wrapper);
		};

		exports._internalSetup = (wrapper, globalObject) => {};

		exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
		  privateData.wrapper = wrapper;

		  exports._internalSetup(wrapper, globalObject);
		  Object.defineProperty(wrapper, implSymbol, {
		    value: new Impl.implementation(globalObject, constructorArgs, privateData),
		    configurable: true
		  });

		  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
		  if (Impl.init) {
		    Impl.init(wrapper[implSymbol]);
		  }
		  return wrapper;
		};

		exports.new = (globalObject, newTarget) => {
		  const wrapper = makeWrapper(globalObject, newTarget);

		  exports._internalSetup(wrapper, globalObject);
		  Object.defineProperty(wrapper, implSymbol, {
		    value: Object.create(Impl.implementation.prototype),
		    configurable: true
		  });

		  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
		  if (Impl.init) {
		    Impl.init(wrapper[implSymbol]);
		  }
		  return wrapper[implSymbol];
		};

		const exposed = new Set(["Window", "Worker"]);

		exports.install = (globalObject, globalNames) => {
		  if (!globalNames.some(globalName => exposed.has(globalName))) {
		    return;
		  }

		  const ctorRegistry = utils.initCtorRegistry(globalObject);
		  class URLSearchParams {
		    constructor() {
		      const args = [];
		      {
		        let curArg = arguments[0];
		        if (curArg !== undefined) {
		          if (utils.isObject(curArg)) {
		            if (curArg[Symbol.iterator] !== undefined) {
		              if (!utils.isObject(curArg)) {
		                throw new globalObject.TypeError(
		                  "Failed to construct 'URLSearchParams': parameter 1" + " sequence" + " is not an iterable object."
		                );
		              } else {
		                const V = [];
		                const tmp = curArg;
		                for (let nextItem of tmp) {
		                  if (!utils.isObject(nextItem)) {
		                    throw new globalObject.TypeError(
		                      "Failed to construct 'URLSearchParams': parameter 1" +
		                        " sequence" +
		                        "'s element" +
		                        " is not an iterable object."
		                    );
		                  } else {
		                    const V = [];
		                    const tmp = nextItem;
		                    for (let nextItem of tmp) {
		                      nextItem = conversions["USVString"](nextItem, {
		                        context:
		                          "Failed to construct 'URLSearchParams': parameter 1" +
		                          " sequence" +
		                          "'s element" +
		                          "'s element",
		                        globals: globalObject
		                      });

		                      V.push(nextItem);
		                    }
		                    nextItem = V;
		                  }

		                  V.push(nextItem);
		                }
		                curArg = V;
		              }
		            } else {
		              if (!utils.isObject(curArg)) {
		                throw new globalObject.TypeError(
		                  "Failed to construct 'URLSearchParams': parameter 1" + " record" + " is not an object."
		                );
		              } else {
		                const result = Object.create(null);
		                for (const key of Reflect.ownKeys(curArg)) {
		                  const desc = Object.getOwnPropertyDescriptor(curArg, key);
		                  if (desc && desc.enumerable) {
		                    let typedKey = key;

		                    typedKey = conversions["USVString"](typedKey, {
		                      context: "Failed to construct 'URLSearchParams': parameter 1" + " record" + "'s key",
		                      globals: globalObject
		                    });

		                    let typedValue = curArg[key];

		                    typedValue = conversions["USVString"](typedValue, {
		                      context: "Failed to construct 'URLSearchParams': parameter 1" + " record" + "'s value",
		                      globals: globalObject
		                    });

		                    result[typedKey] = typedValue;
		                  }
		                }
		                curArg = result;
		              }
		            }
		          } else {
		            curArg = conversions["USVString"](curArg, {
		              context: "Failed to construct 'URLSearchParams': parameter 1",
		              globals: globalObject
		            });
		          }
		        } else {
		          curArg = "";
		        }
		        args.push(curArg);
		      }
		      return exports.setup(Object.create(new.target.prototype), globalObject, args);
		    }

		    append(name, value) {
		      const esValue = this !== null && this !== undefined ? this : globalObject;
		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError(
		          "'append' called on an object that is not a valid instance of URLSearchParams."
		        );
		      }

		      if (arguments.length < 2) {
		        throw new globalObject.TypeError(
		          `Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`
		        );
		      }
		      const args = [];
		      {
		        let curArg = arguments[0];
		        curArg = conversions["USVString"](curArg, {
		          context: "Failed to execute 'append' on 'URLSearchParams': parameter 1",
		          globals: globalObject
		        });
		        args.push(curArg);
		      }
		      {
		        let curArg = arguments[1];
		        curArg = conversions["USVString"](curArg, {
		          context: "Failed to execute 'append' on 'URLSearchParams': parameter 2",
		          globals: globalObject
		        });
		        args.push(curArg);
		      }
		      return utils.tryWrapperForImpl(esValue[implSymbol].append(...args));
		    }

		    delete(name) {
		      const esValue = this !== null && this !== undefined ? this : globalObject;
		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError(
		          "'delete' called on an object that is not a valid instance of URLSearchParams."
		        );
		      }

		      if (arguments.length < 1) {
		        throw new globalObject.TypeError(
		          `Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
		        );
		      }
		      const args = [];
		      {
		        let curArg = arguments[0];
		        curArg = conversions["USVString"](curArg, {
		          context: "Failed to execute 'delete' on 'URLSearchParams': parameter 1",
		          globals: globalObject
		        });
		        args.push(curArg);
		      }
		      {
		        let curArg = arguments[1];
		        if (curArg !== undefined) {
		          curArg = conversions["USVString"](curArg, {
		            context: "Failed to execute 'delete' on 'URLSearchParams': parameter 2",
		            globals: globalObject
		          });
		        }
		        args.push(curArg);
		      }
		      return utils.tryWrapperForImpl(esValue[implSymbol].delete(...args));
		    }

		    get(name) {
		      const esValue = this !== null && this !== undefined ? this : globalObject;
		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'get' called on an object that is not a valid instance of URLSearchParams.");
		      }

		      if (arguments.length < 1) {
		        throw new globalObject.TypeError(
		          `Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
		        );
		      }
		      const args = [];
		      {
		        let curArg = arguments[0];
		        curArg = conversions["USVString"](curArg, {
		          context: "Failed to execute 'get' on 'URLSearchParams': parameter 1",
		          globals: globalObject
		        });
		        args.push(curArg);
		      }
		      return esValue[implSymbol].get(...args);
		    }

		    getAll(name) {
		      const esValue = this !== null && this !== undefined ? this : globalObject;
		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError(
		          "'getAll' called on an object that is not a valid instance of URLSearchParams."
		        );
		      }

		      if (arguments.length < 1) {
		        throw new globalObject.TypeError(
		          `Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
		        );
		      }
		      const args = [];
		      {
		        let curArg = arguments[0];
		        curArg = conversions["USVString"](curArg, {
		          context: "Failed to execute 'getAll' on 'URLSearchParams': parameter 1",
		          globals: globalObject
		        });
		        args.push(curArg);
		      }
		      return utils.tryWrapperForImpl(esValue[implSymbol].getAll(...args));
		    }

		    has(name) {
		      const esValue = this !== null && this !== undefined ? this : globalObject;
		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'has' called on an object that is not a valid instance of URLSearchParams.");
		      }

		      if (arguments.length < 1) {
		        throw new globalObject.TypeError(
		          `Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
		        );
		      }
		      const args = [];
		      {
		        let curArg = arguments[0];
		        curArg = conversions["USVString"](curArg, {
		          context: "Failed to execute 'has' on 'URLSearchParams': parameter 1",
		          globals: globalObject
		        });
		        args.push(curArg);
		      }
		      {
		        let curArg = arguments[1];
		        if (curArg !== undefined) {
		          curArg = conversions["USVString"](curArg, {
		            context: "Failed to execute 'has' on 'URLSearchParams': parameter 2",
		            globals: globalObject
		          });
		        }
		        args.push(curArg);
		      }
		      return esValue[implSymbol].has(...args);
		    }

		    set(name, value) {
		      const esValue = this !== null && this !== undefined ? this : globalObject;
		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'set' called on an object that is not a valid instance of URLSearchParams.");
		      }

		      if (arguments.length < 2) {
		        throw new globalObject.TypeError(
		          `Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`
		        );
		      }
		      const args = [];
		      {
		        let curArg = arguments[0];
		        curArg = conversions["USVString"](curArg, {
		          context: "Failed to execute 'set' on 'URLSearchParams': parameter 1",
		          globals: globalObject
		        });
		        args.push(curArg);
		      }
		      {
		        let curArg = arguments[1];
		        curArg = conversions["USVString"](curArg, {
		          context: "Failed to execute 'set' on 'URLSearchParams': parameter 2",
		          globals: globalObject
		        });
		        args.push(curArg);
		      }
		      return utils.tryWrapperForImpl(esValue[implSymbol].set(...args));
		    }

		    sort() {
		      const esValue = this !== null && this !== undefined ? this : globalObject;
		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'sort' called on an object that is not a valid instance of URLSearchParams.");
		      }

		      return utils.tryWrapperForImpl(esValue[implSymbol].sort());
		    }

		    toString() {
		      const esValue = this !== null && this !== undefined ? this : globalObject;
		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError(
		          "'toString' called on an object that is not a valid instance of URLSearchParams."
		        );
		      }

		      return esValue[implSymbol].toString();
		    }

		    keys() {
		      if (!exports.is(this)) {
		        throw new globalObject.TypeError("'keys' called on an object that is not a valid instance of URLSearchParams.");
		      }
		      return exports.createDefaultIterator(globalObject, this, "key");
		    }

		    values() {
		      if (!exports.is(this)) {
		        throw new globalObject.TypeError(
		          "'values' called on an object that is not a valid instance of URLSearchParams."
		        );
		      }
		      return exports.createDefaultIterator(globalObject, this, "value");
		    }

		    entries() {
		      if (!exports.is(this)) {
		        throw new globalObject.TypeError(
		          "'entries' called on an object that is not a valid instance of URLSearchParams."
		        );
		      }
		      return exports.createDefaultIterator(globalObject, this, "key+value");
		    }

		    forEach(callback) {
		      if (!exports.is(this)) {
		        throw new globalObject.TypeError(
		          "'forEach' called on an object that is not a valid instance of URLSearchParams."
		        );
		      }
		      if (arguments.length < 1) {
		        throw new globalObject.TypeError(
		          "Failed to execute 'forEach' on 'iterable': 1 argument required, but only 0 present."
		        );
		      }
		      callback = Function.convert(globalObject, callback, {
		        context: "Failed to execute 'forEach' on 'iterable': The callback provided as parameter 1"
		      });
		      const thisArg = arguments[1];
		      let pairs = Array.from(this[implSymbol]);
		      let i = 0;
		      while (i < pairs.length) {
		        const [key, value] = pairs[i].map(utils.tryWrapperForImpl);
		        callback.call(thisArg, value, key, this);
		        pairs = Array.from(this[implSymbol]);
		        i++;
		      }
		    }

		    get size() {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError(
		          "'get size' called on an object that is not a valid instance of URLSearchParams."
		        );
		      }

		      return esValue[implSymbol]["size"];
		    }
		  }
		  Object.defineProperties(URLSearchParams.prototype, {
		    append: { enumerable: true },
		    delete: { enumerable: true },
		    get: { enumerable: true },
		    getAll: { enumerable: true },
		    has: { enumerable: true },
		    set: { enumerable: true },
		    sort: { enumerable: true },
		    toString: { enumerable: true },
		    keys: { enumerable: true },
		    values: { enumerable: true },
		    entries: { enumerable: true },
		    forEach: { enumerable: true },
		    size: { enumerable: true },
		    [Symbol.toStringTag]: { value: "URLSearchParams", configurable: true },
		    [Symbol.iterator]: { value: URLSearchParams.prototype.entries, configurable: true, writable: true }
		  });
		  ctorRegistry[interfaceName] = URLSearchParams;

		  ctorRegistry["URLSearchParams Iterator"] = Object.create(ctorRegistry["%IteratorPrototype%"], {
		    [Symbol.toStringTag]: {
		      configurable: true,
		      value: "URLSearchParams Iterator"
		    }
		  });
		  utils.define(ctorRegistry["URLSearchParams Iterator"], {
		    next() {
		      const internal = this && this[utils.iterInternalSymbol];
		      if (!internal) {
		        throw new globalObject.TypeError("next() called on a value that is not a URLSearchParams iterator object");
		      }

		      const { target, kind, index } = internal;
		      const values = Array.from(target[implSymbol]);
		      const len = values.length;
		      if (index >= len) {
		        return newObjectInRealm(globalObject, { value: undefined, done: true });
		      }

		      const pair = values[index];
		      internal.index = index + 1;
		      return newObjectInRealm(globalObject, utils.iteratorResult(pair.map(utils.tryWrapperForImpl), kind));
		    }
		  });

		  Object.defineProperty(globalObject, interfaceName, {
		    configurable: true,
		    writable: true,
		    value: URLSearchParams
		  });
		};

		const Impl = requireURLSearchParamsImpl(); 
	} (URLSearchParams));
	return URLSearchParams;
}

var hasRequiredURLImpl;

function requireURLImpl () {
	if (hasRequiredURLImpl) return URLImpl;
	hasRequiredURLImpl = 1;
	const usm = requireUrlStateMachine();
	const urlencoded = requireUrlencoded();
	const URLSearchParams = requireURLSearchParams();

	URLImpl.implementation = class URLImpl {
	  // Unlike the spec, we duplicate some code between the constructor and canParse, because we want to give useful error
	  // messages in the constructor that distinguish between the different causes of failure.
	  constructor(globalObject, constructorArgs) {
	    const url = constructorArgs[0];
	    const base = constructorArgs[1];

	    let parsedBase = null;
	    if (base !== undefined) {
	      parsedBase = usm.basicURLParse(base);
	      if (parsedBase === null) {
	        throw new TypeError(`Invalid base URL: ${base}`);
	      }
	    }

	    const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
	    if (parsedURL === null) {
	      throw new TypeError(`Invalid URL: ${url}`);
	    }

	    const query = parsedURL.query !== null ? parsedURL.query : "";

	    this._url = parsedURL;

	    // We cannot invoke the "new URLSearchParams object" algorithm without going through the constructor, which strips
	    // question mark by default. Therefore the doNotStripQMark hack is used.
	    this._query = URLSearchParams.createImpl(globalObject, [query], { doNotStripQMark: true });
	    this._query._url = this;
	  }

	  static canParse(url, base) {
	    let parsedBase = null;
	    if (base !== undefined) {
	      parsedBase = usm.basicURLParse(base);
	      if (parsedBase === null) {
	        return false;
	      }
	    }

	    const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
	    if (parsedURL === null) {
	      return false;
	    }

	    return true;
	  }

	  get href() {
	    return usm.serializeURL(this._url);
	  }

	  set href(v) {
	    const parsedURL = usm.basicURLParse(v);
	    if (parsedURL === null) {
	      throw new TypeError(`Invalid URL: ${v}`);
	    }

	    this._url = parsedURL;

	    this._query._list.splice(0);
	    const { query } = parsedURL;
	    if (query !== null) {
	      this._query._list = urlencoded.parseUrlencodedString(query);
	    }
	  }

	  get origin() {
	    return usm.serializeURLOrigin(this._url);
	  }

	  get protocol() {
	    return `${this._url.scheme}:`;
	  }

	  set protocol(v) {
	    usm.basicURLParse(`${v}:`, { url: this._url, stateOverride: "scheme start" });
	  }

	  get username() {
	    return this._url.username;
	  }

	  set username(v) {
	    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
	      return;
	    }

	    usm.setTheUsername(this._url, v);
	  }

	  get password() {
	    return this._url.password;
	  }

	  set password(v) {
	    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
	      return;
	    }

	    usm.setThePassword(this._url, v);
	  }

	  get host() {
	    const url = this._url;

	    if (url.host === null) {
	      return "";
	    }

	    if (url.port === null) {
	      return usm.serializeHost(url.host);
	    }

	    return `${usm.serializeHost(url.host)}:${usm.serializeInteger(url.port)}`;
	  }

	  set host(v) {
	    if (usm.hasAnOpaquePath(this._url)) {
	      return;
	    }

	    usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
	  }

	  get hostname() {
	    if (this._url.host === null) {
	      return "";
	    }

	    return usm.serializeHost(this._url.host);
	  }

	  set hostname(v) {
	    if (usm.hasAnOpaquePath(this._url)) {
	      return;
	    }

	    usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
	  }

	  get port() {
	    if (this._url.port === null) {
	      return "";
	    }

	    return usm.serializeInteger(this._url.port);
	  }

	  set port(v) {
	    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
	      return;
	    }

	    if (v === "") {
	      this._url.port = null;
	    } else {
	      usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
	    }
	  }

	  get pathname() {
	    return usm.serializePath(this._url);
	  }

	  set pathname(v) {
	    if (usm.hasAnOpaquePath(this._url)) {
	      return;
	    }

	    this._url.path = [];
	    usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
	  }

	  get search() {
	    if (this._url.query === null || this._url.query === "") {
	      return "";
	    }

	    return `?${this._url.query}`;
	  }

	  set search(v) {
	    const url = this._url;

	    if (v === "") {
	      url.query = null;
	      this._query._list = [];
	      this._potentiallyStripTrailingSpacesFromAnOpaquePath();
	      return;
	    }

	    const input = v[0] === "?" ? v.substring(1) : v;
	    url.query = "";
	    usm.basicURLParse(input, { url, stateOverride: "query" });
	    this._query._list = urlencoded.parseUrlencodedString(input);
	  }

	  get searchParams() {
	    return this._query;
	  }

	  get hash() {
	    if (this._url.fragment === null || this._url.fragment === "") {
	      return "";
	    }

	    return `#${this._url.fragment}`;
	  }

	  set hash(v) {
	    if (v === "") {
	      this._url.fragment = null;
	      this._potentiallyStripTrailingSpacesFromAnOpaquePath();
	      return;
	    }

	    const input = v[0] === "#" ? v.substring(1) : v;
	    this._url.fragment = "";
	    usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
	  }

	  toJSON() {
	    return this.href;
	  }

	  _potentiallyStripTrailingSpacesFromAnOpaquePath() {
	    if (!usm.hasAnOpaquePath(this._url)) {
	      return;
	    }

	    if (this._url.fragment !== null) {
	      return;
	    }

	    if (this._url.query !== null) {
	      return;
	    }

	    this._url.path = this._url.path.replace(/\u0020+$/u, "");
	  }
	};
	return URLImpl;
}

var hasRequiredURL;

function requireURL () {
	if (hasRequiredURL) return URL$1;
	hasRequiredURL = 1;
	(function (exports) {

		const conversions = requireLib$2();
		const utils = requireUtils();

		const implSymbol = utils.implSymbol;
		const ctorRegistrySymbol = utils.ctorRegistrySymbol;

		const interfaceName = "URL";

		exports.is = value => {
		  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
		};
		exports.isImpl = value => {
		  return utils.isObject(value) && value instanceof Impl.implementation;
		};
		exports.convert = (globalObject, value, { context = "The provided value" } = {}) => {
		  if (exports.is(value)) {
		    return utils.implForWrapper(value);
		  }
		  throw new globalObject.TypeError(`${context} is not of type 'URL'.`);
		};

		function makeWrapper(globalObject, newTarget) {
		  let proto;
		  if (newTarget !== undefined) {
		    proto = newTarget.prototype;
		  }

		  if (!utils.isObject(proto)) {
		    proto = globalObject[ctorRegistrySymbol]["URL"].prototype;
		  }

		  return Object.create(proto);
		}

		exports.create = (globalObject, constructorArgs, privateData) => {
		  const wrapper = makeWrapper(globalObject);
		  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
		};

		exports.createImpl = (globalObject, constructorArgs, privateData) => {
		  const wrapper = exports.create(globalObject, constructorArgs, privateData);
		  return utils.implForWrapper(wrapper);
		};

		exports._internalSetup = (wrapper, globalObject) => {};

		exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
		  privateData.wrapper = wrapper;

		  exports._internalSetup(wrapper, globalObject);
		  Object.defineProperty(wrapper, implSymbol, {
		    value: new Impl.implementation(globalObject, constructorArgs, privateData),
		    configurable: true
		  });

		  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
		  if (Impl.init) {
		    Impl.init(wrapper[implSymbol]);
		  }
		  return wrapper;
		};

		exports.new = (globalObject, newTarget) => {
		  const wrapper = makeWrapper(globalObject, newTarget);

		  exports._internalSetup(wrapper, globalObject);
		  Object.defineProperty(wrapper, implSymbol, {
		    value: Object.create(Impl.implementation.prototype),
		    configurable: true
		  });

		  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
		  if (Impl.init) {
		    Impl.init(wrapper[implSymbol]);
		  }
		  return wrapper[implSymbol];
		};

		const exposed = new Set(["Window", "Worker"]);

		exports.install = (globalObject, globalNames) => {
		  if (!globalNames.some(globalName => exposed.has(globalName))) {
		    return;
		  }

		  const ctorRegistry = utils.initCtorRegistry(globalObject);
		  class URL {
		    constructor(url) {
		      if (arguments.length < 1) {
		        throw new globalObject.TypeError(
		          `Failed to construct 'URL': 1 argument required, but only ${arguments.length} present.`
		        );
		      }
		      const args = [];
		      {
		        let curArg = arguments[0];
		        curArg = conversions["USVString"](curArg, {
		          context: "Failed to construct 'URL': parameter 1",
		          globals: globalObject
		        });
		        args.push(curArg);
		      }
		      {
		        let curArg = arguments[1];
		        if (curArg !== undefined) {
		          curArg = conversions["USVString"](curArg, {
		            context: "Failed to construct 'URL': parameter 2",
		            globals: globalObject
		          });
		        }
		        args.push(curArg);
		      }
		      return exports.setup(Object.create(new.target.prototype), globalObject, args);
		    }

		    toJSON() {
		      const esValue = this !== null && this !== undefined ? this : globalObject;
		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'toJSON' called on an object that is not a valid instance of URL.");
		      }

		      return esValue[implSymbol].toJSON();
		    }

		    get href() {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'get href' called on an object that is not a valid instance of URL.");
		      }

		      return esValue[implSymbol]["href"];
		    }

		    set href(V) {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'set href' called on an object that is not a valid instance of URL.");
		      }

		      V = conversions["USVString"](V, {
		        context: "Failed to set the 'href' property on 'URL': The provided value",
		        globals: globalObject
		      });

		      esValue[implSymbol]["href"] = V;
		    }

		    toString() {
		      const esValue = this;
		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of URL.");
		      }

		      return esValue[implSymbol]["href"];
		    }

		    get origin() {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'get origin' called on an object that is not a valid instance of URL.");
		      }

		      return esValue[implSymbol]["origin"];
		    }

		    get protocol() {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'get protocol' called on an object that is not a valid instance of URL.");
		      }

		      return esValue[implSymbol]["protocol"];
		    }

		    set protocol(V) {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'set protocol' called on an object that is not a valid instance of URL.");
		      }

		      V = conversions["USVString"](V, {
		        context: "Failed to set the 'protocol' property on 'URL': The provided value",
		        globals: globalObject
		      });

		      esValue[implSymbol]["protocol"] = V;
		    }

		    get username() {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'get username' called on an object that is not a valid instance of URL.");
		      }

		      return esValue[implSymbol]["username"];
		    }

		    set username(V) {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'set username' called on an object that is not a valid instance of URL.");
		      }

		      V = conversions["USVString"](V, {
		        context: "Failed to set the 'username' property on 'URL': The provided value",
		        globals: globalObject
		      });

		      esValue[implSymbol]["username"] = V;
		    }

		    get password() {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'get password' called on an object that is not a valid instance of URL.");
		      }

		      return esValue[implSymbol]["password"];
		    }

		    set password(V) {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'set password' called on an object that is not a valid instance of URL.");
		      }

		      V = conversions["USVString"](V, {
		        context: "Failed to set the 'password' property on 'URL': The provided value",
		        globals: globalObject
		      });

		      esValue[implSymbol]["password"] = V;
		    }

		    get host() {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'get host' called on an object that is not a valid instance of URL.");
		      }

		      return esValue[implSymbol]["host"];
		    }

		    set host(V) {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'set host' called on an object that is not a valid instance of URL.");
		      }

		      V = conversions["USVString"](V, {
		        context: "Failed to set the 'host' property on 'URL': The provided value",
		        globals: globalObject
		      });

		      esValue[implSymbol]["host"] = V;
		    }

		    get hostname() {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'get hostname' called on an object that is not a valid instance of URL.");
		      }

		      return esValue[implSymbol]["hostname"];
		    }

		    set hostname(V) {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'set hostname' called on an object that is not a valid instance of URL.");
		      }

		      V = conversions["USVString"](V, {
		        context: "Failed to set the 'hostname' property on 'URL': The provided value",
		        globals: globalObject
		      });

		      esValue[implSymbol]["hostname"] = V;
		    }

		    get port() {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'get port' called on an object that is not a valid instance of URL.");
		      }

		      return esValue[implSymbol]["port"];
		    }

		    set port(V) {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'set port' called on an object that is not a valid instance of URL.");
		      }

		      V = conversions["USVString"](V, {
		        context: "Failed to set the 'port' property on 'URL': The provided value",
		        globals: globalObject
		      });

		      esValue[implSymbol]["port"] = V;
		    }

		    get pathname() {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'get pathname' called on an object that is not a valid instance of URL.");
		      }

		      return esValue[implSymbol]["pathname"];
		    }

		    set pathname(V) {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'set pathname' called on an object that is not a valid instance of URL.");
		      }

		      V = conversions["USVString"](V, {
		        context: "Failed to set the 'pathname' property on 'URL': The provided value",
		        globals: globalObject
		      });

		      esValue[implSymbol]["pathname"] = V;
		    }

		    get search() {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'get search' called on an object that is not a valid instance of URL.");
		      }

		      return esValue[implSymbol]["search"];
		    }

		    set search(V) {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'set search' called on an object that is not a valid instance of URL.");
		      }

		      V = conversions["USVString"](V, {
		        context: "Failed to set the 'search' property on 'URL': The provided value",
		        globals: globalObject
		      });

		      esValue[implSymbol]["search"] = V;
		    }

		    get searchParams() {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'get searchParams' called on an object that is not a valid instance of URL.");
		      }

		      return utils.getSameObject(this, "searchParams", () => {
		        return utils.tryWrapperForImpl(esValue[implSymbol]["searchParams"]);
		      });
		    }

		    get hash() {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'get hash' called on an object that is not a valid instance of URL.");
		      }

		      return esValue[implSymbol]["hash"];
		    }

		    set hash(V) {
		      const esValue = this !== null && this !== undefined ? this : globalObject;

		      if (!exports.is(esValue)) {
		        throw new globalObject.TypeError("'set hash' called on an object that is not a valid instance of URL.");
		      }

		      V = conversions["USVString"](V, {
		        context: "Failed to set the 'hash' property on 'URL': The provided value",
		        globals: globalObject
		      });

		      esValue[implSymbol]["hash"] = V;
		    }

		    static canParse(url) {
		      if (arguments.length < 1) {
		        throw new globalObject.TypeError(
		          `Failed to execute 'canParse' on 'URL': 1 argument required, but only ${arguments.length} present.`
		        );
		      }
		      const args = [];
		      {
		        let curArg = arguments[0];
		        curArg = conversions["USVString"](curArg, {
		          context: "Failed to execute 'canParse' on 'URL': parameter 1",
		          globals: globalObject
		        });
		        args.push(curArg);
		      }
		      {
		        let curArg = arguments[1];
		        if (curArg !== undefined) {
		          curArg = conversions["USVString"](curArg, {
		            context: "Failed to execute 'canParse' on 'URL': parameter 2",
		            globals: globalObject
		          });
		        }
		        args.push(curArg);
		      }
		      return Impl.implementation.canParse(...args);
		    }
		  }
		  Object.defineProperties(URL.prototype, {
		    toJSON: { enumerable: true },
		    href: { enumerable: true },
		    toString: { enumerable: true },
		    origin: { enumerable: true },
		    protocol: { enumerable: true },
		    username: { enumerable: true },
		    password: { enumerable: true },
		    host: { enumerable: true },
		    hostname: { enumerable: true },
		    port: { enumerable: true },
		    pathname: { enumerable: true },
		    search: { enumerable: true },
		    searchParams: { enumerable: true },
		    hash: { enumerable: true },
		    [Symbol.toStringTag]: { value: "URL", configurable: true }
		  });
		  Object.defineProperties(URL, { canParse: { enumerable: true } });
		  ctorRegistry[interfaceName] = URL;

		  Object.defineProperty(globalObject, interfaceName, {
		    configurable: true,
		    writable: true,
		    value: URL
		  });

		  if (globalNames.includes("Window")) {
		    Object.defineProperty(globalObject, "webkitURL", {
		      configurable: true,
		      writable: true,
		      value: URL
		    });
		  }
		};

		const Impl = requireURLImpl(); 
	} (URL$1));
	return URL$1;
}

var hasRequiredWebidl2jsWrapper;

function requireWebidl2jsWrapper () {
	if (hasRequiredWebidl2jsWrapper) return webidl2jsWrapper;
	hasRequiredWebidl2jsWrapper = 1;

	const URL = requireURL();
	const URLSearchParams = requireURLSearchParams();

	webidl2jsWrapper.URL = URL;
	webidl2jsWrapper.URLSearchParams = URLSearchParams;
	return webidl2jsWrapper;
}

var hasRequiredWhatwgUrl;

function requireWhatwgUrl () {
	if (hasRequiredWhatwgUrl) return whatwgUrl;
	hasRequiredWhatwgUrl = 1;

	const { URL, URLSearchParams } = requireWebidl2jsWrapper();
	const urlStateMachine = requireUrlStateMachine();
	const percentEncoding = requirePercentEncoding();

	const sharedGlobalObject = { Array, Object, Promise, String, TypeError };
	URL.install(sharedGlobalObject, ["Window"]);
	URLSearchParams.install(sharedGlobalObject, ["Window"]);

	whatwgUrl.URL = sharedGlobalObject.URL;
	whatwgUrl.URLSearchParams = sharedGlobalObject.URLSearchParams;

	whatwgUrl.parseURL = urlStateMachine.parseURL;
	whatwgUrl.basicURLParse = urlStateMachine.basicURLParse;
	whatwgUrl.serializeURL = urlStateMachine.serializeURL;
	whatwgUrl.serializePath = urlStateMachine.serializePath;
	whatwgUrl.serializeHost = urlStateMachine.serializeHost;
	whatwgUrl.serializeInteger = urlStateMachine.serializeInteger;
	whatwgUrl.serializeURLOrigin = urlStateMachine.serializeURLOrigin;
	whatwgUrl.setTheUsername = urlStateMachine.setTheUsername;
	whatwgUrl.setThePassword = urlStateMachine.setThePassword;
	whatwgUrl.cannotHaveAUsernamePasswordPort = urlStateMachine.cannotHaveAUsernamePasswordPort;
	whatwgUrl.hasAnOpaquePath = urlStateMachine.hasAnOpaquePath;

	whatwgUrl.percentDecodeString = percentEncoding.percentDecodeString;
	whatwgUrl.percentDecodeBytes = percentEncoding.percentDecodeBytes;
	return whatwgUrl;
}

var redact = {};

var hasRequiredRedact;

function requireRedact () {
	if (hasRequiredRedact) return redact;
	hasRequiredRedact = 1;
	var __createBinding = (redact.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (redact.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (redact.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(redact, "__esModule", { value: true });
	redact.redactConnectionString = redact.redactValidConnectionString = void 0;
	const index_1 = __importStar(requireLib$1());
	function redactValidConnectionString(inputUrl, options) {
	    var _a, _b;
	    const url = inputUrl.clone();
	    const replacementString = (_a = options === null || options === void 0 ? void 0 : options.replacementString) !== null && _a !== void 0 ? _a : '_credentials_';
	    const redactUsernames = (_b = options === null || options === void 0 ? void 0 : options.redactUsernames) !== null && _b !== void 0 ? _b : true;
	    if ((url.username || url.password) && redactUsernames) {
	        url.username = replacementString;
	        url.password = '';
	    }
	    else if (url.password) {
	        url.password = replacementString;
	    }
	    if (url.searchParams.has('authMechanismProperties')) {
	        const props = new index_1.CommaAndColonSeparatedRecord(url.searchParams.get('authMechanismProperties'));
	        if (props.get('AWS_SESSION_TOKEN')) {
	            props.set('AWS_SESSION_TOKEN', replacementString);
	            url.searchParams.set('authMechanismProperties', props.toString());
	        }
	    }
	    if (url.searchParams.has('tlsCertificateKeyFilePassword')) {
	        url.searchParams.set('tlsCertificateKeyFilePassword', replacementString);
	    }
	    if (url.searchParams.has('proxyUsername') && redactUsernames) {
	        url.searchParams.set('proxyUsername', replacementString);
	    }
	    if (url.searchParams.has('proxyPassword')) {
	        url.searchParams.set('proxyPassword', replacementString);
	    }
	    return url;
	}
	redact.redactValidConnectionString = redactValidConnectionString;
	function redactConnectionString(uri, options) {
	    var _a, _b;
	    const replacementString = (_a = options === null || options === void 0 ? void 0 : options.replacementString) !== null && _a !== void 0 ? _a : '<credentials>';
	    const redactUsernames = (_b = options === null || options === void 0 ? void 0 : options.redactUsernames) !== null && _b !== void 0 ? _b : true;
	    let parsed;
	    try {
	        parsed = new index_1.default(uri);
	    }
	    catch (_c) { }
	    if (parsed) {
	        options = { ...options, replacementString: '___credentials___' };
	        return parsed.redact(options).toString().replace(/___credentials___/g, replacementString);
	    }
	    const R = replacementString;
	    const replacements = [
	        uri => uri.replace(redactUsernames ? /(\/\/)(.*)(@)/g : /(\/\/[^@]*:)(.*)(@)/g, `$1${R}$3`),
	        uri => uri.replace(/(AWS_SESSION_TOKEN(:|%3A))([^,&]+)/gi, `$1${R}`),
	        uri => uri.replace(/(tlsCertificateKeyFilePassword=)([^&]+)/gi, `$1${R}`),
	        uri => redactUsernames ? uri.replace(/(proxyUsername=)([^&]+)/gi, `$1${R}`) : uri,
	        uri => uri.replace(/(proxyPassword=)([^&]+)/gi, `$1${R}`)
	    ];
	    for (const replacer of replacements) {
	        uri = replacer(uri);
	    }
	    return uri;
	}
	redact.redactConnectionString = redactConnectionString;
	
	return redact;
}

var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib$1;
	hasRequiredLib$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.CommaAndColonSeparatedRecord = exports.ConnectionString = exports.redactConnectionString = void 0;
		const whatwg_url_1 = requireWhatwgUrl();
		const redact_1 = requireRedact();
		Object.defineProperty(exports, "redactConnectionString", { enumerable: true, get: function () { return redact_1.redactConnectionString; } });
		const DUMMY_HOSTNAME = '__this_is_a_placeholder__';
		function connectionStringHasValidScheme(connectionString) {
		    return (connectionString.startsWith('mongodb://') ||
		        connectionString.startsWith('mongodb+srv://'));
		}
		const HOSTS_REGEX = /^(?<protocol>[^/]+):\/\/(?:(?<username>[^:@]*)(?::(?<password>[^@]*))?@)?(?<hosts>(?!:)[^/?@]*)(?<rest>.*)/;
		class CaseInsensitiveMap extends Map {
		    delete(name) {
		        return super.delete(this._normalizeKey(name));
		    }
		    get(name) {
		        return super.get(this._normalizeKey(name));
		    }
		    has(name) {
		        return super.has(this._normalizeKey(name));
		    }
		    set(name, value) {
		        return super.set(this._normalizeKey(name), value);
		    }
		    _normalizeKey(name) {
		        name = `${name}`;
		        for (const key of this.keys()) {
		            if (key.toLowerCase() === name.toLowerCase()) {
		                name = key;
		                break;
		            }
		        }
		        return name;
		    }
		}
		function caseInsenstiveURLSearchParams(Ctor) {
		    return class CaseInsenstiveURLSearchParams extends Ctor {
		        append(name, value) {
		            return super.append(this._normalizeKey(name), value);
		        }
		        delete(name) {
		            return super.delete(this._normalizeKey(name));
		        }
		        get(name) {
		            return super.get(this._normalizeKey(name));
		        }
		        getAll(name) {
		            return super.getAll(this._normalizeKey(name));
		        }
		        has(name) {
		            return super.has(this._normalizeKey(name));
		        }
		        set(name, value) {
		            return super.set(this._normalizeKey(name), value);
		        }
		        keys() {
		            return super.keys();
		        }
		        values() {
		            return super.values();
		        }
		        entries() {
		            return super.entries();
		        }
		        [Symbol.iterator]() {
		            return super[Symbol.iterator]();
		        }
		        _normalizeKey(name) {
		            return CaseInsensitiveMap.prototype._normalizeKey.call(this, name);
		        }
		    };
		}
		class URLWithoutHost extends whatwg_url_1.URL {
		}
		class MongoParseError extends Error {
		    get name() {
		        return 'MongoParseError';
		    }
		}
		class ConnectionString extends URLWithoutHost {
		    constructor(uri, options = {}) {
		        var _a;
		        const { looseValidation } = options;
		        if (!looseValidation && !connectionStringHasValidScheme(uri)) {
		            throw new MongoParseError('Invalid scheme, expected connection string to start with "mongodb://" or "mongodb+srv://"');
		        }
		        const match = uri.match(HOSTS_REGEX);
		        if (!match) {
		            throw new MongoParseError(`Invalid connection string "${uri}"`);
		        }
		        const { protocol, username, password, hosts, rest } = (_a = match.groups) !== null && _a !== void 0 ? _a : {};
		        if (!looseValidation) {
		            if (!protocol || !hosts) {
		                throw new MongoParseError(`Protocol and host list are required in "${uri}"`);
		            }
		            try {
		                decodeURIComponent(username !== null && username !== void 0 ? username : '');
		                decodeURIComponent(password !== null && password !== void 0 ? password : '');
		            }
		            catch (err) {
		                throw new MongoParseError(err.message);
		            }
		            const illegalCharacters = /[:/?#[\]@]/gi;
		            if (username === null || username === void 0 ? void 0 : username.match(illegalCharacters)) {
		                throw new MongoParseError(`Username contains unescaped characters ${username}`);
		            }
		            if (!username || !password) {
		                const uriWithoutProtocol = uri.replace(`${protocol}://`, '');
		                if (uriWithoutProtocol.startsWith('@') || uriWithoutProtocol.startsWith(':')) {
		                    throw new MongoParseError('URI contained empty userinfo section');
		                }
		            }
		            if (password === null || password === void 0 ? void 0 : password.match(illegalCharacters)) {
		                throw new MongoParseError('Password contains unescaped characters');
		            }
		        }
		        let authString = '';
		        if (typeof username === 'string')
		            authString += username;
		        if (typeof password === 'string')
		            authString += `:${password}`;
		        if (authString)
		            authString += '@';
		        try {
		            super(`${protocol.toLowerCase()}://${authString}${DUMMY_HOSTNAME}${rest}`);
		        }
		        catch (err) {
		            if (looseValidation) {
		                new ConnectionString(uri, {
		                    ...options,
		                    looseValidation: false
		                });
		            }
		            if (typeof err.message === 'string') {
		                err.message = err.message.replace(DUMMY_HOSTNAME, hosts);
		            }
		            throw err;
		        }
		        this._hosts = hosts.split(',');
		        if (!looseValidation) {
		            if (this.isSRV && this.hosts.length !== 1) {
		                throw new MongoParseError('mongodb+srv URI cannot have multiple service names');
		            }
		            if (this.isSRV && this.hosts.some(host => host.includes(':'))) {
		                throw new MongoParseError('mongodb+srv URI cannot have port number');
		            }
		        }
		        if (!this.pathname) {
		            this.pathname = '/';
		        }
		        Object.setPrototypeOf(this.searchParams, caseInsenstiveURLSearchParams(this.searchParams.constructor).prototype);
		    }
		    get host() { return DUMMY_HOSTNAME; }
		    set host(_ignored) { throw new Error('No single host for connection string'); }
		    get hostname() { return DUMMY_HOSTNAME; }
		    set hostname(_ignored) { throw new Error('No single host for connection string'); }
		    get port() { return ''; }
		    set port(_ignored) { throw new Error('No single host for connection string'); }
		    get href() { return this.toString(); }
		    set href(_ignored) { throw new Error('Cannot set href for connection strings'); }
		    get isSRV() {
		        return this.protocol.includes('srv');
		    }
		    get hosts() {
		        return this._hosts;
		    }
		    set hosts(list) {
		        this._hosts = list;
		    }
		    toString() {
		        return super.toString().replace(DUMMY_HOSTNAME, this.hosts.join(','));
		    }
		    clone() {
		        return new ConnectionString(this.toString(), {
		            looseValidation: true
		        });
		    }
		    redact(options) {
		        return (0, redact_1.redactValidConnectionString)(this, options);
		    }
		    typedSearchParams() {
		        return this.searchParams;
		    }
		    [Symbol.for('nodejs.util.inspect.custom')]() {
		        const { href, origin, protocol, username, password, hosts, pathname, search, searchParams, hash } = this;
		        return { href, origin, protocol, username, password, hosts, pathname, search, searchParams, hash };
		    }
		}
		exports.ConnectionString = ConnectionString;
		class CommaAndColonSeparatedRecord extends CaseInsensitiveMap {
		    constructor(from) {
		        super();
		        for (const entry of (from !== null && from !== void 0 ? from : '').split(',')) {
		            if (!entry)
		                continue;
		            const colonIndex = entry.indexOf(':');
		            if (colonIndex === -1) {
		                this.set(entry, '');
		            }
		            else {
		                this.set(entry.slice(0, colonIndex), entry.slice(colonIndex + 1));
		            }
		        }
		    }
		    toString() {
		        return [...this].map(entry => entry.join(':')).join(',');
		    }
		}
		exports.CommaAndColonSeparatedRecord = CommaAndColonSeparatedRecord;
		exports.default = ConnectionString;
		
	} (lib$1));
	return lib$1;
}

var client_metadata = {};

var name = "mongodb";
var version = "6.9.0";
var description = "The official MongoDB driver for Node.js";
var main = "lib/index.js";
var files = [
	"lib",
	"src",
	"etc/prepare.js",
	"mongodb.d.ts",
	"tsconfig.json"
];
var types = "mongodb.d.ts";
var repository = {
	type: "git",
	url: "git@github.com:mongodb/node-mongodb-native.git"
};
var keywords = [
	"mongodb",
	"driver",
	"official"
];
var author = {
	name: "The MongoDB NodeJS Team",
	email: "dbx-node@mongodb.com"
};
var dependencies = {
	"@mongodb-js/saslprep": "^1.1.5",
	bson: "^6.7.0",
	"mongodb-connection-string-url": "^3.0.0"
};
var peerDependencies = {
	"@aws-sdk/credential-providers": "^3.188.0",
	"@mongodb-js/zstd": "^1.1.0",
	"gcp-metadata": "^5.2.0",
	kerberos: "^2.0.1",
	"mongodb-client-encryption": ">=6.0.0 <7",
	snappy: "^7.2.2",
	socks: "^2.7.1"
};
var peerDependenciesMeta = {
	"@aws-sdk/credential-providers": {
		optional: true
	},
	"@mongodb-js/zstd": {
		optional: true
	},
	kerberos: {
		optional: true
	},
	snappy: {
		optional: true
	},
	"mongodb-client-encryption": {
		optional: true
	},
	"gcp-metadata": {
		optional: true
	},
	socks: {
		optional: true
	}
};
var devDependencies = {
	"@aws-sdk/credential-providers": "^3.632.0",
	"@iarna/toml": "^2.2.5",
	"@istanbuljs/nyc-config-typescript": "^1.0.2",
	"@microsoft/api-extractor": "^7.47.5",
	"@microsoft/tsdoc-config": "^0.17.0",
	"@mongodb-js/zstd": "^1.2.0",
	"@types/chai": "^4.3.17",
	"@types/chai-subset": "^1.3.5",
	"@types/express": "^4.17.21",
	"@types/kerberos": "^1.1.5",
	"@types/mocha": "^10.0.7",
	"@types/node": "^22.4.1",
	"@types/saslprep": "^1.0.3",
	"@types/semver": "^7.5.8",
	"@types/sinon": "^17.0.3",
	"@types/sinon-chai": "^3.2.12",
	"@types/whatwg-url": "^11.0.5",
	"@typescript-eslint/eslint-plugin": "^8.2.0",
	"@typescript-eslint/parser": "^8.2.0",
	chai: "^4.4.1",
	"chai-subset": "^1.6.0",
	chalk: "^4.1.2",
	eslint: "^9.0.0",
	"eslint-config-prettier": "^9.1.0",
	"eslint-plugin-mocha": "^10.4.1",
	"eslint-plugin-prettier": "^5.2.1",
	"eslint-plugin-simple-import-sort": "^12.1.1",
	"eslint-plugin-tsdoc": "^0.3.0",
	"eslint-plugin-unused-imports": "^4.0.0",
	express: "^4.19.2",
	"gcp-metadata": "^5.3.0",
	"js-yaml": "^4.1.0",
	mocha: "^10.4.0",
	"mocha-sinon": "^2.1.2",
	"mongodb-client-encryption": "^6.1.0",
	"mongodb-legacy": "^6.1.0",
	nyc: "^15.1.0",
	prettier: "^3.3.3",
	semver: "^7.6.3",
	sinon: "^18.0.0",
	"sinon-chai": "^3.7.0",
	snappy: "^7.2.2",
	socks: "^2.8.1",
	"source-map-support": "^0.5.21",
	"ts-node": "^10.9.2",
	tsd: "^0.31.1",
	typescript: "5.5",
	"typescript-cached-transpile": "^0.0.6",
	"v8-heapsnapshot": "^1.3.1",
	yargs: "^17.7.2"
};
var license = "Apache-2.0";
var engines = {
	node: ">=16.20.1"
};
var bugs = {
	url: "https://jira.mongodb.org/projects/NODE/issues/"
};
var homepage = "https://github.com/mongodb/node-mongodb-native";
var scripts = {
	"build:evergreen": "node .evergreen/generate_evergreen_tasks.js",
	"build:ts": "node ./node_modules/typescript/bin/tsc",
	"build:dts": "npm run build:ts && api-extractor run && node etc/clean_definition_files.cjs && ESLINT_USE_FLAT_CONFIG=false eslint --no-ignore --fix mongodb.d.ts lib/beta.d.ts",
	"build:docs": "./etc/docs/build.ts",
	"build:typedoc": "typedoc",
	"build:nightly": "node ./.github/scripts/nightly.mjs",
	"check:bench": "node test/benchmarks/driverBench",
	"check:coverage": "nyc npm run test:all",
	"check:integration-coverage": "nyc npm run check:test",
	"check:lambda": "mocha --config test/mocha_lambda.json test/integration/node-specific/examples/handler.test.js",
	"check:lambda:aws": "mocha --config test/mocha_lambda.json test/integration/node-specific/examples/aws_handler.test.js",
	"check:lint": "npm run build:dts && npm run check:dts && npm run check:eslint && npm run check:tsd",
	"check:eslint": "npm run build:dts && ESLINT_USE_FLAT_CONFIG=false eslint -v && ESLINT_USE_FLAT_CONFIG=false eslint --max-warnings=0 --ext '.js,.ts' src test",
	"check:tsd": "tsd --version && tsd",
	"check:dependencies": "mocha test/action/dependency.test.ts",
	"check:dts": "node ./node_modules/typescript/bin/tsc --noEmit mongodb.d.ts && tsd",
	"check:search-indexes": "nyc mocha --config test/mocha_mongodb.json test/manual/search-index-management.prose.test.ts",
	"check:test": "mocha --config test/mocha_mongodb.json test/integration",
	"check:unit": "mocha test/unit",
	"check:ts": "node ./node_modules/typescript/bin/tsc -v && node ./node_modules/typescript/bin/tsc --noEmit",
	"check:atlas": "mocha --config test/manual/mocharc.json test/manual/atlas_connectivity.test.ts",
	"check:resource-management": "mocha --config test/manual/mocharc.json test/manual/resource_management.test.ts",
	"check:drivers-atlas-testing": "mocha --config test/mocha_mongodb.json test/atlas/drivers_atlas_testing.test.ts",
	"check:adl": "mocha --config test/mocha_mongodb.json test/manual/atlas-data-lake-testing",
	"check:aws": "nyc mocha --config test/mocha_mongodb.json test/integration/auth/mongodb_aws.test.ts",
	"check:oidc-auth": "mocha --config test/mocha_mongodb.json test/integration/auth/auth.spec.test.ts",
	"check:oidc-test": "mocha --config test/mocha_mongodb.json test/integration/auth/mongodb_oidc.prose.test.ts",
	"check:oidc-azure": "mocha --config test/mocha_mongodb.json test/integration/auth/mongodb_oidc_azure.prose.05.test.ts",
	"check:oidc-gcp": "mocha --config test/mocha_mongodb.json test/integration/auth/mongodb_oidc_gcp.prose.06.test.ts",
	"check:ocsp": "mocha --config test/manual/mocharc.json test/manual/ocsp_support.test.js",
	"check:kerberos": "nyc mocha --config test/manual/mocharc.json test/manual/kerberos.test.ts",
	"check:tls": "mocha --config test/manual/mocharc.json test/manual/tls_support.test.ts",
	"check:ldap": "nyc mocha --config test/manual/mocharc.json test/manual/ldap.test.js",
	"check:socks5": "mocha --config test/manual/mocharc.json test/manual/socks5.test.ts",
	"check:csfle": "mocha --config test/mocha_mongodb.json test/integration/client-side-encryption",
	"check:snappy": "mocha test/unit/assorted/snappy.test.js",
	"check:x509": "mocha test/manual/x509_auth.test.ts",
	"fix:eslint": "npm run check:eslint -- --fix",
	prepare: "node etc/prepare.js",
	"preview:docs": "ts-node etc/docs/preview.ts",
	test: "npm run check:lint && npm run test:all",
	"test:all": "npm run check:unit && npm run check:test",
	"update:docs": "npm run build:docs -- --yes"
};
var tsd = {
	directory: "test/types",
	compilerOptions: {
		strict: true,
		target: "esnext",
		module: "commonjs",
		moduleResolution: "node"
	}
};
var require$$5 = {
	name: name,
	version: version,
	description: description,
	main: main,
	files: files,
	types: types,
	repository: repository,
	keywords: keywords,
	author: author,
	dependencies: dependencies,
	peerDependencies: peerDependencies,
	peerDependenciesMeta: peerDependenciesMeta,
	devDependencies: devDependencies,
	license: license,
	engines: engines,
	bugs: bugs,
	homepage: homepage,
	scripts: scripts,
	tsd: tsd
};

var hasRequiredClient_metadata;

function requireClient_metadata () {
	if (hasRequiredClient_metadata) return client_metadata;
	hasRequiredClient_metadata = 1;
	Object.defineProperty(client_metadata, "__esModule", { value: true });
	client_metadata.LimitedSizeDocument = void 0;
	client_metadata.makeClientMetadata = makeClientMetadata;
	client_metadata.addContainerMetadata = addContainerMetadata;
	client_metadata.getFAASEnv = getFAASEnv;
	const os$1 = os;
	const process = process$1;
	const bson_1 = requireBson();
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	// eslint-disable-next-line @typescript-eslint/no-require-imports
	const NODE_DRIVER_VERSION = require$$5.version;
	/** @internal */
	class LimitedSizeDocument {
	    constructor(maxSize) {
	        this.maxSize = maxSize;
	        this.document = new Map();
	        /** BSON overhead: Int32 + Null byte */
	        this.documentSize = 5;
	    }
	    /** Only adds key/value if the bsonByteLength is less than MAX_SIZE */
	    ifItFitsItSits(key, value) {
	        // The BSON byteLength of the new element is the same as serializing it to its own document
	        // subtracting the document size int32 and the null terminator.
	        const newElementSize = bson_1.BSON.serialize(new Map().set(key, value)).byteLength - 5;
	        if (newElementSize + this.documentSize > this.maxSize) {
	            return false;
	        }
	        this.documentSize += newElementSize;
	        this.document.set(key, value);
	        return true;
	    }
	    toObject() {
	        return bson_1.BSON.deserialize(bson_1.BSON.serialize(this.document), {
	            promoteLongs: false,
	            promoteBuffers: false,
	            promoteValues: false,
	            useBigInt64: false
	        });
	    }
	}
	client_metadata.LimitedSizeDocument = LimitedSizeDocument;
	/**
	 * From the specs:
	 * Implementors SHOULD cumulatively update fields in the following order until the document is under the size limit:
	 * 1. Omit fields from `env` except `env.name`.
	 * 2. Omit fields from `os` except `os.type`.
	 * 3. Omit the `env` document entirely.
	 * 4. Truncate `platform`. -- special we do not truncate this field
	 */
	function makeClientMetadata(options) {
	    const metadataDocument = new LimitedSizeDocument(512);
	    const { appName = '' } = options;
	    // Add app name first, it must be sent
	    if (appName.length > 0) {
	        const name = Buffer.byteLength(appName, 'utf8') <= 128
	            ? options.appName
	            : Buffer.from(appName, 'utf8').subarray(0, 128).toString('utf8');
	        metadataDocument.ifItFitsItSits('application', { name });
	    }
	    const { name = '', version = '', platform = '' } = options.driverInfo;
	    const driverInfo = {
	        name: name.length > 0 ? `nodejs|${name}` : 'nodejs',
	        version: version.length > 0 ? `${NODE_DRIVER_VERSION}|${version}` : NODE_DRIVER_VERSION
	    };
	    if (!metadataDocument.ifItFitsItSits('driver', driverInfo)) {
	        throw new error_1.MongoInvalidArgumentError('Unable to include driverInfo name and version, metadata cannot exceed 512 bytes');
	    }
	    let runtimeInfo = getRuntimeInfo();
	    if (platform.length > 0) {
	        runtimeInfo = `${runtimeInfo}|${platform}`;
	    }
	    if (!metadataDocument.ifItFitsItSits('platform', runtimeInfo)) {
	        throw new error_1.MongoInvalidArgumentError('Unable to include driverInfo platform, metadata cannot exceed 512 bytes');
	    }
	    // Note: order matters, os.type is last so it will be removed last if we're at maxSize
	    const osInfo = new Map()
	        .set('name', process.platform)
	        .set('architecture', process.arch)
	        .set('version', os$1.release())
	        .set('type', os$1.type());
	    if (!metadataDocument.ifItFitsItSits('os', osInfo)) {
	        for (const key of osInfo.keys()) {
	            osInfo.delete(key);
	            if (osInfo.size === 0)
	                break;
	            if (metadataDocument.ifItFitsItSits('os', osInfo))
	                break;
	        }
	    }
	    const faasEnv = getFAASEnv();
	    if (faasEnv != null) {
	        if (!metadataDocument.ifItFitsItSits('env', faasEnv)) {
	            for (const key of faasEnv.keys()) {
	                faasEnv.delete(key);
	                if (faasEnv.size === 0)
	                    break;
	                if (metadataDocument.ifItFitsItSits('env', faasEnv))
	                    break;
	            }
	        }
	    }
	    return metadataDocument.toObject();
	}
	let dockerPromise;
	/** @internal */
	async function getContainerMetadata() {
	    const containerMetadata = {};
	    dockerPromise ??= (0, utils_1.fileIsAccessible)('/.dockerenv');
	    const isDocker = await dockerPromise;
	    const { KUBERNETES_SERVICE_HOST = '' } = process.env;
	    const isKubernetes = KUBERNETES_SERVICE_HOST.length > 0 ? true : false;
	    if (isDocker)
	        containerMetadata.runtime = 'docker';
	    if (isKubernetes)
	        containerMetadata.orchestrator = 'kubernetes';
	    return containerMetadata;
	}
	/**
	 * @internal
	 * Re-add each metadata value.
	 * Attempt to add new env container metadata, but keep old data if it does not fit.
	 */
	async function addContainerMetadata(originalMetadata) {
	    const containerMetadata = await getContainerMetadata();
	    if (Object.keys(containerMetadata).length === 0)
	        return originalMetadata;
	    const extendedMetadata = new LimitedSizeDocument(512);
	    const extendedEnvMetadata = { ...originalMetadata?.env, container: containerMetadata };
	    for (const [key, val] of Object.entries(originalMetadata)) {
	        if (key !== 'env') {
	            extendedMetadata.ifItFitsItSits(key, val);
	        }
	        else {
	            if (!extendedMetadata.ifItFitsItSits('env', extendedEnvMetadata)) {
	                // add in old data if newer / extended metadata does not fit
	                extendedMetadata.ifItFitsItSits('env', val);
	            }
	        }
	    }
	    if (!('env' in originalMetadata)) {
	        extendedMetadata.ifItFitsItSits('env', extendedEnvMetadata);
	    }
	    return extendedMetadata.toObject();
	}
	/**
	 * Collects FaaS metadata.
	 * - `name` MUST be the last key in the Map returned.
	 */
	function getFAASEnv() {
	    const { AWS_EXECUTION_ENV = '', AWS_LAMBDA_RUNTIME_API = '', FUNCTIONS_WORKER_RUNTIME = '', K_SERVICE = '', FUNCTION_NAME = '', VERCEL = '', AWS_LAMBDA_FUNCTION_MEMORY_SIZE = '', AWS_REGION = '', FUNCTION_MEMORY_MB = '', FUNCTION_REGION = '', FUNCTION_TIMEOUT_SEC = '', VERCEL_REGION = '' } = process.env;
	    const isAWSFaaS = AWS_EXECUTION_ENV.startsWith('AWS_Lambda_') || AWS_LAMBDA_RUNTIME_API.length > 0;
	    const isAzureFaaS = FUNCTIONS_WORKER_RUNTIME.length > 0;
	    const isGCPFaaS = K_SERVICE.length > 0 || FUNCTION_NAME.length > 0;
	    const isVercelFaaS = VERCEL.length > 0;
	    // Note: order matters, name must always be the last key
	    const faasEnv = new Map();
	    // When isVercelFaaS is true so is isAWSFaaS; Vercel inherits the AWS env
	    if (isVercelFaaS && !(isAzureFaaS || isGCPFaaS)) {
	        if (VERCEL_REGION.length > 0) {
	            faasEnv.set('region', VERCEL_REGION);
	        }
	        faasEnv.set('name', 'vercel');
	        return faasEnv;
	    }
	    if (isAWSFaaS && !(isAzureFaaS || isGCPFaaS || isVercelFaaS)) {
	        if (AWS_REGION.length > 0) {
	            faasEnv.set('region', AWS_REGION);
	        }
	        if (AWS_LAMBDA_FUNCTION_MEMORY_SIZE.length > 0 &&
	            Number.isInteger(+AWS_LAMBDA_FUNCTION_MEMORY_SIZE)) {
	            faasEnv.set('memory_mb', new bson_1.Int32(AWS_LAMBDA_FUNCTION_MEMORY_SIZE));
	        }
	        faasEnv.set('name', 'aws.lambda');
	        return faasEnv;
	    }
	    if (isAzureFaaS && !(isGCPFaaS || isAWSFaaS || isVercelFaaS)) {
	        faasEnv.set('name', 'azure.func');
	        return faasEnv;
	    }
	    if (isGCPFaaS && !(isAzureFaaS || isAWSFaaS || isVercelFaaS)) {
	        if (FUNCTION_REGION.length > 0) {
	            faasEnv.set('region', FUNCTION_REGION);
	        }
	        if (FUNCTION_MEMORY_MB.length > 0 && Number.isInteger(+FUNCTION_MEMORY_MB)) {
	            faasEnv.set('memory_mb', new bson_1.Int32(FUNCTION_MEMORY_MB));
	        }
	        if (FUNCTION_TIMEOUT_SEC.length > 0 && Number.isInteger(+FUNCTION_TIMEOUT_SEC)) {
	            faasEnv.set('timeout_sec', new bson_1.Int32(FUNCTION_TIMEOUT_SEC));
	        }
	        faasEnv.set('name', 'gcp.func');
	        return faasEnv;
	    }
	    return null;
	}
	/**
	 * @internal
	 * Get current JavaScript runtime platform
	 *
	 * NOTE: The version information fetching is intentionally written defensively
	 * to avoid having a released driver version that becomes incompatible
	 * with a future change to these global objects.
	 */
	function getRuntimeInfo() {
	    if ('Deno' in globalThis) {
	        const version = typeof Deno?.version?.deno === 'string' ? Deno?.version?.deno : '0.0.0-unknown';
	        return `Deno v${version}, ${os$1.endianness()}`;
	    }
	    if ('Bun' in globalThis) {
	        const version = typeof Bun?.version === 'string' ? Bun?.version : '0.0.0-unknown';
	        return `Bun v${version}, ${os$1.endianness()}`;
	    }
	    return `Node.js ${process.version}, ${os$1.endianness()}`;
	}
	
	return client_metadata;
}

var compression = {};

var commands = {};

var hasRequiredCommands;

function requireCommands () {
	if (hasRequiredCommands) return commands;
	hasRequiredCommands = 1;
	Object.defineProperty(commands, "__esModule", { value: true });
	commands.OpCompressedRequest = commands.OpMsgResponse = commands.OpMsgRequest = commands.DocumentSequence = commands.OpReply = commands.OpQueryRequest = void 0;
	const BSON = requireBson();
	const error_1 = requireError();
	const compression_1 = requireCompression();
	const constants_1 = requireConstants$1();
	// Incrementing request id
	let _requestId = 0;
	// Query flags
	const OPTS_TAILABLE_CURSOR = 2;
	const OPTS_SECONDARY = 4;
	const OPTS_OPLOG_REPLAY = 8;
	const OPTS_NO_CURSOR_TIMEOUT = 16;
	const OPTS_AWAIT_DATA = 32;
	const OPTS_EXHAUST = 64;
	const OPTS_PARTIAL = 128;
	// Response flags
	const CURSOR_NOT_FOUND = 1;
	const QUERY_FAILURE = 2;
	const SHARD_CONFIG_STALE = 4;
	const AWAIT_CAPABLE = 8;
	const encodeUTF8Into = BSON.BSON.onDemand.ByteUtils.encodeUTF8Into;
	/** @internal */
	class OpQueryRequest {
	    constructor(databaseName, query, options) {
	        this.databaseName = databaseName;
	        this.query = query;
	        // Basic options needed to be passed in
	        // TODO(NODE-3483): Replace with MongoCommandError
	        const ns = `${databaseName}.$cmd`;
	        if (typeof databaseName !== 'string') {
	            throw new error_1.MongoRuntimeError('Database name must be a string for a query');
	        }
	        // TODO(NODE-3483): Replace with MongoCommandError
	        if (query == null)
	            throw new error_1.MongoRuntimeError('A query document must be specified for query');
	        // Validate that we are not passing 0x00 in the collection name
	        if (ns.indexOf('\x00') !== -1) {
	            // TODO(NODE-3483): Use MongoNamespace static method
	            throw new error_1.MongoRuntimeError('Namespace cannot contain a null character');
	        }
	        // Basic options
	        this.ns = ns;
	        // Additional options
	        this.numberToSkip = options.numberToSkip || 0;
	        this.numberToReturn = options.numberToReturn || 0;
	        this.returnFieldSelector = options.returnFieldSelector || undefined;
	        this.requestId = options.requestId ?? OpQueryRequest.getRequestId();
	        // special case for pre-3.2 find commands, delete ASAP
	        this.pre32Limit = options.pre32Limit;
	        // Serialization option
	        this.serializeFunctions =
	            typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
	        this.ignoreUndefined =
	            typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;
	        this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
	        this.checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
	        this.batchSize = this.numberToReturn;
	        // Flags
	        this.tailable = false;
	        this.secondaryOk = typeof options.secondaryOk === 'boolean' ? options.secondaryOk : false;
	        this.oplogReplay = false;
	        this.noCursorTimeout = false;
	        this.awaitData = false;
	        this.exhaust = false;
	        this.partial = false;
	    }
	    /** Assign next request Id. */
	    incRequestId() {
	        this.requestId = _requestId++;
	    }
	    /** Peek next request Id. */
	    nextRequestId() {
	        return _requestId + 1;
	    }
	    /** Increment then return next request Id. */
	    static getRequestId() {
	        return ++_requestId;
	    }
	    // Uses a single allocated buffer for the process, avoiding multiple memory allocations
	    toBin() {
	        const buffers = [];
	        let projection = null;
	        // Set up the flags
	        let flags = 0;
	        if (this.tailable) {
	            flags |= OPTS_TAILABLE_CURSOR;
	        }
	        if (this.secondaryOk) {
	            flags |= OPTS_SECONDARY;
	        }
	        if (this.oplogReplay) {
	            flags |= OPTS_OPLOG_REPLAY;
	        }
	        if (this.noCursorTimeout) {
	            flags |= OPTS_NO_CURSOR_TIMEOUT;
	        }
	        if (this.awaitData) {
	            flags |= OPTS_AWAIT_DATA;
	        }
	        if (this.exhaust) {
	            flags |= OPTS_EXHAUST;
	        }
	        if (this.partial) {
	            flags |= OPTS_PARTIAL;
	        }
	        // If batchSize is different to this.numberToReturn
	        if (this.batchSize !== this.numberToReturn)
	            this.numberToReturn = this.batchSize;
	        // Allocate write protocol header buffer
	        const header = Buffer.alloc(4 * 4 + // Header
	            4 + // Flags
	            Buffer.byteLength(this.ns) +
	            1 + // namespace
	            4 + // numberToSkip
	            4 // numberToReturn
	        );
	        // Add header to buffers
	        buffers.push(header);
	        // Serialize the query
	        const query = BSON.serialize(this.query, {
	            checkKeys: this.checkKeys,
	            serializeFunctions: this.serializeFunctions,
	            ignoreUndefined: this.ignoreUndefined
	        });
	        // Add query document
	        buffers.push(query);
	        if (this.returnFieldSelector && Object.keys(this.returnFieldSelector).length > 0) {
	            // Serialize the projection document
	            projection = BSON.serialize(this.returnFieldSelector, {
	                checkKeys: this.checkKeys,
	                serializeFunctions: this.serializeFunctions,
	                ignoreUndefined: this.ignoreUndefined
	            });
	            // Add projection document
	            buffers.push(projection);
	        }
	        // Total message size
	        const totalLength = header.length + query.length + (projection ? projection.length : 0);
	        // Set up the index
	        let index = 4;
	        // Write total document length
	        header[3] = (totalLength >> 24) & 0xff;
	        header[2] = (totalLength >> 16) & 0xff;
	        header[1] = (totalLength >> 8) & 0xff;
	        header[0] = totalLength & 0xff;
	        // Write header information requestId
	        header[index + 3] = (this.requestId >> 24) & 0xff;
	        header[index + 2] = (this.requestId >> 16) & 0xff;
	        header[index + 1] = (this.requestId >> 8) & 0xff;
	        header[index] = this.requestId & 0xff;
	        index = index + 4;
	        // Write header information responseTo
	        header[index + 3] = (0 >> 24) & 0xff;
	        header[index + 2] = (0 >> 16) & 0xff;
	        header[index + 1] = (0 >> 8) & 0xff;
	        header[index] = 0 & 0xff;
	        index = index + 4;
	        // Write header information OP_QUERY
	        header[index + 3] = (constants_1.OP_QUERY >> 24) & 0xff;
	        header[index + 2] = (constants_1.OP_QUERY >> 16) & 0xff;
	        header[index + 1] = (constants_1.OP_QUERY >> 8) & 0xff;
	        header[index] = constants_1.OP_QUERY & 0xff;
	        index = index + 4;
	        // Write header information flags
	        header[index + 3] = (flags >> 24) & 0xff;
	        header[index + 2] = (flags >> 16) & 0xff;
	        header[index + 1] = (flags >> 8) & 0xff;
	        header[index] = flags & 0xff;
	        index = index + 4;
	        // Write collection name
	        index = index + header.write(this.ns, index, 'utf8') + 1;
	        header[index - 1] = 0;
	        // Write header information flags numberToSkip
	        header[index + 3] = (this.numberToSkip >> 24) & 0xff;
	        header[index + 2] = (this.numberToSkip >> 16) & 0xff;
	        header[index + 1] = (this.numberToSkip >> 8) & 0xff;
	        header[index] = this.numberToSkip & 0xff;
	        index = index + 4;
	        // Write header information flags numberToReturn
	        header[index + 3] = (this.numberToReturn >> 24) & 0xff;
	        header[index + 2] = (this.numberToReturn >> 16) & 0xff;
	        header[index + 1] = (this.numberToReturn >> 8) & 0xff;
	        header[index] = this.numberToReturn & 0xff;
	        index = index + 4;
	        // Return the buffers
	        return buffers;
	    }
	}
	commands.OpQueryRequest = OpQueryRequest;
	/** @internal */
	class OpReply {
	    constructor(message, msgHeader, msgBody, opts) {
	        this.index = 0;
	        this.sections = [];
	        /** moreToCome is an OP_MSG only concept */
	        this.moreToCome = false;
	        this.parsed = false;
	        this.raw = message;
	        this.data = msgBody;
	        this.opts = opts ?? {
	            useBigInt64: false,
	            promoteLongs: true,
	            promoteValues: true,
	            promoteBuffers: false,
	            bsonRegExp: false
	        };
	        // Read the message header
	        this.length = msgHeader.length;
	        this.requestId = msgHeader.requestId;
	        this.responseTo = msgHeader.responseTo;
	        this.opCode = msgHeader.opCode;
	        this.fromCompressed = msgHeader.fromCompressed;
	        // Flag values
	        this.useBigInt64 = typeof this.opts.useBigInt64 === 'boolean' ? this.opts.useBigInt64 : false;
	        this.promoteLongs = typeof this.opts.promoteLongs === 'boolean' ? this.opts.promoteLongs : true;
	        this.promoteValues =
	            typeof this.opts.promoteValues === 'boolean' ? this.opts.promoteValues : true;
	        this.promoteBuffers =
	            typeof this.opts.promoteBuffers === 'boolean' ? this.opts.promoteBuffers : false;
	        this.bsonRegExp = typeof this.opts.bsonRegExp === 'boolean' ? this.opts.bsonRegExp : false;
	    }
	    isParsed() {
	        return this.parsed;
	    }
	    parse() {
	        // Don't parse again if not needed
	        if (this.parsed)
	            return this.sections[0];
	        // Position within OP_REPLY at which documents start
	        // (See https://www.mongodb.com/docs/manual/reference/mongodb-wire-protocol/#wire-op-reply)
	        this.index = 20;
	        // Read the message body
	        this.responseFlags = this.data.readInt32LE(0);
	        this.cursorId = new BSON.Long(this.data.readInt32LE(4), this.data.readInt32LE(8));
	        this.startingFrom = this.data.readInt32LE(12);
	        this.numberReturned = this.data.readInt32LE(16);
	        if (this.numberReturned < 0 || this.numberReturned > 2 ** 32 - 1) {
	            throw new RangeError(`OP_REPLY numberReturned is an invalid array length ${this.numberReturned}`);
	        }
	        this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
	        this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
	        this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
	        this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;
	        // Parse Body
	        for (let i = 0; i < this.numberReturned; i++) {
	            const bsonSize = this.data[this.index] |
	                (this.data[this.index + 1] << 8) |
	                (this.data[this.index + 2] << 16) |
	                (this.data[this.index + 3] << 24);
	            const section = this.data.subarray(this.index, this.index + bsonSize);
	            this.sections.push(section);
	            // Adjust the index
	            this.index = this.index + bsonSize;
	        }
	        // Set parsed
	        this.parsed = true;
	        return this.sections[0];
	    }
	}
	commands.OpReply = OpReply;
	// Msg Flags
	const OPTS_CHECKSUM_PRESENT = 1;
	const OPTS_MORE_TO_COME = 2;
	const OPTS_EXHAUST_ALLOWED = 1 << 16;
	/** @internal */
	class DocumentSequence {
	    constructor(documents) {
	        this.documents = documents;
	    }
	}
	commands.DocumentSequence = DocumentSequence;
	/** @internal */
	class OpMsgRequest {
	    constructor(databaseName, command, options) {
	        this.databaseName = databaseName;
	        this.command = command;
	        this.options = options;
	        // Basic options needed to be passed in
	        if (command == null)
	            throw new error_1.MongoInvalidArgumentError('Query document must be specified for query');
	        // Basic options
	        this.command.$db = databaseName;
	        // Ensure empty options
	        this.options = options ?? {};
	        // Additional options
	        this.requestId = options.requestId ? options.requestId : OpMsgRequest.getRequestId();
	        // Serialization option
	        this.serializeFunctions =
	            typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
	        this.ignoreUndefined =
	            typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;
	        this.checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
	        this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
	        // flags
	        this.checksumPresent = false;
	        this.moreToCome = options.moreToCome || false;
	        this.exhaustAllowed =
	            typeof options.exhaustAllowed === 'boolean' ? options.exhaustAllowed : false;
	    }
	    toBin() {
	        const buffers = [];
	        let flags = 0;
	        if (this.checksumPresent) {
	            flags |= OPTS_CHECKSUM_PRESENT;
	        }
	        if (this.moreToCome) {
	            flags |= OPTS_MORE_TO_COME;
	        }
	        if (this.exhaustAllowed) {
	            flags |= OPTS_EXHAUST_ALLOWED;
	        }
	        const header = Buffer.alloc(4 * 4 + // Header
	            4 // Flags
	        );
	        buffers.push(header);
	        let totalLength = header.length;
	        const command = this.command;
	        totalLength += this.makeSections(buffers, command);
	        header.writeInt32LE(totalLength, 0); // messageLength
	        header.writeInt32LE(this.requestId, 4); // requestID
	        header.writeInt32LE(0, 8); // responseTo
	        header.writeInt32LE(constants_1.OP_MSG, 12); // opCode
	        header.writeUInt32LE(flags, 16); // flags
	        return buffers;
	    }
	    /**
	     * Add the sections to the OP_MSG request's buffers and returns the length.
	     */
	    makeSections(buffers, document) {
	        const sequencesBuffer = this.extractDocumentSequences(document);
	        const payloadTypeBuffer = Buffer.allocUnsafe(1);
	        payloadTypeBuffer[0] = 0;
	        const documentBuffer = this.serializeBson(document);
	        // First section, type 0
	        buffers.push(payloadTypeBuffer);
	        buffers.push(documentBuffer);
	        // Subsequent sections, type 1
	        buffers.push(sequencesBuffer);
	        return payloadTypeBuffer.length + documentBuffer.length + sequencesBuffer.length;
	    }
	    /**
	     * Extracts the document sequences from the command document and returns
	     * a buffer to be added as multiple sections after the initial type 0
	     * section in the message.
	     */
	    extractDocumentSequences(document) {
	        // Pull out any field in the command document that's value is a document sequence.
	        const chunks = [];
	        for (const [key, value] of Object.entries(document)) {
	            if (value instanceof DocumentSequence) {
	                // Document sequences starts with type 1 at the first byte.
	                const buffer = Buffer.allocUnsafe(1 + 4 + key.length);
	                buffer[0] = 1;
	                // Third part is the field name at offset 5.
	                encodeUTF8Into(buffer, key, 5);
	                chunks.push(buffer);
	                // Fourth part are the documents' bytes.
	                let docsLength = 0;
	                for (const doc of value.documents) {
	                    const docBson = this.serializeBson(doc);
	                    docsLength += docBson.length;
	                    chunks.push(docBson);
	                }
	                // Second part of the sequence is the length at offset 1;
	                buffer.writeInt32LE(key.length + docsLength, 1);
	                // Why are we removing the field from the command? This is because it needs to be
	                // removed in the OP_MSG request first section, and DocumentSequence is not a
	                // BSON type and is specific to the MongoDB wire protocol so there's nothing
	                // our BSON serializer can do about this. Since DocumentSequence is not exposed
	                // in the public API and only used internally, we are never mutating an original
	                // command provided by the user, just our own, and it's cheaper to delete from
	                // our own command than copying it.
	                delete document[key];
	            }
	        }
	        if (chunks.length > 0) {
	            return Buffer.concat(chunks);
	        }
	        // If we have no document sequences we return an empty buffer for nothing to add
	        // to the payload.
	        return Buffer.alloc(0);
	    }
	    serializeBson(document) {
	        return BSON.serialize(document, {
	            checkKeys: this.checkKeys,
	            serializeFunctions: this.serializeFunctions,
	            ignoreUndefined: this.ignoreUndefined
	        });
	    }
	    static getRequestId() {
	        _requestId = (_requestId + 1) & 0x7fffffff;
	        return _requestId;
	    }
	}
	commands.OpMsgRequest = OpMsgRequest;
	/** @internal */
	class OpMsgResponse {
	    constructor(message, msgHeader, msgBody, opts) {
	        this.index = 0;
	        this.sections = [];
	        this.parsed = false;
	        this.raw = message;
	        this.data = msgBody;
	        this.opts = opts ?? {
	            useBigInt64: false,
	            promoteLongs: true,
	            promoteValues: true,
	            promoteBuffers: false,
	            bsonRegExp: false
	        };
	        // Read the message header
	        this.length = msgHeader.length;
	        this.requestId = msgHeader.requestId;
	        this.responseTo = msgHeader.responseTo;
	        this.opCode = msgHeader.opCode;
	        this.fromCompressed = msgHeader.fromCompressed;
	        // Read response flags
	        this.responseFlags = msgBody.readInt32LE(0);
	        this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
	        this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
	        this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
	        this.useBigInt64 = typeof this.opts.useBigInt64 === 'boolean' ? this.opts.useBigInt64 : false;
	        this.promoteLongs = typeof this.opts.promoteLongs === 'boolean' ? this.opts.promoteLongs : true;
	        this.promoteValues =
	            typeof this.opts.promoteValues === 'boolean' ? this.opts.promoteValues : true;
	        this.promoteBuffers =
	            typeof this.opts.promoteBuffers === 'boolean' ? this.opts.promoteBuffers : false;
	        this.bsonRegExp = typeof this.opts.bsonRegExp === 'boolean' ? this.opts.bsonRegExp : false;
	    }
	    isParsed() {
	        return this.parsed;
	    }
	    parse() {
	        // Don't parse again if not needed
	        if (this.parsed)
	            return this.sections[0];
	        this.index = 4;
	        while (this.index < this.data.length) {
	            const payloadType = this.data.readUInt8(this.index++);
	            if (payloadType === 0) {
	                const bsonSize = this.data.readUInt32LE(this.index);
	                const bin = this.data.subarray(this.index, this.index + bsonSize);
	                this.sections.push(bin);
	                this.index += bsonSize;
	            }
	            else if (payloadType === 1) {
	                // It was decided that no driver makes use of payload type 1
	                // TODO(NODE-3483): Replace with MongoDeprecationError
	                throw new error_1.MongoRuntimeError('OP_MSG Payload Type 1 detected unsupported protocol');
	            }
	        }
	        this.parsed = true;
	        return this.sections[0];
	    }
	}
	commands.OpMsgResponse = OpMsgResponse;
	const MESSAGE_HEADER_SIZE = 16;
	const COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID
	/**
	 * @internal
	 *
	 * An OP_COMPRESSED request wraps either an OP_QUERY or OP_MSG message.
	 */
	class OpCompressedRequest {
	    constructor(command, options) {
	        this.command = command;
	        this.options = options;
	    }
	    // Return whether a command contains an uncompressible command term
	    // Will return true if command contains no uncompressible command terms
	    static canCompress(command) {
	        const commandDoc = command instanceof OpMsgRequest ? command.command : command.query;
	        const commandName = Object.keys(commandDoc)[0];
	        return !compression_1.uncompressibleCommands.has(commandName);
	    }
	    async toBin() {
	        const concatenatedOriginalCommandBuffer = Buffer.concat(this.command.toBin());
	        // otherwise, compress the message
	        const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
	        // Extract information needed for OP_COMPRESSED from the uncompressed message
	        const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
	        // Compress the message body
	        const compressedMessage = await (0, compression_1.compress)(this.options, messageToBeCompressed);
	        // Create the msgHeader of OP_COMPRESSED
	        const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
	        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength
	        msgHeader.writeInt32LE(this.command.requestId, 4); // requestID
	        msgHeader.writeInt32LE(0, 8); // responseTo (zero)
	        msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12); // opCode
	        // Create the compression details of OP_COMPRESSED
	        const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
	        compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode
	        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader
	        compressionDetails.writeUInt8(compression_1.Compressor[this.options.agreedCompressor], 8); // compressorID
	        return [msgHeader, compressionDetails, compressedMessage];
	    }
	}
	commands.OpCompressedRequest = OpCompressedRequest;
	
	return commands;
}

var hasRequiredCompression;

function requireCompression () {
	if (hasRequiredCompression) return compression;
	hasRequiredCompression = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.uncompressibleCommands = exports.Compressor = void 0;
		exports.compress = compress;
		exports.decompress = decompress;
		exports.compressCommand = compressCommand;
		exports.decompressResponse = decompressResponse;
		const util_1 = require$$0$6;
		const zlib$1 = zlib;
		const constants_1 = requireConstants();
		const deps_1 = requireDeps();
		const error_1 = requireError();
		const commands_1 = requireCommands();
		const constants_2 = requireConstants$1();
		/** @public */
		exports.Compressor = Object.freeze({
		    none: 0,
		    snappy: 1,
		    zlib: 2,
		    zstd: 3
		});
		exports.uncompressibleCommands = new Set([
		    constants_1.LEGACY_HELLO_COMMAND,
		    'saslStart',
		    'saslContinue',
		    'getnonce',
		    'authenticate',
		    'createUser',
		    'updateUser',
		    'copydbSaslStart',
		    'copydbgetnonce',
		    'copydb'
		]);
		const ZSTD_COMPRESSION_LEVEL = 3;
		const zlibInflate = (0, util_1.promisify)(zlib$1.inflate.bind(zlib$1));
		const zlibDeflate = (0, util_1.promisify)(zlib$1.deflate.bind(zlib$1));
		let zstd;
		let Snappy = null;
		function loadSnappy() {
		    if (Snappy == null) {
		        const snappyImport = (0, deps_1.getSnappy)();
		        if ('kModuleError' in snappyImport) {
		            throw snappyImport.kModuleError;
		        }
		        Snappy = snappyImport;
		    }
		    return Snappy;
		}
		// Facilitate compressing a message using an agreed compressor
		async function compress(options, dataToBeCompressed) {
		    const zlibOptions = {};
		    switch (options.agreedCompressor) {
		        case 'snappy': {
		            Snappy ??= loadSnappy();
		            return await Snappy.compress(dataToBeCompressed);
		        }
		        case 'zstd': {
		            loadZstd();
		            if ('kModuleError' in zstd) {
		                throw zstd['kModuleError'];
		            }
		            return await zstd.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL);
		        }
		        case 'zlib': {
		            if (options.zlibCompressionLevel) {
		                zlibOptions.level = options.zlibCompressionLevel;
		            }
		            return await zlibDeflate(dataToBeCompressed, zlibOptions);
		        }
		        default: {
		            throw new error_1.MongoInvalidArgumentError(`Unknown compressor ${options.agreedCompressor} failed to compress`);
		        }
		    }
		}
		// Decompress a message using the given compressor
		async function decompress(compressorID, compressedData) {
		    if (compressorID !== exports.Compressor.snappy &&
		        compressorID !== exports.Compressor.zstd &&
		        compressorID !== exports.Compressor.zlib &&
		        compressorID !== exports.Compressor.none) {
		        throw new error_1.MongoDecompressionError(`Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`);
		    }
		    switch (compressorID) {
		        case exports.Compressor.snappy: {
		            Snappy ??= loadSnappy();
		            return await Snappy.uncompress(compressedData, { asBuffer: true });
		        }
		        case exports.Compressor.zstd: {
		            loadZstd();
		            if ('kModuleError' in zstd) {
		                throw zstd['kModuleError'];
		            }
		            return await zstd.decompress(compressedData);
		        }
		        case exports.Compressor.zlib: {
		            return await zlibInflate(compressedData);
		        }
		        default: {
		            return compressedData;
		        }
		    }
		}
		/**
		 * Load ZStandard if it is not already set.
		 */
		function loadZstd() {
		    if (!zstd) {
		        zstd = (0, deps_1.getZstdLibrary)();
		    }
		}
		const MESSAGE_HEADER_SIZE = 16;
		/**
		 * @internal
		 *
		 * Compresses an OP_MSG or OP_QUERY message, if compression is configured.  This method
		 * also serializes the command to BSON.
		 */
		async function compressCommand(command, description) {
		    const finalCommand = description.agreedCompressor === 'none' || !commands_1.OpCompressedRequest.canCompress(command)
		        ? command
		        : new commands_1.OpCompressedRequest(command, {
		            agreedCompressor: description.agreedCompressor ?? 'none',
		            zlibCompressionLevel: description.zlibCompressionLevel ?? 0
		        });
		    const data = await finalCommand.toBin();
		    return Buffer.concat(data);
		}
		/**
		 * @internal
		 *
		 * Decompresses an OP_MSG or OP_QUERY response from the server, if compression is configured.
		 *
		 * This method does not parse the response's BSON.
		 */
		async function decompressResponse(message) {
		    const messageHeader = {
		        length: message.readInt32LE(0),
		        requestId: message.readInt32LE(4),
		        responseTo: message.readInt32LE(8),
		        opCode: message.readInt32LE(12)
		    };
		    if (messageHeader.opCode !== constants_2.OP_COMPRESSED) {
		        const ResponseType = messageHeader.opCode === constants_2.OP_MSG ? commands_1.OpMsgResponse : commands_1.OpReply;
		        const messageBody = message.subarray(MESSAGE_HEADER_SIZE);
		        return new ResponseType(message, messageHeader, messageBody);
		    }
		    const header = {
		        ...messageHeader,
		        fromCompressed: true,
		        opCode: message.readInt32LE(MESSAGE_HEADER_SIZE),
		        length: message.readInt32LE(MESSAGE_HEADER_SIZE + 4)
		    };
		    const compressorID = message[MESSAGE_HEADER_SIZE + 8];
		    const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);
		    // recalculate based on wrapped opcode
		    const ResponseType = header.opCode === constants_2.OP_MSG ? commands_1.OpMsgResponse : commands_1.OpReply;
		    const messageBody = await decompress(compressorID, compressedBuffer);
		    if (messageBody.length !== header.length) {
		        throw new error_1.MongoDecompressionError('Message body and message header must be the same length');
		    }
		    return new ResponseType(message, header, messageBody);
		}
		
	} (compression));
	return compression;
}

var encrypter = {};

var auto_encrypter = {};

var client_encryption = {};

var crypto_callbacks = {};

var hasRequiredCrypto_callbacks;

function requireCrypto_callbacks () {
	if (hasRequiredCrypto_callbacks) return crypto_callbacks;
	hasRequiredCrypto_callbacks = 1;
	Object.defineProperty(crypto_callbacks, "__esModule", { value: true });
	crypto_callbacks.hmacSha256Hook = crypto_callbacks.hmacSha512Hook = crypto_callbacks.aes256CtrDecryptHook = crypto_callbacks.aes256CtrEncryptHook = crypto_callbacks.aes256CbcDecryptHook = crypto_callbacks.aes256CbcEncryptHook = void 0;
	crypto_callbacks.makeAES256Hook = makeAES256Hook;
	crypto_callbacks.randomHook = randomHook;
	crypto_callbacks.sha256Hook = sha256Hook;
	crypto_callbacks.makeHmacHook = makeHmacHook;
	crypto_callbacks.signRsaSha256Hook = signRsaSha256Hook;
	const crypto = require$$0$c;
	function makeAES256Hook(method, mode) {
	    return function (key, iv, input, output) {
	        let result;
	        try {
	            const cipher = crypto[method](mode, key, iv);
	            cipher.setAutoPadding(false);
	            result = cipher.update(input);
	            const final = cipher.final();
	            if (final.length > 0) {
	                result = Buffer.concat([result, final]);
	            }
	        }
	        catch (e) {
	            return e;
	        }
	        result.copy(output);
	        return result.length;
	    };
	}
	function randomHook(buffer, count) {
	    try {
	        crypto.randomFillSync(buffer, 0, count);
	    }
	    catch (e) {
	        return e;
	    }
	    return count;
	}
	function sha256Hook(input, output) {
	    let result;
	    try {
	        result = crypto.createHash('sha256').update(input).digest();
	    }
	    catch (e) {
	        return e;
	    }
	    result.copy(output);
	    return result.length;
	}
	function makeHmacHook(algorithm) {
	    return (key, input, output) => {
	        let result;
	        try {
	            result = crypto.createHmac(algorithm, key).update(input).digest();
	        }
	        catch (e) {
	            return e;
	        }
	        result.copy(output);
	        return result.length;
	    };
	}
	function signRsaSha256Hook(key, input, output) {
	    let result;
	    try {
	        const signer = crypto.createSign('sha256WithRSAEncryption');
	        const privateKey = Buffer.from(`-----BEGIN PRIVATE KEY-----\n${key.toString('base64')}\n-----END PRIVATE KEY-----\n`);
	        result = signer.update(input).end().sign(privateKey);
	    }
	    catch (e) {
	        return e;
	    }
	    result.copy(output);
	    return result.length;
	}
	crypto_callbacks.aes256CbcEncryptHook = makeAES256Hook('createCipheriv', 'aes-256-cbc');
	crypto_callbacks.aes256CbcDecryptHook = makeAES256Hook('createDecipheriv', 'aes-256-cbc');
	crypto_callbacks.aes256CtrEncryptHook = makeAES256Hook('createCipheriv', 'aes-256-ctr');
	crypto_callbacks.aes256CtrDecryptHook = makeAES256Hook('createDecipheriv', 'aes-256-ctr');
	crypto_callbacks.hmacSha512Hook = makeHmacHook('sha512');
	crypto_callbacks.hmacSha256Hook = makeHmacHook('sha256');
	
	return crypto_callbacks;
}

var errors$1 = {};

var hasRequiredErrors$1;

function requireErrors$1 () {
	if (hasRequiredErrors$1) return errors$1;
	hasRequiredErrors$1 = 1;
	Object.defineProperty(errors$1, "__esModule", { value: true });
	errors$1.MongoCryptKMSRequestNetworkTimeoutError = errors$1.MongoCryptAzureKMSRequestError = errors$1.MongoCryptCreateEncryptedCollectionError = errors$1.MongoCryptCreateDataKeyError = errors$1.MongoCryptInvalidArgumentError = errors$1.MongoCryptError = void 0;
	const error_1 = requireError();
	/**
	 * @public
	 * An error indicating that something went wrong specifically with MongoDB Client Encryption
	 */
	class MongoCryptError extends error_1.MongoError {
	    /**
	     * **Do not use this constructor!**
	     *
	     * Meant for internal use only.
	     *
	     * @remarks
	     * This class is only meant to be constructed within the driver. This constructor is
	     * not subject to semantic versioning compatibility guarantees and may change at any time.
	     *
	     * @public
	     **/
	    constructor(message, options = {}) {
	        super(message, options);
	    }
	    get name() {
	        return 'MongoCryptError';
	    }
	}
	errors$1.MongoCryptError = MongoCryptError;
	/**
	 * @public
	 *
	 * An error indicating an invalid argument was provided to an encryption API.
	 */
	class MongoCryptInvalidArgumentError extends MongoCryptError {
	    /**
	     * **Do not use this constructor!**
	     *
	     * Meant for internal use only.
	     *
	     * @remarks
	     * This class is only meant to be constructed within the driver. This constructor is
	     * not subject to semantic versioning compatibility guarantees and may change at any time.
	     *
	     * @public
	     **/
	    constructor(message) {
	        super(message);
	    }
	    get name() {
	        return 'MongoCryptInvalidArgumentError';
	    }
	}
	errors$1.MongoCryptInvalidArgumentError = MongoCryptInvalidArgumentError;
	/**
	 * @public
	 * An error indicating that `ClientEncryption.createEncryptedCollection()` failed to create data keys
	 */
	class MongoCryptCreateDataKeyError extends MongoCryptError {
	    /**
	     * **Do not use this constructor!**
	     *
	     * Meant for internal use only.
	     *
	     * @remarks
	     * This class is only meant to be constructed within the driver. This constructor is
	     * not subject to semantic versioning compatibility guarantees and may change at any time.
	     *
	     * @public
	     **/
	    constructor(encryptedFields, { cause }) {
	        super(`Unable to complete creating data keys: ${cause.message}`, { cause });
	        this.encryptedFields = encryptedFields;
	    }
	    get name() {
	        return 'MongoCryptCreateDataKeyError';
	    }
	}
	errors$1.MongoCryptCreateDataKeyError = MongoCryptCreateDataKeyError;
	/**
	 * @public
	 * An error indicating that `ClientEncryption.createEncryptedCollection()` failed to create a collection
	 */
	class MongoCryptCreateEncryptedCollectionError extends MongoCryptError {
	    /**
	     * **Do not use this constructor!**
	     *
	     * Meant for internal use only.
	     *
	     * @remarks
	     * This class is only meant to be constructed within the driver. This constructor is
	     * not subject to semantic versioning compatibility guarantees and may change at any time.
	     *
	     * @public
	     **/
	    constructor(encryptedFields, { cause }) {
	        super(`Unable to create collection: ${cause.message}`, { cause });
	        this.encryptedFields = encryptedFields;
	    }
	    get name() {
	        return 'MongoCryptCreateEncryptedCollectionError';
	    }
	}
	errors$1.MongoCryptCreateEncryptedCollectionError = MongoCryptCreateEncryptedCollectionError;
	/**
	 * @public
	 * An error indicating that mongodb-client-encryption failed to auto-refresh Azure KMS credentials.
	 */
	class MongoCryptAzureKMSRequestError extends MongoCryptError {
	    /**
	     * **Do not use this constructor!**
	     *
	     * Meant for internal use only.
	     *
	     * @remarks
	     * This class is only meant to be constructed within the driver. This constructor is
	     * not subject to semantic versioning compatibility guarantees and may change at any time.
	     *
	     * @public
	     **/
	    constructor(message, body) {
	        super(message);
	        this.body = body;
	    }
	    get name() {
	        return 'MongoCryptAzureKMSRequestError';
	    }
	}
	errors$1.MongoCryptAzureKMSRequestError = MongoCryptAzureKMSRequestError;
	/** @public */
	class MongoCryptKMSRequestNetworkTimeoutError extends MongoCryptError {
	    get name() {
	        return 'MongoCryptKMSRequestNetworkTimeoutError';
	    }
	}
	errors$1.MongoCryptKMSRequestNetworkTimeoutError = MongoCryptKMSRequestNetworkTimeoutError;
	
	return errors$1;
}

var providers = {};

var aws = {};

var aws_temporary_credentials = {};

var hasRequiredAws_temporary_credentials;

function requireAws_temporary_credentials () {
	if (hasRequiredAws_temporary_credentials) return aws_temporary_credentials;
	hasRequiredAws_temporary_credentials = 1;
	Object.defineProperty(aws_temporary_credentials, "__esModule", { value: true });
	aws_temporary_credentials.LegacyAWSTemporaryCredentialProvider = aws_temporary_credentials.AWSSDKCredentialProvider = aws_temporary_credentials.AWSTemporaryCredentialProvider = void 0;
	const deps_1 = requireDeps();
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	const AWS_RELATIVE_URI = 'http://169.254.170.2';
	const AWS_EC2_URI = 'http://169.254.169.254';
	const AWS_EC2_PATH = '/latest/meta-data/iam/security-credentials';
	/**
	 * @internal
	 *
	 * Fetches temporary AWS credentials.
	 */
	class AWSTemporaryCredentialProvider {
	    static get awsSDK() {
	        AWSTemporaryCredentialProvider._awsSDK ??= (0, deps_1.getAwsCredentialProvider)();
	        return AWSTemporaryCredentialProvider._awsSDK;
	    }
	    static get isAWSSDKInstalled() {
	        return !('kModuleError' in AWSTemporaryCredentialProvider.awsSDK);
	    }
	}
	aws_temporary_credentials.AWSTemporaryCredentialProvider = AWSTemporaryCredentialProvider;
	/** @internal */
	class AWSSDKCredentialProvider extends AWSTemporaryCredentialProvider {
	    /**
	     * The AWS SDK caches credentials automatically and handles refresh when the credentials have expired.
	     * To ensure this occurs, we need to cache the `provider` returned by the AWS sdk and re-use it when fetching credentials.
	     */
	    get provider() {
	        if ('kModuleError' in AWSTemporaryCredentialProvider.awsSDK) {
	            throw AWSTemporaryCredentialProvider.awsSDK.kModuleError;
	        }
	        if (this._provider) {
	            return this._provider;
	        }
	        let { AWS_STS_REGIONAL_ENDPOINTS = '', AWS_REGION = '' } = process.env;
	        AWS_STS_REGIONAL_ENDPOINTS = AWS_STS_REGIONAL_ENDPOINTS.toLowerCase();
	        AWS_REGION = AWS_REGION.toLowerCase();
	        /** The option setting should work only for users who have explicit settings in their environment, the driver should not encode "defaults" */
	        const awsRegionSettingsExist = AWS_REGION.length !== 0 && AWS_STS_REGIONAL_ENDPOINTS.length !== 0;
	        /**
	         * The following regions use the global AWS STS endpoint, sts.amazonaws.com, by default
	         * https://docs.aws.amazon.com/sdkref/latest/guide/feature-sts-regionalized-endpoints.html
	         */
	        const LEGACY_REGIONS = new Set([
	            'ap-northeast-1',
	            'ap-south-1',
	            'ap-southeast-1',
	            'ap-southeast-2',
	            'aws-global',
	            'ca-central-1',
	            'eu-central-1',
	            'eu-north-1',
	            'eu-west-1',
	            'eu-west-2',
	            'eu-west-3',
	            'sa-east-1',
	            'us-east-1',
	            'us-east-2',
	            'us-west-1',
	            'us-west-2'
	        ]);
	        /**
	         * If AWS_STS_REGIONAL_ENDPOINTS is set to regional, users are opting into the new behavior of respecting the region settings
	         *
	         * If AWS_STS_REGIONAL_ENDPOINTS is set to legacy, then "old" regions need to keep using the global setting.
	         * Technically the SDK gets this wrong, it reaches out to 'sts.us-east-1.amazonaws.com' when it should be 'sts.amazonaws.com'.
	         * That is not our bug to fix here. We leave that up to the SDK.
	         */
	        const useRegionalSts = AWS_STS_REGIONAL_ENDPOINTS === 'regional' ||
	            (AWS_STS_REGIONAL_ENDPOINTS === 'legacy' && !LEGACY_REGIONS.has(AWS_REGION));
	        this._provider =
	            awsRegionSettingsExist && useRegionalSts
	                ? AWSTemporaryCredentialProvider.awsSDK.fromNodeProviderChain({
	                    clientConfig: { region: AWS_REGION }
	                })
	                : AWSTemporaryCredentialProvider.awsSDK.fromNodeProviderChain();
	        return this._provider;
	    }
	    async getCredentials() {
	        /*
	         * Creates a credential provider that will attempt to find credentials from the
	         * following sources (listed in order of precedence):
	         *
	         * - Environment variables exposed via process.env
	         * - SSO credentials from token cache
	         * - Web identity token credentials
	         * - Shared credentials and config ini files
	         * - The EC2/ECS Instance Metadata Service
	         */
	        try {
	            const creds = await this.provider();
	            return {
	                AccessKeyId: creds.accessKeyId,
	                SecretAccessKey: creds.secretAccessKey,
	                Token: creds.sessionToken,
	                Expiration: creds.expiration
	            };
	        }
	        catch (error) {
	            throw new error_1.MongoAWSError(error.message, { cause: error });
	        }
	    }
	}
	aws_temporary_credentials.AWSSDKCredentialProvider = AWSSDKCredentialProvider;
	/**
	 * @internal
	 * Fetches credentials manually (without the AWS SDK), as outlined in the [Obtaining Credentials](https://github.com/mongodb/specifications/blob/master/source/auth/auth.md#obtaining-credentials)
	 * section of the Auth spec.
	 */
	class LegacyAWSTemporaryCredentialProvider extends AWSTemporaryCredentialProvider {
	    async getCredentials() {
	        // If the environment variable AWS_CONTAINER_CREDENTIALS_RELATIVE_URI
	        // is set then drivers MUST assume that it was set by an AWS ECS agent
	        if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
	            return await (0, utils_1.request)(`${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`);
	        }
	        // Otherwise assume we are on an EC2 instance
	        // get a token
	        const token = await (0, utils_1.request)(`${AWS_EC2_URI}/latest/api/token`, {
	            method: 'PUT',
	            json: false,
	            headers: { 'X-aws-ec2-metadata-token-ttl-seconds': 30 }
	        });
	        // get role name
	        const roleName = await (0, utils_1.request)(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, {
	            json: false,
	            headers: { 'X-aws-ec2-metadata-token': token }
	        });
	        // get temp credentials
	        const creds = await (0, utils_1.request)(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, {
	            headers: { 'X-aws-ec2-metadata-token': token }
	        });
	        return creds;
	    }
	}
	aws_temporary_credentials.LegacyAWSTemporaryCredentialProvider = LegacyAWSTemporaryCredentialProvider;
	
	return aws_temporary_credentials;
}

var hasRequiredAws;

function requireAws () {
	if (hasRequiredAws) return aws;
	hasRequiredAws = 1;
	Object.defineProperty(aws, "__esModule", { value: true });
	aws.loadAWSCredentials = loadAWSCredentials;
	const aws_temporary_credentials_1 = requireAws_temporary_credentials();
	/**
	 * @internal
	 */
	async function loadAWSCredentials(kmsProviders) {
	    const credentialProvider = new aws_temporary_credentials_1.AWSSDKCredentialProvider();
	    // We shouldn't ever receive a response from the AWS SDK that doesn't have a `SecretAccessKey`
	    // or `AccessKeyId`.  However, TS says these fields are optional.  We provide empty strings
	    // and let libmongocrypt error if we're unable to fetch the required keys.
	    const { SecretAccessKey = '', AccessKeyId = '', Token } = await credentialProvider.getCredentials();
	    const aws = {
	        secretAccessKey: SecretAccessKey,
	        accessKeyId: AccessKeyId
	    };
	    // the AWS session token is only required for temporary credentials so only attach it to the
	    // result if it's present in the response from the aws sdk
	    Token != null && (aws.sessionToken = Token);
	    return { ...kmsProviders, aws };
	}
	
	return aws;
}

var azure = {};

var hasRequiredAzure;

function requireAzure () {
	if (hasRequiredAzure) return azure;
	hasRequiredAzure = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.tokenCache = exports.AzureCredentialCache = exports.AZURE_BASE_URL = void 0;
		exports.addAzureParams = addAzureParams;
		exports.prepareRequest = prepareRequest;
		exports.fetchAzureKMSToken = fetchAzureKMSToken;
		exports.loadAzureCredentials = loadAzureCredentials;
		const error_1 = requireError();
		const utils_1 = requireUtils$1();
		const errors_1 = requireErrors$1();
		const MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS = 6000;
		/** Base URL for getting Azure tokens. */
		exports.AZURE_BASE_URL = 'http://169.254.169.254/metadata/identity/oauth2/token?';
		/**
		 * @internal
		 */
		class AzureCredentialCache {
		    constructor() {
		        this.cachedToken = null;
		    }
		    async getToken() {
		        if (this.cachedToken == null || this.needsRefresh(this.cachedToken)) {
		            this.cachedToken = await this._getToken();
		        }
		        return { accessToken: this.cachedToken.accessToken };
		    }
		    needsRefresh(token) {
		        const timeUntilExpirationMS = token.expiresOnTimestamp - Date.now();
		        return timeUntilExpirationMS <= MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS;
		    }
		    /**
		     * exposed for testing
		     */
		    resetCache() {
		        this.cachedToken = null;
		    }
		    /**
		     * exposed for testing
		     */
		    _getToken() {
		        return fetchAzureKMSToken();
		    }
		}
		exports.AzureCredentialCache = AzureCredentialCache;
		/** @internal */
		exports.tokenCache = new AzureCredentialCache();
		/** @internal */
		async function parseResponse(response) {
		    const { status, body: rawBody } = response;
		    const body = (() => {
		        try {
		            return JSON.parse(rawBody);
		        }
		        catch {
		            throw new errors_1.MongoCryptAzureKMSRequestError('Malformed JSON body in GET request.');
		        }
		    })();
		    if (status !== 200) {
		        throw new errors_1.MongoCryptAzureKMSRequestError('Unable to complete request.', body);
		    }
		    if (!body.access_token) {
		        throw new errors_1.MongoCryptAzureKMSRequestError('Malformed response body - missing field `access_token`.');
		    }
		    if (!body.expires_in) {
		        throw new errors_1.MongoCryptAzureKMSRequestError('Malformed response body - missing field `expires_in`.');
		    }
		    const expiresInMS = Number(body.expires_in) * 1000;
		    if (Number.isNaN(expiresInMS)) {
		        throw new errors_1.MongoCryptAzureKMSRequestError('Malformed response body - unable to parse int from `expires_in` field.');
		    }
		    return {
		        accessToken: body.access_token,
		        expiresOnTimestamp: Date.now() + expiresInMS
		    };
		}
		/**
		 * @internal
		 * Get the Azure endpoint URL.
		 */
		function addAzureParams(url, resource, username) {
		    url.searchParams.append('api-version', '2018-02-01');
		    url.searchParams.append('resource', resource);
		    if (username) {
		        url.searchParams.append('client_id', username);
		    }
		    return url;
		}
		/**
		 * @internal
		 *
		 * parses any options provided by prose tests to `fetchAzureKMSToken` and merges them with
		 * the default values for headers and the request url.
		 */
		function prepareRequest(options) {
		    const url = new URL(options.url?.toString() ?? exports.AZURE_BASE_URL);
		    addAzureParams(url, 'https://vault.azure.net');
		    const headers = { ...options.headers, 'Content-Type': 'application/json', Metadata: true };
		    return { headers, url };
		}
		/**
		 * @internal
		 *
		 * `AzureKMSRequestOptions` allows prose tests to modify the http request sent to the idms
		 * servers.  This is required to simulate different server conditions.  No options are expected to
		 * be set outside of tests.
		 *
		 * exposed for CSFLE
		 * [prose test 18](https://github.com/mongodb/specifications/tree/master/source/client-side-encryption/tests#azure-imds-credentials)
		 */
		async function fetchAzureKMSToken(options = {}) {
		    const { headers, url } = prepareRequest(options);
		    try {
		        const response = await (0, utils_1.get)(url, { headers });
		        return await parseResponse(response);
		    }
		    catch (error) {
		        if (error instanceof error_1.MongoNetworkTimeoutError) {
		            throw new errors_1.MongoCryptAzureKMSRequestError(`[Azure KMS] ${error.message}`);
		        }
		        throw error;
		    }
		}
		/**
		 * @internal
		 *
		 * @throws Will reject with a `MongoCryptError` if the http request fails or the http response is malformed.
		 */
		async function loadAzureCredentials(kmsProviders) {
		    const azure = await exports.tokenCache.getToken();
		    return { ...kmsProviders, azure };
		}
		
	} (azure));
	return azure;
}

var gcp = {};

var hasRequiredGcp;

function requireGcp () {
	if (hasRequiredGcp) return gcp;
	hasRequiredGcp = 1;
	Object.defineProperty(gcp, "__esModule", { value: true });
	gcp.loadGCPCredentials = loadGCPCredentials;
	const deps_1 = requireDeps();
	/** @internal */
	async function loadGCPCredentials(kmsProviders) {
	    const gcpMetadata = (0, deps_1.getGcpMetadata)();
	    if ('kModuleError' in gcpMetadata) {
	        return kmsProviders;
	    }
	    const { access_token: accessToken } = await gcpMetadata.instance({
	        property: 'service-accounts/default/token'
	    });
	    return { ...kmsProviders, gcp: { accessToken } };
	}
	
	return gcp;
}

var hasRequiredProviders;

function requireProviders () {
	if (hasRequiredProviders) return providers;
	hasRequiredProviders = 1;
	Object.defineProperty(providers, "__esModule", { value: true });
	providers.isEmptyCredentials = isEmptyCredentials;
	providers.refreshKMSCredentials = refreshKMSCredentials;
	const aws_1 = requireAws();
	const azure_1 = requireAzure();
	const gcp_1 = requireGcp();
	/**
	 * Auto credential fetching should only occur when the provider is defined on the kmsProviders map
	 * and the settings are an empty object.
	 *
	 * This is distinct from a nullish provider key.
	 *
	 * @internal - exposed for testing purposes only
	 */
	function isEmptyCredentials(providerName, kmsProviders) {
	    const provider = kmsProviders[providerName];
	    if (provider == null) {
	        return false;
	    }
	    return typeof provider === 'object' && Object.keys(provider).length === 0;
	}
	/**
	 * Load cloud provider credentials for the user provided KMS providers.
	 * Credentials will only attempt to get loaded if they do not exist
	 * and no existing credentials will get overwritten.
	 *
	 * @internal
	 */
	async function refreshKMSCredentials(kmsProviders) {
	    let finalKMSProviders = kmsProviders;
	    if (isEmptyCredentials('aws', kmsProviders)) {
	        finalKMSProviders = await (0, aws_1.loadAWSCredentials)(finalKMSProviders);
	    }
	    if (isEmptyCredentials('gcp', kmsProviders)) {
	        finalKMSProviders = await (0, gcp_1.loadGCPCredentials)(finalKMSProviders);
	    }
	    if (isEmptyCredentials('azure', kmsProviders)) {
	        finalKMSProviders = await (0, azure_1.loadAzureCredentials)(finalKMSProviders);
	    }
	    return finalKMSProviders;
	}
	
	return providers;
}

var state_machine = {};

var hasRequiredState_machine;

function requireState_machine () {
	if (hasRequiredState_machine) return state_machine;
	hasRequiredState_machine = 1;
	Object.defineProperty(state_machine, "__esModule", { value: true });
	state_machine.StateMachine = void 0;
	const fs = require$$0$f;
	const net = require$$0$7;
	const tls = require$$2$3;
	const bson_1 = requireBson();
	const deps_1 = requireDeps();
	const utils_1 = requireUtils$1();
	const client_encryption_1 = requireClient_encryption();
	const errors_1 = requireErrors$1();
	let socks = null;
	function loadSocks() {
	    if (socks == null) {
	        const socksImport = (0, deps_1.getSocks)();
	        if ('kModuleError' in socksImport) {
	            throw socksImport.kModuleError;
	        }
	        socks = socksImport;
	    }
	    return socks;
	}
	// libmongocrypt states
	const MONGOCRYPT_CTX_ERROR = 0;
	const MONGOCRYPT_CTX_NEED_MONGO_COLLINFO = 1;
	const MONGOCRYPT_CTX_NEED_MONGO_MARKINGS = 2;
	const MONGOCRYPT_CTX_NEED_MONGO_KEYS = 3;
	const MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS = 7;
	const MONGOCRYPT_CTX_NEED_KMS = 4;
	const MONGOCRYPT_CTX_READY = 5;
	const MONGOCRYPT_CTX_DONE = 6;
	const HTTPS_PORT = 443;
	const stateToString = new Map([
	    [MONGOCRYPT_CTX_ERROR, 'MONGOCRYPT_CTX_ERROR'],
	    [MONGOCRYPT_CTX_NEED_MONGO_COLLINFO, 'MONGOCRYPT_CTX_NEED_MONGO_COLLINFO'],
	    [MONGOCRYPT_CTX_NEED_MONGO_MARKINGS, 'MONGOCRYPT_CTX_NEED_MONGO_MARKINGS'],
	    [MONGOCRYPT_CTX_NEED_MONGO_KEYS, 'MONGOCRYPT_CTX_NEED_MONGO_KEYS'],
	    [MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS, 'MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS'],
	    [MONGOCRYPT_CTX_NEED_KMS, 'MONGOCRYPT_CTX_NEED_KMS'],
	    [MONGOCRYPT_CTX_READY, 'MONGOCRYPT_CTX_READY'],
	    [MONGOCRYPT_CTX_DONE, 'MONGOCRYPT_CTX_DONE']
	]);
	const INSECURE_TLS_OPTIONS = [
	    'tlsInsecure',
	    'tlsAllowInvalidCertificates',
	    'tlsAllowInvalidHostnames',
	    // These options are disallowed by the spec, so we explicitly filter them out if provided, even
	    // though the StateMachine does not declare support for these options.
	    'tlsDisableOCSPEndpointCheck',
	    'tlsDisableCertificateRevocationCheck'
	];
	/**
	 * Helper function for logging. Enabled by setting the environment flag MONGODB_CRYPT_DEBUG.
	 * @param msg - Anything you want to be logged.
	 */
	function debug(msg) {
	    if (process.env.MONGODB_CRYPT_DEBUG) {
	        // eslint-disable-next-line no-console
	        console.error(msg);
	    }
	}
	/**
	 * This is kind of a hack.  For `rewrapManyDataKey`, we have tests that
	 * guarantee that when there are no matching keys, `rewrapManyDataKey` returns
	 * nothing.  We also have tests for auto encryption that guarantee for `encrypt`
	 * we return an error when there are no matching keys.  This error is generated in
	 * subsequent iterations of the state machine.
	 * Some apis (`encrypt`) throw if there are no filter matches and others (`rewrapManyDataKey`)
	 * do not.  We set the result manually here, and let the state machine continue.  `libmongocrypt`
	 * will inform us if we need to error by setting the state to `MONGOCRYPT_CTX_ERROR` but
	 * otherwise we'll return `{ v: [] }`.
	 */
	let EMPTY_V;
	/**
	 * @internal
	 * An internal class that executes across a MongoCryptContext until either
	 * a finishing state or an error is reached. Do not instantiate directly.
	 */
	class StateMachine {
	    constructor(options, bsonOptions = (0, bson_1.pluckBSONSerializeOptions)(options)) {
	        this.options = options;
	        this.bsonOptions = bsonOptions;
	    }
	    /**
	     * Executes the state machine according to the specification
	     */
	    async execute(executor, context) {
	        const keyVaultNamespace = executor._keyVaultNamespace;
	        const keyVaultClient = executor._keyVaultClient;
	        const metaDataClient = executor._metaDataClient;
	        const mongocryptdClient = executor._mongocryptdClient;
	        const mongocryptdManager = executor._mongocryptdManager;
	        let result = null;
	        while (context.state !== MONGOCRYPT_CTX_DONE && context.state !== MONGOCRYPT_CTX_ERROR) {
	            debug(`[context#${context.id}] ${stateToString.get(context.state) || context.state}`);
	            switch (context.state) {
	                case MONGOCRYPT_CTX_NEED_MONGO_COLLINFO: {
	                    const filter = (0, bson_1.deserialize)(context.nextMongoOperation());
	                    if (!metaDataClient) {
	                        throw new errors_1.MongoCryptError('unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_COLLINFO but metadata client is undefined');
	                    }
	                    const collInfo = await this.fetchCollectionInfo(metaDataClient, context.ns, filter);
	                    if (collInfo) {
	                        context.addMongoOperationResponse(collInfo);
	                    }
	                    context.finishMongoOperation();
	                    break;
	                }
	                case MONGOCRYPT_CTX_NEED_MONGO_MARKINGS: {
	                    const command = context.nextMongoOperation();
	                    if (!mongocryptdClient) {
	                        throw new errors_1.MongoCryptError('unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_MARKINGS but mongocryptdClient is undefined');
	                    }
	                    // When we are using the shared library, we don't have a mongocryptd manager.
	                    const markedCommand = mongocryptdManager
	                        ? await mongocryptdManager.withRespawn(this.markCommand.bind(this, mongocryptdClient, context.ns, command))
	                        : await this.markCommand(mongocryptdClient, context.ns, command);
	                    context.addMongoOperationResponse(markedCommand);
	                    context.finishMongoOperation();
	                    break;
	                }
	                case MONGOCRYPT_CTX_NEED_MONGO_KEYS: {
	                    const filter = context.nextMongoOperation();
	                    const keys = await this.fetchKeys(keyVaultClient, keyVaultNamespace, filter);
	                    if (keys.length === 0) {
	                        // See docs on EMPTY_V
	                        result = EMPTY_V ??= (0, bson_1.serialize)({ v: [] });
	                    }
	                    for await (const key of keys) {
	                        context.addMongoOperationResponse((0, bson_1.serialize)(key));
	                    }
	                    context.finishMongoOperation();
	                    break;
	                }
	                case MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS: {
	                    const kmsProviders = await executor.askForKMSCredentials();
	                    context.provideKMSProviders((0, bson_1.serialize)(kmsProviders));
	                    break;
	                }
	                case MONGOCRYPT_CTX_NEED_KMS: {
	                    const requests = Array.from(this.requests(context));
	                    await Promise.all(requests);
	                    context.finishKMSRequests();
	                    break;
	                }
	                case MONGOCRYPT_CTX_READY: {
	                    const finalizedContext = context.finalize();
	                    // @ts-expect-error finalize can change the state, check for error
	                    if (context.state === MONGOCRYPT_CTX_ERROR) {
	                        const message = context.status.message || 'Finalization error';
	                        throw new errors_1.MongoCryptError(message);
	                    }
	                    result = finalizedContext;
	                    break;
	                }
	                default:
	                    throw new errors_1.MongoCryptError(`Unknown state: ${context.state}`);
	            }
	        }
	        if (context.state === MONGOCRYPT_CTX_ERROR || result == null) {
	            const message = context.status.message;
	            if (!message) {
	                debug(`unidentifiable error in MongoCrypt - received an error status from \`libmongocrypt\` but received no error message.`);
	            }
	            throw new errors_1.MongoCryptError(message ??
	                'unidentifiable error in MongoCrypt - received an error status from `libmongocrypt` but received no error message.');
	        }
	        return result;
	    }
	    /**
	     * Handles the request to the KMS service. Exposed for testing purposes. Do not directly invoke.
	     * @param kmsContext - A C++ KMS context returned from the bindings
	     * @returns A promise that resolves when the KMS reply has be fully parsed
	     */
	    async kmsRequest(request) {
	        const parsedUrl = request.endpoint.split(':');
	        const port = parsedUrl[1] != null ? Number.parseInt(parsedUrl[1], 10) : HTTPS_PORT;
	        const socketOptions = (0, client_encryption_1.autoSelectSocketOptions)(this.options.socketOptions || {});
	        const options = {
	            host: parsedUrl[0],
	            servername: parsedUrl[0],
	            port,
	            ...socketOptions
	        };
	        const message = request.message;
	        const buffer = new utils_1.BufferPool();
	        const netSocket = new net.Socket();
	        let socket;
	        function destroySockets() {
	            for (const sock of [socket, netSocket]) {
	                if (sock) {
	                    sock.removeAllListeners();
	                    sock.destroy();
	                }
	            }
	        }
	        function ontimeout() {
	            return new errors_1.MongoCryptError('KMS request timed out');
	        }
	        function onerror(cause) {
	            return new errors_1.MongoCryptError('KMS request failed', { cause });
	        }
	        function onclose() {
	            return new errors_1.MongoCryptError('KMS request closed');
	        }
	        const tlsOptions = this.options.tlsOptions;
	        if (tlsOptions) {
	            const kmsProvider = request.kmsProvider;
	            const providerTlsOptions = tlsOptions[kmsProvider];
	            if (providerTlsOptions) {
	                const error = this.validateTlsOptions(kmsProvider, providerTlsOptions);
	                if (error) {
	                    throw error;
	                }
	                try {
	                    await this.setTlsOptions(providerTlsOptions, options);
	                }
	                catch (err) {
	                    throw onerror(err);
	                }
	            }
	        }
	        const { promise: willConnect, reject: rejectOnNetSocketError, resolve: resolveOnNetSocketConnect } = (0, utils_1.promiseWithResolvers)();
	        netSocket
	            .once('timeout', () => rejectOnNetSocketError(ontimeout()))
	            .once('error', err => rejectOnNetSocketError(onerror(err)))
	            .once('close', () => rejectOnNetSocketError(onclose()))
	            .once('connect', () => resolveOnNetSocketConnect());
	        try {
	            if (this.options.proxyOptions && this.options.proxyOptions.proxyHost) {
	                const netSocketOptions = {
	                    host: this.options.proxyOptions.proxyHost,
	                    port: this.options.proxyOptions.proxyPort || 1080,
	                    ...socketOptions
	                };
	                netSocket.connect(netSocketOptions);
	                await willConnect;
	                try {
	                    socks ??= loadSocks();
	                    options.socket = (await socks.SocksClient.createConnection({
	                        existing_socket: netSocket,
	                        command: 'connect',
	                        destination: { host: options.host, port: options.port },
	                        proxy: {
	                            // host and port are ignored because we pass existing_socket
	                            host: 'iLoveJavaScript',
	                            port: 0,
	                            type: 5,
	                            userId: this.options.proxyOptions.proxyUsername,
	                            password: this.options.proxyOptions.proxyPassword
	                        }
	                    })).socket;
	                }
	                catch (err) {
	                    throw onerror(err);
	                }
	            }
	            socket = tls.connect(options, () => {
	                socket.write(message);
	            });
	            const { promise: willResolveKmsRequest, reject: rejectOnTlsSocketError, resolve } = (0, utils_1.promiseWithResolvers)();
	            socket
	                .once('timeout', () => rejectOnTlsSocketError(ontimeout()))
	                .once('error', err => rejectOnTlsSocketError(onerror(err)))
	                .once('close', () => rejectOnTlsSocketError(onclose()))
	                .on('data', data => {
	                buffer.append(data);
	                while (request.bytesNeeded > 0 && buffer.length) {
	                    const bytesNeeded = Math.min(request.bytesNeeded, buffer.length);
	                    request.addResponse(buffer.read(bytesNeeded));
	                }
	                if (request.bytesNeeded <= 0) {
	                    resolve();
	                }
	            });
	            await willResolveKmsRequest;
	        }
	        finally {
	            // There's no need for any more activity on this socket at this point.
	            destroySockets();
	        }
	    }
	    *requests(context) {
	        for (let request = context.nextKMSRequest(); request != null; request = context.nextKMSRequest()) {
	            yield this.kmsRequest(request);
	        }
	    }
	    /**
	     * Validates the provided TLS options are secure.
	     *
	     * @param kmsProvider - The KMS provider name.
	     * @param tlsOptions - The client TLS options for the provider.
	     *
	     * @returns An error if any option is invalid.
	     */
	    validateTlsOptions(kmsProvider, tlsOptions) {
	        const tlsOptionNames = Object.keys(tlsOptions);
	        for (const option of INSECURE_TLS_OPTIONS) {
	            if (tlsOptionNames.includes(option)) {
	                return new errors_1.MongoCryptError(`Insecure TLS options prohibited for ${kmsProvider}: ${option}`);
	            }
	        }
	    }
	    /**
	     * Sets only the valid secure TLS options.
	     *
	     * @param tlsOptions - The client TLS options for the provider.
	     * @param options - The existing connection options.
	     */
	    async setTlsOptions(tlsOptions, options) {
	        if (tlsOptions.tlsCertificateKeyFile) {
	            const cert = await fs.readFile(tlsOptions.tlsCertificateKeyFile);
	            options.cert = options.key = cert;
	        }
	        if (tlsOptions.tlsCAFile) {
	            options.ca = await fs.readFile(tlsOptions.tlsCAFile);
	        }
	        if (tlsOptions.tlsCertificateKeyFilePassword) {
	            options.passphrase = tlsOptions.tlsCertificateKeyFilePassword;
	        }
	    }
	    /**
	     * Fetches collection info for a provided namespace, when libmongocrypt
	     * enters the `MONGOCRYPT_CTX_NEED_MONGO_COLLINFO` state. The result is
	     * used to inform libmongocrypt of the schema associated with this
	     * namespace. Exposed for testing purposes. Do not directly invoke.
	     *
	     * @param client - A MongoClient connected to the topology
	     * @param ns - The namespace to list collections from
	     * @param filter - A filter for the listCollections command
	     * @param callback - Invoked with the info of the requested collection, or with an error
	     */
	    async fetchCollectionInfo(client, ns, filter) {
	        const { db } = utils_1.MongoDBCollectionNamespace.fromString(ns);
	        const collections = await client
	            .db(db)
	            .listCollections(filter, {
	            promoteLongs: false,
	            promoteValues: false
	        })
	            .toArray();
	        const info = collections.length > 0 ? (0, bson_1.serialize)(collections[0]) : null;
	        return info;
	    }
	    /**
	     * Calls to the mongocryptd to provide markings for a command.
	     * Exposed for testing purposes. Do not directly invoke.
	     * @param client - A MongoClient connected to a mongocryptd
	     * @param ns - The namespace (database.collection) the command is being executed on
	     * @param command - The command to execute.
	     * @param callback - Invoked with the serialized and marked bson command, or with an error
	     */
	    async markCommand(client, ns, command) {
	        const options = { promoteLongs: false, promoteValues: false };
	        const { db } = utils_1.MongoDBCollectionNamespace.fromString(ns);
	        const rawCommand = (0, bson_1.deserialize)(command, options);
	        const response = await client.db(db).command(rawCommand, options);
	        return (0, bson_1.serialize)(response, this.bsonOptions);
	    }
	    /**
	     * Requests keys from the keyVault collection on the topology.
	     * Exposed for testing purposes. Do not directly invoke.
	     * @param client - A MongoClient connected to the topology
	     * @param keyVaultNamespace - The namespace (database.collection) of the keyVault Collection
	     * @param filter - The filter for the find query against the keyVault Collection
	     * @param callback - Invoked with the found keys, or with an error
	     */
	    fetchKeys(client, keyVaultNamespace, filter) {
	        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(keyVaultNamespace);
	        return client
	            .db(dbName)
	            .collection(collectionName, { readConcern: { level: 'majority' } })
	            .find((0, bson_1.deserialize)(filter))
	            .toArray();
	    }
	}
	state_machine.StateMachine = StateMachine;
	
	return state_machine;
}

var hasRequiredClient_encryption;

function requireClient_encryption () {
	if (hasRequiredClient_encryption) return client_encryption;
	hasRequiredClient_encryption = 1;
	Object.defineProperty(client_encryption, "__esModule", { value: true });
	client_encryption.ClientEncryption = void 0;
	client_encryption.autoSelectSocketOptions = autoSelectSocketOptions;
	const bson_1 = requireBson();
	const deps_1 = requireDeps();
	const utils_1 = requireUtils$1();
	const cryptoCallbacks = requireCrypto_callbacks();
	const errors_1 = requireErrors$1();
	const index_1 = requireProviders();
	const state_machine_1 = requireState_machine();
	/**
	 * @public
	 * The public interface for explicit in-use encryption
	 */
	class ClientEncryption {
	    /** @internal */
	    static getMongoCrypt() {
	        const encryption = (0, deps_1.getMongoDBClientEncryption)();
	        if ('kModuleError' in encryption) {
	            throw encryption.kModuleError;
	        }
	        return encryption.MongoCrypt;
	    }
	    /**
	     * Create a new encryption instance
	     *
	     * @example
	     * ```ts
	     * new ClientEncryption(mongoClient, {
	     *   keyVaultNamespace: 'client.encryption',
	     *   kmsProviders: {
	     *     local: {
	     *       key: masterKey // The master key used for encryption/decryption. A 96-byte long Buffer
	     *     }
	     *   }
	     * });
	     * ```
	     *
	     * @example
	     * ```ts
	     * new ClientEncryption(mongoClient, {
	     *   keyVaultNamespace: 'client.encryption',
	     *   kmsProviders: {
	     *     aws: {
	     *       accessKeyId: AWS_ACCESS_KEY,
	     *       secretAccessKey: AWS_SECRET_KEY
	     *     }
	     *   }
	     * });
	     * ```
	     */
	    constructor(client, options) {
	        this._client = client;
	        this._proxyOptions = options.proxyOptions ?? {};
	        this._tlsOptions = options.tlsOptions ?? {};
	        this._kmsProviders = options.kmsProviders || {};
	        if (options.keyVaultNamespace == null) {
	            throw new errors_1.MongoCryptInvalidArgumentError('Missing required option `keyVaultNamespace`');
	        }
	        const mongoCryptOptions = {
	            ...options,
	            cryptoCallbacks,
	            kmsProviders: !Buffer.isBuffer(this._kmsProviders)
	                ? (0, bson_1.serialize)(this._kmsProviders)
	                : this._kmsProviders
	        };
	        this._keyVaultNamespace = options.keyVaultNamespace;
	        this._keyVaultClient = options.keyVaultClient || client;
	        const MongoCrypt = ClientEncryption.getMongoCrypt();
	        this._mongoCrypt = new MongoCrypt(mongoCryptOptions);
	    }
	    /**
	     * Creates a data key used for explicit encryption and inserts it into the key vault namespace
	     *
	     * @example
	     * ```ts
	     * // Using async/await to create a local key
	     * const dataKeyId = await clientEncryption.createDataKey('local');
	     * ```
	     *
	     * @example
	     * ```ts
	     * // Using async/await to create an aws key
	     * const dataKeyId = await clientEncryption.createDataKey('aws', {
	     *   masterKey: {
	     *     region: 'us-east-1',
	     *     key: 'xxxxxxxxxxxxxx' // CMK ARN here
	     *   }
	     * });
	     * ```
	     *
	     * @example
	     * ```ts
	     * // Using async/await to create an aws key with a keyAltName
	     * const dataKeyId = await clientEncryption.createDataKey('aws', {
	     *   masterKey: {
	     *     region: 'us-east-1',
	     *     key: 'xxxxxxxxxxxxxx' // CMK ARN here
	     *   },
	     *   keyAltNames: [ 'mySpecialKey' ]
	     * });
	     * ```
	     */
	    async createDataKey(provider, options = {}) {
	        if (options.keyAltNames && !Array.isArray(options.keyAltNames)) {
	            throw new errors_1.MongoCryptInvalidArgumentError(`Option "keyAltNames" must be an array of strings, but was of type ${typeof options.keyAltNames}.`);
	        }
	        let keyAltNames = undefined;
	        if (options.keyAltNames && options.keyAltNames.length > 0) {
	            keyAltNames = options.keyAltNames.map((keyAltName, i) => {
	                if (typeof keyAltName !== 'string') {
	                    throw new errors_1.MongoCryptInvalidArgumentError(`Option "keyAltNames" must be an array of strings, but item at index ${i} was of type ${typeof keyAltName}`);
	                }
	                return (0, bson_1.serialize)({ keyAltName });
	            });
	        }
	        let keyMaterial = undefined;
	        if (options.keyMaterial) {
	            keyMaterial = (0, bson_1.serialize)({ keyMaterial: options.keyMaterial });
	        }
	        const dataKeyBson = (0, bson_1.serialize)({
	            provider,
	            ...options.masterKey
	        });
	        const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson, {
	            keyAltNames,
	            keyMaterial
	        });
	        const stateMachine = new state_machine_1.StateMachine({
	            proxyOptions: this._proxyOptions,
	            tlsOptions: this._tlsOptions,
	            socketOptions: autoSelectSocketOptions(this._client.options)
	        });
	        const dataKey = (0, bson_1.deserialize)(await stateMachine.execute(this, context));
	        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
	        const { insertedId } = await this._keyVaultClient
	            .db(dbName)
	            .collection(collectionName)
	            .insertOne(dataKey, { writeConcern: { w: 'majority' } });
	        return insertedId;
	    }
	    /**
	     * Searches the keyvault for any data keys matching the provided filter.  If there are matches, rewrapManyDataKey then attempts to re-wrap the data keys using the provided options.
	     *
	     * If no matches are found, then no bulk write is performed.
	     *
	     * @example
	     * ```ts
	     * // rewrapping all data data keys (using a filter that matches all documents)
	     * const filter = {};
	     *
	     * const result = await clientEncryption.rewrapManyDataKey(filter);
	     * if (result.bulkWriteResult != null) {
	     *  // keys were re-wrapped, results will be available in the bulkWrite object.
	     * }
	     * ```
	     *
	     * @example
	     * ```ts
	     * // attempting to rewrap all data keys with no matches
	     * const filter = { _id: new Binary() } // assume _id matches no documents in the database
	     * const result = await clientEncryption.rewrapManyDataKey(filter);
	     *
	     * if (result.bulkWriteResult == null) {
	     *  // no keys matched, `bulkWriteResult` does not exist on the result object
	     * }
	     * ```
	     */
	    async rewrapManyDataKey(filter, options) {
	        let keyEncryptionKeyBson = undefined;
	        if (options) {
	            const keyEncryptionKey = Object.assign({ provider: options.provider }, options.masterKey);
	            keyEncryptionKeyBson = (0, bson_1.serialize)(keyEncryptionKey);
	        }
	        const filterBson = (0, bson_1.serialize)(filter);
	        const context = this._mongoCrypt.makeRewrapManyDataKeyContext(filterBson, keyEncryptionKeyBson);
	        const stateMachine = new state_machine_1.StateMachine({
	            proxyOptions: this._proxyOptions,
	            tlsOptions: this._tlsOptions,
	            socketOptions: autoSelectSocketOptions(this._client.options)
	        });
	        const { v: dataKeys } = (0, bson_1.deserialize)(await stateMachine.execute(this, context));
	        if (dataKeys.length === 0) {
	            return {};
	        }
	        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
	        const replacements = dataKeys.map((key) => ({
	            updateOne: {
	                filter: { _id: key._id },
	                update: {
	                    $set: {
	                        masterKey: key.masterKey,
	                        keyMaterial: key.keyMaterial
	                    },
	                    $currentDate: {
	                        updateDate: true
	                    }
	                }
	            }
	        }));
	        const result = await this._keyVaultClient
	            .db(dbName)
	            .collection(collectionName)
	            .bulkWrite(replacements, {
	            writeConcern: { w: 'majority' }
	        });
	        return { bulkWriteResult: result };
	    }
	    /**
	     * Deletes the key with the provided id from the keyvault, if it exists.
	     *
	     * @example
	     * ```ts
	     * // delete a key by _id
	     * const id = new Binary(); // id is a bson binary subtype 4 object
	     * const { deletedCount } = await clientEncryption.deleteKey(id);
	     *
	     * if (deletedCount != null && deletedCount > 0) {
	     *   // successful deletion
	     * }
	     * ```
	     *
	     */
	    async deleteKey(_id) {
	        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
	        return await this._keyVaultClient
	            .db(dbName)
	            .collection(collectionName)
	            .deleteOne({ _id }, { writeConcern: { w: 'majority' } });
	    }
	    /**
	     * Finds all the keys currently stored in the keyvault.
	     *
	     * This method will not throw.
	     *
	     * @returns a FindCursor over all keys in the keyvault.
	     * @example
	     * ```ts
	     * // fetching all keys
	     * const keys = await clientEncryption.getKeys().toArray();
	     * ```
	     */
	    getKeys() {
	        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
	        return this._keyVaultClient
	            .db(dbName)
	            .collection(collectionName)
	            .find({}, { readConcern: { level: 'majority' } });
	    }
	    /**
	     * Finds a key in the keyvault with the specified _id.
	     *
	     * Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents
	     * match the id.  The promise rejects with an error if an error is thrown.
	     * @example
	     * ```ts
	     * // getting a key by id
	     * const id = new Binary(); // id is a bson binary subtype 4 object
	     * const key = await clientEncryption.getKey(id);
	     * if (!key) {
	     *  // key is null if there was no matching key
	     * }
	     * ```
	     */
	    async getKey(_id) {
	        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
	        return await this._keyVaultClient
	            .db(dbName)
	            .collection(collectionName)
	            .findOne({ _id }, { readConcern: { level: 'majority' } });
	    }
	    /**
	     * Finds a key in the keyvault which has the specified keyAltName.
	     *
	     * @param keyAltName - a keyAltName to search for a key
	     * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents
	     * match the keyAltName.  The promise rejects with an error if an error is thrown.
	     * @example
	     * ```ts
	     * // get a key by alt name
	     * const keyAltName = 'keyAltName';
	     * const key = await clientEncryption.getKeyByAltName(keyAltName);
	     * if (!key) {
	     *  // key is null if there is no matching key
	     * }
	     * ```
	     */
	    async getKeyByAltName(keyAltName) {
	        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
	        return await this._keyVaultClient
	            .db(dbName)
	            .collection(collectionName)
	            .findOne({ keyAltNames: keyAltName }, { readConcern: { level: 'majority' } });
	    }
	    /**
	     * Adds a keyAltName to a key identified by the provided _id.
	     *
	     * This method resolves to/returns the *old* key value (prior to adding the new altKeyName).
	     *
	     * @param _id - The id of the document to update.
	     * @param keyAltName - a keyAltName to search for a key
	     * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents
	     * match the id.  The promise rejects with an error if an error is thrown.
	     * @example
	     * ```ts
	     * // adding an keyAltName to a data key
	     * const id = new Binary();  // id is a bson binary subtype 4 object
	     * const keyAltName = 'keyAltName';
	     * const oldKey = await clientEncryption.addKeyAltName(id, keyAltName);
	     * if (!oldKey) {
	     *  // null is returned if there is no matching document with an id matching the supplied id
	     * }
	     * ```
	     */
	    async addKeyAltName(_id, keyAltName) {
	        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
	        const value = await this._keyVaultClient
	            .db(dbName)
	            .collection(collectionName)
	            .findOneAndUpdate({ _id }, { $addToSet: { keyAltNames: keyAltName } }, { writeConcern: { w: 'majority' }, returnDocument: 'before' });
	        return value;
	    }
	    /**
	     * Adds a keyAltName to a key identified by the provided _id.
	     *
	     * This method resolves to/returns the *old* key value (prior to removing the new altKeyName).
	     *
	     * If the removed keyAltName is the last keyAltName for that key, the `altKeyNames` property is unset from the document.
	     *
	     * @param _id - The id of the document to update.
	     * @param keyAltName - a keyAltName to search for a key
	     * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents
	     * match the id.  The promise rejects with an error if an error is thrown.
	     * @example
	     * ```ts
	     * // removing a key alt name from a data key
	     * const id = new Binary();  // id is a bson binary subtype 4 object
	     * const keyAltName = 'keyAltName';
	     * const oldKey = await clientEncryption.removeKeyAltName(id, keyAltName);
	     *
	     * if (!oldKey) {
	     *  // null is returned if there is no matching document with an id matching the supplied id
	     * }
	     * ```
	     */
	    async removeKeyAltName(_id, keyAltName) {
	        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
	        const pipeline = [
	            {
	                $set: {
	                    keyAltNames: {
	                        $cond: [
	                            {
	                                $eq: ['$keyAltNames', [keyAltName]]
	                            },
	                            '$$REMOVE',
	                            {
	                                $filter: {
	                                    input: '$keyAltNames',
	                                    cond: {
	                                        $ne: ['$$this', keyAltName]
	                                    }
	                                }
	                            }
	                        ]
	                    }
	                }
	            }
	        ];
	        const value = await this._keyVaultClient
	            .db(dbName)
	            .collection(collectionName)
	            .findOneAndUpdate({ _id }, pipeline, {
	            writeConcern: { w: 'majority' },
	            returnDocument: 'before'
	        });
	        return value;
	    }
	    /**
	     * A convenience method for creating an encrypted collection.
	     * This method will create data keys for any encryptedFields that do not have a `keyId` defined
	     * and then create a new collection with the full set of encryptedFields.
	     *
	     * @param db - A Node.js driver Db object with which to create the collection
	     * @param name - The name of the collection to be created
	     * @param options - Options for createDataKey and for createCollection
	     * @returns created collection and generated encryptedFields
	     * @throws MongoCryptCreateDataKeyError - If part way through the process a createDataKey invocation fails, an error will be rejected that has the partial `encryptedFields` that were created.
	     * @throws MongoCryptCreateEncryptedCollectionError - If creating the collection fails, an error will be rejected that has the entire `encryptedFields` that were created.
	     */
	    async createEncryptedCollection(db, name, options) {
	        const { provider, masterKey, createCollectionOptions: { encryptedFields: { ...encryptedFields }, ...createCollectionOptions } } = options;
	        if (Array.isArray(encryptedFields.fields)) {
	            const createDataKeyPromises = encryptedFields.fields.map(async (field) => field == null || typeof field !== 'object' || field.keyId != null
	                ? field
	                : {
	                    ...field,
	                    keyId: await this.createDataKey(provider, { masterKey })
	                });
	            const createDataKeyResolutions = await Promise.allSettled(createDataKeyPromises);
	            encryptedFields.fields = createDataKeyResolutions.map((resolution, index) => resolution.status === 'fulfilled' ? resolution.value : encryptedFields.fields[index]);
	            const rejection = createDataKeyResolutions.find((result) => result.status === 'rejected');
	            if (rejection != null) {
	                throw new errors_1.MongoCryptCreateDataKeyError(encryptedFields, { cause: rejection.reason });
	            }
	        }
	        try {
	            const collection = await db.createCollection(name, {
	                ...createCollectionOptions,
	                encryptedFields
	            });
	            return { collection, encryptedFields };
	        }
	        catch (cause) {
	            throw new errors_1.MongoCryptCreateEncryptedCollectionError(encryptedFields, { cause });
	        }
	    }
	    /**
	     * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must
	     * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.
	     *
	     * @param value - The value that you wish to serialize. Must be of a type that can be serialized into BSON
	     * @param options -
	     * @returns a Promise that either resolves with the encrypted value, or rejects with an error.
	     *
	     * @example
	     * ```ts
	     * // Encryption with async/await api
	     * async function encryptMyData(value) {
	     *   const keyId = await clientEncryption.createDataKey('local');
	     *   return clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });
	     * }
	     * ```
	     *
	     * @example
	     * ```ts
	     * // Encryption using a keyAltName
	     * async function encryptMyData(value) {
	     *   await clientEncryption.createDataKey('local', { keyAltNames: 'mySpecialKey' });
	     *   return clientEncryption.encrypt(value, { keyAltName: 'mySpecialKey', algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });
	     * }
	     * ```
	     */
	    async encrypt(value, options) {
	        return await this._encrypt(value, false, options);
	    }
	    /**
	     * Encrypts a Match Expression or Aggregate Expression to query a range index.
	     *
	     * Only supported when queryType is "range" and algorithm is "Range".
	     *
	     * @param expression - a BSON document of one of the following forms:
	     *  1. A Match Expression of this form:
	     *      `{$and: [{<field>: {$gt: <value1>}}, {<field>: {$lt: <value2> }}]}`
	     *  2. An Aggregate Expression of this form:
	     *      `{$and: [{$gt: [<fieldpath>, <value1>]}, {$lt: [<fieldpath>, <value2>]}]}`
	     *
	     *    `$gt` may also be `$gte`. `$lt` may also be `$lte`.
	     *
	     * @param options -
	     * @returns Returns a Promise that either resolves with the encrypted value or rejects with an error.
	     */
	    async encryptExpression(expression, options) {
	        return await this._encrypt(expression, true, options);
	    }
	    /**
	     * Explicitly decrypt a provided encrypted value
	     *
	     * @param value - An encrypted value
	     * @returns a Promise that either resolves with the decrypted value, or rejects with an error
	     *
	     * @example
	     * ```ts
	     * // Decrypting value with async/await API
	     * async function decryptMyValue(value) {
	     *   return clientEncryption.decrypt(value);
	     * }
	     * ```
	     */
	    async decrypt(value) {
	        const valueBuffer = (0, bson_1.serialize)({ v: value });
	        const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);
	        const stateMachine = new state_machine_1.StateMachine({
	            proxyOptions: this._proxyOptions,
	            tlsOptions: this._tlsOptions,
	            socketOptions: autoSelectSocketOptions(this._client.options)
	        });
	        const { v } = (0, bson_1.deserialize)(await stateMachine.execute(this, context));
	        return v;
	    }
	    /**
	     * @internal
	     * Ask the user for KMS credentials.
	     *
	     * This returns anything that looks like the kmsProviders original input
	     * option. It can be empty, and any provider specified here will override
	     * the original ones.
	     */
	    async askForKMSCredentials() {
	        return await (0, index_1.refreshKMSCredentials)(this._kmsProviders);
	    }
	    static get libmongocryptVersion() {
	        return ClientEncryption.getMongoCrypt().libmongocryptVersion;
	    }
	    /**
	     * @internal
	     * A helper that perform explicit encryption of values and expressions.
	     * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must
	     * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.
	     *
	     * @param value - The value that you wish to encrypt. Must be of a type that can be serialized into BSON
	     * @param expressionMode - a boolean that indicates whether or not to encrypt the value as an expression
	     * @param options - options to pass to encrypt
	     * @returns the raw result of the call to stateMachine.execute().  When expressionMode is set to true, the return
	     *          value will be a bson document.  When false, the value will be a BSON Binary.
	     *
	     */
	    async _encrypt(value, expressionMode, options) {
	        const { algorithm, keyId, keyAltName, contentionFactor, queryType, rangeOptions } = options;
	        const contextOptions = {
	            expressionMode,
	            algorithm
	        };
	        if (keyId) {
	            contextOptions.keyId = keyId.buffer;
	        }
	        if (keyAltName) {
	            if (keyId) {
	                throw new errors_1.MongoCryptInvalidArgumentError(`"options" cannot contain both "keyId" and "keyAltName"`);
	            }
	            if (typeof keyAltName !== 'string') {
	                throw new errors_1.MongoCryptInvalidArgumentError(`"options.keyAltName" must be of type string, but was of type ${typeof keyAltName}`);
	            }
	            contextOptions.keyAltName = (0, bson_1.serialize)({ keyAltName });
	        }
	        if (typeof contentionFactor === 'number' || typeof contentionFactor === 'bigint') {
	            contextOptions.contentionFactor = contentionFactor;
	        }
	        if (typeof queryType === 'string') {
	            contextOptions.queryType = queryType;
	        }
	        if (typeof rangeOptions === 'object') {
	            contextOptions.rangeOptions = (0, bson_1.serialize)(rangeOptions);
	        }
	        const valueBuffer = (0, bson_1.serialize)({ v: value });
	        const stateMachine = new state_machine_1.StateMachine({
	            proxyOptions: this._proxyOptions,
	            tlsOptions: this._tlsOptions,
	            socketOptions: autoSelectSocketOptions(this._client.options)
	        });
	        const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);
	        const { v } = (0, bson_1.deserialize)(await stateMachine.execute(this, context));
	        return v;
	    }
	}
	client_encryption.ClientEncryption = ClientEncryption;
	/**
	 * Get the socket options from the client.
	 * @param baseOptions - The mongo client options.
	 * @returns ClientEncryptionSocketOptions
	 */
	function autoSelectSocketOptions(baseOptions) {
	    const options = { autoSelectFamily: true };
	    if ('autoSelectFamily' in baseOptions) {
	        options.autoSelectFamily = baseOptions.autoSelectFamily;
	    }
	    if ('autoSelectFamilyAttemptTimeout' in baseOptions) {
	        options.autoSelectFamilyAttemptTimeout = baseOptions.autoSelectFamilyAttemptTimeout;
	    }
	    return options;
	}
	
	return client_encryption;
}

var mongocryptd_manager = {};

var hasRequiredMongocryptd_manager;

function requireMongocryptd_manager () {
	if (hasRequiredMongocryptd_manager) return mongocryptd_manager;
	hasRequiredMongocryptd_manager = 1;
	Object.defineProperty(mongocryptd_manager, "__esModule", { value: true });
	mongocryptd_manager.MongocryptdManager = void 0;
	const error_1 = requireError();
	/**
	 * @internal
	 * An internal class that handles spawning a mongocryptd.
	 */
	class MongocryptdManager {
	    constructor(extraOptions = {}) {
	        this.spawnPath = '';
	        this.spawnArgs = [];
	        this.uri =
	            typeof extraOptions.mongocryptdURI === 'string' && extraOptions.mongocryptdURI.length > 0
	                ? extraOptions.mongocryptdURI
	                : MongocryptdManager.DEFAULT_MONGOCRYPTD_URI;
	        this.bypassSpawn = !!extraOptions.mongocryptdBypassSpawn;
	        if (Object.hasOwn(extraOptions, 'mongocryptdSpawnPath') && extraOptions.mongocryptdSpawnPath) {
	            this.spawnPath = extraOptions.mongocryptdSpawnPath;
	        }
	        if (Object.hasOwn(extraOptions, 'mongocryptdSpawnArgs') &&
	            Array.isArray(extraOptions.mongocryptdSpawnArgs)) {
	            this.spawnArgs = this.spawnArgs.concat(extraOptions.mongocryptdSpawnArgs);
	        }
	        if (this.spawnArgs
	            .filter(arg => typeof arg === 'string')
	            .every(arg => arg.indexOf('--idleShutdownTimeoutSecs') < 0)) {
	            this.spawnArgs.push('--idleShutdownTimeoutSecs', '60');
	        }
	    }
	    /**
	     * Will check to see if a mongocryptd is up. If it is not up, it will attempt
	     * to spawn a mongocryptd in a detached process, and then wait for it to be up.
	     */
	    async spawn() {
	        const cmdName = this.spawnPath || 'mongocryptd';
	        // eslint-disable-next-line @typescript-eslint/no-require-imports
	        const { spawn } = require$$1$2;
	        // Spawned with stdio: ignore and detached: true
	        // to ensure child can outlive parent.
	        this._child = spawn(cmdName, this.spawnArgs, {
	            stdio: 'ignore',
	            detached: true
	        });
	        this._child.on('error', () => {
	            // From the FLE spec:
	            // "The stdout and stderr of the spawned process MUST not be exposed in the driver
	            // (e.g. redirect to /dev/null). Users can pass the argument --logpath to
	            // extraOptions.mongocryptdSpawnArgs if they need to inspect mongocryptd logs.
	            // If spawning is necessary, the driver MUST spawn mongocryptd whenever server
	            // selection on the MongoClient to mongocryptd fails. If the MongoClient fails to
	            // connect after spawning, the server selection error is propagated to the user."
	            // The AutoEncrypter and MongoCryptdManager should work together to spawn
	            // mongocryptd whenever necessary.  Additionally, the `mongocryptd` intentionally
	            // shuts down after 60s and gets respawned when necessary.  We rely on server
	            // selection timeouts when connecting to the `mongocryptd` to inform users that something
	            // has been configured incorrectly.  For those reasons, we suppress stderr from
	            // the `mongocryptd` process and immediately unref the process.
	        });
	        // unref child to remove handle from event loop
	        this._child.unref();
	    }
	    /**
	     * @returns the result of `fn` or rejects with an error.
	     */
	    async withRespawn(fn) {
	        try {
	            const result = await fn();
	            return result;
	        }
	        catch (err) {
	            // If we are not bypassing spawning, then we should retry once on a MongoTimeoutError (server selection error)
	            const shouldSpawn = err instanceof error_1.MongoNetworkTimeoutError && !this.bypassSpawn;
	            if (!shouldSpawn) {
	                throw err;
	            }
	        }
	        await this.spawn();
	        const result = await fn();
	        return result;
	    }
	}
	mongocryptd_manager.MongocryptdManager = MongocryptdManager;
	MongocryptdManager.DEFAULT_MONGOCRYPTD_URI = 'mongodb://localhost:27020';
	
	return mongocryptd_manager;
}

var hasRequiredAuto_encrypter;

function requireAuto_encrypter () {
	if (hasRequiredAuto_encrypter) return auto_encrypter;
	hasRequiredAuto_encrypter = 1;
	var _a;
	Object.defineProperty(auto_encrypter, "__esModule", { value: true });
	auto_encrypter.AutoEncrypter = auto_encrypter.AutoEncryptionLoggerLevel = void 0;
	const net = require$$0$7;
	const bson_1 = requireBson();
	const constants_1 = requireConstants();
	const deps_1 = requireDeps();
	const error_1 = requireError();
	const mongo_client_1 = requireMongo_client();
	const utils_1 = requireUtils$1();
	const client_encryption_1 = requireClient_encryption();
	const cryptoCallbacks = requireCrypto_callbacks();
	const errors_1 = requireErrors$1();
	const mongocryptd_manager_1 = requireMongocryptd_manager();
	const providers_1 = requireProviders();
	const state_machine_1 = requireState_machine();
	/** @public */
	auto_encrypter.AutoEncryptionLoggerLevel = Object.freeze({
	    FatalError: 0,
	    Error: 1,
	    Warning: 2,
	    Info: 3,
	    Trace: 4
	});
	/**
	 * @internal An internal class to be used by the driver for auto encryption
	 * **NOTE**: Not meant to be instantiated directly, this is for internal use only.
	 */
	class AutoEncrypter {
	    /** @internal */
	    static getMongoCrypt() {
	        const encryption = (0, deps_1.getMongoDBClientEncryption)();
	        if ('kModuleError' in encryption) {
	            throw encryption.kModuleError;
	        }
	        return encryption.MongoCrypt;
	    }
	    /**
	     * Create an AutoEncrypter
	     *
	     * **Note**: Do not instantiate this class directly. Rather, supply the relevant options to a MongoClient
	     *
	     * **Note**: Supplying `options.schemaMap` provides more security than relying on JSON Schemas obtained from the server.
	     * It protects against a malicious server advertising a false JSON Schema, which could trick the client into sending unencrypted data that should be encrypted.
	     * Schemas supplied in the schemaMap only apply to configuring automatic encryption for Client-Side Field Level Encryption.
	     * Other validation rules in the JSON schema will not be enforced by the driver and will result in an error.
	     *
	     * @example <caption>Create an AutoEncrypter that makes use of mongocryptd</caption>
	     * ```ts
	     * // Enabling autoEncryption via a MongoClient using mongocryptd
	     * const { MongoClient } = require('mongodb');
	     * const client = new MongoClient(URL, {
	     *   autoEncryption: {
	     *     kmsProviders: {
	     *       aws: {
	     *         accessKeyId: AWS_ACCESS_KEY,
	     *         secretAccessKey: AWS_SECRET_KEY
	     *       }
	     *     }
	     *   }
	     * });
	     * ```
	     *
	     * await client.connect();
	     * // From here on, the client will be encrypting / decrypting automatically
	     * @example <caption>Create an AutoEncrypter that makes use of libmongocrypt's CSFLE shared library</caption>
	     * ```ts
	     * // Enabling autoEncryption via a MongoClient using CSFLE shared library
	     * const { MongoClient } = require('mongodb');
	     * const client = new MongoClient(URL, {
	     *   autoEncryption: {
	     *     kmsProviders: {
	     *       aws: {}
	     *     },
	     *     extraOptions: {
	     *       cryptSharedLibPath: '/path/to/local/crypt/shared/lib',
	     *       cryptSharedLibRequired: true
	     *     }
	     *   }
	     * });
	     * ```
	     *
	     * await client.connect();
	     * // From here on, the client will be encrypting / decrypting automatically
	     */
	    constructor(client, options) {
	        /**
	         * Used by devtools to enable decorating decryption results.
	         *
	         * When set and enabled, `decrypt` will automatically recursively
	         * traverse a decrypted document and if a field has been decrypted,
	         * it will mark it as decrypted.  Compass uses this to determine which
	         * fields were decrypted.
	         */
	        this[_a] = false;
	        this._client = client;
	        this._bypassEncryption = options.bypassAutoEncryption === true;
	        this._keyVaultNamespace = options.keyVaultNamespace || 'admin.datakeys';
	        this._keyVaultClient = options.keyVaultClient || client;
	        this._metaDataClient = options.metadataClient || client;
	        this._proxyOptions = options.proxyOptions || {};
	        this._tlsOptions = options.tlsOptions || {};
	        this._kmsProviders = options.kmsProviders || {};
	        const mongoCryptOptions = {
	            cryptoCallbacks
	        };
	        if (options.schemaMap) {
	            mongoCryptOptions.schemaMap = Buffer.isBuffer(options.schemaMap)
	                ? options.schemaMap
	                : (0, bson_1.serialize)(options.schemaMap);
	        }
	        if (options.encryptedFieldsMap) {
	            mongoCryptOptions.encryptedFieldsMap = Buffer.isBuffer(options.encryptedFieldsMap)
	                ? options.encryptedFieldsMap
	                : (0, bson_1.serialize)(options.encryptedFieldsMap);
	        }
	        mongoCryptOptions.kmsProviders = !Buffer.isBuffer(this._kmsProviders)
	            ? (0, bson_1.serialize)(this._kmsProviders)
	            : this._kmsProviders;
	        if (options.options?.logger) {
	            mongoCryptOptions.logger = options.options.logger;
	        }
	        if (options.extraOptions && options.extraOptions.cryptSharedLibPath) {
	            mongoCryptOptions.cryptSharedLibPath = options.extraOptions.cryptSharedLibPath;
	        }
	        if (options.bypassQueryAnalysis) {
	            mongoCryptOptions.bypassQueryAnalysis = options.bypassQueryAnalysis;
	        }
	        this._bypassMongocryptdAndCryptShared = this._bypassEncryption || !!options.bypassQueryAnalysis;
	        if (options.extraOptions && options.extraOptions.cryptSharedLibSearchPaths) {
	            // Only for driver testing
	            mongoCryptOptions.cryptSharedLibSearchPaths = options.extraOptions.cryptSharedLibSearchPaths;
	        }
	        else if (!this._bypassMongocryptdAndCryptShared) {
	            mongoCryptOptions.cryptSharedLibSearchPaths = ['$SYSTEM'];
	        }
	        const MongoCrypt = AutoEncrypter.getMongoCrypt();
	        this._mongocrypt = new MongoCrypt(mongoCryptOptions);
	        this._contextCounter = 0;
	        if (options.extraOptions &&
	            options.extraOptions.cryptSharedLibRequired &&
	            !this.cryptSharedLibVersionInfo) {
	            throw new errors_1.MongoCryptInvalidArgumentError('`cryptSharedLibRequired` set but no crypt_shared library loaded');
	        }
	        // Only instantiate mongocryptd manager/client once we know for sure
	        // that we are not using the CSFLE shared library.
	        if (!this._bypassMongocryptdAndCryptShared && !this.cryptSharedLibVersionInfo) {
	            this._mongocryptdManager = new mongocryptd_manager_1.MongocryptdManager(options.extraOptions);
	            const clientOptions = {
	                serverSelectionTimeoutMS: 10000
	            };
	            if ((options.extraOptions == null || typeof options.extraOptions.mongocryptdURI !== 'string') &&
	                !net.getDefaultAutoSelectFamily) {
	                // Only set family if autoSelectFamily options are not supported.
	                clientOptions.family = 4;
	            }
	            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
	            // @ts-ignore: TS complains as this always returns true on versions where it is present.
	            if (net.getDefaultAutoSelectFamily) {
	                Object.assign(clientOptions, (0, client_encryption_1.autoSelectSocketOptions)(this._client.options));
	            }
	            this._mongocryptdClient = new mongo_client_1.MongoClient(this._mongocryptdManager.uri, clientOptions);
	        }
	    }
	    /**
	     * Initializes the auto encrypter by spawning a mongocryptd and connecting to it.
	     *
	     * This function is a no-op when bypassSpawn is set or the crypt shared library is used.
	     */
	    async init() {
	        if (this._bypassMongocryptdAndCryptShared || this.cryptSharedLibVersionInfo) {
	            return;
	        }
	        if (!this._mongocryptdManager) {
	            throw new error_1.MongoRuntimeError('Reached impossible state: mongocryptdManager is undefined when neither bypassSpawn nor the shared lib are specified.');
	        }
	        if (!this._mongocryptdClient) {
	            throw new error_1.MongoRuntimeError('Reached impossible state: mongocryptdClient is undefined when neither bypassSpawn nor the shared lib are specified.');
	        }
	        if (!this._mongocryptdManager.bypassSpawn) {
	            await this._mongocryptdManager.spawn();
	        }
	        try {
	            const client = await this._mongocryptdClient.connect();
	            return client;
	        }
	        catch (error) {
	            const { message } = error;
	            if (message && (message.match(/timed out after/) || message.match(/ENOTFOUND/))) {
	                throw new error_1.MongoRuntimeError('Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn', { cause: error });
	            }
	            throw error;
	        }
	    }
	    /**
	     * Cleans up the `_mongocryptdClient`, if present.
	     */
	    async teardown(force) {
	        await this._mongocryptdClient?.close(force);
	    }
	    /**
	     * Encrypt a command for a given namespace.
	     */
	    async encrypt(ns, cmd, options = {}) {
	        if (this._bypassEncryption) {
	            // If `bypassAutoEncryption` has been specified, don't encrypt
	            return cmd;
	        }
	        const commandBuffer = Buffer.isBuffer(cmd) ? cmd : (0, bson_1.serialize)(cmd, options);
	        const context = this._mongocrypt.makeEncryptionContext(utils_1.MongoDBCollectionNamespace.fromString(ns).db, commandBuffer);
	        context.id = this._contextCounter++;
	        context.ns = ns;
	        context.document = cmd;
	        const stateMachine = new state_machine_1.StateMachine({
	            promoteValues: false,
	            promoteLongs: false,
	            proxyOptions: this._proxyOptions,
	            tlsOptions: this._tlsOptions,
	            socketOptions: (0, client_encryption_1.autoSelectSocketOptions)(this._client.options)
	        });
	        return (0, bson_1.deserialize)(await stateMachine.execute(this, context), {
	            promoteValues: false,
	            promoteLongs: false
	        });
	    }
	    /**
	     * Decrypt a command response
	     */
	    async decrypt(response, options = {}) {
	        const context = this._mongocrypt.makeDecryptionContext(response);
	        context.id = this._contextCounter++;
	        const stateMachine = new state_machine_1.StateMachine({
	            ...options,
	            proxyOptions: this._proxyOptions,
	            tlsOptions: this._tlsOptions,
	            socketOptions: (0, client_encryption_1.autoSelectSocketOptions)(this._client.options)
	        });
	        return await stateMachine.execute(this, context);
	    }
	    /**
	     * Ask the user for KMS credentials.
	     *
	     * This returns anything that looks like the kmsProviders original input
	     * option. It can be empty, and any provider specified here will override
	     * the original ones.
	     */
	    async askForKMSCredentials() {
	        return await (0, providers_1.refreshKMSCredentials)(this._kmsProviders);
	    }
	    /**
	     * Return the current libmongocrypt's CSFLE shared library version
	     * as `{ version: bigint, versionStr: string }`, or `null` if no CSFLE
	     * shared library was loaded.
	     */
	    get cryptSharedLibVersionInfo() {
	        return this._mongocrypt.cryptSharedLibVersionInfo;
	    }
	    static get libmongocryptVersion() {
	        return AutoEncrypter.getMongoCrypt().libmongocryptVersion;
	    }
	}
	auto_encrypter.AutoEncrypter = AutoEncrypter;
	_a = constants_1.kDecorateResult;
	
	return auto_encrypter;
}

var hasRequiredEncrypter;

function requireEncrypter () {
	if (hasRequiredEncrypter) return encrypter;
	hasRequiredEncrypter = 1;
	Object.defineProperty(encrypter, "__esModule", { value: true });
	encrypter.Encrypter = void 0;
	const util_1 = require$$0$6;
	const auto_encrypter_1 = requireAuto_encrypter();
	const constants_1 = requireConstants();
	const deps_1 = requireDeps();
	const error_1 = requireError();
	const mongo_client_1 = requireMongo_client();
	/** @internal */
	const kInternalClient = Symbol('internalClient');
	/** @internal */
	class Encrypter {
	    constructor(client, uri, options) {
	        if (typeof options.autoEncryption !== 'object') {
	            throw new error_1.MongoInvalidArgumentError('Option "autoEncryption" must be specified');
	        }
	        // initialize to null, if we call getInternalClient, we may set this it is important to not overwrite those function calls.
	        this[kInternalClient] = null;
	        this.bypassAutoEncryption = !!options.autoEncryption.bypassAutoEncryption;
	        this.needsConnecting = false;
	        if (options.maxPoolSize === 0 && options.autoEncryption.keyVaultClient == null) {
	            options.autoEncryption.keyVaultClient = client;
	        }
	        else if (options.autoEncryption.keyVaultClient == null) {
	            options.autoEncryption.keyVaultClient = this.getInternalClient(client, uri, options);
	        }
	        if (this.bypassAutoEncryption) {
	            options.autoEncryption.metadataClient = undefined;
	        }
	        else if (options.maxPoolSize === 0) {
	            options.autoEncryption.metadataClient = client;
	        }
	        else {
	            options.autoEncryption.metadataClient = this.getInternalClient(client, uri, options);
	        }
	        if (options.proxyHost) {
	            options.autoEncryption.proxyOptions = {
	                proxyHost: options.proxyHost,
	                proxyPort: options.proxyPort,
	                proxyUsername: options.proxyUsername,
	                proxyPassword: options.proxyPassword
	            };
	        }
	        this.autoEncrypter = new auto_encrypter_1.AutoEncrypter(client, options.autoEncryption);
	    }
	    getInternalClient(client, uri, options) {
	        // TODO(NODE-4144): Remove new variable for type narrowing
	        let internalClient = this[kInternalClient];
	        if (internalClient == null) {
	            const clonedOptions = {};
	            for (const key of [
	                ...Object.getOwnPropertyNames(options),
	                ...Object.getOwnPropertySymbols(options)
	            ]) {
	                if (['autoEncryption', 'minPoolSize', 'servers', 'caseTranslate', 'dbName'].includes(key))
	                    continue;
	                Reflect.set(clonedOptions, key, Reflect.get(options, key));
	            }
	            clonedOptions.minPoolSize = 0;
	            internalClient = new mongo_client_1.MongoClient(uri, clonedOptions);
	            this[kInternalClient] = internalClient;
	            for (const eventName of constants_1.MONGO_CLIENT_EVENTS) {
	                for (const listener of client.listeners(eventName)) {
	                    internalClient.on(eventName, listener);
	                }
	            }
	            client.on('newListener', (eventName, listener) => {
	                internalClient?.on(eventName, listener);
	            });
	            this.needsConnecting = true;
	        }
	        return internalClient;
	    }
	    async connectInternalClient() {
	        // TODO(NODE-4144): Remove new variable for type narrowing
	        const internalClient = this[kInternalClient];
	        if (this.needsConnecting && internalClient != null) {
	            this.needsConnecting = false;
	            await internalClient.connect();
	        }
	    }
	    closeCallback(client, force, callback) {
	        (0, util_1.callbackify)(this.close.bind(this))(client, force, callback);
	    }
	    async close(client, force) {
	        let error;
	        try {
	            await this.autoEncrypter.teardown(force);
	        }
	        catch (autoEncrypterError) {
	            error = autoEncrypterError;
	        }
	        const internalClient = this[kInternalClient];
	        if (internalClient != null && client !== internalClient) {
	            return await internalClient.close(force);
	        }
	        if (error != null) {
	            throw error;
	        }
	    }
	    static checkForMongoCrypt() {
	        const mongodbClientEncryption = (0, deps_1.getMongoDBClientEncryption)();
	        if ('kModuleError' in mongodbClientEncryption) {
	            throw new error_1.MongoMissingDependencyError('Auto-encryption requested, but the module is not installed. ' +
	                'Please add `mongodb-client-encryption` as a dependency of your project', {
	                cause: mongodbClientEncryption['kModuleError'],
	                dependencyName: 'mongodb-client-encryption'
	            });
	        }
	    }
	}
	encrypter.Encrypter = Encrypter;
	
	return encrypter;
}

var monitor = {};

var connect = {};

var connection = {};

var sessions = {};

var metrics = {};

var hasRequiredMetrics;

function requireMetrics () {
	if (hasRequiredMetrics) return metrics;
	hasRequiredMetrics = 1;
	Object.defineProperty(metrics, "__esModule", { value: true });
	metrics.ConnectionPoolMetrics = void 0;
	/** @internal */
	class ConnectionPoolMetrics {
	    constructor() {
	        this.txnConnections = 0;
	        this.cursorConnections = 0;
	        this.otherConnections = 0;
	    }
	    /**
	     * Mark a connection as pinned for a specific operation.
	     */
	    markPinned(pinType) {
	        if (pinType === ConnectionPoolMetrics.TXN) {
	            this.txnConnections += 1;
	        }
	        else if (pinType === ConnectionPoolMetrics.CURSOR) {
	            this.cursorConnections += 1;
	        }
	        else {
	            this.otherConnections += 1;
	        }
	    }
	    /**
	     * Unmark a connection as pinned for an operation.
	     */
	    markUnpinned(pinType) {
	        if (pinType === ConnectionPoolMetrics.TXN) {
	            this.txnConnections -= 1;
	        }
	        else if (pinType === ConnectionPoolMetrics.CURSOR) {
	            this.cursorConnections -= 1;
	        }
	        else {
	            this.otherConnections -= 1;
	        }
	    }
	    /**
	     * Return information about the cmap metrics as a string.
	     */
	    info(maxPoolSize) {
	        return ('Timed out while checking out a connection from connection pool: ' +
	            `maxPoolSize: ${maxPoolSize}, ` +
	            `connections in use by cursors: ${this.cursorConnections}, ` +
	            `connections in use by transactions: ${this.txnConnections}, ` +
	            `connections in use by other operations: ${this.otherConnections}`);
	    }
	    /**
	     * Reset the metrics to the initial values.
	     */
	    reset() {
	        this.txnConnections = 0;
	        this.cursorConnections = 0;
	        this.otherConnections = 0;
	    }
	}
	metrics.ConnectionPoolMetrics = ConnectionPoolMetrics;
	ConnectionPoolMetrics.TXN = 'txn';
	ConnectionPoolMetrics.CURSOR = 'cursor';
	ConnectionPoolMetrics.OTHER = 'other';
	
	return metrics;
}

var shared = {};

var topology_description = {};

var server_description = {};

var hasRequiredServer_description;

function requireServer_description () {
	if (hasRequiredServer_description) return server_description;
	hasRequiredServer_description = 1;
	Object.defineProperty(server_description, "__esModule", { value: true });
	server_description.ServerDescription = void 0;
	server_description.parseServerType = parseServerType;
	server_description.compareTopologyVersion = compareTopologyVersion;
	const bson_1 = requireBson();
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	const common_1 = requireCommon$1();
	const WRITABLE_SERVER_TYPES = new Set([
	    common_1.ServerType.RSPrimary,
	    common_1.ServerType.Standalone,
	    common_1.ServerType.Mongos,
	    common_1.ServerType.LoadBalancer
	]);
	const DATA_BEARING_SERVER_TYPES = new Set([
	    common_1.ServerType.RSPrimary,
	    common_1.ServerType.RSSecondary,
	    common_1.ServerType.Mongos,
	    common_1.ServerType.Standalone,
	    common_1.ServerType.LoadBalancer
	]);
	/**
	 * The client's view of a single server, based on the most recent hello outcome.
	 *
	 * Internal type, not meant to be directly instantiated
	 * @public
	 */
	class ServerDescription {
	    /**
	     * Create a ServerDescription
	     * @internal
	     *
	     * @param address - The address of the server
	     * @param hello - An optional hello response for this server
	     */
	    constructor(address, hello, options = {}) {
	        if (address == null || address === '') {
	            throw new error_1.MongoRuntimeError('ServerDescription must be provided with a non-empty address');
	        }
	        this.address =
	            typeof address === 'string'
	                ? utils_1.HostAddress.fromString(address).toString() // Use HostAddress to normalize
	                : address.toString();
	        this.type = parseServerType(hello, options);
	        this.hosts = hello?.hosts?.map((host) => host.toLowerCase()) ?? [];
	        this.passives = hello?.passives?.map((host) => host.toLowerCase()) ?? [];
	        this.arbiters = hello?.arbiters?.map((host) => host.toLowerCase()) ?? [];
	        this.tags = hello?.tags ?? {};
	        this.minWireVersion = hello?.minWireVersion ?? 0;
	        this.maxWireVersion = hello?.maxWireVersion ?? 0;
	        this.roundTripTime = options?.roundTripTime ?? -1;
	        this.minRoundTripTime = options?.minRoundTripTime ?? 0;
	        this.lastUpdateTime = (0, utils_1.now)();
	        this.lastWriteDate = hello?.lastWrite?.lastWriteDate ?? 0;
	        this.error = options.error ?? null;
	        // TODO(NODE-2674): Preserve int64 sent from MongoDB
	        this.topologyVersion = this.error?.topologyVersion ?? hello?.topologyVersion ?? null;
	        this.setName = hello?.setName ?? null;
	        this.setVersion = hello?.setVersion ?? null;
	        this.electionId = hello?.electionId ?? null;
	        this.logicalSessionTimeoutMinutes = hello?.logicalSessionTimeoutMinutes ?? null;
	        this.primary = hello?.primary ?? null;
	        this.me = hello?.me?.toLowerCase() ?? null;
	        this.$clusterTime = hello?.$clusterTime ?? null;
	    }
	    get hostAddress() {
	        return utils_1.HostAddress.fromString(this.address);
	    }
	    get allHosts() {
	        return this.hosts.concat(this.arbiters).concat(this.passives);
	    }
	    /** Is this server available for reads*/
	    get isReadable() {
	        return this.type === common_1.ServerType.RSSecondary || this.isWritable;
	    }
	    /** Is this server data bearing */
	    get isDataBearing() {
	        return DATA_BEARING_SERVER_TYPES.has(this.type);
	    }
	    /** Is this server available for writes */
	    get isWritable() {
	        return WRITABLE_SERVER_TYPES.has(this.type);
	    }
	    get host() {
	        const chopLength = `:${this.port}`.length;
	        return this.address.slice(0, -chopLength);
	    }
	    get port() {
	        const port = this.address.split(':').pop();
	        return port ? Number.parseInt(port, 10) : 27017;
	    }
	    /**
	     * Determines if another `ServerDescription` is equal to this one per the rules defined
	     * in the {@link https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#serverdescription|SDAM spec}
	     */
	    equals(other) {
	        // Despite using the comparator that would determine a nullish topologyVersion as greater than
	        // for equality we should only always perform direct equality comparison
	        const topologyVersionsEqual = this.topologyVersion === other?.topologyVersion ||
	            compareTopologyVersion(this.topologyVersion, other?.topologyVersion) === 0;
	        const electionIdsEqual = this.electionId != null && other?.electionId != null
	            ? (0, utils_1.compareObjectId)(this.electionId, other.electionId) === 0
	            : this.electionId === other?.electionId;
	        return (other != null &&
	            (0, utils_1.errorStrictEqual)(this.error, other.error) &&
	            this.type === other.type &&
	            this.minWireVersion === other.minWireVersion &&
	            (0, utils_1.arrayStrictEqual)(this.hosts, other.hosts) &&
	            tagsStrictEqual(this.tags, other.tags) &&
	            this.setName === other.setName &&
	            this.setVersion === other.setVersion &&
	            electionIdsEqual &&
	            this.primary === other.primary &&
	            this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes &&
	            topologyVersionsEqual);
	    }
	}
	server_description.ServerDescription = ServerDescription;
	// Parses a `hello` message and determines the server type
	function parseServerType(hello, options) {
	    if (options?.loadBalanced) {
	        return common_1.ServerType.LoadBalancer;
	    }
	    if (!hello || !hello.ok) {
	        return common_1.ServerType.Unknown;
	    }
	    if (hello.isreplicaset) {
	        return common_1.ServerType.RSGhost;
	    }
	    if (hello.msg && hello.msg === 'isdbgrid') {
	        return common_1.ServerType.Mongos;
	    }
	    if (hello.setName) {
	        if (hello.hidden) {
	            return common_1.ServerType.RSOther;
	        }
	        else if (hello.isWritablePrimary) {
	            return common_1.ServerType.RSPrimary;
	        }
	        else if (hello.secondary) {
	            return common_1.ServerType.RSSecondary;
	        }
	        else if (hello.arbiterOnly) {
	            return common_1.ServerType.RSArbiter;
	        }
	        else {
	            return common_1.ServerType.RSOther;
	        }
	    }
	    return common_1.ServerType.Standalone;
	}
	function tagsStrictEqual(tags, tags2) {
	    const tagsKeys = Object.keys(tags);
	    const tags2Keys = Object.keys(tags2);
	    return (tagsKeys.length === tags2Keys.length &&
	        tagsKeys.every((key) => tags2[key] === tags[key]));
	}
	/**
	 * Compares two topology versions.
	 *
	 * 1. If the response topologyVersion is unset or the ServerDescription's
	 *    topologyVersion is null, the client MUST assume the response is more recent.
	 * 1. If the response's topologyVersion.processId is not equal to the
	 *    ServerDescription's, the client MUST assume the response is more recent.
	 * 1. If the response's topologyVersion.processId is equal to the
	 *    ServerDescription's, the client MUST use the counter field to determine
	 *    which topologyVersion is more recent.
	 *
	 * ```ts
	 * currentTv <   newTv === -1
	 * currentTv === newTv === 0
	 * currentTv >   newTv === 1
	 * ```
	 */
	function compareTopologyVersion(currentTv, newTv) {
	    if (currentTv == null || newTv == null) {
	        return -1;
	    }
	    if (!currentTv.processId.equals(newTv.processId)) {
	        return -1;
	    }
	    // TODO(NODE-2674): Preserve int64 sent from MongoDB
	    const currentCounter = typeof currentTv.counter === 'bigint'
	        ? bson_1.Long.fromBigInt(currentTv.counter)
	        : bson_1.Long.isLong(currentTv.counter)
	            ? currentTv.counter
	            : bson_1.Long.fromNumber(currentTv.counter);
	    const newCounter = typeof newTv.counter === 'bigint'
	        ? bson_1.Long.fromBigInt(newTv.counter)
	        : bson_1.Long.isLong(newTv.counter)
	            ? newTv.counter
	            : bson_1.Long.fromNumber(newTv.counter);
	    return currentCounter.compare(newCounter);
	}
	
	return server_description;
}

var hasRequiredTopology_description;

function requireTopology_description () {
	if (hasRequiredTopology_description) return topology_description;
	hasRequiredTopology_description = 1;
	Object.defineProperty(topology_description, "__esModule", { value: true });
	topology_description.TopologyDescription = void 0;
	const bson_1 = requireBson();
	const WIRE_CONSTANTS = requireConstants$1();
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	const common_1 = requireCommon$1();
	const server_description_1 = requireServer_description();
	// constants related to compatibility checks
	const MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
	const MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
	const MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
	const MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
	const MONGOS_OR_UNKNOWN = new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);
	const MONGOS_OR_STANDALONE = new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);
	const NON_PRIMARY_RS_MEMBERS = new Set([
	    common_1.ServerType.RSSecondary,
	    common_1.ServerType.RSArbiter,
	    common_1.ServerType.RSOther
	]);
	/**
	 * Representation of a deployment of servers
	 * @public
	 */
	class TopologyDescription {
	    /**
	     * Create a TopologyDescription
	     */
	    constructor(topologyType, serverDescriptions = null, setName = null, maxSetVersion = null, maxElectionId = null, commonWireVersion = null, options = null) {
	        options = options ?? {};
	        this.type = topologyType ?? common_1.TopologyType.Unknown;
	        this.servers = serverDescriptions ?? new Map();
	        this.stale = false;
	        this.compatible = true;
	        this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 0;
	        this.localThresholdMS = options.localThresholdMS ?? 15;
	        this.setName = setName ?? null;
	        this.maxElectionId = maxElectionId ?? null;
	        this.maxSetVersion = maxSetVersion ?? null;
	        this.commonWireVersion = commonWireVersion ?? 0;
	        // determine server compatibility
	        for (const serverDescription of this.servers.values()) {
	            // Load balancer mode is always compatible.
	            if (serverDescription.type === common_1.ServerType.Unknown ||
	                serverDescription.type === common_1.ServerType.LoadBalancer) {
	                continue;
	            }
	            if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
	                this.compatible = false;
	                this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
	            }
	            if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
	                this.compatible = false;
	                this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;
	                break;
	            }
	        }
	        // Whenever a client updates the TopologyDescription from a hello response, it MUST set
	        // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes
	        // value among ServerDescriptions of all data-bearing server types. If any have a null
	        // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be
	        // set to null.
	        this.logicalSessionTimeoutMinutes = null;
	        for (const [, server] of this.servers) {
	            if (server.isReadable) {
	                if (server.logicalSessionTimeoutMinutes == null) {
	                    // If any of the servers have a null logicalSessionsTimeout, then the whole topology does
	                    this.logicalSessionTimeoutMinutes = null;
	                    break;
	                }
	                if (this.logicalSessionTimeoutMinutes == null) {
	                    // First server with a non null logicalSessionsTimeout
	                    this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;
	                    continue;
	                }
	                // Always select the smaller of the:
	                // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout
	                this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);
	            }
	        }
	    }
	    /**
	     * Returns a new TopologyDescription based on the SrvPollingEvent
	     * @internal
	     */
	    updateFromSrvPollingEvent(ev, srvMaxHosts = 0) {
	        /** The SRV addresses defines the set of addresses we should be using */
	        const incomingHostnames = ev.hostnames();
	        const currentHostnames = new Set(this.servers.keys());
	        const hostnamesToAdd = new Set(incomingHostnames);
	        const hostnamesToRemove = new Set();
	        for (const hostname of currentHostnames) {
	            // filter hostnamesToAdd (made from incomingHostnames) down to what is *not* present in currentHostnames
	            hostnamesToAdd.delete(hostname);
	            if (!incomingHostnames.has(hostname)) {
	                // If the SRV Records no longer include this hostname
	                // we have to stop using it
	                hostnamesToRemove.add(hostname);
	            }
	        }
	        if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {
	            // No new hosts to add and none to remove
	            return this;
	        }
	        const serverDescriptions = new Map(this.servers);
	        for (const removedHost of hostnamesToRemove) {
	            serverDescriptions.delete(removedHost);
	        }
	        if (hostnamesToAdd.size > 0) {
	            if (srvMaxHosts === 0) {
	                // Add all!
	                for (const hostToAdd of hostnamesToAdd) {
	                    serverDescriptions.set(hostToAdd, new server_description_1.ServerDescription(hostToAdd));
	                }
	            }
	            else if (serverDescriptions.size < srvMaxHosts) {
	                // Add only the amount needed to get us back to srvMaxHosts
	                const selectedHosts = (0, utils_1.shuffle)(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);
	                for (const selectedHostToAdd of selectedHosts) {
	                    serverDescriptions.set(selectedHostToAdd, new server_description_1.ServerDescription(selectedHostToAdd));
	                }
	            }
	        }
	        return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
	    }
	    /**
	     * Returns a copy of this description updated with a given ServerDescription
	     * @internal
	     */
	    update(serverDescription) {
	        const address = serverDescription.address;
	        // potentially mutated values
	        let { type: topologyType, setName, maxSetVersion, maxElectionId, commonWireVersion } = this;
	        const serverType = serverDescription.type;
	        const serverDescriptions = new Map(this.servers);
	        // update common wire version
	        if (serverDescription.maxWireVersion !== 0) {
	            if (commonWireVersion == null) {
	                commonWireVersion = serverDescription.maxWireVersion;
	            }
	            else {
	                commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
	            }
	        }
	        if (typeof serverDescription.setName === 'string' &&
	            typeof setName === 'string' &&
	            serverDescription.setName !== setName) {
	            if (topologyType === common_1.TopologyType.Single) {
	                // "Single" Topology with setName mismatch is direct connection usage, mark unknown do not remove
	                serverDescription = new server_description_1.ServerDescription(address);
	            }
	            else {
	                serverDescriptions.delete(address);
	            }
	        }
	        // update the actual server description
	        serverDescriptions.set(address, serverDescription);
	        if (topologyType === common_1.TopologyType.Single) {
	            // once we are defined as single, that never changes
	            return new TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
	        }
	        if (topologyType === common_1.TopologyType.Unknown) {
	            if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {
	                serverDescriptions.delete(address);
	            }
	            else {
	                topologyType = topologyTypeForServerType(serverType);
	            }
	        }
	        if (topologyType === common_1.TopologyType.Sharded) {
	            if (!MONGOS_OR_UNKNOWN.has(serverType)) {
	                serverDescriptions.delete(address);
	            }
	        }
	        if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {
	            if (MONGOS_OR_STANDALONE.has(serverType)) {
	                serverDescriptions.delete(address);
	            }
	            if (serverType === common_1.ServerType.RSPrimary) {
	                const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
	                topologyType = result[0];
	                setName = result[1];
	                maxSetVersion = result[2];
	                maxElectionId = result[3];
	            }
	            else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
	                const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);
	                topologyType = result[0];
	                setName = result[1];
	            }
	        }
	        if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {
	            if (MONGOS_OR_STANDALONE.has(serverType)) {
	                serverDescriptions.delete(address);
	                topologyType = checkHasPrimary(serverDescriptions);
	            }
	            else if (serverType === common_1.ServerType.RSPrimary) {
	                const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
	                topologyType = result[0];
	                setName = result[1];
	                maxSetVersion = result[2];
	                maxElectionId = result[3];
	            }
	            else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
	                topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);
	            }
	            else {
	                topologyType = checkHasPrimary(serverDescriptions);
	            }
	        }
	        return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
	    }
	    get error() {
	        const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);
	        if (descriptionsWithError.length > 0) {
	            return descriptionsWithError[0].error;
	        }
	        return null;
	    }
	    /**
	     * Determines if the topology description has any known servers
	     */
	    get hasKnownServers() {
	        return Array.from(this.servers.values()).some((sd) => sd.type !== common_1.ServerType.Unknown);
	    }
	    /**
	     * Determines if this topology description has a data-bearing server available.
	     */
	    get hasDataBearingServers() {
	        return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);
	    }
	    /**
	     * Determines if the topology has a definition for the provided address
	     * @internal
	     */
	    hasServer(address) {
	        return this.servers.has(address);
	    }
	    /**
	     * Returns a JSON-serializable representation of the TopologyDescription.  This is primarily
	     * intended for use with JSON.stringify().
	     *
	     * This method will not throw.
	     */
	    toJSON() {
	        return bson_1.EJSON.serialize(this);
	    }
	}
	topology_description.TopologyDescription = TopologyDescription;
	function topologyTypeForServerType(serverType) {
	    switch (serverType) {
	        case common_1.ServerType.Standalone:
	            return common_1.TopologyType.Single;
	        case common_1.ServerType.Mongos:
	            return common_1.TopologyType.Sharded;
	        case common_1.ServerType.RSPrimary:
	            return common_1.TopologyType.ReplicaSetWithPrimary;
	        case common_1.ServerType.RSOther:
	        case common_1.ServerType.RSSecondary:
	            return common_1.TopologyType.ReplicaSetNoPrimary;
	        default:
	            return common_1.TopologyType.Unknown;
	    }
	}
	function updateRsFromPrimary(serverDescriptions, serverDescription, setName = null, maxSetVersion = null, maxElectionId = null) {
	    setName = setName || serverDescription.setName;
	    if (setName !== serverDescription.setName) {
	        serverDescriptions.delete(serverDescription.address);
	        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
	    }
	    if (serverDescription.maxWireVersion >= 17) {
	        const electionIdComparison = (0, utils_1.compareObjectId)(maxElectionId, serverDescription.electionId);
	        const maxElectionIdIsEqual = electionIdComparison === 0;
	        const maxElectionIdIsLess = electionIdComparison === -1;
	        const maxSetVersionIsLessOrEqual = (maxSetVersion ?? -1) <= (serverDescription.setVersion ?? -1);
	        if (maxElectionIdIsLess || (maxElectionIdIsEqual && maxSetVersionIsLessOrEqual)) {
	            // The reported electionId was greater
	            // or the electionId was equal and reported setVersion was greater
	            // Always update both values, they are a tuple
	            maxElectionId = serverDescription.electionId;
	            maxSetVersion = serverDescription.setVersion;
	        }
	        else {
	            // Stale primary
	            // replace serverDescription with a default ServerDescription of type "Unknown"
	            serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));
	            return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
	        }
	    }
	    else {
	        const electionId = serverDescription.electionId ? serverDescription.electionId : null;
	        if (serverDescription.setVersion && electionId) {
	            if (maxSetVersion && maxElectionId) {
	                if (maxSetVersion > serverDescription.setVersion ||
	                    (0, utils_1.compareObjectId)(maxElectionId, electionId) > 0) {
	                    // this primary is stale, we must remove it
	                    serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));
	                    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
	                }
	            }
	            maxElectionId = serverDescription.electionId;
	        }
	        if (serverDescription.setVersion != null &&
	            (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
	            maxSetVersion = serverDescription.setVersion;
	        }
	    }
	    // We've heard from the primary. Is it the same primary as before?
	    for (const [address, server] of serverDescriptions) {
	        if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {
	            // Reset old primary's type to Unknown.
	            serverDescriptions.set(address, new server_description_1.ServerDescription(server.address));
	            // There can only be one primary
	            break;
	        }
	    }
	    // Discover new hosts from this primary's response.
	    serverDescription.allHosts.forEach((address) => {
	        if (!serverDescriptions.has(address)) {
	            serverDescriptions.set(address, new server_description_1.ServerDescription(address));
	        }
	    });
	    // Remove hosts not in the response.
	    const currentAddresses = Array.from(serverDescriptions.keys());
	    const responseAddresses = serverDescription.allHosts;
	    currentAddresses
	        .filter((addr) => responseAddresses.indexOf(addr) === -1)
	        .forEach((address) => {
	        serverDescriptions.delete(address);
	    });
	    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
	}
	function updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName = null) {
	    if (setName == null) {
	        // TODO(NODE-3483): should be an appropriate runtime error
	        throw new error_1.MongoRuntimeError('Argument "setName" is required if connected to a replica set');
	    }
	    if (setName !== serverDescription.setName ||
	        (serverDescription.me && serverDescription.address !== serverDescription.me)) {
	        serverDescriptions.delete(serverDescription.address);
	    }
	    return checkHasPrimary(serverDescriptions);
	}
	function updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName = null) {
	    const topologyType = common_1.TopologyType.ReplicaSetNoPrimary;
	    setName = setName ?? serverDescription.setName;
	    if (setName !== serverDescription.setName) {
	        serverDescriptions.delete(serverDescription.address);
	        return [topologyType, setName];
	    }
	    serverDescription.allHosts.forEach((address) => {
	        if (!serverDescriptions.has(address)) {
	            serverDescriptions.set(address, new server_description_1.ServerDescription(address));
	        }
	    });
	    if (serverDescription.me && serverDescription.address !== serverDescription.me) {
	        serverDescriptions.delete(serverDescription.address);
	    }
	    return [topologyType, setName];
	}
	function checkHasPrimary(serverDescriptions) {
	    for (const serverDescription of serverDescriptions.values()) {
	        if (serverDescription.type === common_1.ServerType.RSPrimary) {
	            return common_1.TopologyType.ReplicaSetWithPrimary;
	        }
	    }
	    return common_1.TopologyType.ReplicaSetNoPrimary;
	}
	
	return topology_description;
}

var hasRequiredShared;

function requireShared () {
	if (hasRequiredShared) return shared;
	hasRequiredShared = 1;
	Object.defineProperty(shared, "__esModule", { value: true });
	shared.getReadPreference = getReadPreference;
	shared.isSharded = isSharded;
	const error_1 = requireError();
	const read_preference_1 = requireRead_preference();
	const common_1 = requireCommon$1();
	const topology_description_1 = requireTopology_description();
	function getReadPreference(options) {
	    // Default to command version of the readPreference.
	    let readPreference = options?.readPreference ?? read_preference_1.ReadPreference.primary;
	    if (typeof readPreference === 'string') {
	        readPreference = read_preference_1.ReadPreference.fromString(readPreference);
	    }
	    if (!(readPreference instanceof read_preference_1.ReadPreference)) {
	        throw new error_1.MongoInvalidArgumentError('Option "readPreference" must be a ReadPreference instance');
	    }
	    return readPreference;
	}
	function isSharded(topologyOrServer) {
	    if (topologyOrServer == null) {
	        return false;
	    }
	    if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {
	        return true;
	    }
	    // NOTE: This is incredibly inefficient, and should be removed once command construction
	    // happens based on `Server` not `Topology`.
	    if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {
	        const servers = Array.from(topologyOrServer.description.servers.values());
	        return servers.some((server) => server.type === common_1.ServerType.Mongos);
	    }
	    return false;
	}
	
	return shared;
}

var transactions = {};

var hasRequiredTransactions;

function requireTransactions () {
	if (hasRequiredTransactions) return transactions;
	hasRequiredTransactions = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Transaction = exports.TxnState = void 0;
		exports.isTransactionCommand = isTransactionCommand;
		const error_1 = requireError();
		const read_concern_1 = requireRead_concern();
		const read_preference_1 = requireRead_preference();
		const write_concern_1 = requireWrite_concern();
		/** @internal */
		exports.TxnState = Object.freeze({
		    NO_TRANSACTION: 'NO_TRANSACTION',
		    STARTING_TRANSACTION: 'STARTING_TRANSACTION',
		    TRANSACTION_IN_PROGRESS: 'TRANSACTION_IN_PROGRESS',
		    TRANSACTION_COMMITTED: 'TRANSACTION_COMMITTED',
		    TRANSACTION_COMMITTED_EMPTY: 'TRANSACTION_COMMITTED_EMPTY',
		    TRANSACTION_ABORTED: 'TRANSACTION_ABORTED'
		});
		const stateMachine = {
		    [exports.TxnState.NO_TRANSACTION]: [exports.TxnState.NO_TRANSACTION, exports.TxnState.STARTING_TRANSACTION],
		    [exports.TxnState.STARTING_TRANSACTION]: [
		        exports.TxnState.TRANSACTION_IN_PROGRESS,
		        exports.TxnState.TRANSACTION_COMMITTED,
		        exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
		        exports.TxnState.TRANSACTION_ABORTED
		    ],
		    [exports.TxnState.TRANSACTION_IN_PROGRESS]: [
		        exports.TxnState.TRANSACTION_IN_PROGRESS,
		        exports.TxnState.TRANSACTION_COMMITTED,
		        exports.TxnState.TRANSACTION_ABORTED
		    ],
		    [exports.TxnState.TRANSACTION_COMMITTED]: [
		        exports.TxnState.TRANSACTION_COMMITTED,
		        exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
		        exports.TxnState.STARTING_TRANSACTION,
		        exports.TxnState.NO_TRANSACTION
		    ],
		    [exports.TxnState.TRANSACTION_ABORTED]: [exports.TxnState.STARTING_TRANSACTION, exports.TxnState.NO_TRANSACTION],
		    [exports.TxnState.TRANSACTION_COMMITTED_EMPTY]: [
		        exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
		        exports.TxnState.NO_TRANSACTION
		    ]
		};
		const ACTIVE_STATES = new Set([
		    exports.TxnState.STARTING_TRANSACTION,
		    exports.TxnState.TRANSACTION_IN_PROGRESS
		]);
		const COMMITTED_STATES = new Set([
		    exports.TxnState.TRANSACTION_COMMITTED,
		    exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
		    exports.TxnState.TRANSACTION_ABORTED
		]);
		/**
		 * @public
		 * A class maintaining state related to a server transaction. Internal Only
		 */
		class Transaction {
		    /** Create a transaction @internal */
		    constructor(options) {
		        options = options ?? {};
		        this.state = exports.TxnState.NO_TRANSACTION;
		        this.options = {};
		        const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
		        if (writeConcern) {
		            if (writeConcern.w === 0) {
		                throw new error_1.MongoTransactionError('Transactions do not support unacknowledged write concern');
		            }
		            this.options.writeConcern = writeConcern;
		        }
		        if (options.readConcern) {
		            this.options.readConcern = read_concern_1.ReadConcern.fromOptions(options);
		        }
		        if (options.readPreference) {
		            this.options.readPreference = read_preference_1.ReadPreference.fromOptions(options);
		        }
		        if (options.maxCommitTimeMS) {
		            this.options.maxTimeMS = options.maxCommitTimeMS;
		        }
		        // TODO: This isn't technically necessary
		        this._pinnedServer = undefined;
		        this._recoveryToken = undefined;
		    }
		    /** @internal */
		    get server() {
		        return this._pinnedServer;
		    }
		    get recoveryToken() {
		        return this._recoveryToken;
		    }
		    get isPinned() {
		        return !!this.server;
		    }
		    /** @returns Whether the transaction has started */
		    get isStarting() {
		        return this.state === exports.TxnState.STARTING_TRANSACTION;
		    }
		    /**
		     * @returns Whether this session is presently in a transaction
		     */
		    get isActive() {
		        return ACTIVE_STATES.has(this.state);
		    }
		    get isCommitted() {
		        return COMMITTED_STATES.has(this.state);
		    }
		    /**
		     * Transition the transaction in the state machine
		     * @internal
		     * @param nextState - The new state to transition to
		     */
		    transition(nextState) {
		        const nextStates = stateMachine[this.state];
		        if (nextStates && nextStates.includes(nextState)) {
		            this.state = nextState;
		            if (this.state === exports.TxnState.NO_TRANSACTION ||
		                this.state === exports.TxnState.STARTING_TRANSACTION ||
		                this.state === exports.TxnState.TRANSACTION_ABORTED) {
		                this.unpinServer();
		            }
		            return;
		        }
		        throw new error_1.MongoRuntimeError(`Attempted illegal state transition from [${this.state}] to [${nextState}]`);
		    }
		    /** @internal */
		    pinServer(server) {
		        if (this.isActive) {
		            this._pinnedServer = server;
		        }
		    }
		    /** @internal */
		    unpinServer() {
		        this._pinnedServer = undefined;
		    }
		}
		exports.Transaction = Transaction;
		function isTransactionCommand(command) {
		    return !!(command.commitTransaction || command.abortTransaction);
		}
		
	} (transactions));
	return transactions;
}

var hasRequiredSessions;

function requireSessions () {
	if (hasRequiredSessions) return sessions;
	hasRequiredSessions = 1;
	var _a;
	Object.defineProperty(sessions, "__esModule", { value: true });
	sessions.ServerSessionPool = sessions.ServerSession = sessions.ClientSession = void 0;
	sessions.maybeClearPinnedConnection = maybeClearPinnedConnection;
	sessions.applySession = applySession;
	sessions.updateSessionFromResponse = updateSessionFromResponse;
	const bson_1 = requireBson();
	const metrics_1 = requireMetrics();
	const shared_1 = requireShared();
	const constants_1 = requireConstants();
	const error_1 = requireError();
	const mongo_types_1 = requireMongo_types();
	const execute_operation_1 = requireExecute_operation();
	const run_command_1 = requireRun_command();
	const read_concern_1 = requireRead_concern();
	const read_preference_1 = requireRead_preference();
	const resource_management_1 = requireResource_management();
	const common_1 = requireCommon$1();
	const transactions_1 = requireTransactions();
	const utils_1 = requireUtils$1();
	const write_concern_1 = requireWrite_concern();
	const minWireVersionForShardedTransactions = 8;
	/** @internal */
	const kServerSession = Symbol('serverSession');
	/** @internal */
	const kSnapshotTime = Symbol('snapshotTime');
	/** @internal */
	const kSnapshotEnabled = Symbol('snapshotEnabled');
	/** @internal */
	const kPinnedConnection = Symbol('pinnedConnection');
	/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */
	const kTxnNumberIncrement = Symbol('txnNumberIncrement');
	/**
	 * A class representing a client session on the server
	 *
	 * NOTE: not meant to be instantiated directly.
	 * @public
	 */
	class ClientSession extends mongo_types_1.TypedEventEmitter {
	    /**
	     * Create a client session.
	     * @internal
	     * @param client - The current client
	     * @param sessionPool - The server session pool (Internal Class)
	     * @param options - Optional settings
	     * @param clientOptions - Optional settings provided when creating a MongoClient
	     */
	    constructor(client, sessionPool, options, clientOptions) {
	        super();
	        /** @internal */
	        this[_a] = false;
	        if (client == null) {
	            // TODO(NODE-3483)
	            throw new error_1.MongoRuntimeError('ClientSession requires a MongoClient');
	        }
	        if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
	            // TODO(NODE-3483)
	            throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');
	        }
	        options = options ?? {};
	        if (options.snapshot === true) {
	            this[kSnapshotEnabled] = true;
	            if (options.causalConsistency === true) {
	                throw new error_1.MongoInvalidArgumentError('Properties "causalConsistency" and "snapshot" are mutually exclusive');
	            }
	        }
	        this.client = client;
	        this.sessionPool = sessionPool;
	        this.hasEnded = false;
	        this.clientOptions = clientOptions;
	        this.timeoutMS = options.defaultTimeoutMS ?? client.s.options?.timeoutMS;
	        this.explicit = !!options.explicit;
	        this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;
	        this[kTxnNumberIncrement] = 0;
	        const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;
	        this.supports = {
	            // if we can enable causal consistency, do so by default
	            causalConsistency: options.causalConsistency ?? defaultCausalConsistencyValue
	        };
	        this.clusterTime = options.initialClusterTime;
	        this.operationTime = undefined;
	        this.owner = options.owner;
	        this.defaultTransactionOptions = { ...options.defaultTransactionOptions };
	        this.transaction = new transactions_1.Transaction();
	    }
	    /** The server id associated with this session */
	    get id() {
	        return this[kServerSession]?.id;
	    }
	    get serverSession() {
	        let serverSession = this[kServerSession];
	        if (serverSession == null) {
	            if (this.explicit) {
	                throw new error_1.MongoRuntimeError('Unexpected null serverSession for an explicit session');
	            }
	            if (this.hasEnded) {
	                throw new error_1.MongoRuntimeError('Unexpected null serverSession for an ended implicit session');
	            }
	            serverSession = this.sessionPool.acquire();
	            this[kServerSession] = serverSession;
	        }
	        return serverSession;
	    }
	    /** Whether or not this session is configured for snapshot reads */
	    get snapshotEnabled() {
	        return this[kSnapshotEnabled];
	    }
	    get loadBalanced() {
	        return this.client.topology?.description.type === common_1.TopologyType.LoadBalanced;
	    }
	    /** @internal */
	    get pinnedConnection() {
	        return this[kPinnedConnection];
	    }
	    /** @internal */
	    pin(conn) {
	        if (this[kPinnedConnection]) {
	            throw TypeError('Cannot pin multiple connections to the same session');
	        }
	        this[kPinnedConnection] = conn;
	        conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
	    }
	    /** @internal */
	    unpin(options) {
	        if (this.loadBalanced) {
	            return maybeClearPinnedConnection(this, options);
	        }
	        this.transaction.unpinServer();
	    }
	    get isPinned() {
	        return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;
	    }
	    /**
	     * Frees any client-side resources held by the current session.  If a session is in a transaction,
	     * the transaction is aborted.
	     *
	     * Does not end the session on the server.
	     *
	     * @param options - Optional settings. Currently reserved for future use
	     */
	    async endSession(options) {
	        try {
	            if (this.inTransaction()) {
	                await this.abortTransaction();
	            }
	            if (!this.hasEnded) {
	                const serverSession = this[kServerSession];
	                if (serverSession != null) {
	                    // release the server session back to the pool
	                    this.sessionPool.release(serverSession);
	                    // Make sure a new serverSession never makes it onto this ClientSession
	                    Object.defineProperty(this, kServerSession, {
	                        value: ServerSession.clone(serverSession),
	                        writable: false
	                    });
	                }
	                // mark the session as ended, and emit a signal
	                this.hasEnded = true;
	                this.emit('ended', this);
	            }
	        }
	        catch (error) {
	            // spec indicates that we should ignore all errors for `endSessions`
	            (0, utils_1.squashError)(error);
	        }
	        finally {
	            maybeClearPinnedConnection(this, { force: true, ...options });
	        }
	    }
	    /** @internal */
	    async asyncDispose() {
	        await this.endSession({ force: true });
	    }
	    /**
	     * Advances the operationTime for a ClientSession.
	     *
	     * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to
	     */
	    advanceOperationTime(operationTime) {
	        if (this.operationTime == null) {
	            this.operationTime = operationTime;
	            return;
	        }
	        if (operationTime.greaterThan(this.operationTime)) {
	            this.operationTime = operationTime;
	        }
	    }
	    /**
	     * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession
	     *
	     * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature
	     */
	    advanceClusterTime(clusterTime) {
	        if (!clusterTime || typeof clusterTime !== 'object') {
	            throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');
	        }
	        if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {
	            throw new error_1.MongoInvalidArgumentError('input cluster time "clusterTime" property must be a valid BSON Timestamp');
	        }
	        if (!clusterTime.signature ||
	            clusterTime.signature.hash?._bsontype !== 'Binary' ||
	            (typeof clusterTime.signature.keyId !== 'bigint' &&
	                typeof clusterTime.signature.keyId !== 'number' &&
	                clusterTime.signature.keyId?._bsontype !== 'Long') // apparently we decode the key to number?
	        ) {
	            throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid "signature" property with BSON Binary hash and BSON Long keyId');
	        }
	        (0, common_1._advanceClusterTime)(this, clusterTime);
	    }
	    /**
	     * Used to determine if this session equals another
	     *
	     * @param session - The session to compare to
	     */
	    equals(session) {
	        if (!(session instanceof ClientSession)) {
	            return false;
	        }
	        if (this.id == null || session.id == null) {
	            return false;
	        }
	        return utils_1.ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);
	    }
	    /**
	     * Increment the transaction number on the internal ServerSession
	     *
	     * @privateRemarks
	     * This helper increments a value stored on the client session that will be
	     * added to the serverSession's txnNumber upon applying it to a command.
	     * This is because the serverSession is lazily acquired after a connection is obtained
	     */
	    incrementTransactionNumber() {
	        this[kTxnNumberIncrement] += 1;
	    }
	    /** @returns whether this session is currently in a transaction or not */
	    inTransaction() {
	        return this.transaction.isActive;
	    }
	    /**
	     * Starts a new transaction with the given options.
	     *
	     * @remarks
	     * **IMPORTANT**: Running operations in parallel is not supported during a transaction. The use of `Promise.all`,
	     * `Promise.allSettled`, `Promise.race`, etc to parallelize operations inside a transaction is
	     * undefined behaviour.
	     *
	     * @param options - Options for the transaction
	     */
	    startTransaction(options) {
	        if (this[kSnapshotEnabled]) {
	            throw new error_1.MongoCompatibilityError('Transactions are not supported in snapshot sessions');
	        }
	        if (this.inTransaction()) {
	            throw new error_1.MongoTransactionError('Transaction already in progress');
	        }
	        if (this.isPinned && this.transaction.isCommitted) {
	            this.unpin();
	        }
	        const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);
	        if ((0, shared_1.isSharded)(this.client.topology) &&
	            topologyMaxWireVersion != null &&
	            topologyMaxWireVersion < minWireVersionForShardedTransactions) {
	            throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');
	        }
	        // increment txnNumber
	        this.incrementTransactionNumber();
	        // create transaction state
	        this.transaction = new transactions_1.Transaction({
	            readConcern: options?.readConcern ??
	                this.defaultTransactionOptions.readConcern ??
	                this.clientOptions?.readConcern,
	            writeConcern: options?.writeConcern ??
	                this.defaultTransactionOptions.writeConcern ??
	                this.clientOptions?.writeConcern,
	            readPreference: options?.readPreference ??
	                this.defaultTransactionOptions.readPreference ??
	                this.clientOptions?.readPreference,
	            maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS
	        });
	        this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);
	    }
	    /**
	     * Commits the currently active transaction in this session.
	     */
	    async commitTransaction() {
	        if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION) {
	            throw new error_1.MongoTransactionError('No transaction started');
	        }
	        if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION ||
	            this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
	            // the transaction was never started, we can safely exit here
	            this.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);
	            return;
	        }
	        if (this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {
	            throw new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction');
	        }
	        const command = { commitTransaction: 1 };
	        const wc = this.transaction.options.writeConcern ?? this.clientOptions?.writeConcern;
	        if (wc != null) {
	            write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 10000, w: 'majority', ...wc });
	        }
	        if (this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED) {
	            write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 10000, ...wc, w: 'majority' });
	        }
	        if (typeof this.transaction.options.maxTimeMS === 'number') {
	            command.maxTimeMS = this.transaction.options.maxTimeMS;
	        }
	        if (this.transaction.recoveryToken) {
	            command.recoveryToken = this.transaction.recoveryToken;
	        }
	        const operation = new run_command_1.RunAdminCommandOperation(command, {
	            session: this,
	            readPreference: read_preference_1.ReadPreference.primary,
	            bypassPinningCheck: true
	        });
	        try {
	            await (0, execute_operation_1.executeOperation)(this.client, operation);
	            return;
	        }
	        catch (firstCommitError) {
	            if (firstCommitError instanceof error_1.MongoError && (0, error_1.isRetryableWriteError)(firstCommitError)) {
	                // SPEC-1185: apply majority write concern when retrying commitTransaction
	                write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 10000, ...wc, w: 'majority' });
	                // per txns spec, must unpin session in this case
	                this.unpin({ force: true });
	                try {
	                    await (0, execute_operation_1.executeOperation)(this.client, operation);
	                    return;
	                }
	                catch (retryCommitError) {
	                    // If the retry failed, we process that error instead of the original
	                    if (shouldAddUnknownTransactionCommitResultLabel(retryCommitError)) {
	                        retryCommitError.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
	                    }
	                    if (shouldUnpinAfterCommitError(retryCommitError)) {
	                        this.unpin({ error: retryCommitError });
	                    }
	                    throw retryCommitError;
	                }
	            }
	            if (shouldAddUnknownTransactionCommitResultLabel(firstCommitError)) {
	                firstCommitError.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
	            }
	            if (shouldUnpinAfterCommitError(firstCommitError)) {
	                this.unpin({ error: firstCommitError });
	            }
	            throw firstCommitError;
	        }
	        finally {
	            this.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);
	        }
	    }
	    /**
	     * Aborts the currently active transaction in this session.
	     */
	    async abortTransaction() {
	        if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION) {
	            throw new error_1.MongoTransactionError('No transaction started');
	        }
	        if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {
	            // the transaction was never started, we can safely exit here
	            this.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
	            return;
	        }
	        if (this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {
	            throw new error_1.MongoTransactionError('Cannot call abortTransaction twice');
	        }
	        if (this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED ||
	            this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
	            throw new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction');
	        }
	        const command = { abortTransaction: 1 };
	        const wc = this.transaction.options.writeConcern ?? this.clientOptions?.writeConcern;
	        if (wc != null) {
	            write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 10000, w: 'majority', ...wc });
	        }
	        if (this.transaction.recoveryToken) {
	            command.recoveryToken = this.transaction.recoveryToken;
	        }
	        const operation = new run_command_1.RunAdminCommandOperation(command, {
	            session: this,
	            readPreference: read_preference_1.ReadPreference.primary,
	            bypassPinningCheck: true
	        });
	        try {
	            await (0, execute_operation_1.executeOperation)(this.client, operation);
	            this.unpin();
	            return;
	        }
	        catch (firstAbortError) {
	            this.unpin();
	            if (firstAbortError instanceof error_1.MongoError && (0, error_1.isRetryableWriteError)(firstAbortError)) {
	                try {
	                    await (0, execute_operation_1.executeOperation)(this.client, operation);
	                    return;
	                }
	                catch {
	                    // we do not retry the retry
	                }
	            }
	            // The spec indicates that if the operation times out or fails with a non-retryable error, we should ignore all errors on `abortTransaction`
	        }
	        finally {
	            this.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
	            if (this.loadBalanced) {
	                maybeClearPinnedConnection(this, { force: false });
	            }
	        }
	    }
	    /**
	     * This is here to ensure that ClientSession is never serialized to BSON.
	     */
	    toBSON() {
	        throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');
	    }
	    /**
	     * Starts a transaction and runs a provided function, ensuring the commitTransaction is always attempted when all operations run in the function have completed.
	     *
	     * **IMPORTANT:** This method requires the function passed in to return a Promise. That promise must be made by `await`-ing all operations in such a way that rejections are propagated to the returned promise.
	     *
	     * **IMPORTANT:** Running operations in parallel is not supported during a transaction. The use of `Promise.all`,
	     * `Promise.allSettled`, `Promise.race`, etc to parallelize operations inside a transaction is
	     * undefined behaviour.
	     *
	     *
	     * @remarks
	     * - If all operations successfully complete and the `commitTransaction` operation is successful, then the provided function will return the result of the provided function.
	     * - If the transaction is unable to complete or an error is thrown from within the provided function, then the provided function will throw an error.
	     *   - If the transaction is manually aborted within the provided function it will not throw.
	     * - If the driver needs to attempt to retry the operations, the provided function may be called multiple times.
	     *
	     * Checkout a descriptive example here:
	     * @see https://www.mongodb.com/blog/post/quick-start-nodejs--mongodb--how-to-implement-transactions
	     *
	     * If a command inside withTransaction fails:
	     * - It may cause the transaction on the server to be aborted.
	     * - This situation is normally handled transparently by the driver.
	     * - However, if the application catches such an error and does not rethrow it, the driver will not be able to determine whether the transaction was aborted or not.
	     * - The driver will then retry the transaction indefinitely.
	     *
	     * To avoid this situation, the application must not silently handle errors within the provided function.
	     * If the application needs to handle errors within, it must await all operations such that if an operation is rejected it becomes the rejection of the callback function passed into withTransaction.
	     *
	     * @param fn - callback to run within a transaction
	     * @param options - optional settings for the transaction
	     * @returns A raw command response or undefined
	     */
	    async withTransaction(fn, options) {
	        const MAX_TIMEOUT = 120000;
	        const startTime = (0, utils_1.now)();
	        let committed = false;
	        let result;
	        while (!committed) {
	            this.startTransaction(options); // may throw on error
	            try {
	                const promise = fn(this);
	                if (!(0, utils_1.isPromiseLike)(promise)) {
	                    throw new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise');
	                }
	                result = await promise;
	                if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION ||
	                    this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED ||
	                    this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {
	                    // Assume callback intentionally ended the transaction
	                    return result;
	                }
	            }
	            catch (fnError) {
	                if (!(fnError instanceof error_1.MongoError) || fnError instanceof error_1.MongoInvalidArgumentError) {
	                    await this.abortTransaction();
	                    throw fnError;
	                }
	                if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION ||
	                    this.transaction.state === transactions_1.TxnState.TRANSACTION_IN_PROGRESS) {
	                    await this.abortTransaction();
	                }
	                if (fnError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) &&
	                    (0, utils_1.now)() - startTime < MAX_TIMEOUT) {
	                    continue;
	                }
	                throw fnError;
	            }
	            while (!committed) {
	                try {
	                    /*
	                     * We will rely on ClientSession.commitTransaction() to
	                     * apply a majority write concern if commitTransaction is
	                     * being retried (see: DRIVERS-601)
	                     */
	                    await this.commitTransaction();
	                    committed = true;
	                }
	                catch (commitError) {
	                    /*
	                     * Note: a maxTimeMS error will have the MaxTimeMSExpired
	                     * code (50) and can be reported as a top-level error or
	                     * inside writeConcernError, ex.
	                     * { ok:0, code: 50, codeName: 'MaxTimeMSExpired' }
	                     * { ok:1, writeConcernError: { code: 50, codeName: 'MaxTimeMSExpired' } }
	                     */
	                    if (!isMaxTimeMSExpiredError(commitError) &&
	                        commitError.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult) &&
	                        (0, utils_1.now)() - startTime < MAX_TIMEOUT) {
	                        continue;
	                    }
	                    if (commitError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) &&
	                        (0, utils_1.now)() - startTime < MAX_TIMEOUT) {
	                        break;
	                    }
	                    throw commitError;
	                }
	            }
	        }
	        return result;
	    }
	}
	sessions.ClientSession = ClientSession;
	_a = kSnapshotEnabled;
	(0, resource_management_1.configureResourceManagement)(ClientSession.prototype);
	const NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([
	    'CannotSatisfyWriteConcern',
	    'UnknownReplWriteConcern',
	    'UnsatisfiableWriteConcern'
	]);
	function shouldUnpinAfterCommitError(commitError) {
	    if (commitError instanceof error_1.MongoError) {
	        if ((0, error_1.isRetryableWriteError)(commitError) ||
	            commitError instanceof error_1.MongoWriteConcernError ||
	            isMaxTimeMSExpiredError(commitError)) {
	            if (isUnknownTransactionCommitResult(commitError)) {
	                // per txns spec, must unpin session in this case
	                return true;
	            }
	        }
	        else if (commitError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
	            return true;
	        }
	    }
	    return false;
	}
	function shouldAddUnknownTransactionCommitResultLabel(commitError) {
	    let ok = (0, error_1.isRetryableWriteError)(commitError);
	    ok ||= commitError instanceof error_1.MongoWriteConcernError;
	    ok ||= isMaxTimeMSExpiredError(commitError);
	    ok &&= isUnknownTransactionCommitResult(commitError);
	    return ok;
	}
	function isUnknownTransactionCommitResult(err) {
	    const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError &&
	        err.codeName &&
	        NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);
	    return (isMaxTimeMSExpiredError(err) ||
	        (!isNonDeterministicWriteConcernError &&
	            err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern &&
	            err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern));
	}
	function maybeClearPinnedConnection(session, options) {
	    // unpin a connection if it has been pinned
	    const conn = session[kPinnedConnection];
	    const error = options?.error;
	    if (session.inTransaction() &&
	        error &&
	        error instanceof error_1.MongoError &&
	        error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
	        return;
	    }
	    const topology = session.client.topology;
	    // NOTE: the spec talks about what to do on a network error only, but the tests seem to
	    //       to validate that we don't unpin on _all_ errors?
	    if (conn && topology != null) {
	        const servers = Array.from(topology.s.servers.values());
	        const loadBalancer = servers[0];
	        if (options?.error == null || options?.force) {
	            loadBalancer.pool.checkIn(conn);
	            session[kPinnedConnection] = undefined;
	            conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION
	                ? metrics_1.ConnectionPoolMetrics.TXN
	                : metrics_1.ConnectionPoolMetrics.CURSOR);
	            if (options?.forceClear) {
	                loadBalancer.pool.clear({ serviceId: conn.serviceId });
	            }
	        }
	    }
	}
	function isMaxTimeMSExpiredError(err) {
	    if (err == null || !(err instanceof error_1.MongoServerError)) {
	        return false;
	    }
	    return (err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired ||
	        err.writeConcernError?.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired);
	}
	/**
	 * Reflects the existence of a session on the server. Can be reused by the session pool.
	 * WARNING: not meant to be instantiated directly. For internal use only.
	 * @public
	 */
	class ServerSession {
	    /** @internal */
	    constructor() {
	        this.id = { id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID) };
	        this.lastUse = (0, utils_1.now)();
	        this.txnNumber = 0;
	        this.isDirty = false;
	    }
	    /**
	     * Determines if the server session has timed out.
	     *
	     * @param sessionTimeoutMinutes - The server's "logicalSessionTimeoutMinutes"
	     */
	    hasTimedOut(sessionTimeoutMinutes) {
	        // Take the difference of the lastUse timestamp and now, which will result in a value in
	        // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`
	        const idleTimeMinutes = Math.round((((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000) % 3600000) / 60000);
	        return idleTimeMinutes > sessionTimeoutMinutes - 1;
	    }
	    /**
	     * @internal
	     * Cloning meant to keep a readable reference to the server session data
	     * after ClientSession has ended
	     */
	    static clone(serverSession) {
	        const arrayBuffer = new ArrayBuffer(16);
	        const idBytes = Buffer.from(arrayBuffer);
	        idBytes.set(serverSession.id.id.buffer);
	        const id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type);
	        // Manual prototype construction to avoid modifying the constructor of this class
	        return Object.setPrototypeOf({
	            id: { id },
	            lastUse: serverSession.lastUse,
	            txnNumber: serverSession.txnNumber,
	            isDirty: serverSession.isDirty
	        }, ServerSession.prototype);
	    }
	}
	sessions.ServerSession = ServerSession;
	/**
	 * Maintains a pool of Server Sessions.
	 * For internal use only
	 * @internal
	 */
	class ServerSessionPool {
	    constructor(client) {
	        if (client == null) {
	            throw new error_1.MongoRuntimeError('ServerSessionPool requires a MongoClient');
	        }
	        this.client = client;
	        this.sessions = new utils_1.List();
	    }
	    /**
	     * Acquire a Server Session from the pool.
	     * Iterates through each session in the pool, removing any stale sessions
	     * along the way. The first non-stale session found is removed from the
	     * pool and returned. If no non-stale session is found, a new ServerSession is created.
	     */
	    acquire() {
	        const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;
	        let session = null;
	        // Try to obtain from session pool
	        while (this.sessions.length > 0) {
	            const potentialSession = this.sessions.shift();
	            if (potentialSession != null &&
	                (!!this.client.topology?.loadBalanced ||
	                    !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {
	                session = potentialSession;
	                break;
	            }
	        }
	        // If nothing valid came from the pool make a new one
	        if (session == null) {
	            session = new ServerSession();
	        }
	        return session;
	    }
	    /**
	     * Release a session to the session pool
	     * Adds the session back to the session pool if the session has not timed out yet.
	     * This method also removes any stale sessions from the pool.
	     *
	     * @param session - The session to release to the pool
	     */
	    release(session) {
	        const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;
	        if (this.client.topology?.loadBalanced && !sessionTimeoutMinutes) {
	            this.sessions.unshift(session);
	        }
	        if (!sessionTimeoutMinutes) {
	            return;
	        }
	        this.sessions.prune(session => session.hasTimedOut(sessionTimeoutMinutes));
	        if (!session.hasTimedOut(sessionTimeoutMinutes)) {
	            if (session.isDirty) {
	                return;
	            }
	            // otherwise, readd this session to the session pool
	            this.sessions.unshift(session);
	        }
	    }
	}
	sessions.ServerSessionPool = ServerSessionPool;
	/**
	 * Optionally decorate a command with sessions specific keys
	 *
	 * @param session - the session tracking transaction state
	 * @param command - the command to decorate
	 * @param options - Optional settings passed to calling operation
	 *
	 * @internal
	 */
	function applySession(session, command, options) {
	    if (session.hasEnded) {
	        return new error_1.MongoExpiredSessionError();
	    }
	    // May acquire serverSession here
	    const serverSession = session.serverSession;
	    if (serverSession == null) {
	        return new error_1.MongoRuntimeError('Unable to acquire server session');
	    }
	    if (options.writeConcern?.w === 0) {
	        if (session && session.explicit) {
	            // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)
	            return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');
	        }
	        return;
	    }
	    // mark the last use of this session, and apply the `lsid`
	    serverSession.lastUse = (0, utils_1.now)();
	    command.lsid = serverSession.id;
	    const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);
	    const isRetryableWrite = !!options.willRetryWrite;
	    if (isRetryableWrite || inTxnOrTxnCommand) {
	        serverSession.txnNumber += session[kTxnNumberIncrement];
	        session[kTxnNumberIncrement] = 0;
	        // TODO(NODE-2674): Preserve int64 sent from MongoDB
	        command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);
	    }
	    if (!inTxnOrTxnCommand) {
	        if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {
	            session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);
	        }
	        if (session.supports.causalConsistency &&
	            session.operationTime &&
	            (0, utils_1.commandSupportsReadConcern)(command)) {
	            command.readConcern = command.readConcern || {};
	            Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
	        }
	        else if (session[kSnapshotEnabled]) {
	            command.readConcern = command.readConcern || { level: read_concern_1.ReadConcernLevel.snapshot };
	            if (session[kSnapshotTime] != null) {
	                Object.assign(command.readConcern, { atClusterTime: session[kSnapshotTime] });
	            }
	        }
	        return;
	    }
	    // now attempt to apply transaction-specific sessions data
	    // `autocommit` must always be false to differentiate from retryable writes
	    command.autocommit = false;
	    if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {
	        session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);
	        command.startTransaction = true;
	        const readConcern = session.transaction.options.readConcern || session?.clientOptions?.readConcern;
	        if (readConcern) {
	            command.readConcern = readConcern;
	        }
	        if (session.supports.causalConsistency && session.operationTime) {
	            command.readConcern = command.readConcern || {};
	            Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
	        }
	    }
	    return;
	}
	function updateSessionFromResponse(session, document) {
	    if (document.$clusterTime) {
	        (0, common_1._advanceClusterTime)(session, document.$clusterTime);
	    }
	    if (document.operationTime && session && session.supports.causalConsistency) {
	        session.advanceOperationTime(document.operationTime);
	    }
	    if (document.recoveryToken && session && session.inTransaction()) {
	        session.transaction._recoveryToken = document.recoveryToken;
	    }
	    if (session?.[kSnapshotEnabled] && session[kSnapshotTime] == null) {
	        // find and aggregate commands return atClusterTime on the cursor
	        // distinct includes it in the response body
	        const atClusterTime = document.atClusterTime;
	        if (atClusterTime) {
	            session[kSnapshotTime] = atClusterTime;
	        }
	    }
	}
	
	return sessions;
}

var command_monitoring_events = {};

var hasRequiredCommand_monitoring_events;

function requireCommand_monitoring_events () {
	if (hasRequiredCommand_monitoring_events) return command_monitoring_events;
	hasRequiredCommand_monitoring_events = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.SENSITIVE_COMMANDS = exports.CommandFailedEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = void 0;
		const constants_1 = requireConstants();
		const utils_1 = requireUtils$1();
		const commands_1 = requireCommands();
		/**
		 * An event indicating the start of a given command
		 * @public
		 * @category Event
		 */
		class CommandStartedEvent {
		    /**
		     * Create a started event
		     *
		     * @internal
		     * @param pool - the pool that originated the command
		     * @param command - the command
		     */
		    constructor(connection, command, serverConnectionId) {
		        /** @internal */
		        this.name = constants_1.COMMAND_STARTED;
		        const cmd = extractCommand(command);
		        const commandName = extractCommandName(cmd);
		        const { address, connectionId, serviceId } = extractConnectionDetails(connection);
		        // TODO: remove in major revision, this is not spec behavior
		        if (exports.SENSITIVE_COMMANDS.has(commandName)) {
		            this.commandObj = {};
		            this.commandObj[commandName] = true;
		        }
		        this.address = address;
		        this.connectionId = connectionId;
		        this.serviceId = serviceId;
		        this.requestId = command.requestId;
		        this.databaseName = command.databaseName;
		        this.commandName = commandName;
		        this.command = maybeRedact(commandName, cmd, cmd);
		        this.serverConnectionId = serverConnectionId;
		    }
		    /* @internal */
		    get hasServiceId() {
		        return !!this.serviceId;
		    }
		}
		exports.CommandStartedEvent = CommandStartedEvent;
		/**
		 * An event indicating the success of a given command
		 * @public
		 * @category Event
		 */
		class CommandSucceededEvent {
		    /**
		     * Create a succeeded event
		     *
		     * @internal
		     * @param pool - the pool that originated the command
		     * @param command - the command
		     * @param reply - the reply for this command from the server
		     * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration
		     */
		    constructor(connection, command, reply, started, serverConnectionId) {
		        /** @internal */
		        this.name = constants_1.COMMAND_SUCCEEDED;
		        const cmd = extractCommand(command);
		        const commandName = extractCommandName(cmd);
		        const { address, connectionId, serviceId } = extractConnectionDetails(connection);
		        this.address = address;
		        this.connectionId = connectionId;
		        this.serviceId = serviceId;
		        this.requestId = command.requestId;
		        this.commandName = commandName;
		        this.duration = (0, utils_1.calculateDurationInMs)(started);
		        this.reply = maybeRedact(commandName, cmd, extractReply(command, reply));
		        this.serverConnectionId = serverConnectionId;
		    }
		    /* @internal */
		    get hasServiceId() {
		        return !!this.serviceId;
		    }
		}
		exports.CommandSucceededEvent = CommandSucceededEvent;
		/**
		 * An event indicating the failure of a given command
		 * @public
		 * @category Event
		 */
		class CommandFailedEvent {
		    /**
		     * Create a failure event
		     *
		     * @internal
		     * @param pool - the pool that originated the command
		     * @param command - the command
		     * @param error - the generated error or a server error response
		     * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration
		     */
		    constructor(connection, command, error, started, serverConnectionId) {
		        /** @internal */
		        this.name = constants_1.COMMAND_FAILED;
		        const cmd = extractCommand(command);
		        const commandName = extractCommandName(cmd);
		        const { address, connectionId, serviceId } = extractConnectionDetails(connection);
		        this.address = address;
		        this.connectionId = connectionId;
		        this.serviceId = serviceId;
		        this.requestId = command.requestId;
		        this.commandName = commandName;
		        this.duration = (0, utils_1.calculateDurationInMs)(started);
		        this.failure = maybeRedact(commandName, cmd, error);
		        this.serverConnectionId = serverConnectionId;
		    }
		    /* @internal */
		    get hasServiceId() {
		        return !!this.serviceId;
		    }
		}
		exports.CommandFailedEvent = CommandFailedEvent;
		/**
		 * Commands that we want to redact because of the sensitive nature of their contents
		 * @internal
		 */
		exports.SENSITIVE_COMMANDS = new Set([
		    'authenticate',
		    'saslStart',
		    'saslContinue',
		    'getnonce',
		    'createUser',
		    'updateUser',
		    'copydbgetnonce',
		    'copydbsaslstart',
		    'copydb'
		]);
		const HELLO_COMMANDS = new Set(['hello', constants_1.LEGACY_HELLO_COMMAND, constants_1.LEGACY_HELLO_COMMAND_CAMEL_CASE]);
		// helper methods
		const extractCommandName = (commandDoc) => Object.keys(commandDoc)[0];
		const namespace = (command) => command.ns;
		const collectionName = (command) => command.ns.split('.')[1];
		const maybeRedact = (commandName, commandDoc, result) => exports.SENSITIVE_COMMANDS.has(commandName) ||
		    (HELLO_COMMANDS.has(commandName) && commandDoc.speculativeAuthenticate)
		    ? {}
		    : result;
		const LEGACY_FIND_QUERY_MAP = {
		    $query: 'filter',
		    $orderby: 'sort',
		    $hint: 'hint',
		    $comment: 'comment',
		    $maxScan: 'maxScan',
		    $max: 'max',
		    $min: 'min',
		    $returnKey: 'returnKey',
		    $showDiskLoc: 'showRecordId',
		    $maxTimeMS: 'maxTimeMS',
		    $snapshot: 'snapshot'
		};
		const LEGACY_FIND_OPTIONS_MAP = {
		    numberToSkip: 'skip',
		    numberToReturn: 'batchSize',
		    returnFieldSelector: 'projection'
		};
		const OP_QUERY_KEYS = [
		    'tailable',
		    'oplogReplay',
		    'noCursorTimeout',
		    'awaitData',
		    'partial',
		    'exhaust'
		];
		/** Extract the actual command from the query, possibly up-converting if it's a legacy format */
		function extractCommand(command) {
		    if (command instanceof commands_1.OpMsgRequest) {
		        return (0, utils_1.deepCopy)(command.command);
		    }
		    if (command.query?.$query) {
		        let result;
		        if (command.ns === 'admin.$cmd') {
		            // up-convert legacy command
		            result = Object.assign({}, command.query.$query);
		        }
		        else {
		            // up-convert legacy find command
		            result = { find: collectionName(command) };
		            Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => {
		                if (command.query[key] != null) {
		                    result[LEGACY_FIND_QUERY_MAP[key]] = (0, utils_1.deepCopy)(command.query[key]);
		                }
		            });
		        }
		        Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => {
		            const legacyKey = key;
		            if (command[legacyKey] != null) {
		                result[LEGACY_FIND_OPTIONS_MAP[legacyKey]] = (0, utils_1.deepCopy)(command[legacyKey]);
		            }
		        });
		        OP_QUERY_KEYS.forEach(key => {
		            if (command[key]) {
		                result[key] = command[key];
		            }
		        });
		        if (command.pre32Limit != null) {
		            result.limit = command.pre32Limit;
		        }
		        if (command.query.$explain) {
		            return { explain: result };
		        }
		        return result;
		    }
		    const clonedQuery = {};
		    const clonedCommand = {};
		    if (command.query) {
		        for (const k in command.query) {
		            clonedQuery[k] = (0, utils_1.deepCopy)(command.query[k]);
		        }
		        clonedCommand.query = clonedQuery;
		    }
		    for (const k in command) {
		        if (k === 'query')
		            continue;
		        clonedCommand[k] = (0, utils_1.deepCopy)(command[k]);
		    }
		    return command.query ? clonedQuery : clonedCommand;
		}
		function extractReply(command, reply) {
		    if (!reply) {
		        return reply;
		    }
		    if (command instanceof commands_1.OpMsgRequest) {
		        return (0, utils_1.deepCopy)(reply.result ? reply.result : reply);
		    }
		    // is this a legacy find command?
		    if (command.query && command.query.$query != null) {
		        return {
		            ok: 1,
		            cursor: {
		                id: (0, utils_1.deepCopy)(reply.cursorId),
		                ns: namespace(command),
		                firstBatch: (0, utils_1.deepCopy)(reply.documents)
		            }
		        };
		    }
		    return (0, utils_1.deepCopy)(reply.result ? reply.result : reply);
		}
		function extractConnectionDetails(connection) {
		    let connectionId;
		    if ('id' in connection) {
		        connectionId = connection.id;
		    }
		    return {
		        address: connection.address,
		        serviceId: connection.serviceId,
		        connectionId
		    };
		}
		
	} (command_monitoring_events));
	return command_monitoring_events;
}

var stream_description = {};

var hasRequiredStream_description;

function requireStream_description () {
	if (hasRequiredStream_description) return stream_description;
	hasRequiredStream_description = 1;
	Object.defineProperty(stream_description, "__esModule", { value: true });
	stream_description.StreamDescription = void 0;
	const bson_1 = requireBson();
	const common_1 = requireCommon$1();
	const server_description_1 = requireServer_description();
	const RESPONSE_FIELDS = [
	    'minWireVersion',
	    'maxWireVersion',
	    'maxBsonObjectSize',
	    'maxMessageSizeBytes',
	    'maxWriteBatchSize',
	    'logicalSessionTimeoutMinutes'
	];
	/** @public */
	class StreamDescription {
	    constructor(address, options) {
	        this.hello = null;
	        this.address = address;
	        this.type = common_1.ServerType.Unknown;
	        this.minWireVersion = undefined;
	        this.maxWireVersion = undefined;
	        this.maxBsonObjectSize = 16777216;
	        this.maxMessageSizeBytes = 48000000;
	        this.maxWriteBatchSize = 100000;
	        this.logicalSessionTimeoutMinutes = options?.logicalSessionTimeoutMinutes;
	        this.loadBalanced = !!options?.loadBalanced;
	        this.compressors =
	            options && options.compressors && Array.isArray(options.compressors)
	                ? options.compressors
	                : [];
	        this.serverConnectionId = null;
	    }
	    receiveResponse(response) {
	        if (response == null) {
	            return;
	        }
	        this.hello = response;
	        this.type = (0, server_description_1.parseServerType)(response);
	        if ('connectionId' in response) {
	            this.serverConnectionId = this.parseServerConnectionID(response.connectionId);
	        }
	        else {
	            this.serverConnectionId = null;
	        }
	        for (const field of RESPONSE_FIELDS) {
	            if (response[field] != null) {
	                this[field] = response[field];
	            }
	            // testing case
	            if ('__nodejs_mock_server__' in response) {
	                this.__nodejs_mock_server__ = response['__nodejs_mock_server__'];
	            }
	        }
	        if (response.compression) {
	            this.compressor = this.compressors.filter(c => response.compression?.includes(c))[0];
	        }
	    }
	    /* @internal */
	    parseServerConnectionID(serverConnectionId) {
	        // Connection ids are always integral, so it's safe to coerce doubles as well as
	        // any integral type.
	        return bson_1.Long.isLong(serverConnectionId)
	            ? serverConnectionId.toBigInt()
	            : // @ts-expect-error: Doubles are coercible to number
	                BigInt(serverConnectionId);
	    }
	}
	stream_description.StreamDescription = StreamDescription;
	
	return stream_description;
}

var on_data = {};

var hasRequiredOn_data;

function requireOn_data () {
	if (hasRequiredOn_data) return on_data;
	hasRequiredOn_data = 1;
	Object.defineProperty(on_data, "__esModule", { value: true });
	on_data.onData = onData;
	const utils_1 = requireUtils$1();
	/**
	 * onData is adapted from Node.js' events.on helper
	 * https://nodejs.org/api/events.html#eventsonemitter-eventname-options
	 *
	 * Returns an AsyncIterator that iterates each 'data' event emitted from emitter.
	 * It will reject upon an error event.
	 */
	function onData(emitter) {
	    // Setup pending events and pending promise lists
	    /**
	     * When the caller has not yet called .next(), we store the
	     * value from the event in this list. Next time they call .next()
	     * we pull the first value out of this list and resolve a promise with it.
	     */
	    const unconsumedEvents = new utils_1.List();
	    /**
	     * When there has not yet been an event, a new promise will be created
	     * and implicitly stored in this list. When an event occurs we take the first
	     * promise in this list and resolve it.
	     */
	    const unconsumedPromises = new utils_1.List();
	    /**
	     * Stored an error created by an error event.
	     * This error will turn into a rejection for the subsequent .next() call
	     */
	    let error = null;
	    /** Set to true only after event listeners have been removed. */
	    let finished = false;
	    const iterator = {
	        next() {
	            // First, we consume all unread events
	            const value = unconsumedEvents.shift();
	            if (value != null) {
	                return Promise.resolve({ value, done: false });
	            }
	            // Then we error, if an error happened
	            // This happens one time if at all, because after 'error'
	            // we stop listening
	            if (error != null) {
	                const p = Promise.reject(error);
	                // Only the first element errors
	                error = null;
	                return p;
	            }
	            // If the iterator is finished, resolve to done
	            if (finished)
	                return closeHandler();
	            // Wait until an event happens
	            const { promise, resolve, reject } = (0, utils_1.promiseWithResolvers)();
	            unconsumedPromises.push({ resolve, reject });
	            return promise;
	        },
	        return() {
	            return closeHandler();
	        },
	        throw(err) {
	            errorHandler(err);
	            return Promise.resolve({ value: undefined, done: true });
	        },
	        [Symbol.asyncIterator]() {
	            return this;
	        }
	    };
	    // Adding event handlers
	    emitter.on('data', eventHandler);
	    emitter.on('error', errorHandler);
	    return iterator;
	    function eventHandler(value) {
	        const promise = unconsumedPromises.shift();
	        if (promise != null)
	            promise.resolve({ value, done: false });
	        else
	            unconsumedEvents.push(value);
	    }
	    function errorHandler(err) {
	        const promise = unconsumedPromises.shift();
	        if (promise != null)
	            promise.reject(err);
	        else
	            error = err;
	        void closeHandler();
	    }
	    function closeHandler() {
	        // Adding event handlers
	        emitter.off('data', eventHandler);
	        emitter.off('error', errorHandler);
	        finished = true;
	        const doneResult = { value: undefined, done: finished };
	        for (const promise of unconsumedPromises) {
	            promise.resolve(doneResult);
	        }
	        return Promise.resolve(doneResult);
	    }
	}
	
	return on_data;
}

var hasRequiredConnection;

function requireConnection () {
	if (hasRequiredConnection) return connection;
	hasRequiredConnection = 1;
	Object.defineProperty(connection, "__esModule", { value: true });
	connection.CryptoConnection = connection.SizedMessageTransform = connection.Connection = void 0;
	connection.hasSessionSupport = hasSessionSupport;
	const stream_1 = require$$0$9;
	const timers_1 = require$$0$d;
	const bson_1 = requireBson();
	const constants_1 = requireConstants();
	const error_1 = requireError();
	const mongo_logger_1 = requireMongo_logger();
	const mongo_types_1 = requireMongo_types();
	const read_preference_1 = requireRead_preference();
	const common_1 = requireCommon$1();
	const sessions_1 = requireSessions();
	const utils_1 = requireUtils$1();
	const command_monitoring_events_1 = requireCommand_monitoring_events();
	const commands_1 = requireCommands();
	const stream_description_1 = requireStream_description();
	const compression_1 = requireCompression();
	const on_data_1 = requireOn_data();
	const responses_1 = requireResponses();
	const shared_1 = requireShared();
	/** @internal */
	function hasSessionSupport(conn) {
	    const description = conn.description;
	    return description.logicalSessionTimeoutMinutes != null;
	}
	function streamIdentifier(stream, options) {
	    if (options.proxyHost) {
	        // If proxy options are specified, the properties of `stream` itself
	        // will not accurately reflect what endpoint this is connected to.
	        return options.hostAddress.toString();
	    }
	    const { remoteAddress, remotePort } = stream;
	    if (typeof remoteAddress === 'string' && typeof remotePort === 'number') {
	        return utils_1.HostAddress.fromHostPort(remoteAddress, remotePort).toString();
	    }
	    return (0, utils_1.uuidV4)().toString('hex');
	}
	/** @internal */
	class Connection extends mongo_types_1.TypedEventEmitter {
	    constructor(stream, options) {
	        super();
	        this.lastHelloMS = -1;
	        this.helloOk = false;
	        this.delayedTimeoutId = null;
	        /** Indicates that the connection (including underlying TCP socket) has been closed. */
	        this.closed = false;
	        this.clusterTime = null;
	        this.error = null;
	        this.dataEvents = null;
	        this.socket = stream;
	        this.id = options.id;
	        this.address = streamIdentifier(stream, options);
	        this.socketTimeoutMS = options.socketTimeoutMS ?? 0;
	        this.monitorCommands = options.monitorCommands;
	        this.serverApi = options.serverApi;
	        this.mongoLogger = options.mongoLogger;
	        this.established = false;
	        this.description = new stream_description_1.StreamDescription(this.address, options);
	        this.generation = options.generation;
	        this.lastUseTime = (0, utils_1.now)();
	        this.messageStream = this.socket
	            .on('error', this.onError.bind(this))
	            .pipe(new SizedMessageTransform({ connection: this }))
	            .on('error', this.onError.bind(this));
	        this.socket.on('close', this.onClose.bind(this));
	        this.socket.on('timeout', this.onTimeout.bind(this));
	    }
	    get hello() {
	        return this.description.hello;
	    }
	    // the `connect` method stores the result of the handshake hello on the connection
	    set hello(response) {
	        this.description.receiveResponse(response);
	        Object.freeze(this.description);
	    }
	    get serviceId() {
	        return this.hello?.serviceId;
	    }
	    get loadBalanced() {
	        return this.description.loadBalanced;
	    }
	    get idleTime() {
	        return (0, utils_1.calculateDurationInMs)(this.lastUseTime);
	    }
	    get hasSessionSupport() {
	        return this.description.logicalSessionTimeoutMinutes != null;
	    }
	    get supportsOpMsg() {
	        return (this.description != null &&
	            (0, utils_1.maxWireVersion)(this) >= 6 &&
	            !this.description.__nodejs_mock_server__);
	    }
	    get shouldEmitAndLogCommand() {
	        return ((this.monitorCommands ||
	            (this.established &&
	                !this.authContext?.reauthenticating &&
	                this.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.COMMAND, mongo_logger_1.SeverityLevel.DEBUG))) ??
	            false);
	    }
	    markAvailable() {
	        this.lastUseTime = (0, utils_1.now)();
	    }
	    onError(error) {
	        this.cleanup(error);
	    }
	    onClose() {
	        const message = `connection ${this.id} to ${this.address} closed`;
	        this.cleanup(new error_1.MongoNetworkError(message));
	    }
	    onTimeout() {
	        this.delayedTimeoutId = (0, timers_1.setTimeout)(() => {
	            const message = `connection ${this.id} to ${this.address} timed out`;
	            const beforeHandshake = this.hello == null;
	            this.cleanup(new error_1.MongoNetworkTimeoutError(message, { beforeHandshake }));
	        }, 1).unref(); // No need for this timer to hold the event loop open
	    }
	    destroy() {
	        if (this.closed) {
	            return;
	        }
	        // load balanced mode requires that these listeners remain on the connection
	        // after cleanup on timeouts, errors or close so we remove them before calling
	        // cleanup.
	        this.removeAllListeners(Connection.PINNED);
	        this.removeAllListeners(Connection.UNPINNED);
	        const message = `connection ${this.id} to ${this.address} closed`;
	        this.cleanup(new error_1.MongoNetworkError(message));
	    }
	    /**
	     * A method that cleans up the connection.  When `force` is true, this method
	     * forcibly destroys the socket.
	     *
	     * If an error is provided, any in-flight operations will be closed with the error.
	     *
	     * This method does nothing if the connection is already closed.
	     */
	    cleanup(error) {
	        if (this.closed) {
	            return;
	        }
	        this.socket.destroy();
	        this.error = error;
	        this.dataEvents?.throw(error).then(undefined, utils_1.squashError);
	        this.closed = true;
	        this.emit(Connection.CLOSE);
	    }
	    prepareCommand(db, command, options) {
	        let cmd = { ...command };
	        const readPreference = (0, shared_1.getReadPreference)(options);
	        const session = options?.session;
	        let clusterTime = this.clusterTime;
	        if (this.serverApi) {
	            const { version, strict, deprecationErrors } = this.serverApi;
	            cmd.apiVersion = version;
	            if (strict != null)
	                cmd.apiStrict = strict;
	            if (deprecationErrors != null)
	                cmd.apiDeprecationErrors = deprecationErrors;
	        }
	        if (this.hasSessionSupport && session) {
	            if (session.clusterTime &&
	                clusterTime &&
	                session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {
	                clusterTime = session.clusterTime;
	            }
	            const sessionError = (0, sessions_1.applySession)(session, cmd, options);
	            if (sessionError)
	                throw sessionError;
	        }
	        else if (session?.explicit) {
	            throw new error_1.MongoCompatibilityError('Current topology does not support sessions');
	        }
	        // if we have a known cluster time, gossip it
	        if (clusterTime) {
	            cmd.$clusterTime = clusterTime;
	        }
	        // For standalone, drivers MUST NOT set $readPreference.
	        if (this.description.type !== common_1.ServerType.Standalone) {
	            if (!(0, shared_1.isSharded)(this) &&
	                !this.description.loadBalanced &&
	                this.supportsOpMsg &&
	                options.directConnection === true &&
	                readPreference?.mode === 'primary') {
	                // For mongos and load balancers with 'primary' mode, drivers MUST NOT set $readPreference.
	                // For all other types with a direct connection, if the read preference is 'primary'
	                // (driver sets 'primary' as default if no read preference is configured),
	                // the $readPreference MUST be set to 'primaryPreferred'
	                // to ensure that any server type can handle the request.
	                cmd.$readPreference = read_preference_1.ReadPreference.primaryPreferred.toJSON();
	            }
	            else if ((0, shared_1.isSharded)(this) && !this.supportsOpMsg && readPreference?.mode !== 'primary') {
	                // When sending a read operation via OP_QUERY and the $readPreference modifier,
	                // the query MUST be provided using the $query modifier.
	                cmd = {
	                    $query: cmd,
	                    $readPreference: readPreference.toJSON()
	                };
	            }
	            else if (readPreference?.mode !== 'primary') {
	                // For mode 'primary', drivers MUST NOT set $readPreference.
	                // For all other read preference modes (i.e. 'secondary', 'primaryPreferred', ...),
	                // drivers MUST set $readPreference
	                cmd.$readPreference = readPreference.toJSON();
	            }
	        }
	        const commandOptions = {
	            numberToSkip: 0,
	            numberToReturn: -1,
	            checkKeys: false,
	            // This value is not overridable
	            secondaryOk: readPreference.secondaryOk(),
	            ...options
	        };
	        const message = this.supportsOpMsg
	            ? new commands_1.OpMsgRequest(db, cmd, commandOptions)
	            : new commands_1.OpQueryRequest(db, cmd, commandOptions);
	        return message;
	    }
	    async *sendWire(message, options, responseType) {
	        this.throwIfAborted();
	        if (typeof options.socketTimeoutMS === 'number') {
	            this.socket.setTimeout(options.socketTimeoutMS);
	        }
	        else if (this.socketTimeoutMS !== 0) {
	            this.socket.setTimeout(this.socketTimeoutMS);
	        }
	        try {
	            await this.writeCommand(message, {
	                agreedCompressor: this.description.compressor ?? 'none',
	                zlibCompressionLevel: this.description.zlibCompressionLevel
	            });
	            if (options.noResponse) {
	                yield responses_1.MongoDBResponse.empty;
	                return;
	            }
	            this.throwIfAborted();
	            for await (const response of this.readMany()) {
	                this.socket.setTimeout(0);
	                const bson = response.parse();
	                const document = (responseType ?? responses_1.MongoDBResponse).make(bson);
	                yield document;
	                this.throwIfAborted();
	                if (typeof options.socketTimeoutMS === 'number') {
	                    this.socket.setTimeout(options.socketTimeoutMS);
	                }
	                else if (this.socketTimeoutMS !== 0) {
	                    this.socket.setTimeout(this.socketTimeoutMS);
	                }
	            }
	        }
	        finally {
	            this.socket.setTimeout(0);
	        }
	    }
	    async *sendCommand(ns, command, options, responseType) {
	        const message = this.prepareCommand(ns.db, command, options);
	        let started = 0;
	        if (this.shouldEmitAndLogCommand) {
	            started = (0, utils_1.now)();
	            this.emitAndLogCommand(this.monitorCommands, Connection.COMMAND_STARTED, message.databaseName, this.established, new command_monitoring_events_1.CommandStartedEvent(this, message, this.description.serverConnectionId));
	        }
	        // If `documentsReturnedIn` not set or raw is not enabled, use input bson options
	        // Otherwise, support raw flag. Raw only works for cursors that hardcode firstBatch/nextBatch fields
	        const bsonOptions = options.documentsReturnedIn == null || !options.raw
	            ? options
	            : {
	                ...options,
	                raw: false,
	                fieldsAsRaw: { [options.documentsReturnedIn]: true }
	            };
	        /** MongoDBResponse instance or subclass */
	        let document = undefined;
	        /** Cached result of a toObject call */
	        let object = undefined;
	        try {
	            this.throwIfAborted();
	            for await (document of this.sendWire(message, options, responseType)) {
	                object = undefined;
	                if (options.session != null) {
	                    (0, sessions_1.updateSessionFromResponse)(options.session, document);
	                }
	                if (document.$clusterTime) {
	                    this.clusterTime = document.$clusterTime;
	                    this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);
	                }
	                if (document.ok === 0) {
	                    throw new error_1.MongoServerError((object ??= document.toObject(bsonOptions)));
	                }
	                if (this.shouldEmitAndLogCommand) {
	                    this.emitAndLogCommand(this.monitorCommands, Connection.COMMAND_SUCCEEDED, message.databaseName, this.established, new command_monitoring_events_1.CommandSucceededEvent(this, message, options.noResponse ? undefined : (object ??= document.toObject(bsonOptions)), started, this.description.serverConnectionId));
	                }
	                if (responseType == null) {
	                    yield (object ??= document.toObject(bsonOptions));
	                }
	                else {
	                    yield document;
	                }
	                this.throwIfAborted();
	            }
	        }
	        catch (error) {
	            if (this.shouldEmitAndLogCommand) {
	                this.emitAndLogCommand(this.monitorCommands, Connection.COMMAND_FAILED, message.databaseName, this.established, new command_monitoring_events_1.CommandFailedEvent(this, message, error, started, this.description.serverConnectionId));
	            }
	            throw error;
	        }
	    }
	    async command(ns, command, options = {}, responseType) {
	        this.throwIfAborted();
	        for await (const document of this.sendCommand(ns, command, options, responseType)) {
	            return document;
	        }
	        throw new error_1.MongoUnexpectedServerResponseError('Unable to get response from server');
	    }
	    exhaustCommand(ns, command, options, replyListener) {
	        const exhaustLoop = async () => {
	            this.throwIfAborted();
	            for await (const reply of this.sendCommand(ns, command, options)) {
	                replyListener(undefined, reply);
	                this.throwIfAborted();
	            }
	            throw new error_1.MongoUnexpectedServerResponseError('Server ended moreToCome unexpectedly');
	        };
	        exhaustLoop().then(undefined, replyListener);
	    }
	    throwIfAborted() {
	        if (this.error)
	            throw this.error;
	    }
	    /**
	     * @internal
	     *
	     * Writes an OP_MSG or OP_QUERY request to the socket, optionally compressing the command. This method
	     * waits until the socket's buffer has emptied (the Nodejs socket `drain` event has fired).
	     */
	    async writeCommand(command, options) {
	        const finalCommand = options.agreedCompressor === 'none' || !commands_1.OpCompressedRequest.canCompress(command)
	            ? command
	            : new commands_1.OpCompressedRequest(command, {
	                agreedCompressor: options.agreedCompressor ?? 'none',
	                zlibCompressionLevel: options.zlibCompressionLevel ?? 0
	            });
	        const buffer = Buffer.concat(await finalCommand.toBin());
	        if (this.socket.write(buffer))
	            return;
	        return await (0, utils_1.once)(this.socket, 'drain');
	    }
	    /**
	     * @internal
	     *
	     * Returns an async generator that yields full wire protocol messages from the underlying socket.  This function
	     * yields messages until `moreToCome` is false or not present in a response, or the caller cancels the request
	     * by calling `return` on the generator.
	     *
	     * Note that `for-await` loops call `return` automatically when the loop is exited.
	     */
	    async *readMany() {
	        try {
	            this.dataEvents = (0, on_data_1.onData)(this.messageStream);
	            for await (const message of this.dataEvents) {
	                const response = await (0, compression_1.decompressResponse)(message);
	                yield response;
	                if (!response.moreToCome) {
	                    return;
	                }
	            }
	        }
	        finally {
	            this.dataEvents = null;
	            this.throwIfAborted();
	        }
	    }
	}
	connection.Connection = Connection;
	/** @event */
	Connection.COMMAND_STARTED = constants_1.COMMAND_STARTED;
	/** @event */
	Connection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;
	/** @event */
	Connection.COMMAND_FAILED = constants_1.COMMAND_FAILED;
	/** @event */
	Connection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;
	/** @event */
	Connection.CLOSE = constants_1.CLOSE;
	/** @event */
	Connection.PINNED = constants_1.PINNED;
	/** @event */
	Connection.UNPINNED = constants_1.UNPINNED;
	/** @internal */
	class SizedMessageTransform extends stream_1.Transform {
	    constructor({ connection }) {
	        super({ objectMode: false });
	        this.bufferPool = new utils_1.BufferPool();
	        this.connection = connection;
	    }
	    _transform(chunk, encoding, callback) {
	        if (this.connection.delayedTimeoutId != null) {
	            (0, timers_1.clearTimeout)(this.connection.delayedTimeoutId);
	            this.connection.delayedTimeoutId = null;
	        }
	        this.bufferPool.append(chunk);
	        const sizeOfMessage = this.bufferPool.getInt32();
	        if (sizeOfMessage == null) {
	            return callback();
	        }
	        if (sizeOfMessage < 0) {
	            return callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}, too small`));
	        }
	        if (sizeOfMessage > this.bufferPool.length) {
	            return callback();
	        }
	        const message = this.bufferPool.read(sizeOfMessage);
	        return callback(null, message);
	    }
	}
	connection.SizedMessageTransform = SizedMessageTransform;
	/** @internal */
	class CryptoConnection extends Connection {
	    constructor(stream, options) {
	        super(stream, options);
	        this.autoEncrypter = options.autoEncrypter;
	    }
	    async command(ns, cmd, options, responseType) {
	        const { autoEncrypter } = this;
	        if (!autoEncrypter) {
	            // TODO(NODE-6065): throw a MongoRuntimeError in Node V7
	            // @ts-expect-error No cause provided because there is no underlying error.
	            throw new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption', {
	                dependencyName: 'n/a'
	            });
	        }
	        const serverWireVersion = (0, utils_1.maxWireVersion)(this);
	        if (serverWireVersion === 0) {
	            // This means the initial handshake hasn't happened yet
	            return await super.command(ns, cmd, options, responseType);
	        }
	        if (serverWireVersion < 8) {
	            throw new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2');
	        }
	        // Save sort or indexKeys based on the command being run
	        // the encrypt API serializes our JS objects to BSON to pass to the native code layer
	        // and then deserializes the encrypted result, the protocol level components
	        // of the command (ex. sort) are then converted to JS objects potentially losing
	        // import key order information. These fields are never encrypted so we can save the values
	        // from before the encryption and replace them after encryption has been performed
	        const sort = cmd.find || cmd.findAndModify ? cmd.sort : null;
	        const indexKeys = cmd.createIndexes
	            ? cmd.indexes.map((index) => index.key)
	            : null;
	        const encrypted = await autoEncrypter.encrypt(ns.toString(), cmd, options);
	        // Replace the saved values
	        if (sort != null && (cmd.find || cmd.findAndModify)) {
	            encrypted.sort = sort;
	        }
	        if (indexKeys != null && cmd.createIndexes) {
	            for (const [offset, index] of indexKeys.entries()) {
	                // @ts-expect-error `encrypted` is a generic "command", but we've narrowed for only `createIndexes` commands here
	                encrypted.indexes[offset].key = index;
	            }
	        }
	        const encryptedResponse = await super.command(ns, encrypted, options, 
	        // Eventually we want to require `responseType` which means we would satisfy `T` as the return type.
	        // In the meantime, we want encryptedResponse to always be _at least_ a MongoDBResponse if not a more specific subclass
	        // So that we can ensure we have access to the on-demand APIs for decorate response
	        responseType ?? responses_1.MongoDBResponse);
	        const result = await autoEncrypter.decrypt(encryptedResponse.toBytes(), options);
	        const decryptedResponse = responseType?.make(result) ?? (0, bson_1.deserialize)(result, options);
	        if (autoEncrypter[constants_1.kDecorateResult]) {
	            if (responseType == null) {
	                (0, utils_1.decorateDecryptionResult)(decryptedResponse, encryptedResponse.toObject(), true);
	            }
	            else if (decryptedResponse instanceof responses_1.CursorResponse) {
	                decryptedResponse.encryptedResponse = encryptedResponse;
	            }
	        }
	        return decryptedResponse;
	    }
	}
	connection.CryptoConnection = CryptoConnection;
	
	return connection;
}

var hasRequiredConnect;

function requireConnect () {
	if (hasRequiredConnect) return connect;
	hasRequiredConnect = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = void 0;
		exports.connect = connect;
		exports.makeConnection = makeConnection;
		exports.performInitialHandshake = performInitialHandshake;
		exports.prepareHandshakeDocument = prepareHandshakeDocument;
		exports.makeSocket = makeSocket;
		const net = require$$0$7;
		const tls = require$$2$3;
		const constants_1 = requireConstants();
		const deps_1 = requireDeps();
		const error_1 = requireError();
		const utils_1 = requireUtils$1();
		const auth_provider_1 = requireAuth_provider();
		const providers_1 = requireProviders$1();
		const connection_1 = requireConnection();
		const constants_2 = requireConstants$1();
		async function connect(options) {
		    let connection = null;
		    try {
		        const socket = await makeSocket(options);
		        connection = makeConnection(options, socket);
		        await performInitialHandshake(connection, options);
		        return connection;
		    }
		    catch (error) {
		        connection?.destroy();
		        throw error;
		    }
		}
		function makeConnection(options, socket) {
		    let ConnectionType = options.connectionType ?? connection_1.Connection;
		    if (options.autoEncrypter) {
		        ConnectionType = connection_1.CryptoConnection;
		    }
		    return new ConnectionType(socket, options);
		}
		function checkSupportedServer(hello, options) {
		    const maxWireVersion = Number(hello.maxWireVersion);
		    const minWireVersion = Number(hello.minWireVersion);
		    const serverVersionHighEnough = !Number.isNaN(maxWireVersion) && maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;
		    const serverVersionLowEnough = !Number.isNaN(minWireVersion) && minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;
		    if (serverVersionHighEnough) {
		        if (serverVersionLowEnough) {
		            return null;
		        }
		        const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(hello.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_2.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MAX_SUPPORTED_SERVER_VERSION})`;
		        return new error_1.MongoCompatibilityError(message);
		    }
		    const message = `Server at ${options.hostAddress} reports maximum wire version ${JSON.stringify(hello.maxWireVersion) ?? 0}, but this version of the Node.js Driver requires at least ${constants_2.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MIN_SUPPORTED_SERVER_VERSION})`;
		    return new error_1.MongoCompatibilityError(message);
		}
		async function performInitialHandshake(conn, options) {
		    const credentials = options.credentials;
		    if (credentials) {
		        if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) &&
		            !options.authProviders.getOrCreateProvider(credentials.mechanism, credentials.mechanismProperties)) {
		            throw new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`);
		        }
		    }
		    const authContext = new auth_provider_1.AuthContext(conn, credentials, options);
		    conn.authContext = authContext;
		    const handshakeDoc = await prepareHandshakeDocument(authContext);
		    // @ts-expect-error: TODO(NODE-5141): The options need to be filtered properly, Connection options differ from Command options
		    const handshakeOptions = { ...options, raw: false };
		    if (typeof options.connectTimeoutMS === 'number') {
		        // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS
		        handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;
		    }
		    const start = new Date().getTime();
		    const response = await conn.command((0, utils_1.ns)('admin.$cmd'), handshakeDoc, handshakeOptions);
		    if (!('isWritablePrimary' in response)) {
		        // Provide hello-style response document.
		        response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];
		    }
		    if (response.helloOk) {
		        conn.helloOk = true;
		    }
		    const supportedServerErr = checkSupportedServer(response, options);
		    if (supportedServerErr) {
		        throw supportedServerErr;
		    }
		    if (options.loadBalanced) {
		        if (!response.serviceId) {
		            throw new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' +
		                'but the server does not support this mode.');
		        }
		    }
		    // NOTE: This is metadata attached to the connection while porting away from
		    //       handshake being done in the `Server` class. Likely, it should be
		    //       relocated, or at very least restructured.
		    conn.hello = response;
		    conn.lastHelloMS = new Date().getTime() - start;
		    if (!response.arbiterOnly && credentials) {
		        // store the response on auth context
		        authContext.response = response;
		        const resolvedCredentials = credentials.resolveAuthMechanism(response);
		        const provider = options.authProviders.getOrCreateProvider(resolvedCredentials.mechanism, resolvedCredentials.mechanismProperties);
		        if (!provider) {
		            throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`);
		        }
		        try {
		            await provider.auth(authContext);
		        }
		        catch (error) {
		            if (error instanceof error_1.MongoError) {
		                error.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);
		                if ((0, error_1.needsRetryableWriteLabel)(error, response.maxWireVersion, conn.description.type)) {
		                    error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
		                }
		            }
		            throw error;
		        }
		    }
		    // Connection establishment is socket creation (tcp handshake, tls handshake, MongoDB handshake (saslStart, saslContinue))
		    // Once connection is established, command logging can log events (if enabled)
		    conn.established = true;
		}
		/**
		 * @internal
		 *
		 * This function is only exposed for testing purposes.
		 */
		async function prepareHandshakeDocument(authContext) {
		    const options = authContext.options;
		    const compressors = options.compressors ? options.compressors : [];
		    const { serverApi } = authContext.connection;
		    const clientMetadata = await options.extendedMetadata;
		    const handshakeDoc = {
		        [serverApi?.version || options.loadBalanced === true ? 'hello' : constants_1.LEGACY_HELLO_COMMAND]: 1,
		        helloOk: true,
		        client: clientMetadata,
		        compression: compressors
		    };
		    if (options.loadBalanced === true) {
		        handshakeDoc.loadBalanced = true;
		    }
		    const credentials = authContext.credentials;
		    if (credentials) {
		        if (credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {
		            handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;
		            const provider = authContext.options.authProviders.getOrCreateProvider(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, credentials.mechanismProperties);
		            if (!provider) {
		                // This auth mechanism is always present.
		                throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${providers_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`);
		            }
		            return await provider.prepare(handshakeDoc, authContext);
		        }
		        const provider = authContext.options.authProviders.getOrCreateProvider(credentials.mechanism, credentials.mechanismProperties);
		        if (!provider) {
		            throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`);
		        }
		        return await provider.prepare(handshakeDoc, authContext);
		    }
		    return handshakeDoc;
		}
		/** @public */
		exports.LEGAL_TLS_SOCKET_OPTIONS = [
		    'allowPartialTrustChain',
		    'ALPNProtocols',
		    'ca',
		    'cert',
		    'checkServerIdentity',
		    'ciphers',
		    'crl',
		    'ecdhCurve',
		    'key',
		    'minDHSize',
		    'passphrase',
		    'pfx',
		    'rejectUnauthorized',
		    'secureContext',
		    'secureProtocol',
		    'servername',
		    'session'
		];
		/** @public */
		exports.LEGAL_TCP_SOCKET_OPTIONS = [
		    'autoSelectFamily',
		    'autoSelectFamilyAttemptTimeout',
		    'family',
		    'hints',
		    'localAddress',
		    'localPort',
		    'lookup'
		];
		function parseConnectOptions(options) {
		    const hostAddress = options.hostAddress;
		    if (!hostAddress)
		        throw new error_1.MongoInvalidArgumentError('Option "hostAddress" is required');
		    const result = {};
		    for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {
		        if (options[name] != null) {
		            result[name] = options[name];
		        }
		    }
		    if (typeof hostAddress.socketPath === 'string') {
		        result.path = hostAddress.socketPath;
		        return result;
		    }
		    else if (typeof hostAddress.host === 'string') {
		        result.host = hostAddress.host;
		        result.port = hostAddress.port;
		        return result;
		    }
		    else {
		        // This should never happen since we set up HostAddresses
		        // But if we don't throw here the socket could hang until timeout
		        // TODO(NODE-3483)
		        throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);
		    }
		}
		function parseSslOptions(options) {
		    const result = parseConnectOptions(options);
		    // Merge in valid SSL options
		    for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {
		        if (options[name] != null) {
		            result[name] = options[name];
		        }
		    }
		    if (options.existingSocket) {
		        result.socket = options.existingSocket;
		    }
		    // Set default sni servername to be the same as host
		    if (result.servername == null && result.host && !net.isIP(result.host)) {
		        result.servername = result.host;
		    }
		    return result;
		}
		async function makeSocket(options) {
		    const useTLS = options.tls ?? false;
		    const noDelay = options.noDelay ?? true;
		    const connectTimeoutMS = options.connectTimeoutMS ?? 30000;
		    const existingSocket = options.existingSocket;
		    let socket;
		    if (options.proxyHost != null) {
		        // Currently, only Socks5 is supported.
		        return await makeSocks5Connection({
		            ...options,
		            connectTimeoutMS // Should always be present for Socks5
		        });
		    }
		    if (useTLS) {
		        const tlsSocket = tls.connect(parseSslOptions(options));
		        if (typeof tlsSocket.disableRenegotiation === 'function') {
		            tlsSocket.disableRenegotiation();
		        }
		        socket = tlsSocket;
		    }
		    else if (existingSocket) {
		        // In the TLS case, parseSslOptions() sets options.socket to existingSocket,
		        // so we only need to handle the non-TLS case here (where existingSocket
		        // gives us all we need out of the box).
		        socket = existingSocket;
		    }
		    else {
		        socket = net.createConnection(parseConnectOptions(options));
		    }
		    socket.setKeepAlive(true, 300000);
		    socket.setTimeout(connectTimeoutMS);
		    socket.setNoDelay(noDelay);
		    let cancellationHandler = null;
		    const { promise: connectedSocket, resolve, reject } = (0, utils_1.promiseWithResolvers)();
		    if (existingSocket) {
		        resolve(socket);
		    }
		    else {
		        const connectEvent = useTLS ? 'secureConnect' : 'connect';
		        socket
		            .once(connectEvent, () => resolve(socket))
		            .once('error', error => reject(connectionFailureError('error', error)))
		            .once('timeout', () => reject(connectionFailureError('timeout')))
		            .once('close', () => reject(connectionFailureError('close')));
		        if (options.cancellationToken != null) {
		            cancellationHandler = () => reject(connectionFailureError('cancel'));
		            options.cancellationToken.once('cancel', cancellationHandler);
		        }
		    }
		    try {
		        socket = await connectedSocket;
		        return socket;
		    }
		    catch (error) {
		        socket.destroy();
		        throw error;
		    }
		    finally {
		        socket.setTimeout(0);
		        socket.removeAllListeners();
		        if (cancellationHandler != null) {
		            options.cancellationToken?.removeListener('cancel', cancellationHandler);
		        }
		    }
		}
		let socks = null;
		function loadSocks() {
		    if (socks == null) {
		        const socksImport = (0, deps_1.getSocks)();
		        if ('kModuleError' in socksImport) {
		            throw socksImport.kModuleError;
		        }
		        socks = socksImport;
		    }
		    return socks;
		}
		async function makeSocks5Connection(options) {
		    const hostAddress = utils_1.HostAddress.fromHostPort(options.proxyHost ?? '', // proxyHost is guaranteed to set here
		    options.proxyPort ?? 1080);
		    // First, connect to the proxy server itself:
		    const rawSocket = await makeSocket({
		        ...options,
		        hostAddress,
		        tls: false,
		        proxyHost: undefined
		    });
		    const destination = parseConnectOptions(options);
		    if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {
		        throw new error_1.MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts');
		    }
		    socks ??= loadSocks();
		    try {
		        // Then, establish the Socks5 proxy connection:
		        const { socket } = await socks.SocksClient.createConnection({
		            existing_socket: rawSocket,
		            timeout: options.connectTimeoutMS,
		            command: 'connect',
		            destination: {
		                host: destination.host,
		                port: destination.port
		            },
		            proxy: {
		                // host and port are ignored because we pass existing_socket
		                host: 'iLoveJavaScript',
		                port: 0,
		                type: 5,
		                userId: options.proxyUsername || undefined,
		                password: options.proxyPassword || undefined
		            }
		        });
		        // Finally, now treat the resulting duplex stream as the
		        // socket over which we send and receive wire protocol messages:
		        return await makeSocket({
		            ...options,
		            existingSocket: socket,
		            proxyHost: undefined
		        });
		    }
		    catch (error) {
		        throw connectionFailureError('error', error);
		    }
		}
		function connectionFailureError(type, cause) {
		    switch (type) {
		        case 'error':
		            return new error_1.MongoNetworkError(error_1.MongoError.buildErrorMessage(cause), { cause });
		        case 'timeout':
		            return new error_1.MongoNetworkTimeoutError('connection timed out');
		        case 'close':
		            return new error_1.MongoNetworkError('connection closed');
		        case 'cancel':
		            return new error_1.MongoNetworkError('connection establishment was cancelled');
		        default:
		            return new error_1.MongoNetworkError('unknown network error');
		    }
		}
		
	} (connect));
	return connect;
}

var events = {};

var hasRequiredEvents;

function requireEvents () {
	if (hasRequiredEvents) return events;
	hasRequiredEvents = 1;
	Object.defineProperty(events, "__esModule", { value: true });
	events.ServerHeartbeatFailedEvent = events.ServerHeartbeatSucceededEvent = events.ServerHeartbeatStartedEvent = events.TopologyClosedEvent = events.TopologyOpeningEvent = events.TopologyDescriptionChangedEvent = events.ServerClosedEvent = events.ServerOpeningEvent = events.ServerDescriptionChangedEvent = void 0;
	const constants_1 = requireConstants();
	/**
	 * Emitted when server description changes, but does NOT include changes to the RTT.
	 * @public
	 * @category Event
	 */
	class ServerDescriptionChangedEvent {
	    /** @internal */
	    constructor(topologyId, address, previousDescription, newDescription) {
	        this.name = constants_1.SERVER_DESCRIPTION_CHANGED;
	        this.topologyId = topologyId;
	        this.address = address;
	        this.previousDescription = previousDescription;
	        this.newDescription = newDescription;
	    }
	}
	events.ServerDescriptionChangedEvent = ServerDescriptionChangedEvent;
	/**
	 * Emitted when server is initialized.
	 * @public
	 * @category Event
	 */
	class ServerOpeningEvent {
	    /** @internal */
	    constructor(topologyId, address) {
	        /** @internal */
	        this.name = constants_1.SERVER_OPENING;
	        this.topologyId = topologyId;
	        this.address = address;
	    }
	}
	events.ServerOpeningEvent = ServerOpeningEvent;
	/**
	 * Emitted when server is closed.
	 * @public
	 * @category Event
	 */
	class ServerClosedEvent {
	    /** @internal */
	    constructor(topologyId, address) {
	        /** @internal */
	        this.name = constants_1.SERVER_CLOSED;
	        this.topologyId = topologyId;
	        this.address = address;
	    }
	}
	events.ServerClosedEvent = ServerClosedEvent;
	/**
	 * Emitted when topology description changes.
	 * @public
	 * @category Event
	 */
	class TopologyDescriptionChangedEvent {
	    /** @internal */
	    constructor(topologyId, previousDescription, newDescription) {
	        /** @internal */
	        this.name = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;
	        this.topologyId = topologyId;
	        this.previousDescription = previousDescription;
	        this.newDescription = newDescription;
	    }
	}
	events.TopologyDescriptionChangedEvent = TopologyDescriptionChangedEvent;
	/**
	 * Emitted when topology is initialized.
	 * @public
	 * @category Event
	 */
	class TopologyOpeningEvent {
	    /** @internal */
	    constructor(topologyId) {
	        /** @internal */
	        this.name = constants_1.TOPOLOGY_OPENING;
	        this.topologyId = topologyId;
	    }
	}
	events.TopologyOpeningEvent = TopologyOpeningEvent;
	/**
	 * Emitted when topology is closed.
	 * @public
	 * @category Event
	 */
	class TopologyClosedEvent {
	    /** @internal */
	    constructor(topologyId) {
	        /** @internal */
	        this.name = constants_1.TOPOLOGY_CLOSED;
	        this.topologyId = topologyId;
	    }
	}
	events.TopologyClosedEvent = TopologyClosedEvent;
	/**
	 * Emitted when the server monitors hello command is started - immediately before
	 * the hello command is serialized into raw BSON and written to the socket.
	 *
	 * @public
	 * @category Event
	 */
	class ServerHeartbeatStartedEvent {
	    /** @internal */
	    constructor(connectionId, awaited) {
	        /** @internal */
	        this.name = constants_1.SERVER_HEARTBEAT_STARTED;
	        this.connectionId = connectionId;
	        this.awaited = awaited;
	    }
	}
	events.ServerHeartbeatStartedEvent = ServerHeartbeatStartedEvent;
	/**
	 * Emitted when the server monitors hello succeeds.
	 * @public
	 * @category Event
	 */
	class ServerHeartbeatSucceededEvent {
	    /** @internal */
	    constructor(connectionId, duration, reply, awaited) {
	        /** @internal */
	        this.name = constants_1.SERVER_HEARTBEAT_SUCCEEDED;
	        this.connectionId = connectionId;
	        this.duration = duration;
	        this.reply = reply ?? {};
	        this.awaited = awaited;
	    }
	}
	events.ServerHeartbeatSucceededEvent = ServerHeartbeatSucceededEvent;
	/**
	 * Emitted when the server monitors hello fails, either with an ok: 0 or a socket exception.
	 * @public
	 * @category Event
	 */
	class ServerHeartbeatFailedEvent {
	    /** @internal */
	    constructor(connectionId, duration, failure, awaited) {
	        /** @internal */
	        this.name = constants_1.SERVER_HEARTBEAT_FAILED;
	        this.connectionId = connectionId;
	        this.duration = duration;
	        this.failure = failure;
	        this.awaited = awaited;
	    }
	}
	events.ServerHeartbeatFailedEvent = ServerHeartbeatFailedEvent;
	
	return events;
}

var server = {};

var connection_pool = {};

var timeout = {};

var hasRequiredTimeout;

function requireTimeout () {
	if (hasRequiredTimeout) return timeout;
	hasRequiredTimeout = 1;
	Object.defineProperty(timeout, "__esModule", { value: true });
	timeout.Timeout = timeout.TimeoutError = void 0;
	const timers_1 = require$$0$d;
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	/** @internal */
	class TimeoutError extends Error {
	    get name() {
	        return 'TimeoutError';
	    }
	    constructor(message, options) {
	        super(message, options);
	    }
	    static is(error) {
	        return (error != null && typeof error === 'object' && 'name' in error && error.name === 'TimeoutError');
	    }
	}
	timeout.TimeoutError = TimeoutError;
	/**
	 * @internal
	 * This class is an abstraction over timeouts
	 * The Timeout class can only be in the pending or rejected states. It is guaranteed not to resolve
	 * if interacted with exclusively through its public API
	 * */
	class Timeout extends Promise {
	    get [Symbol.toStringTag]() {
	        return 'MongoDBTimeout';
	    }
	    /** Create a new timeout that expires in `duration` ms */
	    constructor(executor = () => null, duration, unref = false) {
	        let reject;
	        if (duration < 0) {
	            throw new error_1.MongoInvalidArgumentError('Cannot create a Timeout with a negative duration');
	        }
	        super((_, promiseReject) => {
	            reject = promiseReject;
	            executor(utils_1.noop, promiseReject);
	        });
	        this.ended = null;
	        this.timedOut = false;
	        this.duration = duration;
	        this.start = Math.trunc(performance.now());
	        if (this.duration > 0) {
	            this.id = (0, timers_1.setTimeout)(() => {
	                this.ended = Math.trunc(performance.now());
	                this.timedOut = true;
	                reject(new TimeoutError(`Expired after ${duration}ms`));
	            }, this.duration);
	            if (typeof this.id.unref === 'function' && unref) {
	                // Ensure we do not keep the Node.js event loop running
	                this.id.unref();
	            }
	        }
	    }
	    /**
	     * Clears the underlying timeout. This method is idempotent
	     */
	    clear() {
	        (0, timers_1.clearTimeout)(this.id);
	        this.id = undefined;
	    }
	    static expires(durationMS, unref) {
	        return new Timeout(undefined, durationMS, unref);
	    }
	    static is(timeout) {
	        return (typeof timeout === 'object' &&
	            timeout != null &&
	            Symbol.toStringTag in timeout &&
	            timeout[Symbol.toStringTag] === 'MongoDBTimeout' &&
	            'then' in timeout &&
	            typeof timeout.then === 'function');
	    }
	}
	timeout.Timeout = Timeout;
	
	return timeout;
}

var connection_pool_events = {};

var hasRequiredConnection_pool_events;

function requireConnection_pool_events () {
	if (hasRequiredConnection_pool_events) return connection_pool_events;
	hasRequiredConnection_pool_events = 1;
	Object.defineProperty(connection_pool_events, "__esModule", { value: true });
	connection_pool_events.ConnectionPoolClearedEvent = connection_pool_events.ConnectionCheckedInEvent = connection_pool_events.ConnectionCheckedOutEvent = connection_pool_events.ConnectionCheckOutFailedEvent = connection_pool_events.ConnectionCheckOutStartedEvent = connection_pool_events.ConnectionClosedEvent = connection_pool_events.ConnectionReadyEvent = connection_pool_events.ConnectionCreatedEvent = connection_pool_events.ConnectionPoolClosedEvent = connection_pool_events.ConnectionPoolReadyEvent = connection_pool_events.ConnectionPoolCreatedEvent = connection_pool_events.ConnectionPoolMonitoringEvent = void 0;
	const constants_1 = requireConstants();
	const utils_1 = requireUtils$1();
	/**
	 * The base export class for all monitoring events published from the connection pool
	 * @public
	 * @category Event
	 */
	class ConnectionPoolMonitoringEvent {
	    /** @internal */
	    constructor(pool) {
	        this.time = new Date();
	        this.address = pool.address;
	    }
	}
	connection_pool_events.ConnectionPoolMonitoringEvent = ConnectionPoolMonitoringEvent;
	/**
	 * An event published when a connection pool is created
	 * @public
	 * @category Event
	 */
	class ConnectionPoolCreatedEvent extends ConnectionPoolMonitoringEvent {
	    /** @internal */
	    constructor(pool) {
	        super(pool);
	        /** @internal */
	        this.name = constants_1.CONNECTION_POOL_CREATED;
	        const { maxConnecting, maxPoolSize, minPoolSize, maxIdleTimeMS, waitQueueTimeoutMS } = pool.options;
	        this.options = { maxConnecting, maxPoolSize, minPoolSize, maxIdleTimeMS, waitQueueTimeoutMS };
	    }
	}
	connection_pool_events.ConnectionPoolCreatedEvent = ConnectionPoolCreatedEvent;
	/**
	 * An event published when a connection pool is ready
	 * @public
	 * @category Event
	 */
	class ConnectionPoolReadyEvent extends ConnectionPoolMonitoringEvent {
	    /** @internal */
	    constructor(pool) {
	        super(pool);
	        /** @internal */
	        this.name = constants_1.CONNECTION_POOL_READY;
	    }
	}
	connection_pool_events.ConnectionPoolReadyEvent = ConnectionPoolReadyEvent;
	/**
	 * An event published when a connection pool is closed
	 * @public
	 * @category Event
	 */
	class ConnectionPoolClosedEvent extends ConnectionPoolMonitoringEvent {
	    /** @internal */
	    constructor(pool) {
	        super(pool);
	        /** @internal */
	        this.name = constants_1.CONNECTION_POOL_CLOSED;
	    }
	}
	connection_pool_events.ConnectionPoolClosedEvent = ConnectionPoolClosedEvent;
	/**
	 * An event published when a connection pool creates a new connection
	 * @public
	 * @category Event
	 */
	class ConnectionCreatedEvent extends ConnectionPoolMonitoringEvent {
	    /** @internal */
	    constructor(pool, connection) {
	        super(pool);
	        /** @internal */
	        this.name = constants_1.CONNECTION_CREATED;
	        this.connectionId = connection.id;
	    }
	}
	connection_pool_events.ConnectionCreatedEvent = ConnectionCreatedEvent;
	/**
	 * An event published when a connection is ready for use
	 * @public
	 * @category Event
	 */
	class ConnectionReadyEvent extends ConnectionPoolMonitoringEvent {
	    /** @internal */
	    constructor(pool, connection, connectionCreatedEventTime) {
	        super(pool);
	        /** @internal */
	        this.name = constants_1.CONNECTION_READY;
	        this.durationMS = (0, utils_1.now)() - connectionCreatedEventTime;
	        this.connectionId = connection.id;
	    }
	}
	connection_pool_events.ConnectionReadyEvent = ConnectionReadyEvent;
	/**
	 * An event published when a connection is closed
	 * @public
	 * @category Event
	 */
	class ConnectionClosedEvent extends ConnectionPoolMonitoringEvent {
	    /** @internal */
	    constructor(pool, connection, reason, error) {
	        super(pool);
	        /** @internal */
	        this.name = constants_1.CONNECTION_CLOSED;
	        this.connectionId = connection.id;
	        this.reason = reason;
	        this.serviceId = connection.serviceId;
	        this.error = error ?? null;
	    }
	}
	connection_pool_events.ConnectionClosedEvent = ConnectionClosedEvent;
	/**
	 * An event published when a request to check a connection out begins
	 * @public
	 * @category Event
	 */
	class ConnectionCheckOutStartedEvent extends ConnectionPoolMonitoringEvent {
	    /** @internal */
	    constructor(pool) {
	        super(pool);
	        /** @internal */
	        this.name = constants_1.CONNECTION_CHECK_OUT_STARTED;
	    }
	}
	connection_pool_events.ConnectionCheckOutStartedEvent = ConnectionCheckOutStartedEvent;
	/**
	 * An event published when a request to check a connection out fails
	 * @public
	 * @category Event
	 */
	class ConnectionCheckOutFailedEvent extends ConnectionPoolMonitoringEvent {
	    /** @internal */
	    constructor(pool, reason, checkoutTime, error) {
	        super(pool);
	        /** @internal */
	        this.name = constants_1.CONNECTION_CHECK_OUT_FAILED;
	        this.durationMS = (0, utils_1.now)() - checkoutTime;
	        this.reason = reason;
	        this.error = error;
	    }
	}
	connection_pool_events.ConnectionCheckOutFailedEvent = ConnectionCheckOutFailedEvent;
	/**
	 * An event published when a connection is checked out of the connection pool
	 * @public
	 * @category Event
	 */
	class ConnectionCheckedOutEvent extends ConnectionPoolMonitoringEvent {
	    /** @internal */
	    constructor(pool, connection, checkoutTime) {
	        super(pool);
	        /** @internal */
	        this.name = constants_1.CONNECTION_CHECKED_OUT;
	        this.durationMS = (0, utils_1.now)() - checkoutTime;
	        this.connectionId = connection.id;
	    }
	}
	connection_pool_events.ConnectionCheckedOutEvent = ConnectionCheckedOutEvent;
	/**
	 * An event published when a connection is checked into the connection pool
	 * @public
	 * @category Event
	 */
	class ConnectionCheckedInEvent extends ConnectionPoolMonitoringEvent {
	    /** @internal */
	    constructor(pool, connection) {
	        super(pool);
	        /** @internal */
	        this.name = constants_1.CONNECTION_CHECKED_IN;
	        this.connectionId = connection.id;
	    }
	}
	connection_pool_events.ConnectionCheckedInEvent = ConnectionCheckedInEvent;
	/**
	 * An event published when a connection pool is cleared
	 * @public
	 * @category Event
	 */
	class ConnectionPoolClearedEvent extends ConnectionPoolMonitoringEvent {
	    /** @internal */
	    constructor(pool, options = {}) {
	        super(pool);
	        /** @internal */
	        this.name = constants_1.CONNECTION_POOL_CLEARED;
	        this.serviceId = options.serviceId;
	        this.interruptInUseConnections = options.interruptInUseConnections;
	    }
	}
	connection_pool_events.ConnectionPoolClearedEvent = ConnectionPoolClearedEvent;
	
	return connection_pool_events;
}

var errors = {};

var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;
	Object.defineProperty(errors, "__esModule", { value: true });
	errors.WaitQueueTimeoutError = errors.PoolClearedOnNetworkError = errors.PoolClearedError = errors.PoolClosedError = void 0;
	const error_1 = requireError();
	/**
	 * An error indicating a connection pool is closed
	 * @category Error
	 */
	class PoolClosedError extends error_1.MongoDriverError {
	    /**
	     * **Do not use this constructor!**
	     *
	     * Meant for internal use only.
	     *
	     * @remarks
	     * This class is only meant to be constructed within the driver. This constructor is
	     * not subject to semantic versioning compatibility guarantees and may change at any time.
	     *
	     * @public
	     **/
	    constructor(pool) {
	        super('Attempted to check out a connection from closed connection pool');
	        this.address = pool.address;
	    }
	    get name() {
	        return 'MongoPoolClosedError';
	    }
	}
	errors.PoolClosedError = PoolClosedError;
	/**
	 * An error indicating a connection pool is currently paused
	 * @category Error
	 */
	class PoolClearedError extends error_1.MongoNetworkError {
	    /**
	     * **Do not use this constructor!**
	     *
	     * Meant for internal use only.
	     *
	     * @remarks
	     * This class is only meant to be constructed within the driver. This constructor is
	     * not subject to semantic versioning compatibility guarantees and may change at any time.
	     *
	     * @public
	     **/
	    constructor(pool, message) {
	        const errorMessage = message
	            ? message
	            : `Connection pool for ${pool.address} was cleared because another operation failed with: "${pool.serverError?.message}"`;
	        super(errorMessage, pool.serverError ? { cause: pool.serverError } : undefined);
	        this.address = pool.address;
	        this.addErrorLabel(error_1.MongoErrorLabel.PoolRequstedRetry);
	    }
	    get name() {
	        return 'MongoPoolClearedError';
	    }
	}
	errors.PoolClearedError = PoolClearedError;
	/**
	 * An error indicating that a connection pool has been cleared after the monitor for that server timed out.
	 * @category Error
	 */
	class PoolClearedOnNetworkError extends PoolClearedError {
	    /**
	     * **Do not use this constructor!**
	     *
	     * Meant for internal use only.
	     *
	     * @remarks
	     * This class is only meant to be constructed within the driver. This constructor is
	     * not subject to semantic versioning compatibility guarantees and may change at any time.
	     *
	     * @public
	     **/
	    constructor(pool) {
	        super(pool, `Connection to ${pool.address} interrupted due to server monitor timeout`);
	    }
	    get name() {
	        return 'PoolClearedOnNetworkError';
	    }
	}
	errors.PoolClearedOnNetworkError = PoolClearedOnNetworkError;
	/**
	 * An error thrown when a request to check out a connection times out
	 * @category Error
	 */
	class WaitQueueTimeoutError extends error_1.MongoDriverError {
	    /**
	     * **Do not use this constructor!**
	     *
	     * Meant for internal use only.
	     *
	     * @remarks
	     * This class is only meant to be constructed within the driver. This constructor is
	     * not subject to semantic versioning compatibility guarantees and may change at any time.
	     *
	     * @public
	     **/
	    constructor(message, address) {
	        super(message);
	        this.address = address;
	    }
	    get name() {
	        return 'MongoWaitQueueTimeoutError';
	    }
	}
	errors.WaitQueueTimeoutError = WaitQueueTimeoutError;
	
	return errors;
}

var hasRequiredConnection_pool;

function requireConnection_pool () {
	if (hasRequiredConnection_pool) return connection_pool;
	hasRequiredConnection_pool = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ConnectionPool = exports.PoolState = void 0;
		const timers_1 = require$$0$d;
		const constants_1 = requireConstants();
		const error_1 = requireError();
		const mongo_types_1 = requireMongo_types();
		const timeout_1 = requireTimeout();
		const utils_1 = requireUtils$1();
		const connect_1 = requireConnect();
		const connection_1 = requireConnection();
		const connection_pool_events_1 = requireConnection_pool_events();
		const errors_1 = requireErrors();
		const metrics_1 = requireMetrics();
		/** @internal */
		const kServer = Symbol('server');
		/** @internal */
		const kConnections = Symbol('connections');
		/** @internal */
		const kPending = Symbol('pending');
		/** @internal */
		const kCheckedOut = Symbol('checkedOut');
		/** @internal */
		const kMinPoolSizeTimer = Symbol('minPoolSizeTimer');
		/** @internal */
		const kGeneration = Symbol('generation');
		/** @internal */
		const kServiceGenerations = Symbol('serviceGenerations');
		/** @internal */
		const kConnectionCounter = Symbol('connectionCounter');
		/** @internal */
		const kCancellationToken = Symbol('cancellationToken');
		/** @internal */
		const kWaitQueue = Symbol('waitQueue');
		/** @internal */
		const kCancelled = Symbol('cancelled');
		/** @internal */
		const kMetrics = Symbol('metrics');
		/** @internal */
		const kProcessingWaitQueue = Symbol('processingWaitQueue');
		/** @internal */
		const kPoolState = Symbol('poolState');
		/** @internal */
		exports.PoolState = Object.freeze({
		    paused: 'paused',
		    ready: 'ready',
		    closed: 'closed'
		});
		/**
		 * A pool of connections which dynamically resizes, and emit events related to pool activity
		 * @internal
		 */
		class ConnectionPool extends mongo_types_1.TypedEventEmitter {
		    constructor(server, options) {
		        super();
		        this.options = Object.freeze({
		            connectionType: connection_1.Connection,
		            ...options,
		            maxPoolSize: options.maxPoolSize ?? 100,
		            minPoolSize: options.minPoolSize ?? 0,
		            maxConnecting: options.maxConnecting ?? 2,
		            maxIdleTimeMS: options.maxIdleTimeMS ?? 0,
		            waitQueueTimeoutMS: options.waitQueueTimeoutMS ?? 0,
		            minPoolSizeCheckFrequencyMS: options.minPoolSizeCheckFrequencyMS ?? 100,
		            autoEncrypter: options.autoEncrypter
		        });
		        if (this.options.minPoolSize > this.options.maxPoolSize) {
		            throw new error_1.MongoInvalidArgumentError('Connection pool minimum size must not be greater than maximum pool size');
		        }
		        this[kPoolState] = exports.PoolState.paused;
		        this[kServer] = server;
		        this[kConnections] = new utils_1.List();
		        this[kPending] = 0;
		        this[kCheckedOut] = new Set();
		        this[kMinPoolSizeTimer] = undefined;
		        this[kGeneration] = 0;
		        this[kServiceGenerations] = new Map();
		        this[kConnectionCounter] = (0, utils_1.makeCounter)(1);
		        this[kCancellationToken] = new mongo_types_1.CancellationToken();
		        this[kCancellationToken].setMaxListeners(Infinity);
		        this[kWaitQueue] = new utils_1.List();
		        this[kMetrics] = new metrics_1.ConnectionPoolMetrics();
		        this[kProcessingWaitQueue] = false;
		        this.mongoLogger = this[kServer].topology.client?.mongoLogger;
		        this.component = 'connection';
		        process.nextTick(() => {
		            this.emitAndLog(ConnectionPool.CONNECTION_POOL_CREATED, new connection_pool_events_1.ConnectionPoolCreatedEvent(this));
		        });
		    }
		    /** The address of the endpoint the pool is connected to */
		    get address() {
		        return this.options.hostAddress.toString();
		    }
		    /**
		     * Check if the pool has been closed
		     *
		     * TODO(NODE-3263): We can remove this property once shell no longer needs it
		     */
		    get closed() {
		        return this[kPoolState] === exports.PoolState.closed;
		    }
		    /** An integer representing the SDAM generation of the pool */
		    get generation() {
		        return this[kGeneration];
		    }
		    /** An integer expressing how many total connections (available + pending + in use) the pool currently has */
		    get totalConnectionCount() {
		        return (this.availableConnectionCount + this.pendingConnectionCount + this.currentCheckedOutCount);
		    }
		    /** An integer expressing how many connections are currently available in the pool. */
		    get availableConnectionCount() {
		        return this[kConnections].length;
		    }
		    get pendingConnectionCount() {
		        return this[kPending];
		    }
		    get currentCheckedOutCount() {
		        return this[kCheckedOut].size;
		    }
		    get waitQueueSize() {
		        return this[kWaitQueue].length;
		    }
		    get loadBalanced() {
		        return this.options.loadBalanced;
		    }
		    get serviceGenerations() {
		        return this[kServiceGenerations];
		    }
		    get serverError() {
		        return this[kServer].description.error;
		    }
		    /**
		     * This is exposed ONLY for use in mongosh, to enable
		     * killing all connections if a user quits the shell with
		     * operations in progress.
		     *
		     * This property may be removed as a part of NODE-3263.
		     */
		    get checkedOutConnections() {
		        return this[kCheckedOut];
		    }
		    /**
		     * Get the metrics information for the pool when a wait queue timeout occurs.
		     */
		    waitQueueErrorMetrics() {
		        return this[kMetrics].info(this.options.maxPoolSize);
		    }
		    /**
		     * Set the pool state to "ready"
		     */
		    ready() {
		        if (this[kPoolState] !== exports.PoolState.paused) {
		            return;
		        }
		        this[kPoolState] = exports.PoolState.ready;
		        this.emitAndLog(ConnectionPool.CONNECTION_POOL_READY, new connection_pool_events_1.ConnectionPoolReadyEvent(this));
		        (0, timers_1.clearTimeout)(this[kMinPoolSizeTimer]);
		        this.ensureMinPoolSize();
		    }
		    /**
		     * Check a connection out of this pool. The connection will continue to be tracked, but no reference to it
		     * will be held by the pool. This means that if a connection is checked out it MUST be checked back in or
		     * explicitly destroyed by the new owner.
		     */
		    async checkOut() {
		        const checkoutTime = (0, utils_1.now)();
		        this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_STARTED, new connection_pool_events_1.ConnectionCheckOutStartedEvent(this));
		        const waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;
		        const { promise, resolve, reject } = (0, utils_1.promiseWithResolvers)();
		        const timeout = timeout_1.Timeout.expires(waitQueueTimeoutMS);
		        const waitQueueMember = {
		            resolve,
		            reject,
		            timeout,
		            checkoutTime
		        };
		        this[kWaitQueue].push(waitQueueMember);
		        process.nextTick(() => this.processWaitQueue());
		        try {
		            return await Promise.race([promise, waitQueueMember.timeout]);
		        }
		        catch (error) {
		            if (timeout_1.TimeoutError.is(error)) {
		                waitQueueMember[kCancelled] = true;
		                waitQueueMember.timeout.clear();
		                this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, 'timeout', waitQueueMember.checkoutTime));
		                const timeoutError = new errors_1.WaitQueueTimeoutError(this.loadBalanced
		                    ? this.waitQueueErrorMetrics()
		                    : 'Timed out while checking out a connection from connection pool', this.address);
		                throw timeoutError;
		            }
		            throw error;
		        }
		    }
		    /**
		     * Check a connection into the pool.
		     *
		     * @param connection - The connection to check in
		     */
		    checkIn(connection) {
		        if (!this[kCheckedOut].has(connection)) {
		            return;
		        }
		        const poolClosed = this.closed;
		        const stale = this.connectionIsStale(connection);
		        const willDestroy = !!(poolClosed || stale || connection.closed);
		        if (!willDestroy) {
		            connection.markAvailable();
		            this[kConnections].unshift(connection);
		        }
		        this[kCheckedOut].delete(connection);
		        this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_IN, new connection_pool_events_1.ConnectionCheckedInEvent(this, connection));
		        if (willDestroy) {
		            const reason = connection.closed ? 'error' : poolClosed ? 'poolClosed' : 'stale';
		            this.destroyConnection(connection, reason);
		        }
		        process.nextTick(() => this.processWaitQueue());
		    }
		    /**
		     * Clear the pool
		     *
		     * Pool reset is handled by incrementing the pool's generation count. Any existing connection of a
		     * previous generation will eventually be pruned during subsequent checkouts.
		     */
		    clear(options = {}) {
		        if (this.closed) {
		            return;
		        }
		        // handle load balanced case
		        if (this.loadBalanced) {
		            const { serviceId } = options;
		            if (!serviceId) {
		                throw new error_1.MongoRuntimeError('ConnectionPool.clear() called in load balanced mode with no serviceId.');
		            }
		            const sid = serviceId.toHexString();
		            const generation = this.serviceGenerations.get(sid);
		            // Only need to worry if the generation exists, since it should
		            // always be there but typescript needs the check.
		            if (generation == null) {
		                throw new error_1.MongoRuntimeError('Service generations are required in load balancer mode.');
		            }
		            else {
		                // Increment the generation for the service id.
		                this.serviceGenerations.set(sid, generation + 1);
		            }
		            this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, { serviceId }));
		            return;
		        }
		        // handle non load-balanced case
		        const interruptInUseConnections = options.interruptInUseConnections ?? false;
		        const oldGeneration = this[kGeneration];
		        this[kGeneration] += 1;
		        const alreadyPaused = this[kPoolState] === exports.PoolState.paused;
		        this[kPoolState] = exports.PoolState.paused;
		        this.clearMinPoolSizeTimer();
		        if (!alreadyPaused) {
		            this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, {
		                interruptInUseConnections
		            }));
		        }
		        if (interruptInUseConnections) {
		            process.nextTick(() => this.interruptInUseConnections(oldGeneration));
		        }
		        this.processWaitQueue();
		    }
		    /**
		     * Closes all stale in-use connections in the pool with a resumable PoolClearedOnNetworkError.
		     *
		     * Only connections where `connection.generation <= minGeneration` are killed.
		     */
		    interruptInUseConnections(minGeneration) {
		        for (const connection of this[kCheckedOut]) {
		            if (connection.generation <= minGeneration) {
		                connection.onError(new errors_1.PoolClearedOnNetworkError(this));
		                this.checkIn(connection);
		            }
		        }
		    }
		    /** Close the pool */
		    close() {
		        if (this.closed) {
		            return;
		        }
		        // immediately cancel any in-flight connections
		        this[kCancellationToken].emit('cancel');
		        // end the connection counter
		        if (typeof this[kConnectionCounter].return === 'function') {
		            this[kConnectionCounter].return(undefined);
		        }
		        this[kPoolState] = exports.PoolState.closed;
		        this.clearMinPoolSizeTimer();
		        this.processWaitQueue();
		        for (const conn of this[kConnections]) {
		            this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, conn, 'poolClosed'));
		            conn.destroy();
		        }
		        this[kConnections].clear();
		        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLOSED, new connection_pool_events_1.ConnectionPoolClosedEvent(this));
		    }
		    /**
		     * @internal
		     * Reauthenticate a connection
		     */
		    async reauthenticate(connection) {
		        const authContext = connection.authContext;
		        if (!authContext) {
		            throw new error_1.MongoRuntimeError('No auth context found on connection.');
		        }
		        const credentials = authContext.credentials;
		        if (!credentials) {
		            throw new error_1.MongoMissingCredentialsError('Connection is missing credentials when asked to reauthenticate');
		        }
		        const resolvedCredentials = credentials.resolveAuthMechanism(connection.hello);
		        const provider = this[kServer].topology.client.s.authProviders.getOrCreateProvider(resolvedCredentials.mechanism, resolvedCredentials.mechanismProperties);
		        if (!provider) {
		            throw new error_1.MongoMissingCredentialsError(`Reauthenticate failed due to no auth provider for ${credentials.mechanism}`);
		        }
		        await provider.reauth(authContext);
		        return;
		    }
		    /** Clear the min pool size timer */
		    clearMinPoolSizeTimer() {
		        const minPoolSizeTimer = this[kMinPoolSizeTimer];
		        if (minPoolSizeTimer) {
		            (0, timers_1.clearTimeout)(minPoolSizeTimer);
		        }
		    }
		    destroyConnection(connection, reason) {
		        this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, connection, reason));
		        // destroy the connection
		        connection.destroy();
		    }
		    connectionIsStale(connection) {
		        const serviceId = connection.serviceId;
		        if (this.loadBalanced && serviceId) {
		            const sid = serviceId.toHexString();
		            const generation = this.serviceGenerations.get(sid);
		            return connection.generation !== generation;
		        }
		        return connection.generation !== this[kGeneration];
		    }
		    connectionIsIdle(connection) {
		        return !!(this.options.maxIdleTimeMS && connection.idleTime > this.options.maxIdleTimeMS);
		    }
		    /**
		     * Destroys a connection if the connection is perished.
		     *
		     * @returns `true` if the connection was destroyed, `false` otherwise.
		     */
		    destroyConnectionIfPerished(connection) {
		        const isStale = this.connectionIsStale(connection);
		        const isIdle = this.connectionIsIdle(connection);
		        if (!isStale && !isIdle && !connection.closed) {
		            return false;
		        }
		        const reason = connection.closed ? 'error' : isStale ? 'stale' : 'idle';
		        this.destroyConnection(connection, reason);
		        return true;
		    }
		    createConnection(callback) {
		        const connectOptions = {
		            ...this.options,
		            id: this[kConnectionCounter].next().value,
		            generation: this[kGeneration],
		            cancellationToken: this[kCancellationToken],
		            mongoLogger: this.mongoLogger,
		            authProviders: this[kServer].topology.client.s.authProviders
		        };
		        this[kPending]++;
		        // This is our version of a "virtual" no-I/O connection as the spec requires
		        const connectionCreatedTime = (0, utils_1.now)();
		        this.emitAndLog(ConnectionPool.CONNECTION_CREATED, new connection_pool_events_1.ConnectionCreatedEvent(this, { id: connectOptions.id }));
		        (0, connect_1.connect)(connectOptions).then(connection => {
		            // The pool might have closed since we started trying to create a connection
		            if (this[kPoolState] !== exports.PoolState.ready) {
		                this[kPending]--;
		                connection.destroy();
		                callback(this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this));
		                return;
		            }
		            // forward all events from the connection to the pool
		            for (const event of [...constants_1.APM_EVENTS, connection_1.Connection.CLUSTER_TIME_RECEIVED]) {
		                connection.on(event, (e) => this.emit(event, e));
		            }
		            if (this.loadBalanced) {
		                connection.on(connection_1.Connection.PINNED, pinType => this[kMetrics].markPinned(pinType));
		                connection.on(connection_1.Connection.UNPINNED, pinType => this[kMetrics].markUnpinned(pinType));
		                const serviceId = connection.serviceId;
		                if (serviceId) {
		                    let generation;
		                    const sid = serviceId.toHexString();
		                    if ((generation = this.serviceGenerations.get(sid))) {
		                        connection.generation = generation;
		                    }
		                    else {
		                        this.serviceGenerations.set(sid, 0);
		                        connection.generation = 0;
		                    }
		                }
		            }
		            connection.markAvailable();
		            this.emitAndLog(ConnectionPool.CONNECTION_READY, new connection_pool_events_1.ConnectionReadyEvent(this, connection, connectionCreatedTime));
		            this[kPending]--;
		            callback(undefined, connection);
		        }, error => {
		            this[kPending]--;
		            this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, { id: connectOptions.id, serviceId: undefined }, 'error', 
		            // TODO(NODE-5192): Remove this cast
		            error));
		            if (error instanceof error_1.MongoNetworkError || error instanceof error_1.MongoServerError) {
		                error.connectionGeneration = connectOptions.generation;
		            }
		            callback(error ?? new error_1.MongoRuntimeError('Connection creation failed without error'));
		        });
		    }
		    ensureMinPoolSize() {
		        const minPoolSize = this.options.minPoolSize;
		        if (this[kPoolState] !== exports.PoolState.ready || minPoolSize === 0) {
		            return;
		        }
		        this[kConnections].prune(connection => this.destroyConnectionIfPerished(connection));
		        if (this.totalConnectionCount < minPoolSize &&
		            this.pendingConnectionCount < this.options.maxConnecting) {
		            // NOTE: ensureMinPoolSize should not try to get all the pending
		            // connection permits because that potentially delays the availability of
		            // the connection to a checkout request
		            this.createConnection((err, connection) => {
		                if (err) {
		                    this[kServer].handleError(err);
		                }
		                if (!err && connection) {
		                    this[kConnections].push(connection);
		                    process.nextTick(() => this.processWaitQueue());
		                }
		                if (this[kPoolState] === exports.PoolState.ready) {
		                    (0, timers_1.clearTimeout)(this[kMinPoolSizeTimer]);
		                    this[kMinPoolSizeTimer] = (0, timers_1.setTimeout)(() => this.ensureMinPoolSize(), this.options.minPoolSizeCheckFrequencyMS);
		                }
		            });
		        }
		        else {
		            (0, timers_1.clearTimeout)(this[kMinPoolSizeTimer]);
		            this[kMinPoolSizeTimer] = (0, timers_1.setTimeout)(() => this.ensureMinPoolSize(), this.options.minPoolSizeCheckFrequencyMS);
		        }
		    }
		    processWaitQueue() {
		        if (this[kProcessingWaitQueue]) {
		            return;
		        }
		        this[kProcessingWaitQueue] = true;
		        while (this.waitQueueSize) {
		            const waitQueueMember = this[kWaitQueue].first();
		            if (!waitQueueMember) {
		                this[kWaitQueue].shift();
		                continue;
		            }
		            if (waitQueueMember[kCancelled]) {
		                this[kWaitQueue].shift();
		                continue;
		            }
		            if (this[kPoolState] !== exports.PoolState.ready) {
		                const reason = this.closed ? 'poolClosed' : 'connectionError';
		                const error = this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this);
		                this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, reason, waitQueueMember.checkoutTime, error));
		                waitQueueMember.timeout.clear();
		                this[kWaitQueue].shift();
		                waitQueueMember.reject(error);
		                continue;
		            }
		            if (!this.availableConnectionCount) {
		                break;
		            }
		            const connection = this[kConnections].shift();
		            if (!connection) {
		                break;
		            }
		            if (!this.destroyConnectionIfPerished(connection)) {
		                this[kCheckedOut].add(connection);
		                this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection, waitQueueMember.checkoutTime));
		                waitQueueMember.timeout.clear();
		                this[kWaitQueue].shift();
		                waitQueueMember.resolve(connection);
		            }
		        }
		        const { maxPoolSize, maxConnecting } = this.options;
		        while (this.waitQueueSize > 0 &&
		            this.pendingConnectionCount < maxConnecting &&
		            (maxPoolSize === 0 || this.totalConnectionCount < maxPoolSize)) {
		            const waitQueueMember = this[kWaitQueue].shift();
		            if (!waitQueueMember || waitQueueMember[kCancelled]) {
		                continue;
		            }
		            this.createConnection((err, connection) => {
		                if (waitQueueMember[kCancelled]) {
		                    if (!err && connection) {
		                        this[kConnections].push(connection);
		                    }
		                }
		                else {
		                    if (err) {
		                        this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, 
		                        // TODO(NODE-5192): Remove this cast
		                        new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, 'connectionError', waitQueueMember.checkoutTime, err));
		                        waitQueueMember.reject(err);
		                    }
		                    else if (connection) {
		                        this[kCheckedOut].add(connection);
		                        this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection, waitQueueMember.checkoutTime));
		                        waitQueueMember.resolve(connection);
		                    }
		                    waitQueueMember.timeout.clear();
		                }
		                process.nextTick(() => this.processWaitQueue());
		            });
		        }
		        this[kProcessingWaitQueue] = false;
		    }
		}
		exports.ConnectionPool = ConnectionPool;
		/**
		 * Emitted when the connection pool is created.
		 * @event
		 */
		ConnectionPool.CONNECTION_POOL_CREATED = constants_1.CONNECTION_POOL_CREATED;
		/**
		 * Emitted once when the connection pool is closed
		 * @event
		 */
		ConnectionPool.CONNECTION_POOL_CLOSED = constants_1.CONNECTION_POOL_CLOSED;
		/**
		 * Emitted each time the connection pool is cleared and it's generation incremented
		 * @event
		 */
		ConnectionPool.CONNECTION_POOL_CLEARED = constants_1.CONNECTION_POOL_CLEARED;
		/**
		 * Emitted each time the connection pool is marked ready
		 * @event
		 */
		ConnectionPool.CONNECTION_POOL_READY = constants_1.CONNECTION_POOL_READY;
		/**
		 * Emitted when a connection is created.
		 * @event
		 */
		ConnectionPool.CONNECTION_CREATED = constants_1.CONNECTION_CREATED;
		/**
		 * Emitted when a connection becomes established, and is ready to use
		 * @event
		 */
		ConnectionPool.CONNECTION_READY = constants_1.CONNECTION_READY;
		/**
		 * Emitted when a connection is closed
		 * @event
		 */
		ConnectionPool.CONNECTION_CLOSED = constants_1.CONNECTION_CLOSED;
		/**
		 * Emitted when an attempt to check out a connection begins
		 * @event
		 */
		ConnectionPool.CONNECTION_CHECK_OUT_STARTED = constants_1.CONNECTION_CHECK_OUT_STARTED;
		/**
		 * Emitted when an attempt to check out a connection fails
		 * @event
		 */
		ConnectionPool.CONNECTION_CHECK_OUT_FAILED = constants_1.CONNECTION_CHECK_OUT_FAILED;
		/**
		 * Emitted each time a connection is successfully checked out of the connection pool
		 * @event
		 */
		ConnectionPool.CONNECTION_CHECKED_OUT = constants_1.CONNECTION_CHECKED_OUT;
		/**
		 * Emitted each time a connection is successfully checked into the connection pool
		 * @event
		 */
		ConnectionPool.CONNECTION_CHECKED_IN = constants_1.CONNECTION_CHECKED_IN;
		
	} (connection_pool));
	return connection_pool;
}

var hasRequiredServer;

function requireServer () {
	if (hasRequiredServer) return server;
	hasRequiredServer = 1;
	Object.defineProperty(server, "__esModule", { value: true });
	server.Server = void 0;
	const connection_1 = requireConnection();
	const connection_pool_1 = requireConnection_pool();
	const errors_1 = requireErrors();
	const constants_1 = requireConstants();
	const error_1 = requireError();
	const mongo_types_1 = requireMongo_types();
	const transactions_1 = requireTransactions();
	const utils_1 = requireUtils$1();
	const write_concern_1 = requireWrite_concern();
	const common_1 = requireCommon$1();
	const monitor_1 = requireMonitor();
	const server_description_1 = requireServer_description();
	const stateTransition = (0, utils_1.makeStateMachine)({
	    [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],
	    [common_1.STATE_CONNECTING]: [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],
	    [common_1.STATE_CONNECTED]: [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],
	    [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, common_1.STATE_CLOSED]
	});
	/** @internal */
	class Server extends mongo_types_1.TypedEventEmitter {
	    /**
	     * Create a server
	     */
	    constructor(topology, description, options) {
	        super();
	        this.serverApi = options.serverApi;
	        const poolOptions = { hostAddress: description.hostAddress, ...options };
	        this.topology = topology;
	        this.pool = new connection_pool_1.ConnectionPool(this, poolOptions);
	        this.s = {
	            description,
	            options,
	            state: common_1.STATE_CLOSED,
	            operationCount: 0
	        };
	        for (const event of [...constants_1.CMAP_EVENTS, ...constants_1.APM_EVENTS]) {
	            this.pool.on(event, (e) => this.emit(event, e));
	        }
	        this.pool.on(connection_1.Connection.CLUSTER_TIME_RECEIVED, (clusterTime) => {
	            this.clusterTime = clusterTime;
	        });
	        if (this.loadBalanced) {
	            this.monitor = null;
	            // monitoring is disabled in load balancing mode
	            return;
	        }
	        // create the monitor
	        this.monitor = new monitor_1.Monitor(this, this.s.options);
	        for (const event of constants_1.HEARTBEAT_EVENTS) {
	            this.monitor.on(event, (e) => this.emit(event, e));
	        }
	        this.monitor.on('resetServer', (error) => markServerUnknown(this, error));
	        this.monitor.on(Server.SERVER_HEARTBEAT_SUCCEEDED, (event) => {
	            this.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(this.description.hostAddress, event.reply, {
	                roundTripTime: this.monitor?.roundTripTime,
	                minRoundTripTime: this.monitor?.minRoundTripTime
	            }));
	            if (this.s.state === common_1.STATE_CONNECTING) {
	                stateTransition(this, common_1.STATE_CONNECTED);
	                this.emit(Server.CONNECT, this);
	            }
	        });
	    }
	    get clusterTime() {
	        return this.topology.clusterTime;
	    }
	    set clusterTime(clusterTime) {
	        this.topology.clusterTime = clusterTime;
	    }
	    get description() {
	        return this.s.description;
	    }
	    get name() {
	        return this.s.description.address;
	    }
	    get autoEncrypter() {
	        if (this.s.options && this.s.options.autoEncrypter) {
	            return this.s.options.autoEncrypter;
	        }
	        return;
	    }
	    get loadBalanced() {
	        return this.topology.description.type === common_1.TopologyType.LoadBalanced;
	    }
	    /**
	     * Initiate server connect
	     */
	    connect() {
	        if (this.s.state !== common_1.STATE_CLOSED) {
	            return;
	        }
	        stateTransition(this, common_1.STATE_CONNECTING);
	        // If in load balancer mode we automatically set the server to
	        // a load balancer. It never transitions out of this state and
	        // has no monitor.
	        if (!this.loadBalanced) {
	            this.monitor?.connect();
	        }
	        else {
	            stateTransition(this, common_1.STATE_CONNECTED);
	            this.emit(Server.CONNECT, this);
	        }
	    }
	    /** Destroy the server connection */
	    destroy() {
	        if (this.s.state === common_1.STATE_CLOSED) {
	            return;
	        }
	        stateTransition(this, common_1.STATE_CLOSING);
	        if (!this.loadBalanced) {
	            this.monitor?.close();
	        }
	        this.pool.close();
	        stateTransition(this, common_1.STATE_CLOSED);
	        this.emit('closed');
	    }
	    /**
	     * Immediately schedule monitoring of this server. If there already an attempt being made
	     * this will be a no-op.
	     */
	    requestCheck() {
	        if (!this.loadBalanced) {
	            this.monitor?.requestCheck();
	        }
	    }
	    async command(ns, cmd, options, responseType) {
	        if (ns.db == null || typeof ns === 'string') {
	            throw new error_1.MongoInvalidArgumentError('Namespace must not be a string');
	        }
	        if (this.s.state === common_1.STATE_CLOSING || this.s.state === common_1.STATE_CLOSED) {
	            throw new error_1.MongoServerClosedError();
	        }
	        // Clone the options
	        const finalOptions = Object.assign({}, options, {
	            wireProtocolCommand: false,
	            directConnection: this.topology.s.options.directConnection
	        });
	        // There are cases where we need to flag the read preference not to get sent in
	        // the command, such as pre-5.0 servers attempting to perform an aggregate write
	        // with a non-primary read preference. In this case the effective read preference
	        // (primary) is not the same as the provided and must be removed completely.
	        if (finalOptions.omitReadPreference) {
	            delete finalOptions.readPreference;
	        }
	        const session = finalOptions.session;
	        let conn = session?.pinnedConnection;
	        this.incrementOperationCount();
	        if (conn == null) {
	            try {
	                conn = await this.pool.checkOut();
	                if (this.loadBalanced && isPinnableCommand(cmd, session)) {
	                    session?.pin(conn);
	                }
	            }
	            catch (checkoutError) {
	                this.decrementOperationCount();
	                if (!(checkoutError instanceof errors_1.PoolClearedError))
	                    this.handleError(checkoutError);
	                throw checkoutError;
	            }
	        }
	        try {
	            try {
	                const res = await conn.command(ns, cmd, finalOptions, responseType);
	                (0, write_concern_1.throwIfWriteConcernError)(res);
	                return res;
	            }
	            catch (commandError) {
	                throw this.decorateCommandError(conn, cmd, finalOptions, commandError);
	            }
	        }
	        catch (operationError) {
	            if (operationError instanceof error_1.MongoError &&
	                operationError.code === error_1.MONGODB_ERROR_CODES.Reauthenticate) {
	                await this.pool.reauthenticate(conn);
	                try {
	                    const res = await conn.command(ns, cmd, finalOptions, responseType);
	                    (0, write_concern_1.throwIfWriteConcernError)(res);
	                    return res;
	                }
	                catch (commandError) {
	                    throw this.decorateCommandError(conn, cmd, finalOptions, commandError);
	                }
	            }
	            else {
	                throw operationError;
	            }
	        }
	        finally {
	            this.decrementOperationCount();
	            if (session?.pinnedConnection !== conn) {
	                this.pool.checkIn(conn);
	            }
	        }
	    }
	    /**
	     * Handle SDAM error
	     * @internal
	     */
	    handleError(error, connection) {
	        if (!(error instanceof error_1.MongoError)) {
	            return;
	        }
	        const isStaleError = error.connectionGeneration && error.connectionGeneration < this.pool.generation;
	        if (isStaleError) {
	            return;
	        }
	        const isNetworkNonTimeoutError = error instanceof error_1.MongoNetworkError && !(error instanceof error_1.MongoNetworkTimeoutError);
	        const isNetworkTimeoutBeforeHandshakeError = (0, error_1.isNetworkErrorBeforeHandshake)(error);
	        const isAuthHandshakeError = error.hasErrorLabel(error_1.MongoErrorLabel.HandshakeError);
	        if (isNetworkNonTimeoutError || isNetworkTimeoutBeforeHandshakeError || isAuthHandshakeError) {
	            // In load balanced mode we never mark the server as unknown and always
	            // clear for the specific service id.
	            if (!this.loadBalanced) {
	                error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
	                markServerUnknown(this, error);
	            }
	            else if (connection) {
	                this.pool.clear({ serviceId: connection.serviceId });
	            }
	        }
	        else {
	            if ((0, error_1.isSDAMUnrecoverableError)(error)) {
	                if (shouldHandleStateChangeError(this, error)) {
	                    const shouldClearPool = (0, utils_1.maxWireVersion)(this) <= 7 || (0, error_1.isNodeShuttingDownError)(error);
	                    if (this.loadBalanced && connection && shouldClearPool) {
	                        this.pool.clear({ serviceId: connection.serviceId });
	                    }
	                    if (!this.loadBalanced) {
	                        if (shouldClearPool) {
	                            error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
	                        }
	                        markServerUnknown(this, error);
	                        process.nextTick(() => this.requestCheck());
	                    }
	                }
	            }
	        }
	    }
	    /**
	     * Ensure that error is properly decorated and internal state is updated before throwing
	     * @internal
	     */
	    decorateCommandError(connection, cmd, options, error) {
	        if (typeof error !== 'object' || error == null || !('name' in error)) {
	            throw new error_1.MongoRuntimeError('An unexpected error type: ' + typeof error);
	        }
	        if (error.name === 'AbortError' && 'cause' in error && error.cause instanceof error_1.MongoError) {
	            error = error.cause;
	        }
	        if (!(error instanceof error_1.MongoError)) {
	            // Node.js or some other error we have not special handling for
	            return error;
	        }
	        if (connectionIsStale(this.pool, connection)) {
	            return error;
	        }
	        const session = options?.session;
	        if (error instanceof error_1.MongoNetworkError) {
	            if (session && !session.hasEnded && session.serverSession) {
	                session.serverSession.isDirty = true;
	            }
	            // inActiveTransaction check handles commit and abort.
	            if (inActiveTransaction(session, cmd) &&
	                !error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
	                error.addErrorLabel(error_1.MongoErrorLabel.TransientTransactionError);
	            }
	            if ((isRetryableWritesEnabled(this.topology) || (0, transactions_1.isTransactionCommand)(cmd)) &&
	                (0, utils_1.supportsRetryableWrites)(this) &&
	                !inActiveTransaction(session, cmd)) {
	                error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
	            }
	        }
	        else {
	            if ((isRetryableWritesEnabled(this.topology) || (0, transactions_1.isTransactionCommand)(cmd)) &&
	                (0, error_1.needsRetryableWriteLabel)(error, (0, utils_1.maxWireVersion)(this), this.description.type) &&
	                !inActiveTransaction(session, cmd)) {
	                error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
	            }
	        }
	        if (session &&
	            session.isPinned &&
	            error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
	            session.unpin({ force: true });
	        }
	        this.handleError(error, connection);
	        return error;
	    }
	    /**
	     * Decrement the operation count, returning the new count.
	     */
	    decrementOperationCount() {
	        return (this.s.operationCount -= 1);
	    }
	    /**
	     * Increment the operation count, returning the new count.
	     */
	    incrementOperationCount() {
	        return (this.s.operationCount += 1);
	    }
	}
	server.Server = Server;
	/** @event */
	Server.SERVER_HEARTBEAT_STARTED = constants_1.SERVER_HEARTBEAT_STARTED;
	/** @event */
	Server.SERVER_HEARTBEAT_SUCCEEDED = constants_1.SERVER_HEARTBEAT_SUCCEEDED;
	/** @event */
	Server.SERVER_HEARTBEAT_FAILED = constants_1.SERVER_HEARTBEAT_FAILED;
	/** @event */
	Server.CONNECT = constants_1.CONNECT;
	/** @event */
	Server.DESCRIPTION_RECEIVED = constants_1.DESCRIPTION_RECEIVED;
	/** @event */
	Server.CLOSED = constants_1.CLOSED;
	/** @event */
	Server.ENDED = constants_1.ENDED;
	function markServerUnknown(server, error) {
	    // Load balancer servers can never be marked unknown.
	    if (server.loadBalanced) {
	        return;
	    }
	    if (error instanceof error_1.MongoNetworkError && !(error instanceof error_1.MongoNetworkTimeoutError)) {
	        server.monitor?.reset();
	    }
	    server.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(server.description.hostAddress, undefined, { error }));
	}
	function isPinnableCommand(cmd, session) {
	    if (session) {
	        return (session.inTransaction() ||
	            (session.transaction.isCommitted && 'commitTransaction' in cmd) ||
	            'aggregate' in cmd ||
	            'find' in cmd ||
	            'getMore' in cmd ||
	            'listCollections' in cmd ||
	            'listIndexes' in cmd);
	    }
	    return false;
	}
	function connectionIsStale(pool, connection) {
	    if (connection.serviceId) {
	        return (connection.generation !== pool.serviceGenerations.get(connection.serviceId.toHexString()));
	    }
	    return connection.generation !== pool.generation;
	}
	function shouldHandleStateChangeError(server, err) {
	    const etv = err.topologyVersion;
	    const stv = server.description.topologyVersion;
	    return (0, server_description_1.compareTopologyVersion)(stv, etv) < 0;
	}
	function inActiveTransaction(session, cmd) {
	    return session && session.inTransaction() && !(0, transactions_1.isTransactionCommand)(cmd);
	}
	/** this checks the retryWrites option passed down from the client options, it
	 * does not check if the server supports retryable writes */
	function isRetryableWritesEnabled(topology) {
	    return topology.s.options.retryWrites !== false;
	}
	
	return server;
}

var hasRequiredMonitor;

function requireMonitor () {
	if (hasRequiredMonitor) return monitor;
	hasRequiredMonitor = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.RTTSampler = exports.MonitorInterval = exports.RTTPinger = exports.Monitor = exports.ServerMonitoringMode = void 0;
		const timers_1 = require$$0$d;
		const bson_1 = requireBson();
		const connect_1 = requireConnect();
		const client_metadata_1 = requireClient_metadata();
		const constants_1 = requireConstants();
		const error_1 = requireError();
		const mongo_logger_1 = requireMongo_logger();
		const mongo_types_1 = requireMongo_types();
		const utils_1 = requireUtils$1();
		const common_1 = requireCommon$1();
		const events_1 = requireEvents();
		const server_1 = requireServer();
		/** @internal */
		const kServer = Symbol('server');
		/** @internal */
		const kMonitorId = Symbol('monitorId');
		/** @internal */
		const kCancellationToken = Symbol('cancellationToken');
		const STATE_IDLE = 'idle';
		const STATE_MONITORING = 'monitoring';
		const stateTransition = (0, utils_1.makeStateMachine)({
		    [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED],
		    [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, STATE_MONITORING],
		    [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING],
		    [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]
		});
		const INVALID_REQUEST_CHECK_STATES = new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);
		function isInCloseState(monitor) {
		    return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;
		}
		/** @public */
		exports.ServerMonitoringMode = Object.freeze({
		    auto: 'auto',
		    poll: 'poll',
		    stream: 'stream'
		});
		/** @internal */
		class Monitor extends mongo_types_1.TypedEventEmitter {
		    constructor(server, options) {
		        super();
		        /** @internal */
		        this.component = mongo_logger_1.MongoLoggableComponent.TOPOLOGY;
		        this[kServer] = server;
		        this.connection = null;
		        this[kCancellationToken] = new mongo_types_1.CancellationToken();
		        this[kCancellationToken].setMaxListeners(Infinity);
		        this[kMonitorId] = undefined;
		        this.s = {
		            state: common_1.STATE_CLOSED
		        };
		        this.address = server.description.address;
		        this.options = Object.freeze({
		            connectTimeoutMS: options.connectTimeoutMS ?? 10000,
		            heartbeatFrequencyMS: options.heartbeatFrequencyMS ?? 10000,
		            minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS ?? 500,
		            serverMonitoringMode: options.serverMonitoringMode
		        });
		        this.isRunningInFaasEnv = (0, client_metadata_1.getFAASEnv)() != null;
		        this.mongoLogger = this[kServer].topology.client?.mongoLogger;
		        this.rttSampler = new RTTSampler(10);
		        const cancellationToken = this[kCancellationToken];
		        // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration
		        const connectOptions = {
		            id: '<monitor>',
		            generation: server.pool.generation,
		            cancellationToken,
		            hostAddress: server.description.hostAddress,
		            ...options,
		            // force BSON serialization options
		            raw: false,
		            useBigInt64: false,
		            promoteLongs: true,
		            promoteValues: true,
		            promoteBuffers: true
		        };
		        // ensure no authentication is used for monitoring
		        delete connectOptions.credentials;
		        if (connectOptions.autoEncrypter) {
		            delete connectOptions.autoEncrypter;
		        }
		        this.connectOptions = Object.freeze(connectOptions);
		    }
		    connect() {
		        if (this.s.state !== common_1.STATE_CLOSED) {
		            return;
		        }
		        // start
		        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
		        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
		        this[kMonitorId] = new MonitorInterval(monitorServer(this), {
		            heartbeatFrequencyMS: heartbeatFrequencyMS,
		            minHeartbeatFrequencyMS: minHeartbeatFrequencyMS,
		            immediate: true
		        });
		    }
		    requestCheck() {
		        if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
		            return;
		        }
		        this[kMonitorId]?.wake();
		    }
		    reset() {
		        const topologyVersion = this[kServer].description.topologyVersion;
		        if (isInCloseState(this) || topologyVersion == null) {
		            return;
		        }
		        stateTransition(this, common_1.STATE_CLOSING);
		        resetMonitorState(this);
		        // restart monitor
		        stateTransition(this, STATE_IDLE);
		        // restart monitoring
		        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
		        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
		        this[kMonitorId] = new MonitorInterval(monitorServer(this), {
		            heartbeatFrequencyMS: heartbeatFrequencyMS,
		            minHeartbeatFrequencyMS: minHeartbeatFrequencyMS
		        });
		    }
		    close() {
		        if (isInCloseState(this)) {
		            return;
		        }
		        stateTransition(this, common_1.STATE_CLOSING);
		        resetMonitorState(this);
		        // close monitor
		        this.emit('close');
		        stateTransition(this, common_1.STATE_CLOSED);
		    }
		    get roundTripTime() {
		        return this.rttSampler.average();
		    }
		    get minRoundTripTime() {
		        return this.rttSampler.min();
		    }
		    get latestRtt() {
		        return this.rttSampler.last;
		    }
		    addRttSample(rtt) {
		        this.rttSampler.addSample(rtt);
		    }
		    clearRttSamples() {
		        this.rttSampler.clear();
		    }
		}
		exports.Monitor = Monitor;
		function resetMonitorState(monitor) {
		    monitor[kMonitorId]?.stop();
		    monitor[kMonitorId] = undefined;
		    monitor.rttPinger?.close();
		    monitor.rttPinger = undefined;
		    monitor[kCancellationToken].emit('cancel');
		    monitor.connection?.destroy();
		    monitor.connection = null;
		    monitor.clearRttSamples();
		}
		function useStreamingProtocol(monitor, topologyVersion) {
		    // If we have no topology version we always poll no matter
		    // what the user provided, since the server does not support
		    // the streaming protocol.
		    if (topologyVersion == null)
		        return false;
		    const serverMonitoringMode = monitor.options.serverMonitoringMode;
		    if (serverMonitoringMode === exports.ServerMonitoringMode.poll)
		        return false;
		    if (serverMonitoringMode === exports.ServerMonitoringMode.stream)
		        return true;
		    // If we are in auto mode, we need to figure out if we're in a FaaS
		    // environment or not and choose the appropriate mode.
		    if (monitor.isRunningInFaasEnv)
		        return false;
		    return true;
		}
		function checkServer(monitor, callback) {
		    let start;
		    let awaited;
		    const topologyVersion = monitor[kServer].description.topologyVersion;
		    const isAwaitable = useStreamingProtocol(monitor, topologyVersion);
		    monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_STARTED, monitor[kServer].topology.s.id, undefined, new events_1.ServerHeartbeatStartedEvent(monitor.address, isAwaitable));
		    function onHeartbeatFailed(err) {
		        monitor.connection?.destroy();
		        monitor.connection = null;
		        monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_FAILED, monitor[kServer].topology.s.id, undefined, new events_1.ServerHeartbeatFailedEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), err, awaited));
		        const error = !(err instanceof error_1.MongoError)
		            ? new error_1.MongoError(error_1.MongoError.buildErrorMessage(err), { cause: err })
		            : err;
		        error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
		        if (error instanceof error_1.MongoNetworkTimeoutError) {
		            error.addErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
		        }
		        monitor.emit('resetServer', error);
		        callback(err);
		    }
		    function onHeartbeatSucceeded(hello) {
		        if (!('isWritablePrimary' in hello)) {
		            // Provide hello-style response document.
		            hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];
		        }
		        // NOTE: here we use the latestRtt as this measurement corresponds with the value
		        // obtained for this successful heartbeat, if there is no latestRtt, then we calculate the
		        // duration
		        const duration = isAwaitable && monitor.rttPinger
		            ? (monitor.rttPinger.latestRtt ?? (0, utils_1.calculateDurationInMs)(start))
		            : (0, utils_1.calculateDurationInMs)(start);
		        monitor.addRttSample(duration);
		        monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, monitor[kServer].topology.s.id, hello.connectionId, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello, isAwaitable));
		        if (isAwaitable) {
		            // If we are using the streaming protocol then we immediately issue another 'started'
		            // event, otherwise the "check" is complete and return to the main monitor loop
		            monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_STARTED, monitor[kServer].topology.s.id, undefined, new events_1.ServerHeartbeatStartedEvent(monitor.address, true));
		            // We have not actually sent an outgoing handshake, but when we get the next response we
		            // want the duration to reflect the time since we last heard from the server
		            start = (0, utils_1.now)();
		        }
		        else {
		            monitor.rttPinger?.close();
		            monitor.rttPinger = undefined;
		            callback(undefined, hello);
		        }
		    }
		    const { connection } = monitor;
		    if (connection && !connection.closed) {
		        const { serverApi, helloOk } = connection;
		        const connectTimeoutMS = monitor.options.connectTimeoutMS;
		        const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
		        const cmd = {
		            [serverApi?.version || helloOk ? 'hello' : constants_1.LEGACY_HELLO_COMMAND]: 1,
		            ...(isAwaitable && topologyVersion
		                ? { maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) }
		                : {})
		        };
		        const options = isAwaitable
		            ? {
		                socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,
		                exhaustAllowed: true
		            }
		            : { socketTimeoutMS: connectTimeoutMS };
		        if (isAwaitable && monitor.rttPinger == null) {
		            monitor.rttPinger = new RTTPinger(monitor);
		        }
		        // Record new start time before sending handshake
		        start = (0, utils_1.now)();
		        if (isAwaitable) {
		            awaited = true;
		            return connection.exhaustCommand((0, utils_1.ns)('admin.$cmd'), cmd, options, (error, hello) => {
		                if (error)
		                    return onHeartbeatFailed(error);
		                return onHeartbeatSucceeded(hello);
		            });
		        }
		        awaited = false;
		        connection
		            .command((0, utils_1.ns)('admin.$cmd'), cmd, options)
		            .then(onHeartbeatSucceeded, onHeartbeatFailed);
		        return;
		    }
		    // connecting does an implicit `hello`
		    (async () => {
		        const socket = await (0, connect_1.makeSocket)(monitor.connectOptions);
		        const connection = (0, connect_1.makeConnection)(monitor.connectOptions, socket);
		        // The start time is after socket creation but before the handshake
		        start = (0, utils_1.now)();
		        try {
		            await (0, connect_1.performInitialHandshake)(connection, monitor.connectOptions);
		            return connection;
		        }
		        catch (error) {
		            connection.destroy();
		            throw error;
		        }
		    })().then(connection => {
		        if (isInCloseState(monitor)) {
		            connection.destroy();
		            return;
		        }
		        const duration = (0, utils_1.calculateDurationInMs)(start);
		        monitor.addRttSample(duration);
		        monitor.connection = connection;
		        monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, monitor[kServer].topology.s.id, connection.hello?.connectionId, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, connection.hello, useStreamingProtocol(monitor, connection.hello?.topologyVersion)));
		        callback(undefined, connection.hello);
		    }, error => {
		        monitor.connection = null;
		        awaited = false;
		        onHeartbeatFailed(error);
		    });
		}
		function monitorServer(monitor) {
		    return (callback) => {
		        if (monitor.s.state === STATE_MONITORING) {
		            process.nextTick(callback);
		            return;
		        }
		        stateTransition(monitor, STATE_MONITORING);
		        function done() {
		            if (!isInCloseState(monitor)) {
		                stateTransition(monitor, STATE_IDLE);
		            }
		            callback();
		        }
		        checkServer(monitor, (err, hello) => {
		            if (err) {
		                // otherwise an error occurred on initial discovery, also bail
		                if (monitor[kServer].description.type === common_1.ServerType.Unknown) {
		                    return done();
		                }
		            }
		            // if the check indicates streaming is supported, immediately reschedule monitoring
		            if (useStreamingProtocol(monitor, hello?.topologyVersion)) {
		                (0, timers_1.setTimeout)(() => {
		                    if (!isInCloseState(monitor)) {
		                        monitor[kMonitorId]?.wake();
		                    }
		                }, 0);
		            }
		            done();
		        });
		    };
		}
		function makeTopologyVersion(tv) {
		    return {
		        processId: tv.processId,
		        // tests mock counter as just number, but in a real situation counter should always be a Long
		        // TODO(NODE-2674): Preserve int64 sent from MongoDB
		        counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)
		    };
		}
		/** @internal */
		class RTTPinger {
		    constructor(monitor) {
		        this.connection = undefined;
		        this[kCancellationToken] = monitor[kCancellationToken];
		        this.closed = false;
		        this.monitor = monitor;
		        this.latestRtt = monitor.latestRtt ?? undefined;
		        const heartbeatFrequencyMS = monitor.options.heartbeatFrequencyMS;
		        this[kMonitorId] = (0, timers_1.setTimeout)(() => this.measureRoundTripTime(), heartbeatFrequencyMS);
		    }
		    get roundTripTime() {
		        return this.monitor.roundTripTime;
		    }
		    get minRoundTripTime() {
		        return this.monitor.minRoundTripTime;
		    }
		    close() {
		        this.closed = true;
		        (0, timers_1.clearTimeout)(this[kMonitorId]);
		        this.connection?.destroy();
		        this.connection = undefined;
		    }
		    measureAndReschedule(start, conn) {
		        if (this.closed) {
		            conn?.destroy();
		            return;
		        }
		        if (this.connection == null) {
		            this.connection = conn;
		        }
		        this.latestRtt = (0, utils_1.calculateDurationInMs)(start);
		        this[kMonitorId] = (0, timers_1.setTimeout)(() => this.measureRoundTripTime(), this.monitor.options.heartbeatFrequencyMS);
		    }
		    measureRoundTripTime() {
		        const start = (0, utils_1.now)();
		        if (this.closed) {
		            return;
		        }
		        const connection = this.connection;
		        if (connection == null) {
		            (0, connect_1.connect)(this.monitor.connectOptions).then(connection => {
		                this.measureAndReschedule(start, connection);
		            }, () => {
		                this.connection = undefined;
		            });
		            return;
		        }
		        const commandName = connection.serverApi?.version || connection.helloOk ? 'hello' : constants_1.LEGACY_HELLO_COMMAND;
		        connection.command((0, utils_1.ns)('admin.$cmd'), { [commandName]: 1 }, undefined).then(() => this.measureAndReschedule(start), () => {
		            this.connection?.destroy();
		            this.connection = undefined;
		            return;
		        });
		    }
		}
		exports.RTTPinger = RTTPinger;
		/**
		 * @internal
		 */
		class MonitorInterval {
		    constructor(fn, options = {}) {
		        this.isExpeditedCallToFnScheduled = false;
		        this.stopped = false;
		        this.isExecutionInProgress = false;
		        this.hasExecutedOnce = false;
		        this._executeAndReschedule = () => {
		            if (this.stopped)
		                return;
		            if (this.timerId) {
		                (0, timers_1.clearTimeout)(this.timerId);
		            }
		            this.isExpeditedCallToFnScheduled = false;
		            this.isExecutionInProgress = true;
		            this.fn(() => {
		                this.lastExecutionEnded = (0, utils_1.now)();
		                this.isExecutionInProgress = false;
		                this._reschedule(this.heartbeatFrequencyMS);
		            });
		        };
		        this.fn = fn;
		        this.lastExecutionEnded = -Infinity;
		        this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1000;
		        this.minHeartbeatFrequencyMS = options.minHeartbeatFrequencyMS ?? 500;
		        if (options.immediate) {
		            this._executeAndReschedule();
		        }
		        else {
		            this._reschedule(undefined);
		        }
		    }
		    wake() {
		        const currentTime = (0, utils_1.now)();
		        const timeSinceLastCall = currentTime - this.lastExecutionEnded;
		        // TODO(NODE-4674): Add error handling and logging to the monitor
		        if (timeSinceLastCall < 0) {
		            return this._executeAndReschedule();
		        }
		        if (this.isExecutionInProgress) {
		            return;
		        }
		        // debounce multiple calls to wake within the `minInterval`
		        if (this.isExpeditedCallToFnScheduled) {
		            return;
		        }
		        // reschedule a call as soon as possible, ensuring the call never happens
		        // faster than the `minInterval`
		        if (timeSinceLastCall < this.minHeartbeatFrequencyMS) {
		            this.isExpeditedCallToFnScheduled = true;
		            this._reschedule(this.minHeartbeatFrequencyMS - timeSinceLastCall);
		            return;
		        }
		        this._executeAndReschedule();
		    }
		    stop() {
		        this.stopped = true;
		        if (this.timerId) {
		            (0, timers_1.clearTimeout)(this.timerId);
		            this.timerId = undefined;
		        }
		        this.lastExecutionEnded = -Infinity;
		        this.isExpeditedCallToFnScheduled = false;
		    }
		    toString() {
		        return JSON.stringify(this);
		    }
		    toJSON() {
		        const currentTime = (0, utils_1.now)();
		        const timeSinceLastCall = currentTime - this.lastExecutionEnded;
		        return {
		            timerId: this.timerId != null ? 'set' : 'cleared',
		            lastCallTime: this.lastExecutionEnded,
		            isExpeditedCheckScheduled: this.isExpeditedCallToFnScheduled,
		            stopped: this.stopped,
		            heartbeatFrequencyMS: this.heartbeatFrequencyMS,
		            minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS,
		            currentTime,
		            timeSinceLastCall
		        };
		    }
		    _reschedule(ms) {
		        if (this.stopped)
		            return;
		        if (this.timerId) {
		            (0, timers_1.clearTimeout)(this.timerId);
		        }
		        this.timerId = (0, timers_1.setTimeout)(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);
		    }
		}
		exports.MonitorInterval = MonitorInterval;
		/** @internal
		 * This class implements the RTT sampling logic specified for [CSOT](https://github.com/mongodb/specifications/blob/bbb335e60cd7ea1e0f7cd9a9443cb95fc9d3b64d/source/client-side-operations-timeout/client-side-operations-timeout.md#drivers-use-minimum-rtt-to-short-circuit-operations)
		 *
		 * This is implemented as a [circular buffer](https://en.wikipedia.org/wiki/Circular_buffer) keeping
		 * the most recent `windowSize` samples
		 * */
		class RTTSampler {
		    constructor(windowSize = 10) {
		        this.rttSamples = new Float64Array(windowSize);
		        this.length = 0;
		        this.writeIndex = 0;
		    }
		    /**
		     * Adds an rtt sample to the end of the circular buffer
		     * When `windowSize` samples have been collected, `addSample` overwrites the least recently added
		     * sample
		     */
		    addSample(sample) {
		        this.rttSamples[this.writeIndex++] = sample;
		        if (this.length < this.rttSamples.length) {
		            this.length++;
		        }
		        this.writeIndex %= this.rttSamples.length;
		    }
		    /**
		     * When \< 2 samples have been collected, returns 0
		     * Otherwise computes the minimum value samples contained in the buffer
		     */
		    min() {
		        if (this.length < 2)
		            return 0;
		        let min = this.rttSamples[0];
		        for (let i = 1; i < this.length; i++) {
		            if (this.rttSamples[i] < min)
		                min = this.rttSamples[i];
		        }
		        return min;
		    }
		    /**
		     * Returns mean of samples contained in the buffer
		     */
		    average() {
		        if (this.length === 0)
		            return 0;
		        let sum = 0;
		        for (let i = 0; i < this.length; i++) {
		            sum += this.rttSamples[i];
		        }
		        return sum / this.length;
		    }
		    /**
		     * Returns most recently inserted element in the buffer
		     * Returns null if the buffer is empty
		     * */
		    get last() {
		        if (this.length === 0)
		            return null;
		        return this.rttSamples[this.writeIndex === 0 ? this.length - 1 : this.writeIndex - 1];
		    }
		    /**
		     * Clear the buffer
		     * NOTE: this does not overwrite the data held in the internal array, just the pointers into
		     * this array
		     */
		    clear() {
		        this.length = 0;
		        this.writeIndex = 0;
		    }
		}
		exports.RTTSampler = RTTSampler;
		
	} (monitor));
	return monitor;
}

var hasRequiredConnection_string;

function requireConnection_string () {
	if (hasRequiredConnection_string) return connection_string;
	hasRequiredConnection_string = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.FEATURE_FLAGS = exports.DEFAULT_OPTIONS = exports.OPTIONS = void 0;
		exports.resolveSRVRecord = resolveSRVRecord;
		exports.parseOptions = parseOptions;
		const dns = require$$0$e;
		const mongodb_connection_string_url_1 = requireLib$1();
		const url_1 = require$$4$1;
		const mongo_credentials_1 = requireMongo_credentials();
		const providers_1 = requireProviders$1();
		const client_metadata_1 = requireClient_metadata();
		const compression_1 = requireCompression();
		const encrypter_1 = requireEncrypter();
		const error_1 = requireError();
		const mongo_client_1 = requireMongo_client();
		const mongo_logger_1 = requireMongo_logger();
		const read_concern_1 = requireRead_concern();
		const read_preference_1 = requireRead_preference();
		const monitor_1 = requireMonitor();
		const utils_1 = requireUtils$1();
		const write_concern_1 = requireWrite_concern();
		const VALID_TXT_RECORDS = ['authSource', 'replicaSet', 'loadBalanced'];
		const LB_SINGLE_HOST_ERROR = 'loadBalanced option only supported with a single host in the URI';
		const LB_REPLICA_SET_ERROR = 'loadBalanced option not supported with a replicaSet option';
		const LB_DIRECT_CONNECTION_ERROR = 'loadBalanced option not supported when directConnection is provided';
		/**
		 * Lookup a `mongodb+srv` connection string, combine the parts and reparse it as a normal
		 * connection string.
		 *
		 * @param uri - The connection string to parse
		 * @param options - Optional user provided connection string options
		 */
		async function resolveSRVRecord(options) {
		    if (typeof options.srvHost !== 'string') {
		        throw new error_1.MongoAPIError('Option "srvHost" must not be empty');
		    }
		    if (options.srvHost.split('.').length < 3) {
		        // TODO(NODE-3484): Replace with MongoConnectionStringError
		        throw new error_1.MongoAPIError('URI must include hostname, domain name, and tld');
		    }
		    // Asynchronously start TXT resolution so that we do not have to wait until
		    // the SRV record is resolved before starting a second DNS query.
		    const lookupAddress = options.srvHost;
		    const txtResolutionPromise = dns.promises.resolveTxt(lookupAddress);
		    txtResolutionPromise.then(undefined, utils_1.squashError); // rejections will be handled later
		    // Resolve the SRV record and use the result as the list of hosts to connect to.
		    const addresses = await dns.promises.resolveSrv(`_${options.srvServiceName}._tcp.${lookupAddress}`);
		    if (addresses.length === 0) {
		        throw new error_1.MongoAPIError('No addresses found at host');
		    }
		    for (const { name } of addresses) {
		        if (!(0, utils_1.matchesParentDomain)(name, lookupAddress)) {
		            throw new error_1.MongoAPIError('Server record does not share hostname with parent URI');
		        }
		    }
		    const hostAddresses = addresses.map(r => utils_1.HostAddress.fromString(`${r.name}:${r.port ?? 27017}`));
		    validateLoadBalancedOptions(hostAddresses, options, true);
		    // Use the result of resolving the TXT record and add options from there if they exist.
		    let record;
		    try {
		        record = await txtResolutionPromise;
		    }
		    catch (error) {
		        if (error.code !== 'ENODATA' && error.code !== 'ENOTFOUND') {
		            throw error;
		        }
		        return hostAddresses;
		    }
		    if (record.length > 1) {
		        throw new error_1.MongoParseError('Multiple text records not allowed');
		    }
		    const txtRecordOptions = new url_1.URLSearchParams(record[0].join(''));
		    const txtRecordOptionKeys = [...txtRecordOptions.keys()];
		    if (txtRecordOptionKeys.some(key => !VALID_TXT_RECORDS.includes(key))) {
		        throw new error_1.MongoParseError(`Text record may only set any of: ${VALID_TXT_RECORDS.join(', ')}`);
		    }
		    if (VALID_TXT_RECORDS.some(option => txtRecordOptions.get(option) === '')) {
		        throw new error_1.MongoParseError('Cannot have empty URI params in DNS TXT Record');
		    }
		    const source = txtRecordOptions.get('authSource') ?? undefined;
		    const replicaSet = txtRecordOptions.get('replicaSet') ?? undefined;
		    const loadBalanced = txtRecordOptions.get('loadBalanced') ?? undefined;
		    if (!options.userSpecifiedAuthSource &&
		        source &&
		        options.credentials &&
		        !providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(options.credentials.mechanism)) {
		        options.credentials = mongo_credentials_1.MongoCredentials.merge(options.credentials, { source });
		    }
		    if (!options.userSpecifiedReplicaSet && replicaSet) {
		        options.replicaSet = replicaSet;
		    }
		    if (loadBalanced === 'true') {
		        options.loadBalanced = true;
		    }
		    if (options.replicaSet && options.srvMaxHosts > 0) {
		        throw new error_1.MongoParseError('Cannot combine replicaSet option with srvMaxHosts');
		    }
		    validateLoadBalancedOptions(hostAddresses, options, true);
		    return hostAddresses;
		}
		/**
		 * Checks if TLS options are valid
		 *
		 * @param allOptions - All options provided by user or included in default options map
		 * @throws MongoAPIError if TLS options are invalid
		 */
		function checkTLSOptions(allOptions) {
		    if (!allOptions)
		        return;
		    const check = (a, b) => {
		        if (allOptions.has(a) && allOptions.has(b)) {
		            throw new error_1.MongoAPIError(`The '${a}' option cannot be used with the '${b}' option`);
		        }
		    };
		    check('tlsInsecure', 'tlsAllowInvalidCertificates');
		    check('tlsInsecure', 'tlsAllowInvalidHostnames');
		    check('tlsInsecure', 'tlsDisableCertificateRevocationCheck');
		    check('tlsInsecure', 'tlsDisableOCSPEndpointCheck');
		    check('tlsAllowInvalidCertificates', 'tlsDisableCertificateRevocationCheck');
		    check('tlsAllowInvalidCertificates', 'tlsDisableOCSPEndpointCheck');
		    check('tlsDisableCertificateRevocationCheck', 'tlsDisableOCSPEndpointCheck');
		}
		function getBoolean(name, value) {
		    if (typeof value === 'boolean')
		        return value;
		    switch (value) {
		        case 'true':
		            return true;
		        case 'false':
		            return false;
		        default:
		            throw new error_1.MongoParseError(`${name} must be either "true" or "false"`);
		    }
		}
		function getIntFromOptions(name, value) {
		    const parsedInt = (0, utils_1.parseInteger)(value);
		    if (parsedInt != null) {
		        return parsedInt;
		    }
		    throw new error_1.MongoParseError(`Expected ${name} to be stringified int value, got: ${value}`);
		}
		function getUIntFromOptions(name, value) {
		    const parsedValue = getIntFromOptions(name, value);
		    if (parsedValue < 0) {
		        throw new error_1.MongoParseError(`${name} can only be a positive int value, got: ${value}`);
		    }
		    return parsedValue;
		}
		function* entriesFromString(value) {
		    if (value === '') {
		        return;
		    }
		    const keyValuePairs = value.split(',');
		    for (const keyValue of keyValuePairs) {
		        const [key, value] = keyValue.split(/:(.*)/);
		        if (value == null) {
		            throw new error_1.MongoParseError('Cannot have undefined values in key value pairs');
		        }
		        yield [key, value];
		    }
		}
		class CaseInsensitiveMap extends Map {
		    constructor(entries = []) {
		        super(entries.map(([k, v]) => [k.toLowerCase(), v]));
		    }
		    has(k) {
		        return super.has(k.toLowerCase());
		    }
		    get(k) {
		        return super.get(k.toLowerCase());
		    }
		    set(k, v) {
		        return super.set(k.toLowerCase(), v);
		    }
		    delete(k) {
		        return super.delete(k.toLowerCase());
		    }
		}
		function parseOptions(uri, mongoClient = undefined, options = {}) {
		    if (mongoClient != null && !(mongoClient instanceof mongo_client_1.MongoClient)) {
		        options = mongoClient;
		        mongoClient = undefined;
		    }
		    // validate BSONOptions
		    if (options.useBigInt64 && typeof options.promoteLongs === 'boolean' && !options.promoteLongs) {
		        throw new error_1.MongoAPIError('Must request either bigint or Long for int64 deserialization');
		    }
		    if (options.useBigInt64 && typeof options.promoteValues === 'boolean' && !options.promoteValues) {
		        throw new error_1.MongoAPIError('Must request either bigint or Long for int64 deserialization');
		    }
		    const url = new mongodb_connection_string_url_1.default(uri);
		    const { hosts, isSRV } = url;
		    const mongoOptions = Object.create(null);
		    // Feature flags
		    for (const flag of Object.getOwnPropertySymbols(options)) {
		        if (exports.FEATURE_FLAGS.has(flag)) {
		            mongoOptions[flag] = options[flag];
		        }
		    }
		    mongoOptions.hosts = isSRV ? [] : hosts.map(utils_1.HostAddress.fromString);
		    const urlOptions = new CaseInsensitiveMap();
		    if (url.pathname !== '/' && url.pathname !== '') {
		        const dbName = decodeURIComponent(url.pathname[0] === '/' ? url.pathname.slice(1) : url.pathname);
		        if (dbName) {
		            urlOptions.set('dbName', [dbName]);
		        }
		    }
		    if (url.username !== '') {
		        const auth = {
		            username: decodeURIComponent(url.username)
		        };
		        if (typeof url.password === 'string') {
		            auth.password = decodeURIComponent(url.password);
		        }
		        urlOptions.set('auth', [auth]);
		    }
		    for (const key of url.searchParams.keys()) {
		        const values = url.searchParams.getAll(key);
		        const isReadPreferenceTags = /readPreferenceTags/i.test(key);
		        if (!isReadPreferenceTags && values.length > 1) {
		            throw new error_1.MongoInvalidArgumentError(`URI option "${key}" cannot appear more than once in the connection string`);
		        }
		        if (!isReadPreferenceTags && values.includes('')) {
		            throw new error_1.MongoAPIError(`URI option "${key}" cannot be specified with no value`);
		        }
		        if (!urlOptions.has(key)) {
		            urlOptions.set(key, values);
		        }
		    }
		    const objectOptions = new CaseInsensitiveMap(Object.entries(options).filter(([, v]) => v != null));
		    // Validate options that can only be provided by one of uri or object
		    if (urlOptions.has('serverApi')) {
		        throw new error_1.MongoParseError('URI cannot contain `serverApi`, it can only be passed to the client');
		    }
		    const uriMechanismProperties = urlOptions.get('authMechanismProperties');
		    if (uriMechanismProperties) {
		        for (const property of uriMechanismProperties) {
		            if (/(^|,)ALLOWED_HOSTS:/.test(property)) {
		                throw new error_1.MongoParseError('Auth mechanism property ALLOWED_HOSTS is not allowed in the connection string.');
		            }
		        }
		    }
		    if (objectOptions.has('loadBalanced')) {
		        throw new error_1.MongoParseError('loadBalanced is only a valid option in the URI');
		    }
		    // All option collection
		    const allProvidedOptions = new CaseInsensitiveMap();
		    const allProvidedKeys = new Set([...urlOptions.keys(), ...objectOptions.keys()]);
		    for (const key of allProvidedKeys) {
		        const values = [];
		        const objectOptionValue = objectOptions.get(key);
		        if (objectOptionValue != null) {
		            values.push(objectOptionValue);
		        }
		        const urlValues = urlOptions.get(key) ?? [];
		        values.push(...urlValues);
		        allProvidedOptions.set(key, values);
		    }
		    if (allProvidedOptions.has('tls') || allProvidedOptions.has('ssl')) {
		        const tlsAndSslOpts = (allProvidedOptions.get('tls') || [])
		            .concat(allProvidedOptions.get('ssl') || [])
		            .map(getBoolean.bind(null, 'tls/ssl'));
		        if (new Set(tlsAndSslOpts).size !== 1) {
		            throw new error_1.MongoParseError('All values of tls/ssl must be the same.');
		        }
		    }
		    checkTLSOptions(allProvidedOptions);
		    const unsupportedOptions = (0, utils_1.setDifference)(allProvidedKeys, Array.from(Object.keys(exports.OPTIONS)).map(s => s.toLowerCase()));
		    if (unsupportedOptions.size !== 0) {
		        const optionWord = unsupportedOptions.size > 1 ? 'options' : 'option';
		        const isOrAre = unsupportedOptions.size > 1 ? 'are' : 'is';
		        throw new error_1.MongoParseError(`${optionWord} ${Array.from(unsupportedOptions).join(', ')} ${isOrAre} not supported`);
		    }
		    // Option parsing and setting
		    for (const [key, descriptor] of Object.entries(exports.OPTIONS)) {
		        const values = allProvidedOptions.get(key);
		        if (!values || values.length === 0) {
		            if (exports.DEFAULT_OPTIONS.has(key)) {
		                setOption(mongoOptions, key, descriptor, [exports.DEFAULT_OPTIONS.get(key)]);
		            }
		        }
		        else {
		            const { deprecated } = descriptor;
		            if (deprecated) {
		                const deprecatedMsg = typeof deprecated === 'string' ? `: ${deprecated}` : '';
		                (0, utils_1.emitWarning)(`${key} is a deprecated option${deprecatedMsg}`);
		            }
		            setOption(mongoOptions, key, descriptor, values);
		        }
		    }
		    if (mongoOptions.credentials) {
		        const isGssapi = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI;
		        const isX509 = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_X509;
		        const isAws = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_AWS;
		        const isOidc = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_OIDC;
		        if ((isGssapi || isX509) &&
		            allProvidedOptions.has('authSource') &&
		            mongoOptions.credentials.source !== '$external') {
		            // If authSource was explicitly given and its incorrect, we error
		            throw new error_1.MongoParseError(`authMechanism ${mongoOptions.credentials.mechanism} requires an authSource of '$external'`);
		        }
		        if (!(isGssapi || isX509 || isAws || isOidc) &&
		            mongoOptions.dbName &&
		            !allProvidedOptions.has('authSource')) {
		            // inherit the dbName unless GSSAPI or X509, then silently ignore dbName
		            // and there was no specific authSource given
		            mongoOptions.credentials = mongo_credentials_1.MongoCredentials.merge(mongoOptions.credentials, {
		                source: mongoOptions.dbName
		            });
		        }
		        if (isAws && mongoOptions.credentials.username && !mongoOptions.credentials.password) {
		            throw new error_1.MongoMissingCredentialsError(`When using ${mongoOptions.credentials.mechanism} password must be set when a username is specified`);
		        }
		        mongoOptions.credentials.validate();
		        // Check if the only auth related option provided was authSource, if so we can remove credentials
		        if (mongoOptions.credentials.password === '' &&
		            mongoOptions.credentials.username === '' &&
		            mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT &&
		            Object.keys(mongoOptions.credentials.mechanismProperties).length === 0) {
		            delete mongoOptions.credentials;
		        }
		    }
		    if (!mongoOptions.dbName) {
		        // dbName default is applied here because of the credential validation above
		        mongoOptions.dbName = 'test';
		    }
		    validateLoadBalancedOptions(hosts, mongoOptions, isSRV);
		    if (mongoClient && mongoOptions.autoEncryption) {
		        encrypter_1.Encrypter.checkForMongoCrypt();
		        mongoOptions.encrypter = new encrypter_1.Encrypter(mongoClient, uri, options);
		        mongoOptions.autoEncrypter = mongoOptions.encrypter.autoEncrypter;
		    }
		    // Potential SRV Overrides and SRV connection string validations
		    mongoOptions.userSpecifiedAuthSource =
		        objectOptions.has('authSource') || urlOptions.has('authSource');
		    mongoOptions.userSpecifiedReplicaSet =
		        objectOptions.has('replicaSet') || urlOptions.has('replicaSet');
		    if (isSRV) {
		        // SRV Record is resolved upon connecting
		        mongoOptions.srvHost = hosts[0];
		        if (mongoOptions.directConnection) {
		            throw new error_1.MongoAPIError('SRV URI does not support directConnection');
		        }
		        if (mongoOptions.srvMaxHosts > 0 && typeof mongoOptions.replicaSet === 'string') {
		            throw new error_1.MongoParseError('Cannot use srvMaxHosts option with replicaSet');
		        }
		        // SRV turns on TLS by default, but users can override and turn it off
		        const noUserSpecifiedTLS = !objectOptions.has('tls') && !urlOptions.has('tls');
		        const noUserSpecifiedSSL = !objectOptions.has('ssl') && !urlOptions.has('ssl');
		        if (noUserSpecifiedTLS && noUserSpecifiedSSL) {
		            mongoOptions.tls = true;
		        }
		    }
		    else {
		        const userSpecifiedSrvOptions = urlOptions.has('srvMaxHosts') ||
		            objectOptions.has('srvMaxHosts') ||
		            urlOptions.has('srvServiceName') ||
		            objectOptions.has('srvServiceName');
		        if (userSpecifiedSrvOptions) {
		            throw new error_1.MongoParseError('Cannot use srvMaxHosts or srvServiceName with a non-srv connection string');
		        }
		    }
		    if (mongoOptions.directConnection && mongoOptions.hosts.length !== 1) {
		        throw new error_1.MongoParseError('directConnection option requires exactly one host');
		    }
		    if (!mongoOptions.proxyHost &&
		        (mongoOptions.proxyPort || mongoOptions.proxyUsername || mongoOptions.proxyPassword)) {
		        throw new error_1.MongoParseError('Must specify proxyHost if other proxy options are passed');
		    }
		    if ((mongoOptions.proxyUsername && !mongoOptions.proxyPassword) ||
		        (!mongoOptions.proxyUsername && mongoOptions.proxyPassword)) {
		        throw new error_1.MongoParseError('Can only specify both of proxy username/password or neither');
		    }
		    const proxyOptions = ['proxyHost', 'proxyPort', 'proxyUsername', 'proxyPassword'].map(key => urlOptions.get(key) ?? []);
		    if (proxyOptions.some(options => options.length > 1)) {
		        throw new error_1.MongoParseError('Proxy options cannot be specified multiple times in the connection string');
		    }
		    const loggerFeatureFlag = Symbol.for('@@mdb.enableMongoLogger');
		    mongoOptions[loggerFeatureFlag] = mongoOptions[loggerFeatureFlag] ?? false;
		    let loggerEnvOptions = {};
		    let loggerClientOptions = {};
		    if (mongoOptions[loggerFeatureFlag]) {
		        loggerEnvOptions = {
		            MONGODB_LOG_COMMAND: process.env.MONGODB_LOG_COMMAND,
		            MONGODB_LOG_TOPOLOGY: process.env.MONGODB_LOG_TOPOLOGY,
		            MONGODB_LOG_SERVER_SELECTION: process.env.MONGODB_LOG_SERVER_SELECTION,
		            MONGODB_LOG_CONNECTION: process.env.MONGODB_LOG_CONNECTION,
		            MONGODB_LOG_CLIENT: process.env.MONGODB_LOG_CLIENT,
		            MONGODB_LOG_ALL: process.env.MONGODB_LOG_ALL,
		            MONGODB_LOG_MAX_DOCUMENT_LENGTH: process.env.MONGODB_LOG_MAX_DOCUMENT_LENGTH,
		            MONGODB_LOG_PATH: process.env.MONGODB_LOG_PATH,
		            ...mongoOptions[Symbol.for('@@mdb.internalLoggerConfig')]
		        };
		        loggerClientOptions = {
		            mongodbLogPath: mongoOptions.mongodbLogPath,
		            mongodbLogComponentSeverities: mongoOptions.mongodbLogComponentSeverities,
		            mongodbLogMaxDocumentLength: mongoOptions.mongodbLogMaxDocumentLength
		        };
		    }
		    mongoOptions.mongoLoggerOptions = mongo_logger_1.MongoLogger.resolveOptions(loggerEnvOptions, loggerClientOptions);
		    mongoOptions.metadata = (0, client_metadata_1.makeClientMetadata)(mongoOptions);
		    mongoOptions.extendedMetadata = (0, client_metadata_1.addContainerMetadata)(mongoOptions.metadata).then(undefined, utils_1.squashError); // rejections will be handled later
		    return mongoOptions;
		}
		/**
		 * #### Throws if LB mode is true:
		 * - hosts contains more than one host
		 * - there is a replicaSet name set
		 * - directConnection is set
		 * - if srvMaxHosts is used when an srv connection string is passed in
		 *
		 * @throws MongoParseError
		 */
		function validateLoadBalancedOptions(hosts, mongoOptions, isSrv) {
		    if (mongoOptions.loadBalanced) {
		        if (hosts.length > 1) {
		            throw new error_1.MongoParseError(LB_SINGLE_HOST_ERROR);
		        }
		        if (mongoOptions.replicaSet) {
		            throw new error_1.MongoParseError(LB_REPLICA_SET_ERROR);
		        }
		        if (mongoOptions.directConnection) {
		            throw new error_1.MongoParseError(LB_DIRECT_CONNECTION_ERROR);
		        }
		        if (isSrv && mongoOptions.srvMaxHosts > 0) {
		            throw new error_1.MongoParseError('Cannot limit srv hosts with loadBalanced enabled');
		        }
		    }
		    return;
		}
		function setOption(mongoOptions, key, descriptor, values) {
		    const { target, type, transform } = descriptor;
		    const name = target ?? key;
		    switch (type) {
		        case 'boolean':
		            mongoOptions[name] = getBoolean(name, values[0]);
		            break;
		        case 'int':
		            mongoOptions[name] = getIntFromOptions(name, values[0]);
		            break;
		        case 'uint':
		            mongoOptions[name] = getUIntFromOptions(name, values[0]);
		            break;
		        case 'string':
		            if (values[0] == null) {
		                break;
		            }
		            mongoOptions[name] = String(values[0]);
		            break;
		        case 'record':
		            if (!(0, utils_1.isRecord)(values[0])) {
		                throw new error_1.MongoParseError(`${name} must be an object`);
		            }
		            mongoOptions[name] = values[0];
		            break;
		        case 'any':
		            mongoOptions[name] = values[0];
		            break;
		        default: {
		            if (!transform) {
		                throw new error_1.MongoParseError('Descriptors missing a type must define a transform');
		            }
		            const transformValue = transform({ name, options: mongoOptions, values });
		            mongoOptions[name] = transformValue;
		            break;
		        }
		    }
		}
		exports.OPTIONS = {
		    appName: {
		        type: 'string'
		    },
		    auth: {
		        target: 'credentials',
		        transform({ name, options, values: [value] }) {
		            if (!(0, utils_1.isRecord)(value, ['username', 'password'])) {
		                throw new error_1.MongoParseError(`${name} must be an object with 'username' and 'password' properties`);
		            }
		            return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
		                username: value.username,
		                password: value.password
		            });
		        }
		    },
		    authMechanism: {
		        target: 'credentials',
		        transform({ options, values: [value] }) {
		            const mechanisms = Object.values(providers_1.AuthMechanism);
		            const [mechanism] = mechanisms.filter(m => m.match(RegExp(String.raw `\b${value}\b`, 'i')));
		            if (!mechanism) {
		                throw new error_1.MongoParseError(`authMechanism one of ${mechanisms}, got ${value}`);
		            }
		            let source = options.credentials?.source;
		            if (mechanism === providers_1.AuthMechanism.MONGODB_PLAIN ||
		                providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(mechanism)) {
		                // some mechanisms have '$external' as the Auth Source
		                source = '$external';
		            }
		            let password = options.credentials?.password;
		            if (mechanism === providers_1.AuthMechanism.MONGODB_X509 && password === '') {
		                password = undefined;
		            }
		            return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
		                mechanism,
		                source,
		                password
		            });
		        }
		    },
		    // Note that if the authMechanismProperties contain a TOKEN_RESOURCE that has a
		    // comma in it, it MUST be supplied as a MongoClient option instead of in the
		    // connection string.
		    authMechanismProperties: {
		        target: 'credentials',
		        transform({ options, values }) {
		            // We can have a combination of options passed in the URI and options passed
		            // as an object to the MongoClient. So we must transform the string options
		            // as well as merge them together with a potentially provided object.
		            let mechanismProperties = Object.create(null);
		            for (const optionValue of values) {
		                if (typeof optionValue === 'string') {
		                    for (const [key, value] of entriesFromString(optionValue)) {
		                        try {
		                            mechanismProperties[key] = getBoolean(key, value);
		                        }
		                        catch {
		                            mechanismProperties[key] = value;
		                        }
		                    }
		                }
		                else {
		                    if (!(0, utils_1.isRecord)(optionValue)) {
		                        throw new error_1.MongoParseError('AuthMechanismProperties must be an object');
		                    }
		                    mechanismProperties = { ...optionValue };
		                }
		            }
		            return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
		                mechanismProperties
		            });
		        }
		    },
		    authSource: {
		        target: 'credentials',
		        transform({ options, values: [value] }) {
		            const source = String(value);
		            return mongo_credentials_1.MongoCredentials.merge(options.credentials, { source });
		        }
		    },
		    autoEncryption: {
		        type: 'record'
		    },
		    autoSelectFamily: {
		        type: 'boolean',
		        default: true
		    },
		    autoSelectFamilyAttemptTimeout: {
		        type: 'uint'
		    },
		    bsonRegExp: {
		        type: 'boolean'
		    },
		    serverApi: {
		        target: 'serverApi',
		        transform({ values: [version] }) {
		            const serverApiToValidate = typeof version === 'string' ? { version } : version;
		            const versionToValidate = serverApiToValidate && serverApiToValidate.version;
		            if (!versionToValidate) {
		                throw new error_1.MongoParseError(`Invalid \`serverApi\` property; must specify a version from the following enum: ["${Object.values(mongo_client_1.ServerApiVersion).join('", "')}"]`);
		            }
		            if (!Object.values(mongo_client_1.ServerApiVersion).some(v => v === versionToValidate)) {
		                throw new error_1.MongoParseError(`Invalid server API version=${versionToValidate}; must be in the following enum: ["${Object.values(mongo_client_1.ServerApiVersion).join('", "')}"]`);
		            }
		            return serverApiToValidate;
		        }
		    },
		    checkKeys: {
		        type: 'boolean'
		    },
		    compressors: {
		        default: 'none',
		        target: 'compressors',
		        transform({ values }) {
		            const compressionList = new Set();
		            for (const compVal of values) {
		                const compValArray = typeof compVal === 'string' ? compVal.split(',') : compVal;
		                if (!Array.isArray(compValArray)) {
		                    throw new error_1.MongoInvalidArgumentError('compressors must be an array or a comma-delimited list of strings');
		                }
		                for (const c of compValArray) {
		                    if (Object.keys(compression_1.Compressor).includes(String(c))) {
		                        compressionList.add(String(c));
		                    }
		                    else {
		                        throw new error_1.MongoInvalidArgumentError(`${c} is not a valid compression mechanism. Must be one of: ${Object.keys(compression_1.Compressor)}.`);
		                    }
		                }
		            }
		            return [...compressionList];
		        }
		    },
		    connectTimeoutMS: {
		        default: 30000,
		        type: 'uint'
		    },
		    dbName: {
		        type: 'string'
		    },
		    directConnection: {
		        default: false,
		        type: 'boolean'
		    },
		    driverInfo: {
		        default: {},
		        type: 'record'
		    },
		    enableUtf8Validation: { type: 'boolean', default: true },
		    family: {
		        transform({ name, values: [value] }) {
		            const transformValue = getIntFromOptions(name, value);
		            if (transformValue === 4 || transformValue === 6) {
		                return transformValue;
		            }
		            throw new error_1.MongoParseError(`Option 'family' must be 4 or 6 got ${transformValue}.`);
		        }
		    },
		    fieldsAsRaw: {
		        type: 'record'
		    },
		    forceServerObjectId: {
		        default: false,
		        type: 'boolean'
		    },
		    fsync: {
		        deprecated: 'Please use journal instead',
		        target: 'writeConcern',
		        transform({ name, options, values: [value] }) {
		            const wc = write_concern_1.WriteConcern.fromOptions({
		                writeConcern: {
		                    ...options.writeConcern,
		                    fsync: getBoolean(name, value)
		                }
		            });
		            if (!wc)
		                throw new error_1.MongoParseError(`Unable to make a writeConcern from fsync=${value}`);
		            return wc;
		        }
		    },
		    heartbeatFrequencyMS: {
		        default: 10000,
		        type: 'uint'
		    },
		    ignoreUndefined: {
		        type: 'boolean'
		    },
		    j: {
		        deprecated: 'Please use journal instead',
		        target: 'writeConcern',
		        transform({ name, options, values: [value] }) {
		            const wc = write_concern_1.WriteConcern.fromOptions({
		                writeConcern: {
		                    ...options.writeConcern,
		                    journal: getBoolean(name, value)
		                }
		            });
		            if (!wc)
		                throw new error_1.MongoParseError(`Unable to make a writeConcern from journal=${value}`);
		            return wc;
		        }
		    },
		    journal: {
		        target: 'writeConcern',
		        transform({ name, options, values: [value] }) {
		            const wc = write_concern_1.WriteConcern.fromOptions({
		                writeConcern: {
		                    ...options.writeConcern,
		                    journal: getBoolean(name, value)
		                }
		            });
		            if (!wc)
		                throw new error_1.MongoParseError(`Unable to make a writeConcern from journal=${value}`);
		            return wc;
		        }
		    },
		    loadBalanced: {
		        default: false,
		        type: 'boolean'
		    },
		    localThresholdMS: {
		        default: 15,
		        type: 'uint'
		    },
		    maxConnecting: {
		        default: 2,
		        transform({ name, values: [value] }) {
		            const maxConnecting = getUIntFromOptions(name, value);
		            if (maxConnecting === 0) {
		                throw new error_1.MongoInvalidArgumentError('maxConnecting must be > 0 if specified');
		            }
		            return maxConnecting;
		        }
		    },
		    maxIdleTimeMS: {
		        default: 0,
		        type: 'uint'
		    },
		    maxPoolSize: {
		        default: 100,
		        type: 'uint'
		    },
		    maxStalenessSeconds: {
		        target: 'readPreference',
		        transform({ name, options, values: [value] }) {
		            const maxStalenessSeconds = getUIntFromOptions(name, value);
		            if (options.readPreference) {
		                return read_preference_1.ReadPreference.fromOptions({
		                    readPreference: { ...options.readPreference, maxStalenessSeconds }
		                });
		            }
		            else {
		                return new read_preference_1.ReadPreference('secondary', undefined, { maxStalenessSeconds });
		            }
		        }
		    },
		    minInternalBufferSize: {
		        type: 'uint'
		    },
		    minPoolSize: {
		        default: 0,
		        type: 'uint'
		    },
		    minHeartbeatFrequencyMS: {
		        default: 500,
		        type: 'uint'
		    },
		    monitorCommands: {
		        default: false,
		        type: 'boolean'
		    },
		    name: {
		        target: 'driverInfo',
		        transform({ values: [value], options }) {
		            return { ...options.driverInfo, name: String(value) };
		        }
		    },
		    noDelay: {
		        default: true,
		        type: 'boolean'
		    },
		    pkFactory: {
		        default: utils_1.DEFAULT_PK_FACTORY,
		        transform({ values: [value] }) {
		            if ((0, utils_1.isRecord)(value, ['createPk']) && typeof value.createPk === 'function') {
		                return value;
		            }
		            throw new error_1.MongoParseError(`Option pkFactory must be an object with a createPk function, got ${value}`);
		        }
		    },
		    promoteBuffers: {
		        type: 'boolean'
		    },
		    promoteLongs: {
		        type: 'boolean'
		    },
		    promoteValues: {
		        type: 'boolean'
		    },
		    useBigInt64: {
		        type: 'boolean'
		    },
		    proxyHost: {
		        type: 'string'
		    },
		    proxyPassword: {
		        type: 'string'
		    },
		    proxyPort: {
		        type: 'uint'
		    },
		    proxyUsername: {
		        type: 'string'
		    },
		    raw: {
		        default: false,
		        type: 'boolean'
		    },
		    readConcern: {
		        transform({ values: [value], options }) {
		            if (value instanceof read_concern_1.ReadConcern || (0, utils_1.isRecord)(value, ['level'])) {
		                return read_concern_1.ReadConcern.fromOptions({ ...options.readConcern, ...value });
		            }
		            throw new error_1.MongoParseError(`ReadConcern must be an object, got ${JSON.stringify(value)}`);
		        }
		    },
		    readConcernLevel: {
		        target: 'readConcern',
		        transform({ values: [level], options }) {
		            return read_concern_1.ReadConcern.fromOptions({
		                ...options.readConcern,
		                level: level
		            });
		        }
		    },
		    readPreference: {
		        default: read_preference_1.ReadPreference.primary,
		        transform({ values: [value], options }) {
		            if (value instanceof read_preference_1.ReadPreference) {
		                return read_preference_1.ReadPreference.fromOptions({
		                    readPreference: { ...options.readPreference, ...value },
		                    ...value
		                });
		            }
		            if ((0, utils_1.isRecord)(value, ['mode'])) {
		                const rp = read_preference_1.ReadPreference.fromOptions({
		                    readPreference: { ...options.readPreference, ...value },
		                    ...value
		                });
		                if (rp)
		                    return rp;
		                else
		                    throw new error_1.MongoParseError(`Cannot make read preference from ${JSON.stringify(value)}`);
		            }
		            if (typeof value === 'string') {
		                const rpOpts = {
		                    hedge: options.readPreference?.hedge,
		                    maxStalenessSeconds: options.readPreference?.maxStalenessSeconds
		                };
		                return new read_preference_1.ReadPreference(value, options.readPreference?.tags, rpOpts);
		            }
		            throw new error_1.MongoParseError(`Unknown ReadPreference value: ${value}`);
		        }
		    },
		    readPreferenceTags: {
		        target: 'readPreference',
		        transform({ values, options }) {
		            const tags = Array.isArray(values[0])
		                ? values[0]
		                : values;
		            const readPreferenceTags = [];
		            for (const tag of tags) {
		                const readPreferenceTag = Object.create(null);
		                if (typeof tag === 'string') {
		                    for (const [k, v] of entriesFromString(tag)) {
		                        readPreferenceTag[k] = v;
		                    }
		                }
		                if ((0, utils_1.isRecord)(tag)) {
		                    for (const [k, v] of Object.entries(tag)) {
		                        readPreferenceTag[k] = v;
		                    }
		                }
		                readPreferenceTags.push(readPreferenceTag);
		            }
		            return read_preference_1.ReadPreference.fromOptions({
		                readPreference: options.readPreference,
		                readPreferenceTags
		            });
		        }
		    },
		    replicaSet: {
		        type: 'string'
		    },
		    retryReads: {
		        default: true,
		        type: 'boolean'
		    },
		    retryWrites: {
		        default: true,
		        type: 'boolean'
		    },
		    serializeFunctions: {
		        type: 'boolean'
		    },
		    serverMonitoringMode: {
		        default: 'auto',
		        transform({ values: [value] }) {
		            if (!Object.values(monitor_1.ServerMonitoringMode).includes(value)) {
		                throw new error_1.MongoParseError('serverMonitoringMode must be one of `auto`, `poll`, or `stream`');
		            }
		            return value;
		        }
		    },
		    serverSelectionTimeoutMS: {
		        default: 30000,
		        type: 'uint'
		    },
		    servername: {
		        type: 'string'
		    },
		    socketTimeoutMS: {
		        default: 0,
		        type: 'uint'
		    },
		    srvMaxHosts: {
		        type: 'uint',
		        default: 0
		    },
		    srvServiceName: {
		        type: 'string',
		        default: 'mongodb'
		    },
		    ssl: {
		        target: 'tls',
		        type: 'boolean'
		    },
		    timeoutMS: {
		        type: 'uint'
		    },
		    tls: {
		        type: 'boolean'
		    },
		    tlsAllowInvalidCertificates: {
		        target: 'rejectUnauthorized',
		        transform({ name, values: [value] }) {
		            // allowInvalidCertificates is the inverse of rejectUnauthorized
		            return !getBoolean(name, value);
		        }
		    },
		    tlsAllowInvalidHostnames: {
		        target: 'checkServerIdentity',
		        transform({ name, values: [value] }) {
		            // tlsAllowInvalidHostnames means setting the checkServerIdentity function to a noop
		            return getBoolean(name, value) ? () => undefined : undefined;
		        }
		    },
		    tlsCAFile: {
		        type: 'string'
		    },
		    tlsCRLFile: {
		        type: 'string'
		    },
		    tlsCertificateKeyFile: {
		        type: 'string'
		    },
		    tlsCertificateKeyFilePassword: {
		        target: 'passphrase',
		        type: 'any'
		    },
		    tlsInsecure: {
		        transform({ name, options, values: [value] }) {
		            const tlsInsecure = getBoolean(name, value);
		            if (tlsInsecure) {
		                options.checkServerIdentity = () => undefined;
		                options.rejectUnauthorized = false;
		            }
		            else {
		                options.checkServerIdentity = options.tlsAllowInvalidHostnames
		                    ? () => undefined
		                    : undefined;
		                options.rejectUnauthorized = options.tlsAllowInvalidCertificates ? false : true;
		            }
		            return tlsInsecure;
		        }
		    },
		    w: {
		        target: 'writeConcern',
		        transform({ values: [value], options }) {
		            return write_concern_1.WriteConcern.fromOptions({ writeConcern: { ...options.writeConcern, w: value } });
		        }
		    },
		    waitQueueTimeoutMS: {
		        default: 0,
		        type: 'uint'
		    },
		    writeConcern: {
		        target: 'writeConcern',
		        transform({ values: [value], options }) {
		            if ((0, utils_1.isRecord)(value) || value instanceof write_concern_1.WriteConcern) {
		                return write_concern_1.WriteConcern.fromOptions({
		                    writeConcern: {
		                        ...options.writeConcern,
		                        ...value
		                    }
		                });
		            }
		            else if (value === 'majority' || typeof value === 'number') {
		                return write_concern_1.WriteConcern.fromOptions({
		                    writeConcern: {
		                        ...options.writeConcern,
		                        w: value
		                    }
		                });
		            }
		            throw new error_1.MongoParseError(`Invalid WriteConcern cannot parse: ${JSON.stringify(value)}`);
		        }
		    },
		    wtimeout: {
		        deprecated: 'Please use wtimeoutMS instead',
		        target: 'writeConcern',
		        transform({ values: [value], options }) {
		            const wc = write_concern_1.WriteConcern.fromOptions({
		                writeConcern: {
		                    ...options.writeConcern,
		                    wtimeout: getUIntFromOptions('wtimeout', value)
		                }
		            });
		            if (wc)
		                return wc;
		            throw new error_1.MongoParseError(`Cannot make WriteConcern from wtimeout`);
		        }
		    },
		    wtimeoutMS: {
		        target: 'writeConcern',
		        transform({ values: [value], options }) {
		            const wc = write_concern_1.WriteConcern.fromOptions({
		                writeConcern: {
		                    ...options.writeConcern,
		                    wtimeoutMS: getUIntFromOptions('wtimeoutMS', value)
		                }
		            });
		            if (wc)
		                return wc;
		            throw new error_1.MongoParseError(`Cannot make WriteConcern from wtimeout`);
		        }
		    },
		    zlibCompressionLevel: {
		        default: 0,
		        type: 'int'
		    },
		    // Custom types for modifying core behavior
		    connectionType: { type: 'any' },
		    srvPoller: { type: 'any' },
		    // Accepted Node.js Options
		    allowPartialTrustChain: { type: 'any' },
		    minDHSize: { type: 'any' },
		    pskCallback: { type: 'any' },
		    secureContext: { type: 'any' },
		    enableTrace: { type: 'any' },
		    requestCert: { type: 'any' },
		    rejectUnauthorized: { type: 'any' },
		    checkServerIdentity: { type: 'any' },
		    ALPNProtocols: { type: 'any' },
		    SNICallback: { type: 'any' },
		    session: { type: 'any' },
		    requestOCSP: { type: 'any' },
		    localAddress: { type: 'any' },
		    localPort: { type: 'any' },
		    hints: { type: 'any' },
		    lookup: { type: 'any' },
		    ca: { type: 'any' },
		    cert: { type: 'any' },
		    ciphers: { type: 'any' },
		    crl: { type: 'any' },
		    ecdhCurve: { type: 'any' },
		    key: { type: 'any' },
		    passphrase: { type: 'any' },
		    pfx: { type: 'any' },
		    secureProtocol: { type: 'any' },
		    index: { type: 'any' },
		    // Legacy options from v3 era
		    useNewUrlParser: {
		        type: 'boolean',
		        deprecated: 'useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version'
		    },
		    useUnifiedTopology: {
		        type: 'boolean',
		        deprecated: 'useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version'
		    },
		    // MongoLogger
		    /**
		     * @internal
		     * TODO: NODE-5671 - remove internal flag
		     */
		    mongodbLogPath: {
		        transform({ values: [value] }) {
		            if (!((typeof value === 'string' && ['stderr', 'stdout'].includes(value)) ||
		                (value &&
		                    typeof value === 'object' &&
		                    'write' in value &&
		                    typeof value.write === 'function'))) {
		                throw new error_1.MongoAPIError(`Option 'mongodbLogPath' must be of type 'stderr' | 'stdout' | MongoDBLogWritable`);
		            }
		            return value;
		        }
		    },
		    /**
		     * @internal
		     * TODO: NODE-5671 - remove internal flag
		     */
		    mongodbLogComponentSeverities: {
		        transform({ values: [value] }) {
		            if (typeof value !== 'object' || !value) {
		                throw new error_1.MongoAPIError(`Option 'mongodbLogComponentSeverities' must be a non-null object`);
		            }
		            for (const [k, v] of Object.entries(value)) {
		                if (typeof v !== 'string' || typeof k !== 'string') {
		                    throw new error_1.MongoAPIError(`User input for option 'mongodbLogComponentSeverities' object cannot include a non-string key or value`);
		                }
		                if (!Object.values(mongo_logger_1.MongoLoggableComponent).some(val => val === k) && k !== 'default') {
		                    throw new error_1.MongoAPIError(`User input for option 'mongodbLogComponentSeverities' contains invalid key: ${k}`);
		                }
		                if (!Object.values(mongo_logger_1.SeverityLevel).some(val => val === v)) {
		                    throw new error_1.MongoAPIError(`Option 'mongodbLogComponentSeverities' does not support ${v} as a value for ${k}`);
		                }
		            }
		            return value;
		        }
		    },
		    /**
		     * @internal
		     * TODO: NODE-5671 - remove internal flag
		     */
		    mongodbLogMaxDocumentLength: { type: 'uint' }
		};
		exports.DEFAULT_OPTIONS = new CaseInsensitiveMap(Object.entries(exports.OPTIONS)
		    .filter(([, descriptor]) => descriptor.default != null)
		    .map(([k, d]) => [k, d.default]));
		/**
		 * Set of permitted feature flags
		 * @internal
		 */
		exports.FEATURE_FLAGS = new Set([
		    Symbol.for('@@mdb.skipPingOnConnect'),
		    Symbol.for('@@mdb.enableMongoLogger'),
		    Symbol.for('@@mdb.internalLoggerConfig')
		]);
		
	} (connection_string));
	return connection_string;
}

var db = {};

var list_collections_cursor = {};

var list_collections = {};

var hasRequiredList_collections;

function requireList_collections () {
	if (hasRequiredList_collections) return list_collections;
	hasRequiredList_collections = 1;
	Object.defineProperty(list_collections, "__esModule", { value: true });
	list_collections.ListCollectionsOperation = void 0;
	const responses_1 = requireResponses();
	const utils_1 = requireUtils$1();
	const command_1 = requireCommand();
	const operation_1 = requireOperation();
	/** @internal */
	class ListCollectionsOperation extends command_1.CommandOperation {
	    constructor(db, filter, options) {
	        super(db, options);
	        this.options = { ...options };
	        delete this.options.writeConcern;
	        this.db = db;
	        this.filter = filter;
	        this.nameOnly = !!this.options.nameOnly;
	        this.authorizedCollections = !!this.options.authorizedCollections;
	        if (typeof this.options.batchSize === 'number') {
	            this.batchSize = this.options.batchSize;
	        }
	    }
	    get commandName() {
	        return 'listCollections';
	    }
	    async execute(server, session) {
	        return await super.executeCommand(server, session, this.generateCommand((0, utils_1.maxWireVersion)(server)), responses_1.CursorResponse);
	    }
	    /* This is here for the purpose of unit testing the final command that gets sent. */
	    generateCommand(wireVersion) {
	        const command = {
	            listCollections: 1,
	            filter: this.filter,
	            cursor: this.batchSize ? { batchSize: this.batchSize } : {},
	            nameOnly: this.nameOnly,
	            authorizedCollections: this.authorizedCollections
	        };
	        // we check for undefined specifically here to allow falsy values
	        // eslint-disable-next-line no-restricted-syntax
	        if (wireVersion >= 9 && this.options.comment !== undefined) {
	            command.comment = this.options.comment;
	        }
	        return command;
	    }
	}
	list_collections.ListCollectionsOperation = ListCollectionsOperation;
	(0, operation_1.defineAspects)(ListCollectionsOperation, [
	    operation_1.Aspect.READ_OPERATION,
	    operation_1.Aspect.RETRYABLE,
	    operation_1.Aspect.CURSOR_CREATING
	]);
	
	return list_collections;
}

var hasRequiredList_collections_cursor;

function requireList_collections_cursor () {
	if (hasRequiredList_collections_cursor) return list_collections_cursor;
	hasRequiredList_collections_cursor = 1;
	Object.defineProperty(list_collections_cursor, "__esModule", { value: true });
	list_collections_cursor.ListCollectionsCursor = void 0;
	const execute_operation_1 = requireExecute_operation();
	const list_collections_1 = requireList_collections();
	const abstract_cursor_1 = requireAbstract_cursor();
	/** @public */
	class ListCollectionsCursor extends abstract_cursor_1.AbstractCursor {
	    constructor(db, filter, options) {
	        super(db.client, db.s.namespace, options);
	        this.parent = db;
	        this.filter = filter;
	        this.options = options;
	    }
	    clone() {
	        return new ListCollectionsCursor(this.parent, this.filter, {
	            ...this.options,
	            ...this.cursorOptions
	        });
	    }
	    /** @internal */
	    async _initialize(session) {
	        const operation = new list_collections_1.ListCollectionsOperation(this.parent, this.filter, {
	            ...this.cursorOptions,
	            ...this.options,
	            session
	        });
	        const response = await (0, execute_operation_1.executeOperation)(this.parent.client, operation);
	        return { server: operation.server, session, response };
	    }
	}
	list_collections_cursor.ListCollectionsCursor = ListCollectionsCursor;
	
	return list_collections_cursor;
}

var run_command_cursor = {};

var hasRequiredRun_command_cursor;

function requireRun_command_cursor () {
	if (hasRequiredRun_command_cursor) return run_command_cursor;
	hasRequiredRun_command_cursor = 1;
	Object.defineProperty(run_command_cursor, "__esModule", { value: true });
	run_command_cursor.RunCommandCursor = void 0;
	const responses_1 = requireResponses();
	const error_1 = requireError();
	const execute_operation_1 = requireExecute_operation();
	const get_more_1 = requireGet_more();
	const run_command_1 = requireRun_command();
	const utils_1 = requireUtils$1();
	const abstract_cursor_1 = requireAbstract_cursor();
	/** @public */
	class RunCommandCursor extends abstract_cursor_1.AbstractCursor {
	    /**
	     * Controls the `getMore.comment` field
	     * @param comment - any BSON value
	     */
	    setComment(comment) {
	        this.getMoreOptions.comment = comment;
	        return this;
	    }
	    /**
	     * Controls the `getMore.maxTimeMS` field. Only valid when cursor is tailable await
	     * @param maxTimeMS - the number of milliseconds to wait for new data
	     */
	    setMaxTimeMS(maxTimeMS) {
	        this.getMoreOptions.maxAwaitTimeMS = maxTimeMS;
	        return this;
	    }
	    /**
	     * Controls the `getMore.batchSize` field
	     * @param maxTimeMS - the number documents to return in the `nextBatch`
	     */
	    setBatchSize(batchSize) {
	        this.getMoreOptions.batchSize = batchSize;
	        return this;
	    }
	    /** Unsupported for RunCommandCursor */
	    clone() {
	        throw new error_1.MongoAPIError('Clone not supported, create a new cursor with db.runCursorCommand');
	    }
	    /** Unsupported for RunCommandCursor: readConcern must be configured directly on command document */
	    withReadConcern(_) {
	        throw new error_1.MongoAPIError('RunCommandCursor does not support readConcern it must be attached to the command being run');
	    }
	    /** Unsupported for RunCommandCursor: various cursor flags must be configured directly on command document */
	    addCursorFlag(_, __) {
	        throw new error_1.MongoAPIError('RunCommandCursor does not support cursor flags, they must be attached to the command being run');
	    }
	    /** Unsupported for RunCommandCursor: maxTimeMS must be configured directly on command document */
	    maxTimeMS(_) {
	        throw new error_1.MongoAPIError('maxTimeMS must be configured on the command document directly, to configure getMore.maxTimeMS use cursor.setMaxTimeMS()');
	    }
	    /** Unsupported for RunCommandCursor: batchSize must be configured directly on command document */
	    batchSize(_) {
	        throw new error_1.MongoAPIError('batchSize must be configured on the command document directly, to configure getMore.batchSize use cursor.setBatchSize()');
	    }
	    /** @internal */
	    constructor(db, command, options = {}) {
	        super(db.client, (0, utils_1.ns)(db.namespace), options);
	        this.getMoreOptions = {};
	        this.db = db;
	        this.command = Object.freeze({ ...command });
	    }
	    /** @internal */
	    async _initialize(session) {
	        const operation = new run_command_1.RunCommandOperation(this.db, this.command, {
	            ...this.cursorOptions,
	            session: session,
	            readPreference: this.cursorOptions.readPreference,
	            responseType: responses_1.CursorResponse
	        });
	        const response = await (0, execute_operation_1.executeOperation)(this.client, operation);
	        return {
	            server: operation.server,
	            session,
	            response
	        };
	    }
	    /** @internal */
	    async getMore(_batchSize) {
	        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	        const getMoreOperation = new get_more_1.GetMoreOperation(this.namespace, this.id, this.server, {
	            ...this.cursorOptions,
	            session: this.session,
	            ...this.getMoreOptions
	        });
	        return await (0, execute_operation_1.executeOperation)(this.client, getMoreOperation);
	    }
	}
	run_command_cursor.RunCommandCursor = RunCommandCursor;
	
	return run_command_cursor;
}

var collections = {};

var hasRequiredCollections;

function requireCollections () {
	if (hasRequiredCollections) return collections;
	hasRequiredCollections = 1;
	Object.defineProperty(collections, "__esModule", { value: true });
	collections.CollectionsOperation = void 0;
	const collection_1 = requireCollection();
	const operation_1 = requireOperation();
	/** @internal */
	class CollectionsOperation extends operation_1.AbstractOperation {
	    constructor(db, options) {
	        super(options);
	        this.options = options;
	        this.db = db;
	    }
	    get commandName() {
	        return 'listCollections';
	    }
	    async execute(server, session) {
	        // Let's get the collection names
	        const documents = await this.db
	            .listCollections({}, { ...this.options, nameOnly: true, readPreference: this.readPreference, session })
	            .toArray();
	        const collections = [];
	        for (const { name } of documents) {
	            if (!name.includes('$')) {
	                // Filter collections removing any illegal ones
	                collections.push(new collection_1.Collection(this.db, name, this.db.s.options));
	            }
	        }
	        // Return the collection objects
	        return collections;
	    }
	}
	collections.CollectionsOperation = CollectionsOperation;
	
	return collections;
}

var create_collection = {};

var indexes = {};

var hasRequiredIndexes;

function requireIndexes () {
	if (hasRequiredIndexes) return indexes;
	hasRequiredIndexes = 1;
	Object.defineProperty(indexes, "__esModule", { value: true });
	indexes.ListIndexesOperation = indexes.DropIndexOperation = indexes.CreateIndexesOperation = void 0;
	const responses_1 = requireResponses();
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	const command_1 = requireCommand();
	const operation_1 = requireOperation();
	const VALID_INDEX_OPTIONS = new Set([
	    'background',
	    'unique',
	    'name',
	    'partialFilterExpression',
	    'sparse',
	    'hidden',
	    'expireAfterSeconds',
	    'storageEngine',
	    'collation',
	    'version',
	    // text indexes
	    'weights',
	    'default_language',
	    'language_override',
	    'textIndexVersion',
	    // 2d-sphere indexes
	    '2dsphereIndexVersion',
	    // 2d indexes
	    'bits',
	    'min',
	    'max',
	    // geoHaystack Indexes
	    'bucketSize',
	    // wildcard indexes
	    'wildcardProjection'
	]);
	function isIndexDirection(x) {
	    return (typeof x === 'number' || x === '2d' || x === '2dsphere' || x === 'text' || x === 'geoHaystack');
	}
	function isSingleIndexTuple(t) {
	    return Array.isArray(t) && t.length === 2 && isIndexDirection(t[1]);
	}
	/**
	 * Converts an `IndexSpecification`, which can be specified in multiple formats, into a
	 * valid `key` for the createIndexes command.
	 */
	function constructIndexDescriptionMap(indexSpec) {
	    const key = new Map();
	    const indexSpecs = !Array.isArray(indexSpec) || isSingleIndexTuple(indexSpec) ? [indexSpec] : indexSpec;
	    // Iterate through array and handle different types
	    for (const spec of indexSpecs) {
	        if (typeof spec === 'string') {
	            key.set(spec, 1);
	        }
	        else if (Array.isArray(spec)) {
	            key.set(spec[0], spec[1] ?? 1);
	        }
	        else if (spec instanceof Map) {
	            for (const [property, value] of spec) {
	                key.set(property, value);
	            }
	        }
	        else if ((0, utils_1.isObject)(spec)) {
	            for (const [property, value] of Object.entries(spec)) {
	                key.set(property, value);
	            }
	        }
	    }
	    return key;
	}
	/**
	 * Receives an index description and returns a modified index description which has had invalid options removed
	 * from the description and has mapped the `version` option to the `v` option.
	 */
	function resolveIndexDescription(description) {
	    const validProvidedOptions = Object.entries(description).filter(([optionName]) => VALID_INDEX_OPTIONS.has(optionName));
	    return Object.fromEntries(
	    // we support the `version` option, but the `createIndexes` command expects it to be the `v`
	    validProvidedOptions.map(([name, value]) => (name === 'version' ? ['v', value] : [name, value])));
	}
	/** @internal */
	class CreateIndexesOperation extends command_1.CommandOperation {
	    constructor(parent, collectionName, indexes, options) {
	        super(parent, options);
	        this.options = options ?? {};
	        this.collectionName = collectionName;
	        this.indexes = indexes.map((userIndex) => {
	            // Ensure the key is a Map to preserve index key ordering
	            const key = userIndex.key instanceof Map ? userIndex.key : new Map(Object.entries(userIndex.key));
	            const name = userIndex.name ?? Array.from(key).flat().join('_');
	            const validIndexOptions = resolveIndexDescription(userIndex);
	            return {
	                ...validIndexOptions,
	                name,
	                key
	            };
	        });
	    }
	    static fromIndexDescriptionArray(parent, collectionName, indexes, options) {
	        return new CreateIndexesOperation(parent, collectionName, indexes, options);
	    }
	    static fromIndexSpecification(parent, collectionName, indexSpec, options = {}) {
	        const key = constructIndexDescriptionMap(indexSpec);
	        const description = { ...options, key };
	        return new CreateIndexesOperation(parent, collectionName, [description], options);
	    }
	    get commandName() {
	        return 'createIndexes';
	    }
	    async execute(server, session) {
	        const options = this.options;
	        const indexes = this.indexes;
	        const serverWireVersion = (0, utils_1.maxWireVersion)(server);
	        const cmd = { createIndexes: this.collectionName, indexes };
	        if (options.commitQuorum != null) {
	            if (serverWireVersion < 9) {
	                throw new error_1.MongoCompatibilityError('Option `commitQuorum` for `createIndexes` not supported on servers < 4.4');
	            }
	            cmd.commitQuorum = options.commitQuorum;
	        }
	        // collation is set on each index, it should not be defined at the root
	        this.options.collation = undefined;
	        await super.executeCommand(server, session, cmd);
	        const indexNames = indexes.map(index => index.name || '');
	        return indexNames;
	    }
	}
	indexes.CreateIndexesOperation = CreateIndexesOperation;
	/** @internal */
	class DropIndexOperation extends command_1.CommandOperation {
	    constructor(collection, indexName, options) {
	        super(collection, options);
	        this.options = options ?? {};
	        this.collection = collection;
	        this.indexName = indexName;
	    }
	    get commandName() {
	        return 'dropIndexes';
	    }
	    async execute(server, session) {
	        const cmd = { dropIndexes: this.collection.collectionName, index: this.indexName };
	        return await super.executeCommand(server, session, cmd);
	    }
	}
	indexes.DropIndexOperation = DropIndexOperation;
	/** @internal */
	class ListIndexesOperation extends command_1.CommandOperation {
	    constructor(collection, options) {
	        super(collection, options);
	        this.options = { ...options };
	        delete this.options.writeConcern;
	        this.collectionNamespace = collection.s.namespace;
	    }
	    get commandName() {
	        return 'listIndexes';
	    }
	    async execute(server, session) {
	        const serverWireVersion = (0, utils_1.maxWireVersion)(server);
	        const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};
	        const command = { listIndexes: this.collectionNamespace.collection, cursor };
	        // we check for undefined specifically here to allow falsy values
	        // eslint-disable-next-line no-restricted-syntax
	        if (serverWireVersion >= 9 && this.options.comment !== undefined) {
	            command.comment = this.options.comment;
	        }
	        return await super.executeCommand(server, session, command, responses_1.CursorResponse);
	    }
	}
	indexes.ListIndexesOperation = ListIndexesOperation;
	(0, operation_1.defineAspects)(ListIndexesOperation, [
	    operation_1.Aspect.READ_OPERATION,
	    operation_1.Aspect.RETRYABLE,
	    operation_1.Aspect.CURSOR_CREATING
	]);
	(0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);
	(0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
	
	return indexes;
}

var hasRequiredCreate_collection;

function requireCreate_collection () {
	if (hasRequiredCreate_collection) return create_collection;
	hasRequiredCreate_collection = 1;
	Object.defineProperty(create_collection, "__esModule", { value: true });
	create_collection.CreateCollectionOperation = void 0;
	const constants_1 = requireConstants$1();
	const collection_1 = requireCollection();
	const error_1 = requireError();
	const command_1 = requireCommand();
	const indexes_1 = requireIndexes();
	const operation_1 = requireOperation();
	const ILLEGAL_COMMAND_FIELDS = new Set([
	    'w',
	    'wtimeout',
	    'j',
	    'fsync',
	    'autoIndexId',
	    'pkFactory',
	    'raw',
	    'readPreference',
	    'session',
	    'readConcern',
	    'writeConcern',
	    'raw',
	    'fieldsAsRaw',
	    'useBigInt64',
	    'promoteLongs',
	    'promoteValues',
	    'promoteBuffers',
	    'bsonRegExp',
	    'serializeFunctions',
	    'ignoreUndefined',
	    'enableUtf8Validation'
	]);
	/* @internal */
	const INVALID_QE_VERSION = 'Driver support of Queryable Encryption is incompatible with server. Upgrade server to use Queryable Encryption.';
	/** @internal */
	class CreateCollectionOperation extends command_1.CommandOperation {
	    constructor(db, name, options = {}) {
	        super(db, options);
	        this.options = options;
	        this.db = db;
	        this.name = name;
	    }
	    get commandName() {
	        return 'create';
	    }
	    async execute(server, session) {
	        const db = this.db;
	        const name = this.name;
	        const options = this.options;
	        const encryptedFields = options.encryptedFields ??
	            db.client.options.autoEncryption?.encryptedFieldsMap?.[`${db.databaseName}.${name}`];
	        if (encryptedFields) {
	            // Creating a QE collection required min server of 7.0.0
	            // TODO(NODE-5353): Get wire version information from connection.
	            if (!server.loadBalanced &&
	                server.description.maxWireVersion < constants_1.MIN_SUPPORTED_QE_WIRE_VERSION) {
	                throw new error_1.MongoCompatibilityError(`${INVALID_QE_VERSION} The minimum server version required is ${constants_1.MIN_SUPPORTED_QE_SERVER_VERSION}`);
	            }
	            // Create auxilliary collections for queryable encryption support.
	            const escCollection = encryptedFields.escCollection ?? `enxcol_.${name}.esc`;
	            const ecocCollection = encryptedFields.ecocCollection ?? `enxcol_.${name}.ecoc`;
	            for (const collectionName of [escCollection, ecocCollection]) {
	                const createOp = new CreateCollectionOperation(db, collectionName, {
	                    clusteredIndex: {
	                        key: { _id: 1 },
	                        unique: true
	                    }
	                });
	                await createOp.executeWithoutEncryptedFieldsCheck(server, session);
	            }
	            if (!options.encryptedFields) {
	                this.options = { ...this.options, encryptedFields };
	            }
	        }
	        const coll = await this.executeWithoutEncryptedFieldsCheck(server, session);
	        if (encryptedFields) {
	            // Create the required index for queryable encryption support.
	            const createIndexOp = indexes_1.CreateIndexesOperation.fromIndexSpecification(db, name, { __safeContent__: 1 }, {});
	            await createIndexOp.execute(server, session);
	        }
	        return coll;
	    }
	    async executeWithoutEncryptedFieldsCheck(server, session) {
	        const db = this.db;
	        const name = this.name;
	        const options = this.options;
	        const cmd = { create: name };
	        for (const n in options) {
	            if (options[n] != null &&
	                typeof options[n] !== 'function' &&
	                !ILLEGAL_COMMAND_FIELDS.has(n)) {
	                cmd[n] = options[n];
	            }
	        }
	        // otherwise just execute the command
	        await super.executeCommand(server, session, cmd);
	        return new collection_1.Collection(db, name, options);
	    }
	}
	create_collection.CreateCollectionOperation = CreateCollectionOperation;
	(0, operation_1.defineAspects)(CreateCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
	
	return create_collection;
}

var drop$1 = {};

var hasRequiredDrop$1;

function requireDrop$1 () {
	if (hasRequiredDrop$1) return drop$1;
	hasRequiredDrop$1 = 1;
	Object.defineProperty(drop$1, "__esModule", { value: true });
	drop$1.DropDatabaseOperation = drop$1.DropCollectionOperation = void 0;
	const error_1 = requireError();
	const command_1 = requireCommand();
	const operation_1 = requireOperation();
	/** @internal */
	class DropCollectionOperation extends command_1.CommandOperation {
	    constructor(db, name, options = {}) {
	        super(db, options);
	        this.db = db;
	        this.options = options;
	        this.name = name;
	    }
	    get commandName() {
	        return 'drop';
	    }
	    async execute(server, session) {
	        const db = this.db;
	        const options = this.options;
	        const name = this.name;
	        const encryptedFieldsMap = db.client.options.autoEncryption?.encryptedFieldsMap;
	        let encryptedFields = options.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];
	        if (!encryptedFields && encryptedFieldsMap) {
	            // If the MongoClient was configured with an encryptedFieldsMap,
	            // and no encryptedFields config was available in it or explicitly
	            // passed as an argument, the spec tells us to look one up using
	            // listCollections().
	            const listCollectionsResult = await db
	                .listCollections({ name }, { nameOnly: false })
	                .toArray();
	            encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;
	        }
	        if (encryptedFields) {
	            const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;
	            const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;
	            for (const collectionName of [escCollection, ecocCollection]) {
	                // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.
	                const dropOp = new DropCollectionOperation(db, collectionName);
	                try {
	                    await dropOp.executeWithoutEncryptedFieldsCheck(server, session);
	                }
	                catch (err) {
	                    if (!(err instanceof error_1.MongoServerError) ||
	                        err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
	                        throw err;
	                    }
	                }
	            }
	        }
	        return await this.executeWithoutEncryptedFieldsCheck(server, session);
	    }
	    async executeWithoutEncryptedFieldsCheck(server, session) {
	        await super.executeCommand(server, session, { drop: this.name });
	        return true;
	    }
	}
	drop$1.DropCollectionOperation = DropCollectionOperation;
	/** @internal */
	class DropDatabaseOperation extends command_1.CommandOperation {
	    constructor(db, options) {
	        super(db, options);
	        this.options = options;
	    }
	    get commandName() {
	        return 'dropDatabase';
	    }
	    async execute(server, session) {
	        await super.executeCommand(server, session, { dropDatabase: 1 });
	        return true;
	    }
	}
	drop$1.DropDatabaseOperation = DropDatabaseOperation;
	(0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
	(0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);
	
	return drop$1;
}

var profiling_level = {};

var hasRequiredProfiling_level;

function requireProfiling_level () {
	if (hasRequiredProfiling_level) return profiling_level;
	hasRequiredProfiling_level = 1;
	Object.defineProperty(profiling_level, "__esModule", { value: true });
	profiling_level.ProfilingLevelOperation = void 0;
	const error_1 = requireError();
	const command_1 = requireCommand();
	/** @internal */
	class ProfilingLevelOperation extends command_1.CommandOperation {
	    constructor(db, options) {
	        super(db, options);
	        this.options = options;
	    }
	    get commandName() {
	        return 'profile';
	    }
	    async execute(server, session) {
	        const doc = await super.executeCommand(server, session, { profile: -1 });
	        if (doc.ok === 1) {
	            const was = doc.was;
	            if (was === 0)
	                return 'off';
	            if (was === 1)
	                return 'slow_only';
	            if (was === 2)
	                return 'all';
	            throw new error_1.MongoUnexpectedServerResponseError(`Illegal profiling level value ${was}`);
	        }
	        else {
	            throw new error_1.MongoUnexpectedServerResponseError('Error with profile command');
	        }
	    }
	}
	profiling_level.ProfilingLevelOperation = ProfilingLevelOperation;
	
	return profiling_level;
}

var rename = {};

var hasRequiredRename;

function requireRename () {
	if (hasRequiredRename) return rename;
	hasRequiredRename = 1;
	Object.defineProperty(rename, "__esModule", { value: true });
	rename.RenameOperation = void 0;
	const collection_1 = requireCollection();
	const utils_1 = requireUtils$1();
	const command_1 = requireCommand();
	const operation_1 = requireOperation();
	/** @internal */
	class RenameOperation extends command_1.CommandOperation {
	    constructor(collection, newName, options) {
	        super(collection, options);
	        this.collection = collection;
	        this.newName = newName;
	        this.options = options;
	        this.ns = new utils_1.MongoDBNamespace('admin', '$cmd');
	    }
	    get commandName() {
	        return 'renameCollection';
	    }
	    async execute(server, session) {
	        // Build the command
	        const renameCollection = this.collection.namespace;
	        const toCollection = this.collection.s.namespace.withCollection(this.newName).toString();
	        const dropTarget = typeof this.options.dropTarget === 'boolean' ? this.options.dropTarget : false;
	        const command = {
	            renameCollection: renameCollection,
	            to: toCollection,
	            dropTarget: dropTarget
	        };
	        await super.executeCommand(server, session, command);
	        return new collection_1.Collection(this.collection.s.db, this.newName, this.collection.s.options);
	    }
	}
	rename.RenameOperation = RenameOperation;
	(0, operation_1.defineAspects)(RenameOperation, [operation_1.Aspect.WRITE_OPERATION]);
	
	return rename;
}

var set_profiling_level = {};

var hasRequiredSet_profiling_level;

function requireSet_profiling_level () {
	if (hasRequiredSet_profiling_level) return set_profiling_level;
	hasRequiredSet_profiling_level = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.SetProfilingLevelOperation = exports.ProfilingLevel = void 0;
		const error_1 = requireError();
		const utils_1 = requireUtils$1();
		const command_1 = requireCommand();
		const levelValues = new Set(['off', 'slow_only', 'all']);
		/** @public */
		exports.ProfilingLevel = Object.freeze({
		    off: 'off',
		    slowOnly: 'slow_only',
		    all: 'all'
		});
		/** @internal */
		class SetProfilingLevelOperation extends command_1.CommandOperation {
		    constructor(db, level, options) {
		        super(db, options);
		        this.options = options;
		        switch (level) {
		            case exports.ProfilingLevel.off:
		                this.profile = 0;
		                break;
		            case exports.ProfilingLevel.slowOnly:
		                this.profile = 1;
		                break;
		            case exports.ProfilingLevel.all:
		                this.profile = 2;
		                break;
		            default:
		                this.profile = 0;
		                break;
		        }
		        this.level = level;
		    }
		    get commandName() {
		        return 'profile';
		    }
		    async execute(server, session) {
		        const level = this.level;
		        if (!levelValues.has(level)) {
		            throw new error_1.MongoInvalidArgumentError(`Profiling level must be one of "${(0, utils_1.enumToString)(exports.ProfilingLevel)}"`);
		        }
		        // TODO(NODE-3483): Determine error to put here
		        await super.executeCommand(server, session, { profile: this.profile });
		        return level;
		    }
		}
		exports.SetProfilingLevelOperation = SetProfilingLevelOperation;
		
	} (set_profiling_level));
	return set_profiling_level;
}

var stats = {};

var hasRequiredStats;

function requireStats () {
	if (hasRequiredStats) return stats;
	hasRequiredStats = 1;
	Object.defineProperty(stats, "__esModule", { value: true });
	stats.DbStatsOperation = void 0;
	const command_1 = requireCommand();
	const operation_1 = requireOperation();
	/** @internal */
	class DbStatsOperation extends command_1.CommandOperation {
	    constructor(db, options) {
	        super(db, options);
	        this.options = options;
	    }
	    get commandName() {
	        return 'dbStats';
	    }
	    async execute(server, session) {
	        const command = { dbStats: true };
	        if (this.options.scale != null) {
	            command.scale = this.options.scale;
	        }
	        return await super.executeCommand(server, session, command);
	    }
	}
	stats.DbStatsOperation = DbStatsOperation;
	(0, operation_1.defineAspects)(DbStatsOperation, [operation_1.Aspect.READ_OPERATION]);
	
	return stats;
}

var hasRequiredDb;

function requireDb () {
	if (hasRequiredDb) return db;
	hasRequiredDb = 1;
	Object.defineProperty(db, "__esModule", { value: true });
	db.Db = void 0;
	const admin_1 = requireAdmin();
	const bson_1 = requireBson();
	const change_stream_1 = requireChange_stream();
	const collection_1 = requireCollection();
	const CONSTANTS = requireConstants();
	const aggregation_cursor_1 = requireAggregation_cursor();
	const list_collections_cursor_1 = requireList_collections_cursor();
	const run_command_cursor_1 = requireRun_command_cursor();
	const error_1 = requireError();
	const collections_1 = requireCollections();
	const create_collection_1 = requireCreate_collection();
	const drop_1 = requireDrop$1();
	const execute_operation_1 = requireExecute_operation();
	const indexes_1 = requireIndexes();
	const profiling_level_1 = requireProfiling_level();
	const remove_user_1 = requireRemove_user();
	const rename_1 = requireRename();
	const run_command_1 = requireRun_command();
	const set_profiling_level_1 = requireSet_profiling_level();
	const stats_1 = requireStats();
	const read_concern_1 = requireRead_concern();
	const read_preference_1 = requireRead_preference();
	const utils_1 = requireUtils$1();
	const write_concern_1 = requireWrite_concern();
	// Allowed parameters
	const DB_OPTIONS_ALLOW_LIST = [
	    'writeConcern',
	    'readPreference',
	    'readPreferenceTags',
	    'native_parser',
	    'forceServerObjectId',
	    'pkFactory',
	    'serializeFunctions',
	    'raw',
	    'authSource',
	    'ignoreUndefined',
	    'readConcern',
	    'retryMiliSeconds',
	    'numberOfRetries',
	    'useBigInt64',
	    'promoteBuffers',
	    'promoteLongs',
	    'bsonRegExp',
	    'enableUtf8Validation',
	    'promoteValues',
	    'compression',
	    'retryWrites',
	    'timeoutMS'
	];
	/**
	 * The **Db** class is a class that represents a MongoDB Database.
	 * @public
	 *
	 * @example
	 * ```ts
	 * import { MongoClient } from 'mongodb';
	 *
	 * interface Pet {
	 *   name: string;
	 *   kind: 'dog' | 'cat' | 'fish';
	 * }
	 *
	 * const client = new MongoClient('mongodb://localhost:27017');
	 * const db = client.db();
	 *
	 * // Create a collection that validates our union
	 * await db.createCollection<Pet>('pets', {
	 *   validator: { $expr: { $in: ['$kind', ['dog', 'cat', 'fish']] } }
	 * })
	 * ```
	 */
	class Db {
	    /**
	     * Creates a new Db instance.
	     *
	     * Db name cannot contain a dot, the server may apply more restrictions when an operation is run.
	     *
	     * @param client - The MongoClient for the database.
	     * @param databaseName - The name of the database this instance represents.
	     * @param options - Optional settings for Db construction.
	     */
	    constructor(client, databaseName, options) {
	        options = options ?? {};
	        // Filter the options
	        options = (0, utils_1.filterOptions)(options, DB_OPTIONS_ALLOW_LIST);
	        // Ensure there are no dots in database name
	        if (typeof databaseName === 'string' && databaseName.includes('.')) {
	            throw new error_1.MongoInvalidArgumentError(`Database names cannot contain the character '.'`);
	        }
	        // Internal state of the db object
	        this.s = {
	            // Options
	            options,
	            // Unpack read preference
	            readPreference: read_preference_1.ReadPreference.fromOptions(options),
	            // Merge bson options
	            bsonOptions: (0, bson_1.resolveBSONOptions)(options, client),
	            // Set up the primary key factory or fallback to ObjectId
	            pkFactory: options?.pkFactory ?? utils_1.DEFAULT_PK_FACTORY,
	            // ReadConcern
	            readConcern: read_concern_1.ReadConcern.fromOptions(options),
	            writeConcern: write_concern_1.WriteConcern.fromOptions(options),
	            // Namespace
	            namespace: new utils_1.MongoDBNamespace(databaseName)
	        };
	        this.client = client;
	    }
	    get databaseName() {
	        return this.s.namespace.db;
	    }
	    // Options
	    get options() {
	        return this.s.options;
	    }
	    /**
	     * Check if a secondary can be used (because the read preference is *not* set to primary)
	     */
	    get secondaryOk() {
	        return this.s.readPreference?.preference !== 'primary' || false;
	    }
	    get readConcern() {
	        return this.s.readConcern;
	    }
	    /**
	     * The current readPreference of the Db. If not explicitly defined for
	     * this Db, will be inherited from the parent MongoClient
	     */
	    get readPreference() {
	        if (this.s.readPreference == null) {
	            return this.client.readPreference;
	        }
	        return this.s.readPreference;
	    }
	    get bsonOptions() {
	        return this.s.bsonOptions;
	    }
	    // get the write Concern
	    get writeConcern() {
	        return this.s.writeConcern;
	    }
	    get namespace() {
	        return this.s.namespace.toString();
	    }
	    /**
	     * Create a new collection on a server with the specified options. Use this to create capped collections.
	     * More information about command options available at https://www.mongodb.com/docs/manual/reference/command/create/
	     *
	     * Collection namespace validation is performed server-side.
	     *
	     * @param name - The name of the collection to create
	     * @param options - Optional settings for the command
	     */
	    async createCollection(name, options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new create_collection_1.CreateCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)));
	    }
	    /**
	     * Execute a command
	     *
	     * @remarks
	     * This command does not inherit options from the MongoClient.
	     *
	     * The driver will ensure the following fields are attached to the command sent to the server:
	     * - `lsid` - sourced from an implicit session or options.session
	     * - `$readPreference` - defaults to primary or can be configured by options.readPreference
	     * - `$db` - sourced from the name of this database
	     *
	     * If the client has a serverApi setting:
	     * - `apiVersion`
	     * - `apiStrict`
	     * - `apiDeprecationErrors`
	     *
	     * When in a transaction:
	     * - `readConcern` - sourced from readConcern set on the TransactionOptions
	     * - `writeConcern` - sourced from writeConcern set on the TransactionOptions
	     *
	     * Attaching any of the above fields to the command will have no effect as the driver will overwrite the value.
	     *
	     * @param command - The command to run
	     * @param options - Optional settings for the command
	     */
	    async command(command, options) {
	        // Intentionally, we do not inherit options from parent for this operation.
	        return await (0, execute_operation_1.executeOperation)(this.client, new run_command_1.RunCommandOperation(this, command, {
	            ...(0, bson_1.resolveBSONOptions)(options),
	            session: options?.session,
	            readPreference: options?.readPreference
	        }));
	    }
	    /**
	     * Execute an aggregation framework pipeline against the database, needs MongoDB \>= 3.6
	     *
	     * @param pipeline - An array of aggregation stages to be executed
	     * @param options - Optional settings for the command
	     */
	    aggregate(pipeline = [], options) {
	        return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));
	    }
	    /** Return the Admin db instance */
	    admin() {
	        return new admin_1.Admin(this);
	    }
	    /**
	     * Returns a reference to a MongoDB Collection. If it does not exist it will be created implicitly.
	     *
	     * Collection namespace validation is performed server-side.
	     *
	     * @param name - the collection name we wish to access.
	     * @returns return the new Collection instance
	     */
	    collection(name, options = {}) {
	        if (typeof options === 'function') {
	            throw new error_1.MongoInvalidArgumentError('The callback form of this helper has been removed.');
	        }
	        return new collection_1.Collection(this, name, (0, utils_1.resolveOptions)(this, options));
	    }
	    /**
	     * Get all the db statistics.
	     *
	     * @param options - Optional settings for the command
	     */
	    async stats(options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new stats_1.DbStatsOperation(this, (0, utils_1.resolveOptions)(this, options)));
	    }
	    listCollections(filter = {}, options = {}) {
	        return new list_collections_cursor_1.ListCollectionsCursor(this, filter, (0, utils_1.resolveOptions)(this, options));
	    }
	    /**
	     * Rename a collection.
	     *
	     * @remarks
	     * This operation does not inherit options from the MongoClient.
	     *
	     * @param fromCollection - Name of current collection to rename
	     * @param toCollection - New name of of the collection
	     * @param options - Optional settings for the command
	     */
	    async renameCollection(fromCollection, toCollection, options) {
	        // Intentionally, we do not inherit options from parent for this operation.
	        return await (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this.collection(fromCollection), toCollection, { ...options, new_collection: true, readPreference: read_preference_1.ReadPreference.primary }));
	    }
	    /**
	     * Drop a collection from the database, removing it permanently. New accesses will create a new collection.
	     *
	     * @param name - Name of collection to drop
	     * @param options - Optional settings for the command
	     */
	    async dropCollection(name, options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)));
	    }
	    /**
	     * Drop a database, removing it permanently from the server.
	     *
	     * @param options - Optional settings for the command
	     */
	    async dropDatabase(options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropDatabaseOperation(this, (0, utils_1.resolveOptions)(this, options)));
	    }
	    /**
	     * Fetch all collections for the current db.
	     *
	     * @param options - Optional settings for the command
	     */
	    async collections(options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new collections_1.CollectionsOperation(this, (0, utils_1.resolveOptions)(this, options)));
	    }
	    /**
	     * Creates an index on the db and collection.
	     *
	     * @param name - Name of the collection to create the index on.
	     * @param indexSpec - Specify the field to index, or an index specification
	     * @param options - Optional settings for the command
	     */
	    async createIndex(name, indexSpec, options) {
	        const indexes = await (0, execute_operation_1.executeOperation)(this.client, indexes_1.CreateIndexesOperation.fromIndexSpecification(this, name, indexSpec, options));
	        return indexes[0];
	    }
	    /**
	     * Remove a user from a database
	     *
	     * @param username - The username to remove
	     * @param options - Optional settings for the command
	     */
	    async removeUser(username, options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new remove_user_1.RemoveUserOperation(this, username, (0, utils_1.resolveOptions)(this, options)));
	    }
	    /**
	     * Set the current profiling level of MongoDB
	     *
	     * @param level - The new profiling level (off, slow_only, all).
	     * @param options - Optional settings for the command
	     */
	    async setProfilingLevel(level, options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new set_profiling_level_1.SetProfilingLevelOperation(this, level, (0, utils_1.resolveOptions)(this, options)));
	    }
	    /**
	     * Retrieve the current profiling Level for MongoDB
	     *
	     * @param options - Optional settings for the command
	     */
	    async profilingLevel(options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new profiling_level_1.ProfilingLevelOperation(this, (0, utils_1.resolveOptions)(this, options)));
	    }
	    async indexInformation(name, options) {
	        return await this.collection(name).indexInformation((0, utils_1.resolveOptions)(this, options));
	    }
	    /**
	     * Create a new Change Stream, watching for new changes (insertions, updates,
	     * replacements, deletions, and invalidations) in this database. Will ignore all
	     * changes to system collections.
	     *
	     * @remarks
	     * watch() accepts two generic arguments for distinct use cases:
	     * - The first is to provide the schema that may be defined for all the collections within this database
	     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
	     *
	     * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
	     * @param options - Optional settings for the command
	     * @typeParam TSchema - Type of the data being detected by the change stream
	     * @typeParam TChange - Type of the whole change stream document emitted
	     */
	    watch(pipeline = [], options = {}) {
	        // Allow optionally not specifying a pipeline
	        if (!Array.isArray(pipeline)) {
	            options = pipeline;
	            pipeline = [];
	        }
	        return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
	    }
	    /**
	     * A low level cursor API providing basic driver functionality:
	     * - ClientSession management
	     * - ReadPreference for server selection
	     * - Running getMores automatically when a local batch is exhausted
	     *
	     * @param command - The command that will start a cursor on the server.
	     * @param options - Configurations for running the command, bson options will apply to getMores
	     */
	    runCursorCommand(command, options) {
	        return new run_command_cursor_1.RunCommandCursor(this, command, options);
	    }
	}
	db.Db = Db;
	Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
	Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
	Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
	Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
	Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
	Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
	
	return db;
}

var mongo_client_auth_providers = {};

var mongocr = {};

var hasRequiredMongocr;

function requireMongocr () {
	if (hasRequiredMongocr) return mongocr;
	hasRequiredMongocr = 1;
	Object.defineProperty(mongocr, "__esModule", { value: true });
	mongocr.MongoCR = void 0;
	const crypto = require$$0$c;
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	const auth_provider_1 = requireAuth_provider();
	class MongoCR extends auth_provider_1.AuthProvider {
	    async auth(authContext) {
	        const { connection, credentials } = authContext;
	        if (!credentials) {
	            throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');
	        }
	        const { username, password, source } = credentials;
	        const { nonce } = await connection.command((0, utils_1.ns)(`${source}.$cmd`), { getnonce: 1 }, undefined);
	        const hashPassword = crypto
	            .createHash('md5')
	            .update(`${username}:mongo:${password}`, 'utf8')
	            .digest('hex');
	        // Final key
	        const key = crypto
	            .createHash('md5')
	            .update(`${nonce}${username}${hashPassword}`, 'utf8')
	            .digest('hex');
	        const authenticateCommand = {
	            authenticate: 1,
	            user: username,
	            nonce,
	            key
	        };
	        await connection.command((0, utils_1.ns)(`${source}.$cmd`), authenticateCommand, undefined);
	    }
	}
	mongocr.MongoCR = MongoCR;
	
	return mongocr;
}

var mongodb_aws = {};

var hasRequiredMongodb_aws;

function requireMongodb_aws () {
	if (hasRequiredMongodb_aws) return mongodb_aws;
	hasRequiredMongodb_aws = 1;
	Object.defineProperty(mongodb_aws, "__esModule", { value: true });
	mongodb_aws.MongoDBAWS = void 0;
	const BSON = requireBson();
	const deps_1 = requireDeps();
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	const auth_provider_1 = requireAuth_provider();
	const aws_temporary_credentials_1 = requireAws_temporary_credentials();
	const mongo_credentials_1 = requireMongo_credentials();
	const providers_1 = requireProviders$1();
	const ASCII_N = 110;
	const bsonOptions = {
	    useBigInt64: false,
	    promoteLongs: true,
	    promoteValues: true,
	    promoteBuffers: false,
	    bsonRegExp: false
	};
	class MongoDBAWS extends auth_provider_1.AuthProvider {
	    constructor() {
	        super();
	        this.credentialFetcher = aws_temporary_credentials_1.AWSTemporaryCredentialProvider.isAWSSDKInstalled
	            ? new aws_temporary_credentials_1.AWSSDKCredentialProvider()
	            : new aws_temporary_credentials_1.LegacyAWSTemporaryCredentialProvider();
	    }
	    async auth(authContext) {
	        const { connection } = authContext;
	        if (!authContext.credentials) {
	            throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');
	        }
	        if ('kModuleError' in deps_1.aws4) {
	            throw deps_1.aws4['kModuleError'];
	        }
	        const { sign } = deps_1.aws4;
	        if ((0, utils_1.maxWireVersion)(connection) < 9) {
	            throw new error_1.MongoCompatibilityError('MONGODB-AWS authentication requires MongoDB version 4.4 or later');
	        }
	        if (!authContext.credentials.username) {
	            authContext.credentials = await makeTempCredentials(authContext.credentials, this.credentialFetcher);
	        }
	        const { credentials } = authContext;
	        const accessKeyId = credentials.username;
	        const secretAccessKey = credentials.password;
	        // Allow the user to specify an AWS session token for authentication with temporary credentials.
	        const sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN;
	        // If all three defined, include sessionToken, else include username and pass, else no credentials
	        const awsCredentials = accessKeyId && secretAccessKey && sessionToken
	            ? { accessKeyId, secretAccessKey, sessionToken }
	            : accessKeyId && secretAccessKey
	                ? { accessKeyId, secretAccessKey }
	                : undefined;
	        const db = credentials.source;
	        const nonce = await (0, utils_1.randomBytes)(32);
	        // All messages between MongoDB clients and servers are sent as BSON objects
	        // in the payload field of saslStart and saslContinue.
	        const saslStart = {
	            saslStart: 1,
	            mechanism: 'MONGODB-AWS',
	            payload: BSON.serialize({ r: nonce, p: ASCII_N }, bsonOptions)
	        };
	        const saslStartResponse = await connection.command((0, utils_1.ns)(`${db}.$cmd`), saslStart, undefined);
	        const serverResponse = BSON.deserialize(saslStartResponse.payload.buffer, bsonOptions);
	        const host = serverResponse.h;
	        const serverNonce = serverResponse.s.buffer;
	        if (serverNonce.length !== 64) {
	            // TODO(NODE-3483)
	            throw new error_1.MongoRuntimeError(`Invalid server nonce length ${serverNonce.length}, expected 64`);
	        }
	        if (!utils_1.ByteUtils.equals(serverNonce.subarray(0, nonce.byteLength), nonce)) {
	            // throw because the serverNonce's leading 32 bytes must equal the client nonce's 32 bytes
	            // https://github.com/mongodb/specifications/blob/875446db44aade414011731840831f38a6c668df/source/auth/auth.rst#id11
	            // TODO(NODE-3483)
	            throw new error_1.MongoRuntimeError('Server nonce does not begin with client nonce');
	        }
	        if (host.length < 1 || host.length > 255 || host.indexOf('..') !== -1) {
	            // TODO(NODE-3483)
	            throw new error_1.MongoRuntimeError(`Server returned an invalid host: "${host}"`);
	        }
	        const body = 'Action=GetCallerIdentity&Version=2011-06-15';
	        const options = sign({
	            method: 'POST',
	            host,
	            region: deriveRegion(serverResponse.h),
	            service: 'sts',
	            headers: {
	                'Content-Type': 'application/x-www-form-urlencoded',
	                'Content-Length': body.length,
	                'X-MongoDB-Server-Nonce': utils_1.ByteUtils.toBase64(serverNonce),
	                'X-MongoDB-GS2-CB-Flag': 'n'
	            },
	            path: '/',
	            body
	        }, awsCredentials);
	        const payload = {
	            a: options.headers.Authorization,
	            d: options.headers['X-Amz-Date']
	        };
	        if (sessionToken) {
	            payload.t = sessionToken;
	        }
	        const saslContinue = {
	            saslContinue: 1,
	            conversationId: 1,
	            payload: BSON.serialize(payload, bsonOptions)
	        };
	        await connection.command((0, utils_1.ns)(`${db}.$cmd`), saslContinue, undefined);
	    }
	}
	mongodb_aws.MongoDBAWS = MongoDBAWS;
	async function makeTempCredentials(credentials, awsCredentialFetcher) {
	    function makeMongoCredentialsFromAWSTemp(creds) {
	        // The AWS session token (creds.Token) may or may not be set.
	        if (!creds.AccessKeyId || !creds.SecretAccessKey) {
	            throw new error_1.MongoMissingCredentialsError('Could not obtain temporary MONGODB-AWS credentials');
	        }
	        return new mongo_credentials_1.MongoCredentials({
	            username: creds.AccessKeyId,
	            password: creds.SecretAccessKey,
	            source: credentials.source,
	            mechanism: providers_1.AuthMechanism.MONGODB_AWS,
	            mechanismProperties: {
	                AWS_SESSION_TOKEN: creds.Token
	            }
	        });
	    }
	    const temporaryCredentials = await awsCredentialFetcher.getCredentials();
	    return makeMongoCredentialsFromAWSTemp(temporaryCredentials);
	}
	function deriveRegion(host) {
	    const parts = host.split('.');
	    if (parts.length === 1 || parts[1] === 'amazonaws') {
	        return 'us-east-1';
	    }
	    return parts[1];
	}
	
	return mongodb_aws;
}

var mongodb_oidc = {};

var azure_machine_workflow = {};

var machine_workflow = {};

var command_builders = {};

var hasRequiredCommand_builders;

function requireCommand_builders () {
	if (hasRequiredCommand_builders) return command_builders;
	hasRequiredCommand_builders = 1;
	Object.defineProperty(command_builders, "__esModule", { value: true });
	command_builders.finishCommandDocument = finishCommandDocument;
	command_builders.startCommandDocument = startCommandDocument;
	const bson_1 = requireBson$1();
	const providers_1 = requireProviders$1();
	/**
	 * Generate the finishing command document for authentication. Will be a
	 * saslStart or saslContinue depending on the presence of a conversation id.
	 */
	function finishCommandDocument(token, conversationId) {
	    if (conversationId != null) {
	        return {
	            saslContinue: 1,
	            conversationId: conversationId,
	            payload: new bson_1.Binary(bson_1.BSON.serialize({ jwt: token }))
	        };
	    }
	    // saslContinue requires a conversationId in the command to be valid so in this
	    // case the server allows "step two" to actually be a saslStart with the token
	    // as the jwt since the use of the cached value has no correlating conversating
	    // on the particular connection.
	    return {
	        saslStart: 1,
	        mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
	        payload: new bson_1.Binary(bson_1.BSON.serialize({ jwt: token }))
	    };
	}
	/**
	 * Generate the saslStart command document.
	 */
	function startCommandDocument(credentials) {
	    const payload = {};
	    if (credentials.username) {
	        payload.n = credentials.username;
	    }
	    return {
	        saslStart: 1,
	        autoAuthorize: 1,
	        mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
	        payload: new bson_1.Binary(bson_1.BSON.serialize(payload))
	    };
	}
	
	return command_builders;
}

var hasRequiredMachine_workflow;

function requireMachine_workflow () {
	if (hasRequiredMachine_workflow) return machine_workflow;
	hasRequiredMachine_workflow = 1;
	Object.defineProperty(machine_workflow, "__esModule", { value: true });
	machine_workflow.MachineWorkflow = void 0;
	const promises_1 = require$$0$g;
	const utils_1 = requireUtils$1();
	const command_builders_1 = requireCommand_builders();
	/** The time to throttle callback calls. */
	const THROTTLE_MS = 100;
	/**
	 * Common behaviour for OIDC machine workflows.
	 * @internal
	 */
	class MachineWorkflow {
	    /**
	     * Instantiate the machine workflow.
	     */
	    constructor(cache) {
	        this.cache = cache;
	        this.callback = this.withLock(this.getToken.bind(this));
	        this.lastExecutionTime = Date.now() - THROTTLE_MS;
	    }
	    /**
	     * Execute the workflow. Gets the token from the subclass implementation.
	     */
	    async execute(connection, credentials) {
	        const token = await this.getTokenFromCacheOrEnv(connection, credentials);
	        const command = (0, command_builders_1.finishCommandDocument)(token);
	        await connection.command((0, utils_1.ns)(credentials.source), command, undefined);
	    }
	    /**
	     * Reauthenticate on a machine workflow just grabs the token again since the server
	     * has said the current access token is invalid or expired.
	     */
	    async reauthenticate(connection, credentials) {
	        if (this.cache.hasAccessToken) {
	            // Reauthentication implies the token has expired.
	            if (connection.accessToken === this.cache.getAccessToken()) {
	                // If connection's access token is the same as the cache's, remove
	                // the token from the cache and connection.
	                this.cache.removeAccessToken();
	                delete connection.accessToken;
	            }
	            else {
	                // If the connection's access token is different from the cache's, set
	                // the cache's token on the connection and do not remove from the
	                // cache.
	                connection.accessToken = this.cache.getAccessToken();
	            }
	        }
	        await this.execute(connection, credentials);
	    }
	    /**
	     * Get the document to add for speculative authentication.
	     */
	    async speculativeAuth(connection, credentials) {
	        // The spec states only cached access tokens can use speculative auth.
	        if (!this.cache.hasAccessToken) {
	            return {};
	        }
	        const token = await this.getTokenFromCacheOrEnv(connection, credentials);
	        const document = (0, command_builders_1.finishCommandDocument)(token);
	        document.db = credentials.source;
	        return { speculativeAuthenticate: document };
	    }
	    /**
	     * Get the token from the cache or environment.
	     */
	    async getTokenFromCacheOrEnv(connection, credentials) {
	        if (this.cache.hasAccessToken) {
	            return this.cache.getAccessToken();
	        }
	        else {
	            const token = await this.callback(credentials);
	            this.cache.put({ accessToken: token.access_token, expiresInSeconds: token.expires_in });
	            // Put the access token on the connection as well.
	            connection.accessToken = token.access_token;
	            return token.access_token;
	        }
	    }
	    /**
	     * Ensure the callback is only executed one at a time, and throttled to
	     * only once per 100ms.
	     */
	    withLock(callback) {
	        let lock = Promise.resolve();
	        return async (credentials) => {
	            // We do this to ensure that we would never return the result of the
	            // previous lock, only the current callback's value would get returned.
	            await lock;
	            lock = lock
	                .catch(() => null)
	                .then(async () => {
	                const difference = Date.now() - this.lastExecutionTime;
	                if (difference <= THROTTLE_MS) {
	                    await (0, promises_1.setTimeout)(THROTTLE_MS - difference);
	                }
	                this.lastExecutionTime = Date.now();
	                return await callback(credentials);
	            });
	            return await lock;
	        };
	    }
	}
	machine_workflow.MachineWorkflow = MachineWorkflow;
	
	return machine_workflow;
}

var hasRequiredAzure_machine_workflow;

function requireAzure_machine_workflow () {
	if (hasRequiredAzure_machine_workflow) return azure_machine_workflow;
	hasRequiredAzure_machine_workflow = 1;
	Object.defineProperty(azure_machine_workflow, "__esModule", { value: true });
	azure_machine_workflow.AzureMachineWorkflow = void 0;
	const azure_1 = requireAzure();
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	const machine_workflow_1 = requireMachine_workflow();
	/** Azure request headers. */
	const AZURE_HEADERS = Object.freeze({ Metadata: 'true', Accept: 'application/json' });
	/** Invalid endpoint result error. */
	const ENDPOINT_RESULT_ERROR = 'Azure endpoint did not return a value with only access_token and expires_in properties';
	/** Error for when the token audience is missing in the environment. */
	const TOKEN_RESOURCE_MISSING_ERROR = 'TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is azure.';
	/**
	 * Device workflow implementation for Azure.
	 *
	 * @internal
	 */
	class AzureMachineWorkflow extends machine_workflow_1.MachineWorkflow {
	    /**
	     * Instantiate the machine workflow.
	     */
	    constructor(cache) {
	        super(cache);
	    }
	    /**
	     * Get the token from the environment.
	     */
	    async getToken(credentials) {
	        const tokenAudience = credentials?.mechanismProperties.TOKEN_RESOURCE;
	        const username = credentials?.username;
	        if (!tokenAudience) {
	            throw new error_1.MongoAzureError(TOKEN_RESOURCE_MISSING_ERROR);
	        }
	        const response = await getAzureTokenData(tokenAudience, username);
	        if (!isEndpointResultValid(response)) {
	            throw new error_1.MongoAzureError(ENDPOINT_RESULT_ERROR);
	        }
	        return response;
	    }
	}
	azure_machine_workflow.AzureMachineWorkflow = AzureMachineWorkflow;
	/**
	 * Hit the Azure endpoint to get the token data.
	 */
	async function getAzureTokenData(tokenAudience, username) {
	    const url = new URL(azure_1.AZURE_BASE_URL);
	    (0, azure_1.addAzureParams)(url, tokenAudience, username);
	    const response = await (0, utils_1.get)(url, {
	        headers: AZURE_HEADERS
	    });
	    if (response.status !== 200) {
	        throw new error_1.MongoAzureError(`Status code ${response.status} returned from the Azure endpoint. Response body: ${response.body}`);
	    }
	    const result = JSON.parse(response.body);
	    return {
	        access_token: result.access_token,
	        expires_in: Number(result.expires_in)
	    };
	}
	/**
	 * Determines if a result returned from the endpoint is valid.
	 * This means the result is not nullish, contains the access_token required field
	 * and the expires_in required field.
	 */
	function isEndpointResultValid(token) {
	    if (token == null || typeof token !== 'object')
	        return false;
	    return ('access_token' in token &&
	        typeof token.access_token === 'string' &&
	        'expires_in' in token &&
	        typeof token.expires_in === 'number');
	}
	
	return azure_machine_workflow;
}

var gcp_machine_workflow = {};

var hasRequiredGcp_machine_workflow;

function requireGcp_machine_workflow () {
	if (hasRequiredGcp_machine_workflow) return gcp_machine_workflow;
	hasRequiredGcp_machine_workflow = 1;
	Object.defineProperty(gcp_machine_workflow, "__esModule", { value: true });
	gcp_machine_workflow.GCPMachineWorkflow = void 0;
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	const machine_workflow_1 = requireMachine_workflow();
	/** GCP base URL. */
	const GCP_BASE_URL = 'http://metadata/computeMetadata/v1/instance/service-accounts/default/identity';
	/** GCP request headers. */
	const GCP_HEADERS = Object.freeze({ 'Metadata-Flavor': 'Google' });
	/** Error for when the token audience is missing in the environment. */
	const TOKEN_RESOURCE_MISSING_ERROR = 'TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is gcp.';
	class GCPMachineWorkflow extends machine_workflow_1.MachineWorkflow {
	    /**
	     * Instantiate the machine workflow.
	     */
	    constructor(cache) {
	        super(cache);
	    }
	    /**
	     * Get the token from the environment.
	     */
	    async getToken(credentials) {
	        const tokenAudience = credentials?.mechanismProperties.TOKEN_RESOURCE;
	        if (!tokenAudience) {
	            throw new error_1.MongoGCPError(TOKEN_RESOURCE_MISSING_ERROR);
	        }
	        return await getGcpTokenData(tokenAudience);
	    }
	}
	gcp_machine_workflow.GCPMachineWorkflow = GCPMachineWorkflow;
	/**
	 * Hit the GCP endpoint to get the token data.
	 */
	async function getGcpTokenData(tokenAudience) {
	    const url = new URL(GCP_BASE_URL);
	    url.searchParams.append('audience', tokenAudience);
	    const response = await (0, utils_1.get)(url, {
	        headers: GCP_HEADERS
	    });
	    if (response.status !== 200) {
	        throw new error_1.MongoGCPError(`Status code ${response.status} returned from the GCP endpoint. Response body: ${response.body}`);
	    }
	    return { access_token: response.body };
	}
	
	return gcp_machine_workflow;
}

var token_cache = {};

var hasRequiredToken_cache;

function requireToken_cache () {
	if (hasRequiredToken_cache) return token_cache;
	hasRequiredToken_cache = 1;
	Object.defineProperty(token_cache, "__esModule", { value: true });
	token_cache.TokenCache = void 0;
	const error_1 = requireError();
	class MongoOIDCError extends error_1.MongoDriverError {
	}
	/** @internal */
	class TokenCache {
	    get hasAccessToken() {
	        return !!this.accessToken;
	    }
	    get hasRefreshToken() {
	        return !!this.refreshToken;
	    }
	    get hasIdpInfo() {
	        return !!this.idpInfo;
	    }
	    getAccessToken() {
	        if (!this.accessToken) {
	            throw new MongoOIDCError('Attempted to get an access token when none exists.');
	        }
	        return this.accessToken;
	    }
	    getRefreshToken() {
	        if (!this.refreshToken) {
	            throw new MongoOIDCError('Attempted to get a refresh token when none exists.');
	        }
	        return this.refreshToken;
	    }
	    getIdpInfo() {
	        if (!this.idpInfo) {
	            throw new MongoOIDCError('Attempted to get IDP information when none exists.');
	        }
	        return this.idpInfo;
	    }
	    put(response, idpInfo) {
	        this.accessToken = response.accessToken;
	        this.refreshToken = response.refreshToken;
	        this.expiresInSeconds = response.expiresInSeconds;
	        if (idpInfo) {
	            this.idpInfo = idpInfo;
	        }
	    }
	    removeAccessToken() {
	        this.accessToken = undefined;
	    }
	    removeRefreshToken() {
	        this.refreshToken = undefined;
	    }
	}
	token_cache.TokenCache = TokenCache;
	
	return token_cache;
}

var token_machine_workflow = {};

var hasRequiredToken_machine_workflow;

function requireToken_machine_workflow () {
	if (hasRequiredToken_machine_workflow) return token_machine_workflow;
	hasRequiredToken_machine_workflow = 1;
	Object.defineProperty(token_machine_workflow, "__esModule", { value: true });
	token_machine_workflow.TokenMachineWorkflow = void 0;
	const fs$1 = fs;
	const error_1 = requireError();
	const machine_workflow_1 = requireMachine_workflow();
	/** Error for when the token is missing in the environment. */
	const TOKEN_MISSING_ERROR = 'OIDC_TOKEN_FILE must be set in the environment.';
	/**
	 * Device workflow implementation for AWS.
	 *
	 * @internal
	 */
	class TokenMachineWorkflow extends machine_workflow_1.MachineWorkflow {
	    /**
	     * Instantiate the machine workflow.
	     */
	    constructor(cache) {
	        super(cache);
	    }
	    /**
	     * Get the token from the environment.
	     */
	    async getToken() {
	        const tokenFile = process.env.OIDC_TOKEN_FILE;
	        if (!tokenFile) {
	            throw new error_1.MongoAWSError(TOKEN_MISSING_ERROR);
	        }
	        const token = await fs$1.promises.readFile(tokenFile, 'utf8');
	        return { access_token: token };
	    }
	}
	token_machine_workflow.TokenMachineWorkflow = TokenMachineWorkflow;
	
	return token_machine_workflow;
}

var hasRequiredMongodb_oidc;

function requireMongodb_oidc () {
	if (hasRequiredMongodb_oidc) return mongodb_oidc;
	hasRequiredMongodb_oidc = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.MongoDBOIDC = exports.OIDC_WORKFLOWS = exports.OIDC_VERSION = void 0;
		const error_1 = requireError();
		const auth_provider_1 = requireAuth_provider();
		const azure_machine_workflow_1 = requireAzure_machine_workflow();
		const gcp_machine_workflow_1 = requireGcp_machine_workflow();
		const token_cache_1 = requireToken_cache();
		const token_machine_workflow_1 = requireToken_machine_workflow();
		/** Error when credentials are missing. */
		const MISSING_CREDENTIALS_ERROR = 'AuthContext must provide credentials.';
		/** The current version of OIDC implementation. */
		exports.OIDC_VERSION = 1;
		/** @internal */
		exports.OIDC_WORKFLOWS = new Map();
		exports.OIDC_WORKFLOWS.set('test', () => new token_machine_workflow_1.TokenMachineWorkflow(new token_cache_1.TokenCache()));
		exports.OIDC_WORKFLOWS.set('azure', () => new azure_machine_workflow_1.AzureMachineWorkflow(new token_cache_1.TokenCache()));
		exports.OIDC_WORKFLOWS.set('gcp', () => new gcp_machine_workflow_1.GCPMachineWorkflow(new token_cache_1.TokenCache()));
		/**
		 * OIDC auth provider.
		 */
		class MongoDBOIDC extends auth_provider_1.AuthProvider {
		    /**
		     * Instantiate the auth provider.
		     */
		    constructor(workflow) {
		        super();
		        if (!workflow) {
		            throw new error_1.MongoInvalidArgumentError('No workflow provided to the OIDC auth provider.');
		        }
		        this.workflow = workflow;
		    }
		    /**
		     * Authenticate using OIDC
		     */
		    async auth(authContext) {
		        const { connection, reauthenticating, response } = authContext;
		        if (response?.speculativeAuthenticate?.done) {
		            return;
		        }
		        const credentials = getCredentials(authContext);
		        if (reauthenticating) {
		            await this.workflow.reauthenticate(connection, credentials);
		        }
		        else {
		            await this.workflow.execute(connection, credentials, response);
		        }
		    }
		    /**
		     * Add the speculative auth for the initial handshake.
		     */
		    async prepare(handshakeDoc, authContext) {
		        const { connection } = authContext;
		        const credentials = getCredentials(authContext);
		        const result = await this.workflow.speculativeAuth(connection, credentials);
		        return { ...handshakeDoc, ...result };
		    }
		}
		exports.MongoDBOIDC = MongoDBOIDC;
		/**
		 * Get credentials from the auth context, throwing if they do not exist.
		 */
		function getCredentials(authContext) {
		    const { credentials } = authContext;
		    if (!credentials) {
		        throw new error_1.MongoMissingCredentialsError(MISSING_CREDENTIALS_ERROR);
		    }
		    return credentials;
		}
		
	} (mongodb_oidc));
	return mongodb_oidc;
}

var automated_callback_workflow = {};

var callback_workflow = {};

var hasRequiredCallback_workflow;

function requireCallback_workflow () {
	if (hasRequiredCallback_workflow) return callback_workflow;
	hasRequiredCallback_workflow = 1;
	Object.defineProperty(callback_workflow, "__esModule", { value: true });
	callback_workflow.CallbackWorkflow = callback_workflow.AUTOMATED_TIMEOUT_MS = callback_workflow.HUMAN_TIMEOUT_MS = void 0;
	const promises_1 = require$$0$g;
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	const command_builders_1 = requireCommand_builders();
	/** 5 minutes in milliseconds */
	callback_workflow.HUMAN_TIMEOUT_MS = 300000;
	/** 1 minute in milliseconds */
	callback_workflow.AUTOMATED_TIMEOUT_MS = 60000;
	/** Properties allowed on results of callbacks. */
	const RESULT_PROPERTIES = ['accessToken', 'expiresInSeconds', 'refreshToken'];
	/** Error message when the callback result is invalid. */
	const CALLBACK_RESULT_ERROR = 'User provided OIDC callbacks must return a valid object with an accessToken.';
	/** The time to throttle callback calls. */
	const THROTTLE_MS = 100;
	/**
	 * OIDC implementation of a callback based workflow.
	 * @internal
	 */
	class CallbackWorkflow {
	    /**
	     * Instantiate the callback workflow.
	     */
	    constructor(cache, callback) {
	        this.cache = cache;
	        this.callback = this.withLock(callback);
	        this.lastExecutionTime = Date.now() - THROTTLE_MS;
	    }
	    /**
	     * Get the document to add for speculative authentication. This also needs
	     * to add a db field from the credentials source.
	     */
	    async speculativeAuth(connection, credentials) {
	        // Check if the Client Cache has an access token.
	        // If it does, cache the access token in the Connection Cache and send a JwtStepRequest
	        // with the cached access token in the speculative authentication SASL payload.
	        if (this.cache.hasAccessToken) {
	            const accessToken = this.cache.getAccessToken();
	            connection.accessToken = accessToken;
	            const document = (0, command_builders_1.finishCommandDocument)(accessToken);
	            document.db = credentials.source;
	            return { speculativeAuthenticate: document };
	        }
	        return {};
	    }
	    /**
	     * Reauthenticate the callback workflow. For this we invalidated the access token
	     * in the cache and run the authentication steps again. No initial handshake needs
	     * to be sent.
	     */
	    async reauthenticate(connection, credentials) {
	        if (this.cache.hasAccessToken) {
	            // Reauthentication implies the token has expired.
	            if (connection.accessToken === this.cache.getAccessToken()) {
	                // If connection's access token is the same as the cache's, remove
	                // the token from the cache and connection.
	                this.cache.removeAccessToken();
	                delete connection.accessToken;
	            }
	            else {
	                // If the connection's access token is different from the cache's, set
	                // the cache's token on the connection and do not remove from the
	                // cache.
	                connection.accessToken = this.cache.getAccessToken();
	            }
	        }
	        await this.execute(connection, credentials);
	    }
	    /**
	     * Starts the callback authentication process. If there is a speculative
	     * authentication document from the initial handshake, then we will use that
	     * value to get the issuer, otherwise we will send the saslStart command.
	     */
	    async startAuthentication(connection, credentials, response) {
	        let result;
	        if (response?.speculativeAuthenticate) {
	            result = response.speculativeAuthenticate;
	        }
	        else {
	            result = await connection.command((0, utils_1.ns)(credentials.source), (0, command_builders_1.startCommandDocument)(credentials), undefined);
	        }
	        return result;
	    }
	    /**
	     * Finishes the callback authentication process.
	     */
	    async finishAuthentication(connection, credentials, token, conversationId) {
	        await connection.command((0, utils_1.ns)(credentials.source), (0, command_builders_1.finishCommandDocument)(token, conversationId), undefined);
	    }
	    /**
	     * Executes the callback and validates the output.
	     */
	    async executeAndValidateCallback(params) {
	        const result = await this.callback(params);
	        // Validate that the result returned by the callback is acceptable. If it is not
	        // we must clear the token result from the cache.
	        if (isCallbackResultInvalid(result)) {
	            throw new error_1.MongoMissingCredentialsError(CALLBACK_RESULT_ERROR);
	        }
	        return result;
	    }
	    /**
	     * Ensure the callback is only executed one at a time and throttles the calls
	     * to every 100ms.
	     */
	    withLock(callback) {
	        let lock = Promise.resolve();
	        return async (params) => {
	            // We do this to ensure that we would never return the result of the
	            // previous lock, only the current callback's value would get returned.
	            await lock;
	            lock = lock
	                .catch(() => null)
	                .then(async () => {
	                const difference = Date.now() - this.lastExecutionTime;
	                if (difference <= THROTTLE_MS) {
	                    await (0, promises_1.setTimeout)(THROTTLE_MS - difference, { signal: params.timeoutContext });
	                }
	                this.lastExecutionTime = Date.now();
	                return await callback(params);
	            });
	            return await lock;
	        };
	    }
	}
	callback_workflow.CallbackWorkflow = CallbackWorkflow;
	/**
	 * Determines if a result returned from a request or refresh callback
	 * function is invalid. This means the result is nullish, doesn't contain
	 * the accessToken required field, and does not contain extra fields.
	 */
	function isCallbackResultInvalid(tokenResult) {
	    if (tokenResult == null || typeof tokenResult !== 'object')
	        return true;
	    if (!('accessToken' in tokenResult))
	        return true;
	    return !Object.getOwnPropertyNames(tokenResult).every(prop => RESULT_PROPERTIES.includes(prop));
	}
	
	return callback_workflow;
}

var hasRequiredAutomated_callback_workflow;

function requireAutomated_callback_workflow () {
	if (hasRequiredAutomated_callback_workflow) return automated_callback_workflow;
	hasRequiredAutomated_callback_workflow = 1;
	Object.defineProperty(automated_callback_workflow, "__esModule", { value: true });
	automated_callback_workflow.AutomatedCallbackWorkflow = void 0;
	const error_1 = requireError();
	const timeout_1 = requireTimeout();
	const mongodb_oidc_1 = requireMongodb_oidc();
	const callback_workflow_1 = requireCallback_workflow();
	/**
	 * Class implementing behaviour for the non human callback workflow.
	 * @internal
	 */
	class AutomatedCallbackWorkflow extends callback_workflow_1.CallbackWorkflow {
	    /**
	     * Instantiate the human callback workflow.
	     */
	    constructor(cache, callback) {
	        super(cache, callback);
	    }
	    /**
	     * Execute the OIDC callback workflow.
	     */
	    async execute(connection, credentials) {
	        // If there is a cached access token, try to authenticate with it. If
	        // authentication fails with an Authentication error (18),
	        // invalidate the access token, fetch a new access token, and try
	        // to authenticate again.
	        // If the server fails for any other reason, do not clear the cache.
	        if (this.cache.hasAccessToken) {
	            const token = this.cache.getAccessToken();
	            try {
	                return await this.finishAuthentication(connection, credentials, token);
	            }
	            catch (error) {
	                if (error instanceof error_1.MongoError &&
	                    error.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {
	                    this.cache.removeAccessToken();
	                    return await this.execute(connection, credentials);
	                }
	                else {
	                    throw error;
	                }
	            }
	        }
	        const response = await this.fetchAccessToken(credentials);
	        this.cache.put(response);
	        connection.accessToken = response.accessToken;
	        await this.finishAuthentication(connection, credentials, response.accessToken);
	    }
	    /**
	     * Fetches the access token using the callback.
	     */
	    async fetchAccessToken(credentials) {
	        const controller = new AbortController();
	        const params = {
	            timeoutContext: controller.signal,
	            version: mongodb_oidc_1.OIDC_VERSION
	        };
	        if (credentials.username) {
	            params.username = credentials.username;
	        }
	        const timeout = timeout_1.Timeout.expires(callback_workflow_1.AUTOMATED_TIMEOUT_MS);
	        try {
	            return await Promise.race([this.executeAndValidateCallback(params), timeout]);
	        }
	        catch (error) {
	            if (timeout_1.TimeoutError.is(error)) {
	                controller.abort();
	                throw new error_1.MongoOIDCError(`OIDC callback timed out after ${callback_workflow_1.AUTOMATED_TIMEOUT_MS}ms.`);
	            }
	            throw error;
	        }
	        finally {
	            timeout.clear();
	        }
	    }
	}
	automated_callback_workflow.AutomatedCallbackWorkflow = AutomatedCallbackWorkflow;
	
	return automated_callback_workflow;
}

var human_callback_workflow = {};

var hasRequiredHuman_callback_workflow;

function requireHuman_callback_workflow () {
	if (hasRequiredHuman_callback_workflow) return human_callback_workflow;
	hasRequiredHuman_callback_workflow = 1;
	Object.defineProperty(human_callback_workflow, "__esModule", { value: true });
	human_callback_workflow.HumanCallbackWorkflow = void 0;
	const bson_1 = requireBson$1();
	const error_1 = requireError();
	const timeout_1 = requireTimeout();
	const mongodb_oidc_1 = requireMongodb_oidc();
	const callback_workflow_1 = requireCallback_workflow();
	/**
	 * Class implementing behaviour for the non human callback workflow.
	 * @internal
	 */
	class HumanCallbackWorkflow extends callback_workflow_1.CallbackWorkflow {
	    /**
	     * Instantiate the human callback workflow.
	     */
	    constructor(cache, callback) {
	        super(cache, callback);
	    }
	    /**
	     * Execute the OIDC human callback workflow.
	     */
	    async execute(connection, credentials) {
	        // Check if the Client Cache has an access token.
	        // If it does, cache the access token in the Connection Cache and perform a One-Step SASL conversation
	        // using the access token. If the server returns an Authentication error (18),
	        // invalidate the access token token from the Client Cache, clear the Connection Cache,
	        // and restart the authentication flow. Raise any other errors to the user. On success, exit the algorithm.
	        if (this.cache.hasAccessToken) {
	            const token = this.cache.getAccessToken();
	            connection.accessToken = token;
	            try {
	                return await this.finishAuthentication(connection, credentials, token);
	            }
	            catch (error) {
	                if (error instanceof error_1.MongoError &&
	                    error.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {
	                    this.cache.removeAccessToken();
	                    delete connection.accessToken;
	                    return await this.execute(connection, credentials);
	                }
	                else {
	                    throw error;
	                }
	            }
	        }
	        // Check if the Client Cache has a refresh token.
	        // If it does, call the OIDC Human Callback with the cached refresh token and IdpInfo to get a
	        // new access token. Cache the new access token in the Client Cache and Connection Cache.
	        // Perform a One-Step SASL conversation using the new access token. If the the server returns
	        // an Authentication error (18), clear the refresh token, invalidate the access token from the
	        // Client Cache, clear the Connection Cache, and restart the authentication flow. Raise any other
	        // errors to the user. On success, exit the algorithm.
	        if (this.cache.hasRefreshToken) {
	            const refreshToken = this.cache.getRefreshToken();
	            const result = await this.fetchAccessToken(this.cache.getIdpInfo(), credentials, refreshToken);
	            this.cache.put(result);
	            connection.accessToken = result.accessToken;
	            try {
	                return await this.finishAuthentication(connection, credentials, result.accessToken);
	            }
	            catch (error) {
	                if (error instanceof error_1.MongoError &&
	                    error.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {
	                    this.cache.removeRefreshToken();
	                    delete connection.accessToken;
	                    return await this.execute(connection, credentials);
	                }
	                else {
	                    throw error;
	                }
	            }
	        }
	        // Start a new Two-Step SASL conversation.
	        // Run a PrincipalStepRequest to get the IdpInfo.
	        // Call the OIDC Human Callback with the new IdpInfo to get a new access token and optional refresh
	        // token. Drivers MUST NOT pass a cached refresh token to the callback when performing
	        // a new Two-Step conversation. Cache the new IdpInfo and refresh token in the Client Cache and the
	        // new access token in the Client Cache and Connection Cache.
	        // Attempt to authenticate using a JwtStepRequest with the new access token. Raise any errors to the user.
	        const startResponse = await this.startAuthentication(connection, credentials);
	        const conversationId = startResponse.conversationId;
	        const idpInfo = bson_1.BSON.deserialize(startResponse.payload.buffer);
	        const callbackResponse = await this.fetchAccessToken(idpInfo, credentials);
	        this.cache.put(callbackResponse, idpInfo);
	        connection.accessToken = callbackResponse.accessToken;
	        return await this.finishAuthentication(connection, credentials, callbackResponse.accessToken, conversationId);
	    }
	    /**
	     * Fetches an access token using the callback.
	     */
	    async fetchAccessToken(idpInfo, credentials, refreshToken) {
	        const controller = new AbortController();
	        const params = {
	            timeoutContext: controller.signal,
	            version: mongodb_oidc_1.OIDC_VERSION,
	            idpInfo: idpInfo
	        };
	        if (credentials.username) {
	            params.username = credentials.username;
	        }
	        if (refreshToken) {
	            params.refreshToken = refreshToken;
	        }
	        const timeout = timeout_1.Timeout.expires(callback_workflow_1.HUMAN_TIMEOUT_MS);
	        try {
	            return await Promise.race([this.executeAndValidateCallback(params), timeout]);
	        }
	        catch (error) {
	            if (timeout_1.TimeoutError.is(error)) {
	                controller.abort();
	                throw new error_1.MongoOIDCError(`OIDC callback timed out after ${callback_workflow_1.HUMAN_TIMEOUT_MS}ms.`);
	            }
	            throw error;
	        }
	        finally {
	            timeout.clear();
	        }
	    }
	}
	human_callback_workflow.HumanCallbackWorkflow = HumanCallbackWorkflow;
	
	return human_callback_workflow;
}

var plain = {};

var hasRequiredPlain;

function requirePlain () {
	if (hasRequiredPlain) return plain;
	hasRequiredPlain = 1;
	Object.defineProperty(plain, "__esModule", { value: true });
	plain.Plain = void 0;
	const bson_1 = requireBson();
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	const auth_provider_1 = requireAuth_provider();
	class Plain extends auth_provider_1.AuthProvider {
	    async auth(authContext) {
	        const { connection, credentials } = authContext;
	        if (!credentials) {
	            throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');
	        }
	        const { username, password } = credentials;
	        const payload = new bson_1.Binary(Buffer.from(`\x00${username}\x00${password}`));
	        const command = {
	            saslStart: 1,
	            mechanism: 'PLAIN',
	            payload: payload,
	            autoAuthorize: 1
	        };
	        await connection.command((0, utils_1.ns)('$external.$cmd'), command, undefined);
	    }
	}
	plain.Plain = Plain;
	
	return plain;
}

var scram = {};

var dist;
var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	const getCodePoint = (character) => character.codePointAt(0);
	const first = (x) => x[0];
	const last = (x) => x[x.length - 1];
	function toCodePoints(input) {
	    const codepoints = [];
	    const size = input.length;
	    for (let i = 0; i < size; i += 1) {
	        const before = input.charCodeAt(i);
	        if (before >= 0xd800 && before <= 0xdbff && size > i + 1) {
	            const next = input.charCodeAt(i + 1);
	            if (next >= 0xdc00 && next <= 0xdfff) {
	                codepoints.push((before - 0xd800) * 0x400 + next - 0xdc00 + 0x10000);
	                i += 1;
	                continue;
	            }
	        }
	        codepoints.push(before);
	    }
	    return codepoints;
	}
	function saslprep({ unassigned_code_points, commonly_mapped_to_nothing, non_ASCII_space_characters, prohibited_characters, bidirectional_r_al, bidirectional_l, }, input, opts = {}) {
	    const mapping2space = non_ASCII_space_characters;
	    const mapping2nothing = commonly_mapped_to_nothing;
	    if (typeof input !== 'string') {
	        throw new TypeError('Expected string.');
	    }
	    if (input.length === 0) {
	        return '';
	    }
	    const mapped_input = toCodePoints(input)
	        .map((character) => (mapping2space.get(character) ? 0x20 : character))
	        .filter((character) => !mapping2nothing.get(character));
	    const normalized_input = String.fromCodePoint
	        .apply(null, mapped_input)
	        .normalize('NFKC');
	    const normalized_map = toCodePoints(normalized_input);
	    const hasProhibited = normalized_map.some((character) => prohibited_characters.get(character));
	    if (hasProhibited) {
	        throw new Error('Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3');
	    }
	    if (opts.allowUnassigned !== true) {
	        const hasUnassigned = normalized_map.some((character) => unassigned_code_points.get(character));
	        if (hasUnassigned) {
	            throw new Error('Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5');
	        }
	    }
	    const hasBidiRAL = normalized_map.some((character) => bidirectional_r_al.get(character));
	    const hasBidiL = normalized_map.some((character) => bidirectional_l.get(character));
	    if (hasBidiRAL && hasBidiL) {
	        throw new Error('String must not contain RandALCat and LCat at the same time,' +
	            ' see https://tools.ietf.org/html/rfc3454#section-6');
	    }
	    const isFirstBidiRAL = bidirectional_r_al.get(getCodePoint(first(normalized_input)));
	    const isLastBidiRAL = bidirectional_r_al.get(getCodePoint(last(normalized_input)));
	    if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {
	        throw new Error('Bidirectional RandALCat character must be the first and the last' +
	            ' character of the string, see https://tools.ietf.org/html/rfc3454#section-6');
	    }
	    return normalized_input;
	}
	saslprep.saslprep = saslprep;
	saslprep.default = saslprep;
	dist = saslprep;
	
	return dist;
}

var memoryCodePoints = {};

var memoryPager;
var hasRequiredMemoryPager;

function requireMemoryPager () {
	if (hasRequiredMemoryPager) return memoryPager;
	hasRequiredMemoryPager = 1;
	memoryPager = Pager;

	function Pager (pageSize, opts) {
	  if (!(this instanceof Pager)) return new Pager(pageSize, opts)

	  this.length = 0;
	  this.updates = [];
	  this.path = new Uint16Array(4);
	  this.pages = new Array(32768);
	  this.maxPages = this.pages.length;
	  this.level = 0;
	  this.pageSize = pageSize || 1024;
	  this.deduplicate = opts ? opts.deduplicate : null;
	  this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null;
	}

	Pager.prototype.updated = function (page) {
	  while (this.deduplicate && page.buffer[page.deduplicate] === this.deduplicate[page.deduplicate]) {
	    page.deduplicate++;
	    if (page.deduplicate === this.deduplicate.length) {
	      page.deduplicate = 0;
	      if (page.buffer.equals && page.buffer.equals(this.deduplicate)) page.buffer = this.deduplicate;
	      break
	    }
	  }
	  if (page.updated || !this.updates) return
	  page.updated = true;
	  this.updates.push(page);
	};

	Pager.prototype.lastUpdate = function () {
	  if (!this.updates || !this.updates.length) return null
	  var page = this.updates.pop();
	  page.updated = false;
	  return page
	};

	Pager.prototype._array = function (i, noAllocate) {
	  if (i >= this.maxPages) {
	    if (noAllocate) return
	    grow(this, i);
	  }

	  factor(i, this.path);

	  var arr = this.pages;

	  for (var j = this.level; j > 0; j--) {
	    var p = this.path[j];
	    var next = arr[p];

	    if (!next) {
	      if (noAllocate) return
	      next = arr[p] = new Array(32768);
	    }

	    arr = next;
	  }

	  return arr
	};

	Pager.prototype.get = function (i, noAllocate) {
	  var arr = this._array(i, noAllocate);
	  var first = this.path[0];
	  var page = arr && arr[first];

	  if (!page && !noAllocate) {
	    page = arr[first] = new Page(i, alloc(this.pageSize));
	    if (i >= this.length) this.length = i + 1;
	  }

	  if (page && page.buffer === this.deduplicate && this.deduplicate && !noAllocate) {
	    page.buffer = copy(page.buffer);
	    page.deduplicate = 0;
	  }

	  return page
	};

	Pager.prototype.set = function (i, buf) {
	  var arr = this._array(i, false);
	  var first = this.path[0];

	  if (i >= this.length) this.length = i + 1;

	  if (!buf || (this.zeros && buf.equals && buf.equals(this.zeros))) {
	    arr[first] = undefined;
	    return
	  }

	  if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {
	    buf = this.deduplicate;
	  }

	  var page = arr[first];
	  var b = truncate(buf, this.pageSize);

	  if (page) page.buffer = b;
	  else arr[first] = new Page(i, b);
	};

	Pager.prototype.toBuffer = function () {
	  var list = new Array(this.length);
	  var empty = alloc(this.pageSize);
	  var ptr = 0;

	  while (ptr < list.length) {
	    var arr = this._array(ptr, true);
	    for (var i = 0; i < 32768 && ptr < list.length; i++) {
	      list[ptr++] = (arr && arr[i]) ? arr[i].buffer : empty;
	    }
	  }

	  return Buffer.concat(list)
	};

	function grow (pager, index) {
	  while (pager.maxPages < index) {
	    var old = pager.pages;
	    pager.pages = new Array(32768);
	    pager.pages[0] = old;
	    pager.level++;
	    pager.maxPages *= 32768;
	  }
	}

	function truncate (buf, len) {
	  if (buf.length === len) return buf
	  if (buf.length > len) return buf.slice(0, len)
	  var cpy = alloc(len);
	  buf.copy(cpy);
	  return cpy
	}

	function alloc (size) {
	  if (Buffer.alloc) return Buffer.alloc(size)
	  var buf = new Buffer(size);
	  buf.fill(0);
	  return buf
	}

	function copy (buf) {
	  var cpy = Buffer.allocUnsafe ? Buffer.allocUnsafe(buf.length) : new Buffer(buf.length);
	  buf.copy(cpy);
	  return cpy
	}

	function Page (i, buf) {
	  this.offset = i * buf.length;
	  this.buffer = buf;
	  this.updated = false;
	  this.deduplicate = 0;
	}

	function factor (n, out) {
	  n = (n - (out[0] = (n & 32767))) / 32768;
	  n = (n - (out[1] = (n & 32767))) / 32768;
	  out[3] = ((n - (out[2] = (n & 32767))) / 32768) & 32767;
	}
	return memoryPager;
}

var sparseBitfield;
var hasRequiredSparseBitfield;

function requireSparseBitfield () {
	if (hasRequiredSparseBitfield) return sparseBitfield;
	hasRequiredSparseBitfield = 1;
	var pager = requireMemoryPager();

	sparseBitfield = Bitfield;

	function Bitfield (opts) {
	  if (!(this instanceof Bitfield)) return new Bitfield(opts)
	  if (!opts) opts = {};
	  if (Buffer.isBuffer(opts)) opts = {buffer: opts};

	  this.pageOffset = opts.pageOffset || 0;
	  this.pageSize = opts.pageSize || 1024;
	  this.pages = opts.pages || pager(this.pageSize);

	  this.byteLength = this.pages.length * this.pageSize;
	  this.length = 8 * this.byteLength;

	  if (!powerOfTwo(this.pageSize)) throw new Error('The page size should be a power of two')

	  this._trackUpdates = !!opts.trackUpdates;
	  this._pageMask = this.pageSize - 1;

	  if (opts.buffer) {
	    for (var i = 0; i < opts.buffer.length; i += this.pageSize) {
	      this.pages.set(i / this.pageSize, opts.buffer.slice(i, i + this.pageSize));
	    }
	    this.byteLength = opts.buffer.length;
	    this.length = 8 * this.byteLength;
	  }
	}

	Bitfield.prototype.get = function (i) {
	  var o = i & 7;
	  var j = (i - o) / 8;

	  return !!(this.getByte(j) & (128 >> o))
	};

	Bitfield.prototype.getByte = function (i) {
	  var o = i & this._pageMask;
	  var j = (i - o) / this.pageSize;
	  var page = this.pages.get(j, true);

	  return page ? page.buffer[o + this.pageOffset] : 0
	};

	Bitfield.prototype.set = function (i, v) {
	  var o = i & 7;
	  var j = (i - o) / 8;
	  var b = this.getByte(j);

	  return this.setByte(j, v ? b | (128 >> o) : b & (255 ^ (128 >> o)))
	};

	Bitfield.prototype.toBuffer = function () {
	  var all = alloc(this.pages.length * this.pageSize);

	  for (var i = 0; i < this.pages.length; i++) {
	    var next = this.pages.get(i, true);
	    var allOffset = i * this.pageSize;
	    if (next) next.buffer.copy(all, allOffset, this.pageOffset, this.pageOffset + this.pageSize);
	  }

	  return all
	};

	Bitfield.prototype.setByte = function (i, b) {
	  var o = i & this._pageMask;
	  var j = (i - o) / this.pageSize;
	  var page = this.pages.get(j, false);

	  o += this.pageOffset;

	  if (page.buffer[o] === b) return false
	  page.buffer[o] = b;

	  if (i >= this.byteLength) {
	    this.byteLength = i + 1;
	    this.length = this.byteLength * 8;
	  }

	  if (this._trackUpdates) this.pages.updated(page);

	  return true
	};

	function alloc (n) {
	  if (Buffer.alloc) return Buffer.alloc(n)
	  var b = new Buffer(n);
	  b.fill(0);
	  return b
	}

	function powerOfTwo (x) {
	  return !(x & (x - 1))
	}
	return sparseBitfield;
}

var hasRequiredMemoryCodePoints;

function requireMemoryCodePoints () {
	if (hasRequiredMemoryCodePoints) return memoryCodePoints;
	hasRequiredMemoryCodePoints = 1;
	var __importDefault = (memoryCodePoints.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(memoryCodePoints, "__esModule", { value: true });
	memoryCodePoints.createMemoryCodePoints = void 0;
	const sparse_bitfield_1 = __importDefault(requireSparseBitfield());
	function createMemoryCodePoints(data) {
	    let offset = 0;
	    function read() {
	        const size = data.readUInt32BE(offset);
	        offset += 4;
	        const codepoints = data.slice(offset, offset + size);
	        offset += size;
	        return (0, sparse_bitfield_1.default)({ buffer: codepoints });
	    }
	    const unassigned_code_points = read();
	    const commonly_mapped_to_nothing = read();
	    const non_ASCII_space_characters = read();
	    const prohibited_characters = read();
	    const bidirectional_r_al = read();
	    const bidirectional_l = read();
	    return {
	        unassigned_code_points,
	        commonly_mapped_to_nothing,
	        non_ASCII_space_characters,
	        prohibited_characters,
	        bidirectional_r_al,
	        bidirectional_l,
	    };
	}
	memoryCodePoints.createMemoryCodePoints = createMemoryCodePoints;
	
	return memoryCodePoints;
}

var codePointsData = {};

var hasRequiredCodePointsData;

function requireCodePointsData () {
	if (hasRequiredCodePointsData) return codePointsData;
	hasRequiredCodePointsData = 1;
	Object.defineProperty(codePointsData, "__esModule", { value: true });
	const zlib_1 = zlib;
	codePointsData.default = (0, zlib_1.gunzipSync)(Buffer.from('H4sIAAAAAAACA+3dTYgcaRkA4LemO9Mhxm0FITnE9Cwr4jHgwgZ22B6YywqCJ0HQg5CL4sGTuOjCtGSF4CkHEW856MlTQHD3EJnWkU0Owh5VxE3LHlYQdNxd2U6mU59UV/d09fw4M2EySSXPAzNdP1/9fX/99bzVNZEN4jisRDulVFnQmLxm1aXF9Id/2/xMxNJ4XZlg576yuYlGt9gupV6xoFf8jhu9YvulVrFlp5XSx+lfvYhORGPXvqIRWSxERKtIm8bKFd10WNfKDS5Fo9jJWrq2+M2IlW+8uHgl/+BsROfPF4v5L7148Ur68Sha6dqZpYiVVy8tvLCWXo80Sf/lS89dGX2wHGvpzoXVn75/YWH5wmqe8uika82ViJXTy83Ve2k5Urozm38wm4/ls6t5uT6yfsTSJ7J3T0VKt8c5ExEXI8aFkH729c3eT+7EC6ca8cVULZUiYacX0R5PNWNxlh9L1y90q5kyzrpyy+9WcvOV6URntqw7La9sNVstXyczWVaWYbaaTYqzOHpr7pyiNT3/YzKuT63Z/FqKZlFTiuXtFM2vVOtIq7jiyKJbWZaOWD0euz0yoV2Z7kY0xq2x0YhfzVpmM5px9nTEH7JZ0ot5u39p0ma75Z472/s/H+2yr2inYyuq7fMvJivH2rM72N/Z3lyL31F2b1ya1P0zn816k2KP6JU9UzseucdQH5YqVeH/lFajSN2udg+TLJ9rksNxlvV2lki19rXKI43TPLejFu4ov7k3nMbhyhfY3Xb37f8BAGCf0eMTOH5szf154KmnNgKcnLb+Fzi2AfXktbN7fJelwTAiO/W5uQ2KINXRYu+znqo/WTAdLadURHmy3qciazd3bra4T3w16/f7t7Ms9U5gfJu10955sx1r3vmhBAAAAAAAgId20J1iZbDowNvIjuH427Gr5l/eiC+8OplZON8sVjx/qr9y+Pj+YRItT+NqAM+kkZs3AAAAAID6yfx1FwCAI97/dCh1/ub6SA0AAAAAAAAAgNoT/wcAAAAAAACA+hP/BwAAAAAAAID6E/8HAAAAAAAAgPoT/wcAAAAAAACA+hP/BwAAAAAAAID6E/8HAAAAAAAAgPoT/wcAAAAAAACA+hP/BwAAAAAAAID6E/8HAAAAAAAAgPoT/wcAAAAAAACA+hutp5SiQpYAAAAAAAAAQO2MIpZiT804flnAE2fhwjOeAZXr76kOAAAAAAAA8FjNf4N/l0NE3U/vuVQskLpSd4/Yh2xu9xTu0tFeeNYsLI2f/VMdNxTzj6Je9E/+6pp6Nn3awW3A54goe4Bss6v+PGsjQGMAAAAAAOBp5XEgwH6e7J7rwEQHRb/XvAMAAAAAAAA8yzoDeQDwVGjIAgAAAAAAAACoPfF/AAAAAAAAAKg/8X8AAAAAAAAAqD/xfwAAAAAAAACoP/F/AAAAAAAAAKg/8X8AAAAAAAAAqD/xfwAAAAAAAACoP/F/AAAAAAAAAKg/8X8AAAAAAAAAqD/xfwAAAAAAAACoP/F/AAAAAAAAAKg/8X8AAAAAAAAAqL/GSkSkClkCAAAAAAAAALXTSAAAAAAAAABA3Y1kAQAAAAAAAADUX8RSXZ9dsHC9+M8Fg2Ex/em1lAZpEBGttcrVjZqLEa+k0XpKw9mG4zWx4ukPUMhkAQAAAAAAABzBqbSe3//rXOS9HxGdo4TqR2XkutCdBu+LaPZw/lBbO7cbHnh2C7N7AIo4evEznllqLqWUp/LnYOtpM2bnOH66wI1+9GO4sOuISwv/TOlumu56FDv3NZhc4mR9v7zYIrafr40j/Cccvj9Xns3t3mu99E7qxUv3bqS0/ouNH/08++RGemfQ+nsx/5uNXsQPGulynPvv3ZTW37zd+1ovrqaYpP/122X6Xpx779Z3zr/3YOPKW1lkaRDf31pPaf3j/msRsVGkL+d/f+/m4sJsPm1cfSsr16e8m9Ldj/KsnyIuR3nXw83Is3EhxLd/2V773ks3m/cj/THKUummdP9qKhIOImuOU0Xjwb3y+oqt735rpTetVbF9n8R4x9crRfO77TKqVOZpDclv5bfK18lMnk+q0K18UpxF/RrGXE0Zxtqx3tWSj+vxbL4XaasfKb0dRbtLW73JsfPGg177H+OmGKlfvS1msllt7JEJm9XOJqXR+Fkfo1H66uy5H1v3Xx5+uJmGLw9jro2u7Loj4PnuR6+f+e3d261+eazNhzrL7X83MohoHpS4PddV8ki1it61//pw1g7z6p1U/26Nm2llST57B5rUvuG0XqSU/rPd7jYrqWcbd+beJQ77BgPMDwn37/8BAGCf0eMTOH4cPlufv9VGgJOzqf8Fjm1APXkd7B7f5dF57GPMaWy/MTvjvNvtXj6h8W2+GXvnzXaseeeHEgAAAAAAAB7aQXeKlcGiadBoEOeLb2dtpGOL2MyOtf391a3P/zD96c3JzIP3t4oV797vrh8+vn+YRL5bBuj/AQAAAABqJvfHXQAAHkX82zfXAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACeAgkAAAAAAAAAqLuRLAAAAAAAAACA2hv9D1iu/VAYaAYA', 'base64'));
	
	return codePointsData;
}

var node;
var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node;
	hasRequiredNode = 1;
	var __importDefault = (node && node.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	const index_1 = __importDefault(requireDist());
	const memory_code_points_1 = requireMemoryCodePoints();
	const code_points_data_1 = __importDefault(requireCodePointsData());
	const codePoints = (0, memory_code_points_1.createMemoryCodePoints)(code_points_data_1.default);
	function saslprep(input, opts) {
	    return (0, index_1.default)(codePoints, input, opts);
	}
	saslprep.saslprep = saslprep;
	saslprep.default = saslprep;
	node = saslprep;
	
	return node;
}

var hasRequiredScram;

function requireScram () {
	if (hasRequiredScram) return scram;
	hasRequiredScram = 1;
	Object.defineProperty(scram, "__esModule", { value: true });
	scram.ScramSHA256 = scram.ScramSHA1 = void 0;
	const saslprep_1 = requireNode();
	const crypto = require$$0$c;
	const bson_1 = requireBson();
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	const auth_provider_1 = requireAuth_provider();
	const providers_1 = requireProviders$1();
	class ScramSHA extends auth_provider_1.AuthProvider {
	    constructor(cryptoMethod) {
	        super();
	        this.cryptoMethod = cryptoMethod || 'sha1';
	    }
	    async prepare(handshakeDoc, authContext) {
	        const cryptoMethod = this.cryptoMethod;
	        const credentials = authContext.credentials;
	        if (!credentials) {
	            throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');
	        }
	        const nonce = await (0, utils_1.randomBytes)(24);
	        // store the nonce for later use
	        authContext.nonce = nonce;
	        const request = {
	            ...handshakeDoc,
	            speculativeAuthenticate: {
	                ...makeFirstMessage(cryptoMethod, credentials, nonce),
	                db: credentials.source
	            }
	        };
	        return request;
	    }
	    async auth(authContext) {
	        const { reauthenticating, response } = authContext;
	        if (response?.speculativeAuthenticate && !reauthenticating) {
	            return await continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext);
	        }
	        return await executeScram(this.cryptoMethod, authContext);
	    }
	}
	function cleanUsername(username) {
	    return username.replace('=', '=3D').replace(',', '=2C');
	}
	function clientFirstMessageBare(username, nonce) {
	    // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.
	    // Since the username is not sasl-prep-d, we need to do this here.
	    return Buffer.concat([
	        Buffer.from('n=', 'utf8'),
	        Buffer.from(username, 'utf8'),
	        Buffer.from(',r=', 'utf8'),
	        Buffer.from(nonce.toString('base64'), 'utf8')
	    ]);
	}
	function makeFirstMessage(cryptoMethod, credentials, nonce) {
	    const username = cleanUsername(credentials.username);
	    const mechanism = cryptoMethod === 'sha1' ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA256;
	    // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.
	    // Since the username is not sasl-prep-d, we need to do this here.
	    return {
	        saslStart: 1,
	        mechanism,
	        payload: new bson_1.Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),
	        autoAuthorize: 1,
	        options: { skipEmptyExchange: true }
	    };
	}
	async function executeScram(cryptoMethod, authContext) {
	    const { connection, credentials } = authContext;
	    if (!credentials) {
	        throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');
	    }
	    if (!authContext.nonce) {
	        throw new error_1.MongoInvalidArgumentError('AuthContext must contain a valid nonce property');
	    }
	    const nonce = authContext.nonce;
	    const db = credentials.source;
	    const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
	    const response = await connection.command((0, utils_1.ns)(`${db}.$cmd`), saslStartCmd, undefined);
	    await continueScramConversation(cryptoMethod, response, authContext);
	}
	async function continueScramConversation(cryptoMethod, response, authContext) {
	    const connection = authContext.connection;
	    const credentials = authContext.credentials;
	    if (!credentials) {
	        throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');
	    }
	    if (!authContext.nonce) {
	        throw new error_1.MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce');
	    }
	    const nonce = authContext.nonce;
	    const db = credentials.source;
	    const username = cleanUsername(credentials.username);
	    const password = credentials.password;
	    const processedPassword = cryptoMethod === 'sha256' ? (0, saslprep_1.saslprep)(password) : passwordDigest(username, password);
	    const payload = Buffer.isBuffer(response.payload)
	        ? new bson_1.Binary(response.payload)
	        : response.payload;
	    const dict = parsePayload(payload);
	    const iterations = parseInt(dict.i, 10);
	    if (iterations && iterations < 4096) {
	        // TODO(NODE-3483)
	        throw new error_1.MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`);
	    }
	    const salt = dict.s;
	    const rnonce = dict.r;
	    if (rnonce.startsWith('nonce')) {
	        // TODO(NODE-3483)
	        throw new error_1.MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`);
	    }
	    // Set up start of proof
	    const withoutProof = `c=biws,r=${rnonce}`;
	    const saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);
	    const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');
	    const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');
	    const storedKey = H(cryptoMethod, clientKey);
	    const authMessage = [
	        clientFirstMessageBare(username, nonce),
	        payload.toString('utf8'),
	        withoutProof
	    ].join(',');
	    const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
	    const clientProof = `p=${xor(clientKey, clientSignature)}`;
	    const clientFinal = [withoutProof, clientProof].join(',');
	    const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
	    const saslContinueCmd = {
	        saslContinue: 1,
	        conversationId: response.conversationId,
	        payload: new bson_1.Binary(Buffer.from(clientFinal))
	    };
	    const r = await connection.command((0, utils_1.ns)(`${db}.$cmd`), saslContinueCmd, undefined);
	    const parsedResponse = parsePayload(r.payload);
	    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {
	        throw new error_1.MongoRuntimeError('Server returned an invalid signature');
	    }
	    if (r.done !== false) {
	        // If the server sends r.done === true we can save one RTT
	        return;
	    }
	    const retrySaslContinueCmd = {
	        saslContinue: 1,
	        conversationId: r.conversationId,
	        payload: Buffer.alloc(0)
	    };
	    await connection.command((0, utils_1.ns)(`${db}.$cmd`), retrySaslContinueCmd, undefined);
	}
	function parsePayload(payload) {
	    const payloadStr = payload.toString('utf8');
	    const dict = {};
	    const parts = payloadStr.split(',');
	    for (let i = 0; i < parts.length; i++) {
	        const valueParts = (parts[i].match(/^([^=]*)=(.*)$/) ?? []).slice(1);
	        dict[valueParts[0]] = valueParts[1];
	    }
	    return dict;
	}
	function passwordDigest(username, password) {
	    if (typeof username !== 'string') {
	        throw new error_1.MongoInvalidArgumentError('Username must be a string');
	    }
	    if (typeof password !== 'string') {
	        throw new error_1.MongoInvalidArgumentError('Password must be a string');
	    }
	    if (password.length === 0) {
	        throw new error_1.MongoInvalidArgumentError('Password cannot be empty');
	    }
	    let md5;
	    try {
	        md5 = crypto.createHash('md5');
	    }
	    catch (err) {
	        if (crypto.getFips()) {
	            // This error is (slightly) more helpful than what comes from OpenSSL directly, e.g.
	            // 'Error: error:060800C8:digital envelope routines:EVP_DigestInit_ex:disabled for FIPS'
	            throw new Error('Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode');
	        }
	        throw err;
	    }
	    md5.update(`${username}:mongo:${password}`, 'utf8');
	    return md5.digest('hex');
	}
	// XOR two buffers
	function xor(a, b) {
	    if (!Buffer.isBuffer(a)) {
	        a = Buffer.from(a);
	    }
	    if (!Buffer.isBuffer(b)) {
	        b = Buffer.from(b);
	    }
	    const length = Math.max(a.length, b.length);
	    const res = [];
	    for (let i = 0; i < length; i += 1) {
	        res.push(a[i] ^ b[i]);
	    }
	    return Buffer.from(res).toString('base64');
	}
	function H(method, text) {
	    return crypto.createHash(method).update(text).digest();
	}
	function HMAC(method, key, text) {
	    return crypto.createHmac(method, key).update(text).digest();
	}
	let _hiCache = {};
	let _hiCacheCount = 0;
	function _hiCachePurge() {
	    _hiCache = {};
	    _hiCacheCount = 0;
	}
	const hiLengthMap = {
	    sha256: 32,
	    sha1: 20
	};
	function HI(data, salt, iterations, cryptoMethod) {
	    // omit the work if already generated
	    const key = [data, salt.toString('base64'), iterations].join('_');
	    if (_hiCache[key] != null) {
	        return _hiCache[key];
	    }
	    // generate the salt
	    const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);
	    // cache a copy to speed up the next lookup, but prevent unbounded cache growth
	    if (_hiCacheCount >= 200) {
	        _hiCachePurge();
	    }
	    _hiCache[key] = saltedData;
	    _hiCacheCount += 1;
	    return saltedData;
	}
	function compareDigest(lhs, rhs) {
	    if (lhs.length !== rhs.length) {
	        return false;
	    }
	    if (typeof crypto.timingSafeEqual === 'function') {
	        return crypto.timingSafeEqual(lhs, rhs);
	    }
	    let result = 0;
	    for (let i = 0; i < lhs.length; i++) {
	        result |= lhs[i] ^ rhs[i];
	    }
	    return result === 0;
	}
	class ScramSHA1 extends ScramSHA {
	    constructor() {
	        super('sha1');
	    }
	}
	scram.ScramSHA1 = ScramSHA1;
	class ScramSHA256 extends ScramSHA {
	    constructor() {
	        super('sha256');
	    }
	}
	scram.ScramSHA256 = ScramSHA256;
	
	return scram;
}

var x509 = {};

var hasRequiredX509;

function requireX509 () {
	if (hasRequiredX509) return x509;
	hasRequiredX509 = 1;
	Object.defineProperty(x509, "__esModule", { value: true });
	x509.X509 = void 0;
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	const auth_provider_1 = requireAuth_provider();
	class X509 extends auth_provider_1.AuthProvider {
	    async prepare(handshakeDoc, authContext) {
	        const { credentials } = authContext;
	        if (!credentials) {
	            throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');
	        }
	        return { ...handshakeDoc, speculativeAuthenticate: x509AuthenticateCommand(credentials) };
	    }
	    async auth(authContext) {
	        const connection = authContext.connection;
	        const credentials = authContext.credentials;
	        if (!credentials) {
	            throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');
	        }
	        const response = authContext.response;
	        if (response?.speculativeAuthenticate) {
	            return;
	        }
	        await connection.command((0, utils_1.ns)('$external.$cmd'), x509AuthenticateCommand(credentials), undefined);
	    }
	}
	x509.X509 = X509;
	function x509AuthenticateCommand(credentials) {
	    const command = { authenticate: 1, mechanism: 'MONGODB-X509' };
	    if (credentials.username) {
	        command.user = credentials.username;
	    }
	    return command;
	}
	
	return x509;
}

var hasRequiredMongo_client_auth_providers;

function requireMongo_client_auth_providers () {
	if (hasRequiredMongo_client_auth_providers) return mongo_client_auth_providers;
	hasRequiredMongo_client_auth_providers = 1;
	Object.defineProperty(mongo_client_auth_providers, "__esModule", { value: true });
	mongo_client_auth_providers.MongoClientAuthProviders = void 0;
	const gssapi_1 = requireGssapi();
	const mongocr_1 = requireMongocr();
	const mongodb_aws_1 = requireMongodb_aws();
	const mongodb_oidc_1 = requireMongodb_oidc();
	const automated_callback_workflow_1 = requireAutomated_callback_workflow();
	const human_callback_workflow_1 = requireHuman_callback_workflow();
	const token_cache_1 = requireToken_cache();
	const plain_1 = requirePlain();
	const providers_1 = requireProviders$1();
	const scram_1 = requireScram();
	const x509_1 = requireX509();
	const error_1 = requireError();
	/** @internal */
	const AUTH_PROVIDERS = new Map([
	    [providers_1.AuthMechanism.MONGODB_AWS, () => new mongodb_aws_1.MongoDBAWS()],
	    [providers_1.AuthMechanism.MONGODB_CR, () => new mongocr_1.MongoCR()],
	    [providers_1.AuthMechanism.MONGODB_GSSAPI, () => new gssapi_1.GSSAPI()],
	    [providers_1.AuthMechanism.MONGODB_OIDC, (workflow) => new mongodb_oidc_1.MongoDBOIDC(workflow)],
	    [providers_1.AuthMechanism.MONGODB_PLAIN, () => new plain_1.Plain()],
	    [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, () => new scram_1.ScramSHA1()],
	    [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, () => new scram_1.ScramSHA256()],
	    [providers_1.AuthMechanism.MONGODB_X509, () => new x509_1.X509()]
	]);
	/**
	 * Create a set of providers per client
	 * to avoid sharing the provider's cache between different clients.
	 * @internal
	 */
	class MongoClientAuthProviders {
	    constructor() {
	        this.existingProviders = new Map();
	    }
	    /**
	     * Get or create an authentication provider based on the provided mechanism.
	     * We don't want to create all providers at once, as some providers may not be used.
	     * @param name - The name of the provider to get or create.
	     * @param credentials - The credentials.
	     * @returns The provider.
	     * @throws MongoInvalidArgumentError if the mechanism is not supported.
	     * @internal
	     */
	    getOrCreateProvider(name, authMechanismProperties) {
	        const authProvider = this.existingProviders.get(name);
	        if (authProvider) {
	            return authProvider;
	        }
	        const providerFunction = AUTH_PROVIDERS.get(name);
	        if (!providerFunction) {
	            throw new error_1.MongoInvalidArgumentError(`authMechanism ${name} not supported`);
	        }
	        let provider;
	        if (name === providers_1.AuthMechanism.MONGODB_OIDC) {
	            provider = providerFunction(this.getWorkflow(authMechanismProperties));
	        }
	        else {
	            provider = providerFunction();
	        }
	        this.existingProviders.set(name, provider);
	        return provider;
	    }
	    /**
	     * Gets either a device workflow or callback workflow.
	     */
	    getWorkflow(authMechanismProperties) {
	        if (authMechanismProperties.OIDC_HUMAN_CALLBACK) {
	            return new human_callback_workflow_1.HumanCallbackWorkflow(new token_cache_1.TokenCache(), authMechanismProperties.OIDC_HUMAN_CALLBACK);
	        }
	        else if (authMechanismProperties.OIDC_CALLBACK) {
	            return new automated_callback_workflow_1.AutomatedCallbackWorkflow(new token_cache_1.TokenCache(), authMechanismProperties.OIDC_CALLBACK);
	        }
	        else {
	            const environment = authMechanismProperties.ENVIRONMENT;
	            const workflow = mongodb_oidc_1.OIDC_WORKFLOWS.get(environment)?.();
	            if (!workflow) {
	                throw new error_1.MongoInvalidArgumentError(`Could not load workflow for environment ${authMechanismProperties.ENVIRONMENT}`);
	            }
	            return workflow;
	        }
	    }
	}
	mongo_client_auth_providers.MongoClientAuthProviders = MongoClientAuthProviders;
	
	return mongo_client_auth_providers;
}

var topology = {};

var server_selection_events = {};

var hasRequiredServer_selection_events;

function requireServer_selection_events () {
	if (hasRequiredServer_selection_events) return server_selection_events;
	hasRequiredServer_selection_events = 1;
	Object.defineProperty(server_selection_events, "__esModule", { value: true });
	server_selection_events.WaitingForSuitableServerEvent = server_selection_events.ServerSelectionSucceededEvent = server_selection_events.ServerSelectionFailedEvent = server_selection_events.ServerSelectionStartedEvent = server_selection_events.ServerSelectionEvent = void 0;
	const utils_1 = requireUtils$1();
	const constants_1 = requireConstants();
	/**
	 * The base export class for all logs published from server selection
	 * @internal
	 * @category Log Type
	 */
	class ServerSelectionEvent {
	    /** @internal */
	    constructor(selector, topologyDescription, operation) {
	        this.selector = selector;
	        this.operation = operation;
	        this.topologyDescription = topologyDescription;
	    }
	}
	server_selection_events.ServerSelectionEvent = ServerSelectionEvent;
	/**
	 * An event published when server selection starts
	 * @internal
	 * @category Event
	 */
	class ServerSelectionStartedEvent extends ServerSelectionEvent {
	    /** @internal */
	    constructor(selector, topologyDescription, operation) {
	        super(selector, topologyDescription, operation);
	        /** @internal */
	        this.name = constants_1.SERVER_SELECTION_STARTED;
	        this.message = 'Server selection started';
	    }
	}
	server_selection_events.ServerSelectionStartedEvent = ServerSelectionStartedEvent;
	/**
	 * An event published when a server selection fails
	 * @internal
	 * @category Event
	 */
	class ServerSelectionFailedEvent extends ServerSelectionEvent {
	    /** @internal */
	    constructor(selector, topologyDescription, error, operation) {
	        super(selector, topologyDescription, operation);
	        /** @internal */
	        this.name = constants_1.SERVER_SELECTION_FAILED;
	        this.message = 'Server selection failed';
	        this.failure = error;
	    }
	}
	server_selection_events.ServerSelectionFailedEvent = ServerSelectionFailedEvent;
	/**
	 * An event published when server selection succeeds
	 * @internal
	 * @category Event
	 */
	class ServerSelectionSucceededEvent extends ServerSelectionEvent {
	    /** @internal */
	    constructor(selector, topologyDescription, address, operation) {
	        super(selector, topologyDescription, operation);
	        /** @internal */
	        this.name = constants_1.SERVER_SELECTION_SUCCEEDED;
	        this.message = 'Server selection succeeded';
	        const { host, port } = utils_1.HostAddress.fromString(address).toHostPort();
	        this.serverHost = host;
	        this.serverPort = port;
	    }
	}
	server_selection_events.ServerSelectionSucceededEvent = ServerSelectionSucceededEvent;
	/**
	 * An event published when server selection is waiting for a suitable server to become available
	 * @internal
	 * @category Event
	 */
	class WaitingForSuitableServerEvent extends ServerSelectionEvent {
	    /** @internal */
	    constructor(selector, topologyDescription, remainingTimeMS, operation) {
	        super(selector, topologyDescription, operation);
	        /** @internal */
	        this.name = constants_1.WAITING_FOR_SUITABLE_SERVER;
	        this.message = 'Waiting for suitable server to become available';
	        this.remainingTimeMS = remainingTimeMS;
	    }
	}
	server_selection_events.WaitingForSuitableServerEvent = WaitingForSuitableServerEvent;
	
	return server_selection_events;
}

var srv_polling = {};

var hasRequiredSrv_polling;

function requireSrv_polling () {
	if (hasRequiredSrv_polling) return srv_polling;
	hasRequiredSrv_polling = 1;
	Object.defineProperty(srv_polling, "__esModule", { value: true });
	srv_polling.SrvPoller = srv_polling.SrvPollingEvent = void 0;
	const dns = require$$0$e;
	const timers_1 = require$$0$d;
	const error_1 = requireError();
	const mongo_types_1 = requireMongo_types();
	const utils_1 = requireUtils$1();
	/**
	 * @internal
	 * @category Event
	 */
	class SrvPollingEvent {
	    constructor(srvRecords) {
	        this.srvRecords = srvRecords;
	    }
	    hostnames() {
	        return new Set(this.srvRecords.map(r => utils_1.HostAddress.fromSrvRecord(r).toString()));
	    }
	}
	srv_polling.SrvPollingEvent = SrvPollingEvent;
	/** @internal */
	class SrvPoller extends mongo_types_1.TypedEventEmitter {
	    constructor(options) {
	        super();
	        if (!options || !options.srvHost) {
	            throw new error_1.MongoRuntimeError('Options for SrvPoller must exist and include srvHost');
	        }
	        this.srvHost = options.srvHost;
	        this.srvMaxHosts = options.srvMaxHosts ?? 0;
	        this.srvServiceName = options.srvServiceName ?? 'mongodb';
	        this.rescanSrvIntervalMS = 60000;
	        this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 10000;
	        this.haMode = false;
	        this.generation = 0;
	        this._timeout = undefined;
	    }
	    get srvAddress() {
	        return `_${this.srvServiceName}._tcp.${this.srvHost}`;
	    }
	    get intervalMS() {
	        return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
	    }
	    start() {
	        if (!this._timeout) {
	            this.schedule();
	        }
	    }
	    stop() {
	        if (this._timeout) {
	            (0, timers_1.clearTimeout)(this._timeout);
	            this.generation += 1;
	            this._timeout = undefined;
	        }
	    }
	    // TODO(NODE-4994): implement new logging logic for SrvPoller failures
	    schedule() {
	        if (this._timeout) {
	            (0, timers_1.clearTimeout)(this._timeout);
	        }
	        this._timeout = (0, timers_1.setTimeout)(() => {
	            this._poll().then(undefined, utils_1.squashError);
	        }, this.intervalMS);
	    }
	    success(srvRecords) {
	        this.haMode = false;
	        this.schedule();
	        this.emit(SrvPoller.SRV_RECORD_DISCOVERY, new SrvPollingEvent(srvRecords));
	    }
	    failure() {
	        this.haMode = true;
	        this.schedule();
	    }
	    async _poll() {
	        const generation = this.generation;
	        let srvRecords;
	        try {
	            srvRecords = await dns.promises.resolveSrv(this.srvAddress);
	        }
	        catch {
	            this.failure();
	            return;
	        }
	        if (generation !== this.generation) {
	            return;
	        }
	        const finalAddresses = [];
	        for (const record of srvRecords) {
	            if ((0, utils_1.matchesParentDomain)(record.name, this.srvHost)) {
	                finalAddresses.push(record);
	            }
	        }
	        if (!finalAddresses.length) {
	            this.failure();
	            return;
	        }
	        this.success(finalAddresses);
	    }
	}
	srv_polling.SrvPoller = SrvPoller;
	/** @event */
	SrvPoller.SRV_RECORD_DISCOVERY = 'srvRecordDiscovery';
	
	return srv_polling;
}

var hasRequiredTopology;

function requireTopology () {
	if (hasRequiredTopology) return topology;
	hasRequiredTopology = 1;
	Object.defineProperty(topology, "__esModule", { value: true });
	topology.ServerCapabilities = topology.Topology = void 0;
	const connection_string_1 = requireConnection_string();
	const constants_1 = requireConstants();
	const error_1 = requireError();
	const mongo_logger_1 = requireMongo_logger();
	const mongo_types_1 = requireMongo_types();
	const read_preference_1 = requireRead_preference();
	const timeout_1 = requireTimeout();
	const utils_1 = requireUtils$1();
	const common_1 = requireCommon$1();
	const events_1 = requireEvents();
	const server_1 = requireServer();
	const server_description_1 = requireServer_description();
	const server_selection_1 = requireServer_selection();
	const server_selection_events_1 = requireServer_selection_events();
	const srv_polling_1 = requireSrv_polling();
	const topology_description_1 = requireTopology_description();
	// Global state
	let globalTopologyCounter = 0;
	const stateTransition = (0, utils_1.makeStateMachine)({
	    [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],
	    [common_1.STATE_CONNECTING]: [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],
	    [common_1.STATE_CONNECTED]: [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],
	    [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, common_1.STATE_CLOSED]
	});
	/** @internal */
	const kCancelled = Symbol('cancelled');
	/** @internal */
	const kWaitQueue = Symbol('waitQueue');
	/**
	 * A container of server instances representing a connection to a MongoDB topology.
	 * @internal
	 */
	class Topology extends mongo_types_1.TypedEventEmitter {
	    /**
	     * @param seedlist - a list of HostAddress instances to connect to
	     */
	    constructor(client, seeds, options) {
	        super();
	        this.client = client;
	        // Options should only be undefined in tests, MongoClient will always have defined options
	        options = options ?? {
	            hosts: [utils_1.HostAddress.fromString('localhost:27017')],
	            ...Object.fromEntries(connection_string_1.DEFAULT_OPTIONS.entries()),
	            ...Object.fromEntries(connection_string_1.FEATURE_FLAGS.entries())
	        };
	        if (typeof seeds === 'string') {
	            seeds = [utils_1.HostAddress.fromString(seeds)];
	        }
	        else if (!Array.isArray(seeds)) {
	            seeds = [seeds];
	        }
	        const seedlist = [];
	        for (const seed of seeds) {
	            if (typeof seed === 'string') {
	                seedlist.push(utils_1.HostAddress.fromString(seed));
	            }
	            else if (seed instanceof utils_1.HostAddress) {
	                seedlist.push(seed);
	            }
	            else {
	                // FIXME(NODE-3483): May need to be a MongoParseError
	                throw new error_1.MongoRuntimeError(`Topology cannot be constructed from ${JSON.stringify(seed)}`);
	            }
	        }
	        const topologyType = topologyTypeFromOptions(options);
	        const topologyId = globalTopologyCounter++;
	        const selectedHosts = options.srvMaxHosts == null ||
	            options.srvMaxHosts === 0 ||
	            options.srvMaxHosts >= seedlist.length
	            ? seedlist
	            : (0, utils_1.shuffle)(seedlist, options.srvMaxHosts);
	        const serverDescriptions = new Map();
	        for (const hostAddress of selectedHosts) {
	            serverDescriptions.set(hostAddress.toString(), new server_description_1.ServerDescription(hostAddress));
	        }
	        this[kWaitQueue] = new utils_1.List();
	        this.s = {
	            // the id of this topology
	            id: topologyId,
	            // passed in options
	            options,
	            // initial seedlist of servers to connect to
	            seedlist,
	            // initial state
	            state: common_1.STATE_CLOSED,
	            // the topology description
	            description: new topology_description_1.TopologyDescription(topologyType, serverDescriptions, options.replicaSet, undefined, undefined, undefined, options),
	            serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,
	            heartbeatFrequencyMS: options.heartbeatFrequencyMS,
	            minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,
	            // a map of server instances to normalized addresses
	            servers: new Map(),
	            credentials: options?.credentials,
	            clusterTime: undefined,
	            // timer management
	            connectionTimers: new Set(),
	            detectShardedTopology: ev => this.detectShardedTopology(ev),
	            detectSrvRecords: ev => this.detectSrvRecords(ev)
	        };
	        this.mongoLogger = client.mongoLogger;
	        this.component = 'topology';
	        if (options.srvHost && !options.loadBalanced) {
	            this.s.srvPoller =
	                options.srvPoller ??
	                    new srv_polling_1.SrvPoller({
	                        heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,
	                        srvHost: options.srvHost,
	                        srvMaxHosts: options.srvMaxHosts,
	                        srvServiceName: options.srvServiceName
	                    });
	            this.on(Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
	        }
	        this.connectionLock = undefined;
	    }
	    detectShardedTopology(event) {
	        const previousType = event.previousDescription.type;
	        const newType = event.newDescription.type;
	        const transitionToSharded = previousType !== common_1.TopologyType.Sharded && newType === common_1.TopologyType.Sharded;
	        const srvListeners = this.s.srvPoller?.listeners(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY);
	        const listeningToSrvPolling = !!srvListeners?.includes(this.s.detectSrvRecords);
	        if (transitionToSharded && !listeningToSrvPolling) {
	            this.s.srvPoller?.on(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
	            this.s.srvPoller?.start();
	        }
	    }
	    detectSrvRecords(ev) {
	        const previousTopologyDescription = this.s.description;
	        this.s.description = this.s.description.updateFromSrvPollingEvent(ev, this.s.options.srvMaxHosts);
	        if (this.s.description === previousTopologyDescription) {
	            // Nothing changed, so return
	            return;
	        }
	        updateServers(this);
	        this.emitAndLog(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
	    }
	    /**
	     * @returns A `TopologyDescription` for this topology
	     */
	    get description() {
	        return this.s.description;
	    }
	    get loadBalanced() {
	        return this.s.options.loadBalanced;
	    }
	    get serverApi() {
	        return this.s.options.serverApi;
	    }
	    get capabilities() {
	        return new ServerCapabilities(this.lastHello());
	    }
	    /** Initiate server connect */
	    async connect(options) {
	        this.connectionLock ??= this._connect(options);
	        try {
	            await this.connectionLock;
	            return this;
	        }
	        finally {
	            this.connectionLock = undefined;
	        }
	        return this;
	    }
	    async _connect(options) {
	        options = options ?? {};
	        if (this.s.state === common_1.STATE_CONNECTED) {
	            return this;
	        }
	        stateTransition(this, common_1.STATE_CONNECTING);
	        // emit SDAM monitoring events
	        this.emitAndLog(Topology.TOPOLOGY_OPENING, new events_1.TopologyOpeningEvent(this.s.id));
	        // emit an event for the topology change
	        this.emitAndLog(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, new topology_description_1.TopologyDescription(common_1.TopologyType.Unknown), // initial is always Unknown
	        this.s.description));
	        // connect all known servers, then attempt server selection to connect
	        const serverDescriptions = Array.from(this.s.description.servers.values());
	        this.s.servers = new Map(serverDescriptions.map(serverDescription => [
	            serverDescription.address,
	            createAndConnectServer(this, serverDescription)
	        ]));
	        // In load balancer mode we need to fake a server description getting
	        // emitted from the monitor, since the monitor doesn't exist.
	        if (this.s.options.loadBalanced) {
	            for (const description of serverDescriptions) {
	                const newDescription = new server_description_1.ServerDescription(description.hostAddress, undefined, {
	                    loadBalanced: this.s.options.loadBalanced
	                });
	                this.serverUpdateHandler(newDescription);
	            }
	        }
	        const readPreference = options.readPreference ?? read_preference_1.ReadPreference.primary;
	        const selectServerOptions = { operationName: 'ping', ...options };
	        try {
	            const server = await this.selectServer((0, server_selection_1.readPreferenceServerSelector)(readPreference), selectServerOptions);
	            const skipPingOnConnect = this.s.options[Symbol.for('@@mdb.skipPingOnConnect')] === true;
	            if (!skipPingOnConnect && server && this.s.credentials) {
	                await server.command((0, utils_1.ns)('admin.$cmd'), { ping: 1 }, {});
	                stateTransition(this, common_1.STATE_CONNECTED);
	                this.emit(Topology.OPEN, this);
	                this.emit(Topology.CONNECT, this);
	                return this;
	            }
	            stateTransition(this, common_1.STATE_CONNECTED);
	            this.emit(Topology.OPEN, this);
	            this.emit(Topology.CONNECT, this);
	            return this;
	        }
	        catch (error) {
	            this.close();
	            throw error;
	        }
	    }
	    /** Close this topology */
	    close() {
	        if (this.s.state === common_1.STATE_CLOSED || this.s.state === common_1.STATE_CLOSING) {
	            return;
	        }
	        for (const server of this.s.servers.values()) {
	            destroyServer(server, this);
	        }
	        this.s.servers.clear();
	        stateTransition(this, common_1.STATE_CLOSING);
	        drainWaitQueue(this[kWaitQueue], new error_1.MongoTopologyClosedError());
	        (0, common_1.drainTimerQueue)(this.s.connectionTimers);
	        if (this.s.srvPoller) {
	            this.s.srvPoller.stop();
	            this.s.srvPoller.removeListener(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
	        }
	        this.removeListener(Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
	        stateTransition(this, common_1.STATE_CLOSED);
	        // emit an event for close
	        this.emitAndLog(Topology.TOPOLOGY_CLOSED, new events_1.TopologyClosedEvent(this.s.id));
	    }
	    /**
	     * Selects a server according to the selection predicate provided
	     *
	     * @param selector - An optional selector to select servers by, defaults to a random selection within a latency window
	     * @param options - Optional settings related to server selection
	     * @param callback - The callback used to indicate success or failure
	     * @returns An instance of a `Server` meeting the criteria of the predicate provided
	     */
	    async selectServer(selector, options) {
	        let serverSelector;
	        if (typeof selector !== 'function') {
	            if (typeof selector === 'string') {
	                serverSelector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.fromString(selector));
	            }
	            else {
	                let readPreference;
	                if (selector instanceof read_preference_1.ReadPreference) {
	                    readPreference = selector;
	                }
	                else {
	                    read_preference_1.ReadPreference.translate(options);
	                    readPreference = options.readPreference || read_preference_1.ReadPreference.primary;
	                }
	                serverSelector = (0, server_selection_1.readPreferenceServerSelector)(readPreference);
	            }
	        }
	        else {
	            serverSelector = selector;
	        }
	        options = { serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS, ...options };
	        if (this.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
	            this.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionStartedEvent(selector, this.description, options.operationName));
	        }
	        const isSharded = this.description.type === common_1.TopologyType.Sharded;
	        const session = options.session;
	        const transaction = session && session.transaction;
	        if (isSharded && transaction && transaction.server) {
	            if (this.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
	                this.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionSucceededEvent(selector, this.description, transaction.server.pool.address, options.operationName));
	            }
	            return transaction.server;
	        }
	        const { promise: serverPromise, resolve, reject } = (0, utils_1.promiseWithResolvers)();
	        const timeout = timeout_1.Timeout.expires(options.serverSelectionTimeoutMS ?? 0);
	        const waitQueueMember = {
	            serverSelector,
	            topologyDescription: this.description,
	            mongoLogger: this.client.mongoLogger,
	            transaction,
	            resolve,
	            reject,
	            timeout,
	            startTime: (0, utils_1.now)(),
	            operationName: options.operationName,
	            waitingLogged: false,
	            previousServer: options.previousServer
	        };
	        this[kWaitQueue].push(waitQueueMember);
	        processWaitQueue(this);
	        try {
	            return await Promise.race([serverPromise, waitQueueMember.timeout]);
	        }
	        catch (error) {
	            if (timeout_1.TimeoutError.is(error)) {
	                // Timeout
	                waitQueueMember[kCancelled] = true;
	                timeout.clear();
	                const timeoutError = new error_1.MongoServerSelectionError(`Server selection timed out after ${options.serverSelectionTimeoutMS} ms`, this.description);
	                if (this.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
	                    this.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(selector, this.description, timeoutError, options.operationName));
	                }
	                throw timeoutError;
	            }
	            // Other server selection error
	            throw error;
	        }
	    }
	    /**
	     * Update the internal TopologyDescription with a ServerDescription
	     *
	     * @param serverDescription - The server to update in the internal list of server descriptions
	     */
	    serverUpdateHandler(serverDescription) {
	        if (!this.s.description.hasServer(serverDescription.address)) {
	            return;
	        }
	        // ignore this server update if its from an outdated topologyVersion
	        if (isStaleServerDescription(this.s.description, serverDescription)) {
	            return;
	        }
	        // these will be used for monitoring events later
	        const previousTopologyDescription = this.s.description;
	        const previousServerDescription = this.s.description.servers.get(serverDescription.address);
	        if (!previousServerDescription) {
	            return;
	        }
	        // Driver Sessions Spec: "Whenever a driver receives a cluster time from
	        // a server it MUST compare it to the current highest seen cluster time
	        // for the deployment. If the new cluster time is higher than the
	        // highest seen cluster time it MUST become the new highest seen cluster
	        // time. Two cluster times are compared using only the BsonTimestamp
	        // value of the clusterTime embedded field."
	        const clusterTime = serverDescription.$clusterTime;
	        if (clusterTime) {
	            (0, common_1._advanceClusterTime)(this, clusterTime);
	        }
	        // If we already know all the information contained in this updated description, then
	        // we don't need to emit SDAM events, but still need to update the description, in order
	        // to keep client-tracked attributes like last update time and round trip time up to date
	        const equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);
	        // first update the TopologyDescription
	        this.s.description = this.s.description.update(serverDescription);
	        if (this.s.description.compatibilityError) {
	            this.emit(Topology.ERROR, new error_1.MongoCompatibilityError(this.s.description.compatibilityError));
	            return;
	        }
	        // emit monitoring events for this change
	        if (!equalDescriptions) {
	            const newDescription = this.s.description.servers.get(serverDescription.address);
	            if (newDescription) {
	                this.emit(Topology.SERVER_DESCRIPTION_CHANGED, new events_1.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, newDescription));
	            }
	        }
	        // update server list from updated descriptions
	        updateServers(this, serverDescription);
	        // attempt to resolve any outstanding server selection attempts
	        if (this[kWaitQueue].length > 0) {
	            processWaitQueue(this);
	        }
	        if (!equalDescriptions) {
	            this.emitAndLog(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
	        }
	    }
	    auth(credentials, callback) {
	        if (typeof credentials === 'function')
	            (callback = credentials), (credentials = undefined);
	        if (typeof callback === 'function')
	            callback(undefined, true);
	    }
	    get clientMetadata() {
	        return this.s.options.metadata;
	    }
	    isConnected() {
	        return this.s.state === common_1.STATE_CONNECTED;
	    }
	    isDestroyed() {
	        return this.s.state === common_1.STATE_CLOSED;
	    }
	    // NOTE: There are many places in code where we explicitly check the last hello
	    //       to do feature support detection. This should be done any other way, but for
	    //       now we will just return the first hello seen, which should suffice.
	    lastHello() {
	        const serverDescriptions = Array.from(this.description.servers.values());
	        if (serverDescriptions.length === 0)
	            return {};
	        const sd = serverDescriptions.filter((sd) => sd.type !== common_1.ServerType.Unknown)[0];
	        const result = sd || { maxWireVersion: this.description.commonWireVersion };
	        return result;
	    }
	    get commonWireVersion() {
	        return this.description.commonWireVersion;
	    }
	    get logicalSessionTimeoutMinutes() {
	        return this.description.logicalSessionTimeoutMinutes;
	    }
	    get clusterTime() {
	        return this.s.clusterTime;
	    }
	    set clusterTime(clusterTime) {
	        this.s.clusterTime = clusterTime;
	    }
	}
	topology.Topology = Topology;
	/** @event */
	Topology.SERVER_OPENING = constants_1.SERVER_OPENING;
	/** @event */
	Topology.SERVER_CLOSED = constants_1.SERVER_CLOSED;
	/** @event */
	Topology.SERVER_DESCRIPTION_CHANGED = constants_1.SERVER_DESCRIPTION_CHANGED;
	/** @event */
	Topology.TOPOLOGY_OPENING = constants_1.TOPOLOGY_OPENING;
	/** @event */
	Topology.TOPOLOGY_CLOSED = constants_1.TOPOLOGY_CLOSED;
	/** @event */
	Topology.TOPOLOGY_DESCRIPTION_CHANGED = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;
	/** @event */
	Topology.ERROR = constants_1.ERROR;
	/** @event */
	Topology.OPEN = constants_1.OPEN;
	/** @event */
	Topology.CONNECT = constants_1.CONNECT;
	/** @event */
	Topology.CLOSE = constants_1.CLOSE;
	/** @event */
	Topology.TIMEOUT = constants_1.TIMEOUT;
	/** Destroys a server, and removes all event listeners from the instance */
	function destroyServer(server, topology) {
	    for (const event of constants_1.LOCAL_SERVER_EVENTS) {
	        server.removeAllListeners(event);
	    }
	    server.destroy();
	    topology.emitAndLog(Topology.SERVER_CLOSED, new events_1.ServerClosedEvent(topology.s.id, server.description.address));
	    for (const event of constants_1.SERVER_RELAY_EVENTS) {
	        server.removeAllListeners(event);
	    }
	}
	/** Predicts the TopologyType from options */
	function topologyTypeFromOptions(options) {
	    if (options?.directConnection) {
	        return common_1.TopologyType.Single;
	    }
	    if (options?.replicaSet) {
	        return common_1.TopologyType.ReplicaSetNoPrimary;
	    }
	    if (options?.loadBalanced) {
	        return common_1.TopologyType.LoadBalanced;
	    }
	    return common_1.TopologyType.Unknown;
	}
	/**
	 * Creates new server instances and attempts to connect them
	 *
	 * @param topology - The topology that this server belongs to
	 * @param serverDescription - The description for the server to initialize and connect to
	 */
	function createAndConnectServer(topology, serverDescription) {
	    topology.emitAndLog(Topology.SERVER_OPENING, new events_1.ServerOpeningEvent(topology.s.id, serverDescription.address));
	    const server = new server_1.Server(topology, serverDescription, topology.s.options);
	    for (const event of constants_1.SERVER_RELAY_EVENTS) {
	        server.on(event, (e) => topology.emit(event, e));
	    }
	    server.on(server_1.Server.DESCRIPTION_RECEIVED, description => topology.serverUpdateHandler(description));
	    server.connect();
	    return server;
	}
	/**
	 * @param topology - Topology to update.
	 * @param incomingServerDescription - New server description.
	 */
	function updateServers(topology, incomingServerDescription) {
	    // update the internal server's description
	    if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
	        const server = topology.s.servers.get(incomingServerDescription.address);
	        if (server) {
	            server.s.description = incomingServerDescription;
	            if (incomingServerDescription.error instanceof error_1.MongoError &&
	                incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.ResetPool)) {
	                const interruptInUseConnections = incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
	                server.pool.clear({ interruptInUseConnections });
	            }
	            else if (incomingServerDescription.error == null) {
	                const newTopologyType = topology.s.description.type;
	                const shouldMarkPoolReady = incomingServerDescription.isDataBearing ||
	                    (incomingServerDescription.type !== common_1.ServerType.Unknown &&
	                        newTopologyType === common_1.TopologyType.Single);
	                if (shouldMarkPoolReady) {
	                    server.pool.ready();
	                }
	            }
	        }
	    }
	    // add new servers for all descriptions we currently don't know about locally
	    for (const serverDescription of topology.description.servers.values()) {
	        if (!topology.s.servers.has(serverDescription.address)) {
	            const server = createAndConnectServer(topology, serverDescription);
	            topology.s.servers.set(serverDescription.address, server);
	        }
	    }
	    // for all servers no longer known, remove their descriptions and destroy their instances
	    for (const entry of topology.s.servers) {
	        const serverAddress = entry[0];
	        if (topology.description.hasServer(serverAddress)) {
	            continue;
	        }
	        if (!topology.s.servers.has(serverAddress)) {
	            continue;
	        }
	        const server = topology.s.servers.get(serverAddress);
	        topology.s.servers.delete(serverAddress);
	        // prepare server for garbage collection
	        if (server) {
	            destroyServer(server, topology);
	        }
	    }
	}
	function drainWaitQueue(queue, drainError) {
	    while (queue.length) {
	        const waitQueueMember = queue.shift();
	        if (!waitQueueMember) {
	            continue;
	        }
	        waitQueueMember.timeout.clear();
	        if (!waitQueueMember[kCancelled]) {
	            if (waitQueueMember.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
	                waitQueueMember.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(waitQueueMember.serverSelector, waitQueueMember.topologyDescription, drainError, waitQueueMember.operationName));
	            }
	            waitQueueMember.reject(drainError);
	        }
	    }
	}
	function processWaitQueue(topology) {
	    if (topology.s.state === common_1.STATE_CLOSED) {
	        drainWaitQueue(topology[kWaitQueue], new error_1.MongoTopologyClosedError());
	        return;
	    }
	    const isSharded = topology.description.type === common_1.TopologyType.Sharded;
	    const serverDescriptions = Array.from(topology.description.servers.values());
	    const membersToProcess = topology[kWaitQueue].length;
	    for (let i = 0; i < membersToProcess; ++i) {
	        const waitQueueMember = topology[kWaitQueue].shift();
	        if (!waitQueueMember) {
	            continue;
	        }
	        if (waitQueueMember[kCancelled]) {
	            continue;
	        }
	        let selectedDescriptions;
	        try {
	            const serverSelector = waitQueueMember.serverSelector;
	            const previousServer = waitQueueMember.previousServer;
	            selectedDescriptions = serverSelector
	                ? serverSelector(topology.description, serverDescriptions, previousServer ? [previousServer] : [])
	                : serverDescriptions;
	        }
	        catch (selectorError) {
	            waitQueueMember.timeout.clear();
	            if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
	                topology.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(waitQueueMember.serverSelector, topology.description, selectorError, waitQueueMember.operationName));
	            }
	            waitQueueMember.reject(selectorError);
	            continue;
	        }
	        let selectedServer;
	        if (selectedDescriptions.length === 0) {
	            if (!waitQueueMember.waitingLogged) {
	                if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.INFORMATIONAL)) {
	                    topology.client.mongoLogger?.info(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.WaitingForSuitableServerEvent(waitQueueMember.serverSelector, topology.description, topology.s.serverSelectionTimeoutMS !== 0
	                        ? topology.s.serverSelectionTimeoutMS - ((0, utils_1.now)() - waitQueueMember.startTime)
	                        : -1, waitQueueMember.operationName));
	                }
	                waitQueueMember.waitingLogged = true;
	            }
	            topology[kWaitQueue].push(waitQueueMember);
	            continue;
	        }
	        else if (selectedDescriptions.length === 1) {
	            selectedServer = topology.s.servers.get(selectedDescriptions[0].address);
	        }
	        else {
	            const descriptions = (0, utils_1.shuffle)(selectedDescriptions, 2);
	            const server1 = topology.s.servers.get(descriptions[0].address);
	            const server2 = topology.s.servers.get(descriptions[1].address);
	            selectedServer =
	                server1 && server2 && server1.s.operationCount < server2.s.operationCount
	                    ? server1
	                    : server2;
	        }
	        if (!selectedServer) {
	            const serverSelectionError = new error_1.MongoServerSelectionError('server selection returned a server description but the server was not found in the topology', topology.description);
	            if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
	                topology.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(waitQueueMember.serverSelector, topology.description, serverSelectionError, waitQueueMember.operationName));
	            }
	            waitQueueMember.reject(serverSelectionError);
	            return;
	        }
	        const transaction = waitQueueMember.transaction;
	        if (isSharded && transaction && transaction.isActive && selectedServer) {
	            transaction.pinServer(selectedServer);
	        }
	        waitQueueMember.timeout.clear();
	        if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
	            topology.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionSucceededEvent(waitQueueMember.serverSelector, waitQueueMember.topologyDescription, selectedServer.pool.address, waitQueueMember.operationName));
	        }
	        waitQueueMember.resolve(selectedServer);
	    }
	    if (topology[kWaitQueue].length > 0) {
	        // ensure all server monitors attempt monitoring soon
	        for (const [, server] of topology.s.servers) {
	            process.nextTick(function scheduleServerCheck() {
	                return server.requestCheck();
	            });
	        }
	    }
	}
	function isStaleServerDescription(topologyDescription, incomingServerDescription) {
	    const currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);
	    const currentTopologyVersion = currentServerDescription?.topologyVersion;
	    return ((0, server_description_1.compareTopologyVersion)(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0);
	}
	/** @public */
	class ServerCapabilities {
	    constructor(hello) {
	        this.minWireVersion = hello.minWireVersion || 0;
	        this.maxWireVersion = hello.maxWireVersion || 0;
	    }
	    get hasAggregationCursor() {
	        return this.maxWireVersion >= 1;
	    }
	    get hasWriteCommands() {
	        return this.maxWireVersion >= 2;
	    }
	    get hasTextSearch() {
	        return this.minWireVersion >= 0;
	    }
	    get hasAuthCommands() {
	        return this.maxWireVersion >= 1;
	    }
	    get hasListCollectionsCommand() {
	        return this.maxWireVersion >= 3;
	    }
	    get hasListIndexesCommand() {
	        return this.maxWireVersion >= 3;
	    }
	    get supportsSnapshotReads() {
	        return this.maxWireVersion >= 13;
	    }
	    get commandsTakeWriteConcern() {
	        return this.maxWireVersion >= 5;
	    }
	    get commandsTakeCollation() {
	        return this.maxWireVersion >= 5;
	    }
	}
	topology.ServerCapabilities = ServerCapabilities;
	
	return topology;
}

var hasRequiredMongo_client;

function requireMongo_client () {
	if (hasRequiredMongo_client) return mongo_client;
	hasRequiredMongo_client = 1;
	Object.defineProperty(mongo_client, "__esModule", { value: true });
	mongo_client.MongoClient = mongo_client.ServerApiVersion = void 0;
	const fs_1 = fs;
	const bson_1 = requireBson();
	const change_stream_1 = requireChange_stream();
	const mongo_credentials_1 = requireMongo_credentials();
	const providers_1 = requireProviders$1();
	const connection_string_1 = requireConnection_string();
	const constants_1 = requireConstants();
	const db_1 = requireDb();
	const error_1 = requireError();
	const mongo_client_auth_providers_1 = requireMongo_client_auth_providers();
	const mongo_logger_1 = requireMongo_logger();
	const mongo_types_1 = requireMongo_types();
	const execute_operation_1 = requireExecute_operation();
	const run_command_1 = requireRun_command();
	const read_preference_1 = requireRead_preference();
	const resource_management_1 = requireResource_management();
	const server_selection_1 = requireServer_selection();
	const topology_1 = requireTopology();
	const sessions_1 = requireSessions();
	const utils_1 = requireUtils$1();
	/** @public */
	mongo_client.ServerApiVersion = Object.freeze({
	    v1: '1'
	});
	/** @internal */
	const kOptions = Symbol('options');
	/**
	 * The **MongoClient** class is a class that allows for making Connections to MongoDB.
	 * @public
	 *
	 * @remarks
	 * The programmatically provided options take precedence over the URI options.
	 *
	 * @example
	 * ```ts
	 * import { MongoClient } from 'mongodb';
	 *
	 * // Enable command monitoring for debugging
	 * const client = new MongoClient('mongodb://localhost:27017', { monitorCommands: true });
	 *
	 * client.on('commandStarted', started => console.log(started));
	 * client.db().collection('pets');
	 * await client.insertOne({ name: 'spot', kind: 'dog' });
	 * ```
	 */
	class MongoClient extends mongo_types_1.TypedEventEmitter {
	    constructor(url, options) {
	        super();
	        this[kOptions] = (0, connection_string_1.parseOptions)(url, this, options);
	        const shouldSetLogger = Object.values(this[kOptions].mongoLoggerOptions.componentSeverities).some(value => value !== mongo_logger_1.SeverityLevel.OFF);
	        this.mongoLogger = shouldSetLogger
	            ? new mongo_logger_1.MongoLogger(this[kOptions].mongoLoggerOptions)
	            : undefined;
	        // eslint-disable-next-line @typescript-eslint/no-this-alias
	        const client = this;
	        // The internal state
	        this.s = {
	            url,
	            bsonOptions: (0, bson_1.resolveBSONOptions)(this[kOptions]),
	            namespace: (0, utils_1.ns)('admin'),
	            hasBeenClosed: false,
	            sessionPool: new sessions_1.ServerSessionPool(this),
	            activeSessions: new Set(),
	            authProviders: new mongo_client_auth_providers_1.MongoClientAuthProviders(),
	            get options() {
	                return client[kOptions];
	            },
	            get readConcern() {
	                return client[kOptions].readConcern;
	            },
	            get writeConcern() {
	                return client[kOptions].writeConcern;
	            },
	            get readPreference() {
	                return client[kOptions].readPreference;
	            },
	            get isMongoClient() {
	                return true;
	            }
	        };
	        this.checkForNonGenuineHosts();
	    }
	    /** @internal */
	    async asyncDispose() {
	        await this.close();
	    }
	    /** @internal */
	    checkForNonGenuineHosts() {
	        const documentDBHostnames = this[kOptions].hosts.filter((hostAddress) => (0, utils_1.isHostMatch)(utils_1.DOCUMENT_DB_CHECK, hostAddress.host));
	        const srvHostIsDocumentDB = (0, utils_1.isHostMatch)(utils_1.DOCUMENT_DB_CHECK, this[kOptions].srvHost);
	        const cosmosDBHostnames = this[kOptions].hosts.filter((hostAddress) => (0, utils_1.isHostMatch)(utils_1.COSMOS_DB_CHECK, hostAddress.host));
	        const srvHostIsCosmosDB = (0, utils_1.isHostMatch)(utils_1.COSMOS_DB_CHECK, this[kOptions].srvHost);
	        if (documentDBHostnames.length !== 0 || srvHostIsDocumentDB) {
	            this.mongoLogger?.info('client', utils_1.DOCUMENT_DB_MSG);
	        }
	        else if (cosmosDBHostnames.length !== 0 || srvHostIsCosmosDB) {
	            this.mongoLogger?.info('client', utils_1.COSMOS_DB_MSG);
	        }
	    }
	    /** @see MongoOptions */
	    get options() {
	        return Object.freeze({ ...this[kOptions] });
	    }
	    get serverApi() {
	        return this[kOptions].serverApi && Object.freeze({ ...this[kOptions].serverApi });
	    }
	    /**
	     * Intended for APM use only
	     * @internal
	     */
	    get monitorCommands() {
	        return this[kOptions].monitorCommands;
	    }
	    set monitorCommands(value) {
	        this[kOptions].monitorCommands = value;
	    }
	    /** @internal */
	    get autoEncrypter() {
	        return this[kOptions].autoEncrypter;
	    }
	    get readConcern() {
	        return this.s.readConcern;
	    }
	    get writeConcern() {
	        return this.s.writeConcern;
	    }
	    get readPreference() {
	        return this.s.readPreference;
	    }
	    get bsonOptions() {
	        return this.s.bsonOptions;
	    }
	    /**
	     * Connect to MongoDB using a url
	     *
	     * @see docs.mongodb.org/manual/reference/connection-string/
	     */
	    async connect() {
	        if (this.connectionLock) {
	            return await this.connectionLock;
	        }
	        try {
	            this.connectionLock = this._connect();
	            await this.connectionLock;
	        }
	        finally {
	            // release
	            this.connectionLock = undefined;
	        }
	        return this;
	    }
	    /**
	     * Create a topology to open the connection, must be locked to avoid topology leaks in concurrency scenario.
	     * Locking is enforced by the connect method.
	     *
	     * @internal
	     */
	    async _connect() {
	        if (this.topology && this.topology.isConnected()) {
	            return this;
	        }
	        const options = this[kOptions];
	        if (options.tls) {
	            if (typeof options.tlsCAFile === 'string') {
	                options.ca ??= await fs_1.promises.readFile(options.tlsCAFile);
	            }
	            if (typeof options.tlsCRLFile === 'string') {
	                options.crl ??= await fs_1.promises.readFile(options.tlsCRLFile);
	            }
	            if (typeof options.tlsCertificateKeyFile === 'string') {
	                if (!options.key || !options.cert) {
	                    const contents = await fs_1.promises.readFile(options.tlsCertificateKeyFile);
	                    options.key ??= contents;
	                    options.cert ??= contents;
	                }
	            }
	        }
	        if (typeof options.srvHost === 'string') {
	            const hosts = await (0, connection_string_1.resolveSRVRecord)(options);
	            for (const [index, host] of hosts.entries()) {
	                options.hosts[index] = host;
	            }
	        }
	        // It is important to perform validation of hosts AFTER SRV resolution, to check the real hostname,
	        // but BEFORE we even attempt connecting with a potentially not allowed hostname
	        if (options.credentials?.mechanism === providers_1.AuthMechanism.MONGODB_OIDC) {
	            const allowedHosts = options.credentials?.mechanismProperties?.ALLOWED_HOSTS || mongo_credentials_1.DEFAULT_ALLOWED_HOSTS;
	            const isServiceAuth = !!options.credentials?.mechanismProperties?.ENVIRONMENT;
	            if (!isServiceAuth) {
	                for (const host of options.hosts) {
	                    if (!(0, utils_1.hostMatchesWildcards)(host.toHostPort().host, allowedHosts)) {
	                        throw new error_1.MongoInvalidArgumentError(`Host '${host}' is not valid for OIDC authentication with ALLOWED_HOSTS of '${allowedHosts.join(',')}'`);
	                    }
	                }
	            }
	        }
	        this.topology = new topology_1.Topology(this, options.hosts, options);
	        // Events can be emitted before initialization is complete so we have to
	        // save the reference to the topology on the client ASAP if the event handlers need to access it
	        this.topology.once(topology_1.Topology.OPEN, () => this.emit('open', this));
	        for (const event of constants_1.MONGO_CLIENT_EVENTS) {
	            this.topology.on(event, (...args) => this.emit(event, ...args));
	        }
	        const topologyConnect = async () => {
	            try {
	                await this.topology?.connect(options);
	            }
	            catch (error) {
	                this.topology?.close();
	                throw error;
	            }
	        };
	        if (this.autoEncrypter) {
	            await this.autoEncrypter?.init();
	            await topologyConnect();
	            await options.encrypter.connectInternalClient();
	        }
	        else {
	            await topologyConnect();
	        }
	        return this;
	    }
	    /**
	     * Cleans up client-side resources used by the MongoCLient and .  This includes:
	     *
	     * - Closes all open, unused connections (see note).
	     * - Ends all in-use sessions with {@link ClientSession#endSession|ClientSession.endSession()}.
	     * - Ends all unused sessions server-side.
	     * - Cleans up any resources being used for auto encryption if auto encryption is enabled.
	     *
	     * @remarks Any in-progress operations are not killed and any connections used by in progress operations
	     * will be cleaned up lazily as operations finish.
	     *
	     * @param force - Force close, emitting no events
	     */
	    async close(force = false) {
	        // There's no way to set hasBeenClosed back to false
	        Object.defineProperty(this.s, 'hasBeenClosed', {
	            value: true,
	            enumerable: true,
	            configurable: false,
	            writable: false
	        });
	        const activeSessionEnds = Array.from(this.s.activeSessions, session => session.endSession());
	        this.s.activeSessions.clear();
	        await Promise.all(activeSessionEnds);
	        if (this.topology == null) {
	            return;
	        }
	        // If we would attempt to select a server and get nothing back we short circuit
	        // to avoid the server selection timeout.
	        const selector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.primaryPreferred);
	        const topologyDescription = this.topology.description;
	        const serverDescriptions = Array.from(topologyDescription.servers.values());
	        const servers = selector(topologyDescription, serverDescriptions);
	        if (servers.length !== 0) {
	            const endSessions = Array.from(this.s.sessionPool.sessions, ({ id }) => id);
	            if (endSessions.length !== 0) {
	                try {
	                    await (0, execute_operation_1.executeOperation)(this, new run_command_1.RunAdminCommandOperation({ endSessions }, { readPreference: read_preference_1.ReadPreference.primaryPreferred, noResponse: true }));
	                }
	                catch (error) {
	                    (0, utils_1.squashError)(error);
	                }
	            }
	        }
	        // clear out references to old topology
	        const topology = this.topology;
	        this.topology = undefined;
	        topology.close();
	        const { encrypter } = this[kOptions];
	        if (encrypter) {
	            await encrypter.close(this, force);
	        }
	    }
	    /**
	     * Create a new Db instance sharing the current socket connections.
	     *
	     * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.
	     * @param options - Optional settings for Db construction
	     */
	    db(dbName, options) {
	        options = options ?? {};
	        // Default to db from connection string if not provided
	        if (!dbName) {
	            dbName = this.options.dbName;
	        }
	        // Copy the options and add out internal override of the not shared flag
	        const finalOptions = Object.assign({}, this[kOptions], options);
	        // Return the db object
	        const db = new db_1.Db(this, dbName, finalOptions);
	        // Return the database
	        return db;
	    }
	    /**
	     * Connect to MongoDB using a url
	     *
	     * @remarks
	     * The programmatically provided options take precedence over the URI options.
	     *
	     * @see https://www.mongodb.com/docs/manual/reference/connection-string/
	     */
	    static async connect(url, options) {
	        const client = new this(url, options);
	        return await client.connect();
	    }
	    /**
	     * Creates a new ClientSession. When using the returned session in an operation
	     * a corresponding ServerSession will be created.
	     *
	     * @remarks
	     * A ClientSession instance may only be passed to operations being performed on the same
	     * MongoClient it was started from.
	     */
	    startSession(options) {
	        const session = new sessions_1.ClientSession(this, this.s.sessionPool, { explicit: true, ...options }, this[kOptions]);
	        this.s.activeSessions.add(session);
	        session.once('ended', () => {
	            this.s.activeSessions.delete(session);
	        });
	        return session;
	    }
	    async withSession(optionsOrExecutor, executor) {
	        const options = {
	            // Always define an owner
	            owner: Symbol(),
	            // If it's an object inherit the options
	            ...(typeof optionsOrExecutor === 'object' ? optionsOrExecutor : {})
	        };
	        const withSessionCallback = typeof optionsOrExecutor === 'function' ? optionsOrExecutor : executor;
	        if (withSessionCallback == null) {
	            throw new error_1.MongoInvalidArgumentError('Missing required callback parameter');
	        }
	        const session = this.startSession(options);
	        try {
	            return await withSessionCallback(session);
	        }
	        finally {
	            try {
	                await session.endSession();
	            }
	            catch (error) {
	                (0, utils_1.squashError)(error);
	            }
	        }
	    }
	    /**
	     * Create a new Change Stream, watching for new changes (insertions, updates,
	     * replacements, deletions, and invalidations) in this cluster. Will ignore all
	     * changes to system collections, as well as the local, admin, and config databases.
	     *
	     * @remarks
	     * watch() accepts two generic arguments for distinct use cases:
	     * - The first is to provide the schema that may be defined for all the data within the current cluster
	     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
	     *
	     * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
	     * @param options - Optional settings for the command
	     * @typeParam TSchema - Type of the data being detected by the change stream
	     * @typeParam TChange - Type of the whole change stream document emitted
	     */
	    watch(pipeline = [], options = {}) {
	        // Allow optionally not specifying a pipeline
	        if (!Array.isArray(pipeline)) {
	            options = pipeline;
	            pipeline = [];
	        }
	        return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
	    }
	}
	mongo_client.MongoClient = MongoClient;
	(0, resource_management_1.configureResourceManagement)(MongoClient.prototype);
	
	return mongo_client;
}

var hasRequiredResource_management;

function requireResource_management () {
	if (hasRequiredResource_management) return resource_management;
	hasRequiredResource_management = 1;
	Object.defineProperty(resource_management, "__esModule", { value: true });
	resource_management.configureResourceManagement = configureResourceManagement;
	resource_management.configureExplicitResourceManagement = configureExplicitResourceManagement;
	/** @internal */
	function configureResourceManagement(target) {
	    Symbol.asyncDispose &&
	        Object.defineProperty(target, Symbol.asyncDispose, {
	            value: async function asyncDispose() {
	                await this.asyncDispose();
	            },
	            enumerable: false,
	            configurable: true,
	            writable: true
	        });
	}
	/**
	 * @beta
	 * @experimental
	 *
	 * Attaches `Symbol.asyncDispose` methods to the MongoClient, Cursors, sessions and change streams
	 * if Symbol.asyncDispose is defined.
	 *
	 * It's usually not necessary to call this method - the driver attempts to attach these methods
	 * itself when its loaded.  However, sometimes the driver may be loaded before `Symbol.asyncDispose`
	 * is defined, in which case it is necessary to call this method directly.  This can happen if the
	 * application is polyfilling `Symbol.asyncDispose`.
	 *
	 * Example:
	 *
	 * ```typescript
	 * import { configureExplicitResourceManagement, MongoClient } from 'mongodb/lib/beta';
	 *
	 * Symbol.asyncDispose ??= Symbol('dispose');
	 * load();
	 *
	 * await using client = new MongoClient(...);
	 * ```
	 */
	function configureExplicitResourceManagement() {
	    // We must import lazily here, because there's a circular dependency between the resource management
	    // file and each resources' file.  We could move `configureResourceManagement` to a separate
	    // function, but keeping all resource-management related code together seemed preferable and I chose
	    // lazy requiring of resources instead.
	    // eslint-disable-next-line @typescript-eslint/no-require-imports
	    const { MongoClient } = requireMongo_client();
	    // eslint-disable-next-line @typescript-eslint/no-require-imports
	    const { ClientSession } = requireSessions();
	    // eslint-disable-next-line @typescript-eslint/no-require-imports
	    const { AbstractCursor } = requireAbstract_cursor();
	    // eslint-disable-next-line @typescript-eslint/no-require-imports
	    const { ChangeStream } = requireChange_stream();
	    configureResourceManagement(MongoClient.prototype);
	    configureResourceManagement(ClientSession.prototype);
	    configureResourceManagement(AbstractCursor.prototype);
	    configureResourceManagement(ChangeStream.prototype);
	}
	
	return resource_management;
}

var hasRequiredAbstract_cursor;

function requireAbstract_cursor () {
	if (hasRequiredAbstract_cursor) return abstract_cursor;
	hasRequiredAbstract_cursor = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.AbstractCursor = exports.CURSOR_FLAGS = void 0;
		const stream_1 = require$$0$9;
		const bson_1 = requireBson();
		const error_1 = requireError();
		const mongo_types_1 = requireMongo_types();
		const execute_operation_1 = requireExecute_operation();
		const get_more_1 = requireGet_more();
		const kill_cursors_1 = requireKill_cursors();
		const read_concern_1 = requireRead_concern();
		const read_preference_1 = requireRead_preference();
		const resource_management_1 = requireResource_management();
		const sessions_1 = requireSessions();
		const utils_1 = requireUtils$1();
		/** @public */
		exports.CURSOR_FLAGS = [
		    'tailable',
		    'oplogReplay',
		    'noCursorTimeout',
		    'awaitData',
		    'exhaust',
		    'partial'
		];
		/** @public */
		class AbstractCursor extends mongo_types_1.TypedEventEmitter {
		    /** @internal */
		    constructor(client, namespace, options = {}) {
		        super();
		        /** @internal */
		        this.documents = null;
		        /** @internal */
		        this.hasEmittedClose = false;
		        if (!client.s.isMongoClient) {
		            throw new error_1.MongoRuntimeError('Cursor must be constructed with MongoClient');
		        }
		        this.cursorClient = client;
		        this.cursorNamespace = namespace;
		        this.cursorId = null;
		        this.initialized = false;
		        this.isClosed = false;
		        this.isKilled = false;
		        this.cursorOptions = {
		            readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference
		                ? options.readPreference
		                : read_preference_1.ReadPreference.primary,
		            ...(0, bson_1.pluckBSONSerializeOptions)(options)
		        };
		        this.cursorOptions.timeoutMS = options.timeoutMS;
		        const readConcern = read_concern_1.ReadConcern.fromOptions(options);
		        if (readConcern) {
		            this.cursorOptions.readConcern = readConcern;
		        }
		        if (typeof options.batchSize === 'number') {
		            this.cursorOptions.batchSize = options.batchSize;
		        }
		        // we check for undefined specifically here to allow falsy values
		        // eslint-disable-next-line no-restricted-syntax
		        if (options.comment !== undefined) {
		            this.cursorOptions.comment = options.comment;
		        }
		        if (typeof options.maxTimeMS === 'number') {
		            this.cursorOptions.maxTimeMS = options.maxTimeMS;
		        }
		        if (typeof options.maxAwaitTimeMS === 'number') {
		            this.cursorOptions.maxAwaitTimeMS = options.maxAwaitTimeMS;
		        }
		        if (options.session instanceof sessions_1.ClientSession) {
		            this.cursorSession = options.session;
		        }
		        else {
		            this.cursorSession = this.cursorClient.startSession({ owner: this, explicit: false });
		        }
		        this.deserializationOptions = {
		            ...this.cursorOptions,
		            validation: {
		                utf8: options?.enableUtf8Validation === false ? false : true
		            }
		        };
		    }
		    /**
		     * The cursor has no id until it receives a response from the initial cursor creating command.
		     *
		     * It is non-zero for as long as the database has an open cursor.
		     *
		     * The initiating command may receive a zero id if the entire result is in the `firstBatch`.
		     */
		    get id() {
		        return this.cursorId ?? undefined;
		    }
		    /** @internal */
		    get isDead() {
		        return (this.cursorId?.isZero() ?? false) || this.isClosed || this.isKilled;
		    }
		    /** @internal */
		    get client() {
		        return this.cursorClient;
		    }
		    /** @internal */
		    get server() {
		        return this.selectedServer;
		    }
		    get namespace() {
		        return this.cursorNamespace;
		    }
		    get readPreference() {
		        return this.cursorOptions.readPreference;
		    }
		    get readConcern() {
		        return this.cursorOptions.readConcern;
		    }
		    /** @internal */
		    get session() {
		        return this.cursorSession;
		    }
		    set session(clientSession) {
		        this.cursorSession = clientSession;
		    }
		    /**
		     * The cursor is closed and all remaining locally buffered documents have been iterated.
		     */
		    get closed() {
		        return this.isClosed && (this.documents?.length ?? 0) === 0;
		    }
		    /**
		     * A `killCursors` command was attempted on this cursor.
		     * This is performed if the cursor id is non zero.
		     */
		    get killed() {
		        return this.isKilled;
		    }
		    get loadBalanced() {
		        return !!this.cursorClient.topology?.loadBalanced;
		    }
		    /** @internal */
		    async asyncDispose() {
		        await this.close();
		    }
		    /** Returns current buffered documents length */
		    bufferedCount() {
		        return this.documents?.length ?? 0;
		    }
		    /** Returns current buffered documents */
		    readBufferedDocuments(number) {
		        const bufferedDocs = [];
		        const documentsToRead = Math.min(number ?? this.documents?.length ?? 0, this.documents?.length ?? 0);
		        for (let count = 0; count < documentsToRead; count++) {
		            const document = this.documents?.shift(this.deserializationOptions);
		            if (document != null) {
		                bufferedDocs.push(document);
		            }
		        }
		        return bufferedDocs;
		    }
		    async *[Symbol.asyncIterator]() {
		        if (this.closed) {
		            return;
		        }
		        try {
		            while (true) {
		                if (this.isKilled) {
		                    return;
		                }
		                if (this.closed) {
		                    return;
		                }
		                if (this.cursorId != null && this.isDead && (this.documents?.length ?? 0) === 0) {
		                    return;
		                }
		                const document = await this.next();
		                // eslint-disable-next-line no-restricted-syntax
		                if (document === null) {
		                    return;
		                }
		                yield document;
		            }
		        }
		        finally {
		            // Only close the cursor if it has not already been closed. This finally clause handles
		            // the case when a user would break out of a for await of loop early.
		            if (!this.isClosed) {
		                try {
		                    await this.close();
		                }
		                catch (error) {
		                    (0, utils_1.squashError)(error);
		                }
		            }
		        }
		    }
		    stream(options) {
		        if (options?.transform) {
		            const transform = options.transform;
		            const readable = new ReadableCursorStream(this);
		            const transformedStream = readable.pipe(new stream_1.Transform({
		                objectMode: true,
		                highWaterMark: 1,
		                transform(chunk, _, callback) {
		                    try {
		                        const transformed = transform(chunk);
		                        callback(undefined, transformed);
		                    }
		                    catch (err) {
		                        callback(err);
		                    }
		                }
		            }));
		            // Bubble errors to transformed stream, because otherwise no way
		            // to handle this error.
		            readable.on('error', err => transformedStream.emit('error', err));
		            return transformedStream;
		        }
		        return new ReadableCursorStream(this);
		    }
		    async hasNext() {
		        if (this.cursorId === bson_1.Long.ZERO) {
		            return false;
		        }
		        do {
		            if ((this.documents?.length ?? 0) !== 0) {
		                return true;
		            }
		            await this.fetchBatch();
		        } while (!this.isDead || (this.documents?.length ?? 0) !== 0);
		        return false;
		    }
		    /** Get the next available document from the cursor, returns null if no more documents are available. */
		    async next() {
		        if (this.cursorId === bson_1.Long.ZERO) {
		            throw new error_1.MongoCursorExhaustedError();
		        }
		        do {
		            const doc = this.documents?.shift(this.deserializationOptions);
		            if (doc != null) {
		                if (this.transform != null)
		                    return await this.transformDocument(doc);
		                return doc;
		            }
		            await this.fetchBatch();
		        } while (!this.isDead || (this.documents?.length ?? 0) !== 0);
		        return null;
		    }
		    /**
		     * Try to get the next available document from the cursor or `null` if an empty batch is returned
		     */
		    async tryNext() {
		        if (this.cursorId === bson_1.Long.ZERO) {
		            throw new error_1.MongoCursorExhaustedError();
		        }
		        let doc = this.documents?.shift(this.deserializationOptions);
		        if (doc != null) {
		            if (this.transform != null)
		                return await this.transformDocument(doc);
		            return doc;
		        }
		        await this.fetchBatch();
		        doc = this.documents?.shift(this.deserializationOptions);
		        if (doc != null) {
		            if (this.transform != null)
		                return await this.transformDocument(doc);
		            return doc;
		        }
		        return null;
		    }
		    /**
		     * Iterates over all the documents for this cursor using the iterator, callback pattern.
		     *
		     * If the iterator returns `false`, iteration will stop.
		     *
		     * @param iterator - The iteration callback.
		     * @deprecated - Will be removed in a future release. Use for await...of instead.
		     */
		    async forEach(iterator) {
		        if (typeof iterator !== 'function') {
		            throw new error_1.MongoInvalidArgumentError('Argument "iterator" must be a function');
		        }
		        for await (const document of this) {
		            const result = iterator(document);
		            if (result === false) {
		                break;
		            }
		        }
		    }
		    /**
		     * Frees any client-side resources used by the cursor.
		     */
		    async close() {
		        await this.cleanup();
		    }
		    /**
		     * Returns an array of documents. The caller is responsible for making sure that there
		     * is enough memory to store the results. Note that the array only contains partial
		     * results when this cursor had been previously accessed. In that case,
		     * cursor.rewind() can be used to reset the cursor.
		     */
		    async toArray() {
		        const array = [];
		        // at the end of the loop (since readBufferedDocuments is called) the buffer will be empty
		        // then, the 'await of' syntax will run a getMore call
		        for await (const document of this) {
		            array.push(document);
		            const docs = this.readBufferedDocuments();
		            if (this.transform != null) {
		                for (const doc of docs) {
		                    array.push(await this.transformDocument(doc));
		                }
		            }
		            else {
		                array.push(...docs);
		            }
		        }
		        return array;
		    }
		    /**
		     * Add a cursor flag to the cursor
		     *
		     * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.
		     * @param value - The flag boolean value.
		     */
		    addCursorFlag(flag, value) {
		        this.throwIfInitialized();
		        if (!exports.CURSOR_FLAGS.includes(flag)) {
		            throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);
		        }
		        if (typeof value !== 'boolean') {
		            throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);
		        }
		        this.cursorOptions[flag] = value;
		        return this;
		    }
		    /**
		     * Map all documents using the provided function
		     * If there is a transform set on the cursor, that will be called first and the result passed to
		     * this function's transform.
		     *
		     * @remarks
		     *
		     * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping
		     * function that maps values to `null` will result in the cursor closing itself before it has finished iterating
		     * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:
		     *
		     * ```typescript
		     * const cursor = collection.find({});
		     * cursor.map(() => null);
		     *
		     * const documents = await cursor.toArray();
		     * // documents is always [], regardless of how many documents are in the collection.
		     * ```
		     *
		     * Other falsey values are allowed:
		     *
		     * ```typescript
		     * const cursor = collection.find({});
		     * cursor.map(() => '');
		     *
		     * const documents = await cursor.toArray();
		     * // documents is now an array of empty strings
		     * ```
		     *
		     * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
		     * it **does not** return a new instance of a cursor. This means when calling map,
		     * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
		     * Take note of the following example:
		     *
		     * @example
		     * ```typescript
		     * const cursor: FindCursor<Document> = coll.find();
		     * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);
		     * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]
		     * ```
		     * @param transform - The mapping transformation method.
		     */
		    map(transform) {
		        this.throwIfInitialized();
		        const oldTransform = this.transform;
		        if (oldTransform) {
		            this.transform = doc => {
		                return transform(oldTransform(doc));
		            };
		        }
		        else {
		            this.transform = transform;
		        }
		        return this;
		    }
		    /**
		     * Set the ReadPreference for the cursor.
		     *
		     * @param readPreference - The new read preference for the cursor.
		     */
		    withReadPreference(readPreference) {
		        this.throwIfInitialized();
		        if (readPreference instanceof read_preference_1.ReadPreference) {
		            this.cursorOptions.readPreference = readPreference;
		        }
		        else if (typeof readPreference === 'string') {
		            this.cursorOptions.readPreference = read_preference_1.ReadPreference.fromString(readPreference);
		        }
		        else {
		            throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);
		        }
		        return this;
		    }
		    /**
		     * Set the ReadPreference for the cursor.
		     *
		     * @param readPreference - The new read preference for the cursor.
		     */
		    withReadConcern(readConcern) {
		        this.throwIfInitialized();
		        const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({ readConcern });
		        if (resolvedReadConcern) {
		            this.cursorOptions.readConcern = resolvedReadConcern;
		        }
		        return this;
		    }
		    /**
		     * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)
		     *
		     * @param value - Number of milliseconds to wait before aborting the query.
		     */
		    maxTimeMS(value) {
		        this.throwIfInitialized();
		        if (typeof value !== 'number') {
		            throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');
		        }
		        this.cursorOptions.maxTimeMS = value;
		        return this;
		    }
		    /**
		     * Set the batch size for the cursor.
		     *
		     * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.
		     */
		    batchSize(value) {
		        this.throwIfInitialized();
		        if (this.cursorOptions.tailable) {
		            throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');
		        }
		        if (typeof value !== 'number') {
		            throw new error_1.MongoInvalidArgumentError('Operation "batchSize" requires an integer');
		        }
		        this.cursorOptions.batchSize = value;
		        return this;
		    }
		    /**
		     * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will
		     * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even
		     * if the resultant data has already been retrieved by this cursor.
		     */
		    rewind() {
		        if (!this.initialized) {
		            return;
		        }
		        this.cursorId = null;
		        this.documents?.clear();
		        this.isClosed = false;
		        this.isKilled = false;
		        this.initialized = false;
		        const session = this.cursorSession;
		        if (session) {
		            // We only want to end this session if we created it, and it hasn't ended yet
		            if (session.explicit === false) {
		                if (!session.hasEnded) {
		                    session.endSession().then(undefined, utils_1.squashError);
		                }
		                this.cursorSession = this.cursorClient.startSession({ owner: this, explicit: false });
		            }
		        }
		    }
		    /** @internal */
		    async getMore(batchSize) {
		        if (this.cursorId == null) {
		            throw new error_1.MongoRuntimeError('Unexpected null cursor id. A cursor creating command should have set this');
		        }
		        if (this.selectedServer == null) {
		            throw new error_1.MongoRuntimeError('Unexpected null selectedServer. A cursor creating command should have set this');
		        }
		        const getMoreOperation = new get_more_1.GetMoreOperation(this.cursorNamespace, this.cursorId, this.selectedServer, {
		            ...this.cursorOptions,
		            session: this.cursorSession,
		            batchSize
		        });
		        return await (0, execute_operation_1.executeOperation)(this.cursorClient, getMoreOperation);
		    }
		    /**
		     * @internal
		     *
		     * This function is exposed for the unified test runner's createChangeStream
		     * operation.  We cannot refactor to use the abstract _initialize method without
		     * a significant refactor.
		     */
		    async cursorInit() {
		        try {
		            const state = await this._initialize(this.cursorSession);
		            const response = state.response;
		            this.selectedServer = state.server;
		            this.cursorId = response.id;
		            this.cursorNamespace = response.ns ?? this.namespace;
		            this.documents = response;
		            this.initialized = true; // the cursor is now initialized, even if it is dead
		        }
		        catch (error) {
		            // the cursor is now initialized, even if an error occurred
		            this.initialized = true;
		            await this.cleanup(error);
		            throw error;
		        }
		        if (this.isDead) {
		            await this.cleanup();
		        }
		        return;
		    }
		    /** @internal Attempt to obtain more documents */
		    async fetchBatch() {
		        if (this.isClosed) {
		            return;
		        }
		        if (this.isDead) {
		            // if the cursor is dead, we clean it up
		            // cleanupCursor should never throw, but if it does it indicates a bug in the driver
		            // and we should surface the error
		            await this.cleanup();
		            return;
		        }
		        if (this.cursorId == null) {
		            await this.cursorInit();
		            // If the cursor died or returned documents, return
		            if ((this.documents?.length ?? 0) !== 0 || this.isDead)
		                return;
		            // Otherwise, run a getMore
		        }
		        // otherwise need to call getMore
		        const batchSize = this.cursorOptions.batchSize || 1000;
		        try {
		            const response = await this.getMore(batchSize);
		            this.cursorId = response.id;
		            this.documents = response;
		        }
		        catch (error) {
		            try {
		                await this.cleanup(error);
		            }
		            catch (error) {
		                // `cleanupCursor` should never throw, squash and throw the original error
		                (0, utils_1.squashError)(error);
		            }
		            throw error;
		        }
		        if (this.isDead) {
		            // If we successfully received a response from a cursor BUT the cursor indicates that it is exhausted,
		            // we intentionally clean up the cursor to release its session back into the pool before the cursor
		            // is iterated.  This prevents a cursor that is exhausted on the server from holding
		            // onto a session indefinitely until the AbstractCursor is iterated.
		            //
		            // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver
		            // and we should surface the error
		            await this.cleanup();
		        }
		    }
		    /** @internal */
		    async cleanup(error) {
		        this.isClosed = true;
		        const session = this.cursorSession;
		        try {
		            if (!this.isKilled &&
		                this.cursorId &&
		                !this.cursorId.isZero() &&
		                this.cursorNamespace &&
		                this.selectedServer &&
		                !session.hasEnded) {
		                this.isKilled = true;
		                const cursorId = this.cursorId;
		                this.cursorId = bson_1.Long.ZERO;
		                await (0, execute_operation_1.executeOperation)(this.cursorClient, new kill_cursors_1.KillCursorsOperation(cursorId, this.cursorNamespace, this.selectedServer, {
		                    session
		                }));
		            }
		        }
		        catch (error) {
		            (0, utils_1.squashError)(error);
		        }
		        finally {
		            if (session?.owner === this) {
		                await session.endSession({ error });
		            }
		            if (!session?.inTransaction()) {
		                (0, sessions_1.maybeClearPinnedConnection)(session, { error });
		            }
		            this.emitClose();
		        }
		    }
		    /** @internal */
		    emitClose() {
		        try {
		            if (!this.hasEmittedClose && ((this.documents?.length ?? 0) === 0 || this.isClosed)) {
		                // @ts-expect-error: CursorEvents is generic so Parameters<CursorEvents["close"]> may not be assignable to `[]`. Not sure how to require extenders do not add parameters.
		                this.emit('close');
		            }
		        }
		        finally {
		            this.hasEmittedClose = true;
		        }
		    }
		    /** @internal */
		    async transformDocument(document) {
		        if (this.transform == null)
		            return document;
		        try {
		            const transformedDocument = this.transform(document);
		            // eslint-disable-next-line no-restricted-syntax
		            if (transformedDocument === null) {
		                const TRANSFORM_TO_NULL_ERROR = 'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';
		                throw new error_1.MongoAPIError(TRANSFORM_TO_NULL_ERROR);
		            }
		            return transformedDocument;
		        }
		        catch (transformError) {
		            try {
		                await this.close();
		            }
		            catch (closeError) {
		                (0, utils_1.squashError)(closeError);
		            }
		            throw transformError;
		        }
		    }
		    /** @internal */
		    throwIfInitialized() {
		        if (this.initialized)
		            throw new error_1.MongoCursorInUseError();
		    }
		}
		exports.AbstractCursor = AbstractCursor;
		/** @event */
		AbstractCursor.CLOSE = 'close';
		class ReadableCursorStream extends stream_1.Readable {
		    constructor(cursor) {
		        super({
		            objectMode: true,
		            autoDestroy: false,
		            highWaterMark: 1
		        });
		        this._readInProgress = false;
		        this._cursor = cursor;
		    }
		    // eslint-disable-next-line @typescript-eslint/no-unused-vars
		    _read(size) {
		        if (!this._readInProgress) {
		            this._readInProgress = true;
		            this._readNext();
		        }
		    }
		    _destroy(error, callback) {
		        this._cursor.close().then(() => callback(error), closeError => callback(closeError));
		    }
		    _readNext() {
		        if (this._cursor.id === bson_1.Long.ZERO) {
		            this.push(null);
		            return;
		        }
		        this._cursor.next().then(result => {
		            if (result == null) {
		                this.push(null);
		            }
		            else if (this.destroyed) {
		                this._cursor.close().then(undefined, utils_1.squashError);
		            }
		            else {
		                if (this.push(result)) {
		                    return this._readNext();
		                }
		                this._readInProgress = false;
		            }
		        }, err => {
		            // NOTE: This is questionable, but we have a test backing the behavior. It seems the
		            //       desired behavior is that a stream ends cleanly when a user explicitly closes
		            //       a client during iteration. Alternatively, we could do the "right" thing and
		            //       propagate the error message by removing this special case.
		            if (err.message.match(/server is closed/)) {
		                this._cursor.close().then(undefined, utils_1.squashError);
		                return this.push(null);
		            }
		            // NOTE: This is also perhaps questionable. The rationale here is that these errors tend
		            //       to be "operation was interrupted", where a cursor has been closed but there is an
		            //       active getMore in-flight. This used to check if the cursor was killed but once
		            //       that changed to happen in cleanup legitimate errors would not destroy the
		            //       stream. There are change streams test specifically test these cases.
		            if (err.message.match(/operation was interrupted/)) {
		                return this.push(null);
		            }
		            // NOTE: The two above checks on the message of the error will cause a null to be pushed
		            //       to the stream, thus closing the stream before the destroy call happens. This means
		            //       that either of those error messages on a change stream will not get a proper
		            //       'error' event to be emitted (the error passed to destroy). Change stream resumability
		            //       relies on that error event to be emitted to create its new cursor and thus was not
		            //       working on 4.4 servers because the error emitted on failover was "interrupted at
		            //       shutdown" while on 5.0+ it is "The server is in quiesce mode and will shut down".
		            //       See NODE-4475.
		            return this.destroy(err);
		        });
		    }
		}
		(0, resource_management_1.configureResourceManagement)(AbstractCursor.prototype);
		
	} (abstract_cursor));
	return abstract_cursor;
}

var hasRequiredAggregation_cursor;

function requireAggregation_cursor () {
	if (hasRequiredAggregation_cursor) return aggregation_cursor;
	hasRequiredAggregation_cursor = 1;
	Object.defineProperty(aggregation_cursor, "__esModule", { value: true });
	aggregation_cursor.AggregationCursor = void 0;
	const aggregate_1 = requireAggregate();
	const execute_operation_1 = requireExecute_operation();
	const utils_1 = requireUtils$1();
	const abstract_cursor_1 = requireAbstract_cursor();
	/**
	 * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB
	 * allowing for iteration over the results returned from the underlying query. It supports
	 * one by one document iteration, conversion to an array or can be iterated as a Node 4.X
	 * or higher stream
	 * @public
	 */
	class AggregationCursor extends abstract_cursor_1.AbstractCursor {
	    /** @internal */
	    constructor(client, namespace, pipeline = [], options = {}) {
	        super(client, namespace, options);
	        this.pipeline = pipeline;
	        this.aggregateOptions = options;
	    }
	    clone() {
	        const clonedOptions = (0, utils_1.mergeOptions)({}, this.aggregateOptions);
	        delete clonedOptions.session;
	        return new AggregationCursor(this.client, this.namespace, this.pipeline, {
	            ...clonedOptions
	        });
	    }
	    map(transform) {
	        return super.map(transform);
	    }
	    /** @internal */
	    async _initialize(session) {
	        const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {
	            ...this.aggregateOptions,
	            ...this.cursorOptions,
	            session
	        });
	        const response = await (0, execute_operation_1.executeOperation)(this.client, aggregateOperation);
	        return { server: aggregateOperation.server, session, response };
	    }
	    /** Execute the explain for the cursor */
	    async explain(verbosity) {
	        return (await (0, execute_operation_1.executeOperation)(this.client, new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {
	            ...this.aggregateOptions, // NOTE: order matters here, we may need to refine this
	            ...this.cursorOptions,
	            explain: verbosity ?? true
	        }))).shift(this.deserializationOptions);
	    }
	    addStage(stage) {
	        this.throwIfInitialized();
	        this.pipeline.push(stage);
	        return this;
	    }
	    group($group) {
	        return this.addStage({ $group });
	    }
	    /** Add a limit stage to the aggregation pipeline */
	    limit($limit) {
	        return this.addStage({ $limit });
	    }
	    /** Add a match stage to the aggregation pipeline */
	    match($match) {
	        return this.addStage({ $match });
	    }
	    /** Add an out stage to the aggregation pipeline */
	    out($out) {
	        return this.addStage({ $out });
	    }
	    /**
	     * Add a project stage to the aggregation pipeline
	     *
	     * @remarks
	     * In order to strictly type this function you must provide an interface
	     * that represents the effect of your projection on the result documents.
	     *
	     * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.
	     * You should specify a parameterized type to have assertions on your final results.
	     *
	     * @example
	     * ```typescript
	     * // Best way
	     * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });
	     * // Flexible way
	     * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });
	     * ```
	     *
	     * @remarks
	     * In order to strictly type this function you must provide an interface
	     * that represents the effect of your projection on the result documents.
	     *
	     * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
	     * it **does not** return a new instance of a cursor. This means when calling project,
	     * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
	     * Take note of the following example:
	     *
	     * @example
	     * ```typescript
	     * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);
	     * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });
	     * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();
	     *
	     * // or always use chaining and save the final cursor
	     *
	     * const cursor = coll.aggregate().project<{ a: string }>({
	     *   _id: 0,
	     *   a: { $convert: { input: '$a', to: 'string' }
	     * }});
	     * ```
	     */
	    project($project) {
	        return this.addStage({ $project });
	    }
	    /** Add a lookup stage to the aggregation pipeline */
	    lookup($lookup) {
	        return this.addStage({ $lookup });
	    }
	    /** Add a redact stage to the aggregation pipeline */
	    redact($redact) {
	        return this.addStage({ $redact });
	    }
	    /** Add a skip stage to the aggregation pipeline */
	    skip($skip) {
	        return this.addStage({ $skip });
	    }
	    /** Add a sort stage to the aggregation pipeline */
	    sort($sort) {
	        return this.addStage({ $sort });
	    }
	    /** Add a unwind stage to the aggregation pipeline */
	    unwind($unwind) {
	        return this.addStage({ $unwind });
	    }
	    /** Add a geoNear stage to the aggregation pipeline */
	    geoNear($geoNear) {
	        return this.addStage({ $geoNear });
	    }
	}
	aggregation_cursor.AggregationCursor = AggregationCursor;
	
	return aggregation_cursor;
}

var find_cursor = {};

var count = {};

var hasRequiredCount;

function requireCount () {
	if (hasRequiredCount) return count;
	hasRequiredCount = 1;
	Object.defineProperty(count, "__esModule", { value: true });
	count.CountOperation = void 0;
	const command_1 = requireCommand();
	const operation_1 = requireOperation();
	/** @internal */
	class CountOperation extends command_1.CommandOperation {
	    constructor(namespace, filter, options) {
	        super({ s: { namespace: namespace } }, options);
	        this.options = options;
	        this.collectionName = namespace.collection;
	        this.query = filter;
	    }
	    get commandName() {
	        return 'count';
	    }
	    async execute(server, session) {
	        const options = this.options;
	        const cmd = {
	            count: this.collectionName,
	            query: this.query
	        };
	        if (typeof options.limit === 'number') {
	            cmd.limit = options.limit;
	        }
	        if (typeof options.skip === 'number') {
	            cmd.skip = options.skip;
	        }
	        if (options.hint != null) {
	            cmd.hint = options.hint;
	        }
	        if (typeof options.maxTimeMS === 'number') {
	            cmd.maxTimeMS = options.maxTimeMS;
	        }
	        const result = await super.executeCommand(server, session, cmd);
	        return result ? result.n : 0;
	    }
	}
	count.CountOperation = CountOperation;
	(0, operation_1.defineAspects)(CountOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);
	
	return count;
}

var find = {};

var sort = {};

var hasRequiredSort;

function requireSort () {
	if (hasRequiredSort) return sort;
	hasRequiredSort = 1;
	Object.defineProperty(sort, "__esModule", { value: true });
	sort.formatSort = formatSort;
	const error_1 = requireError();
	/** @internal */
	function prepareDirection(direction = 1) {
	    const value = `${direction}`.toLowerCase();
	    if (isMeta(direction))
	        return direction;
	    switch (value) {
	        case 'ascending':
	        case 'asc':
	        case '1':
	            return 1;
	        case 'descending':
	        case 'desc':
	        case '-1':
	            return -1;
	        default:
	            throw new error_1.MongoInvalidArgumentError(`Invalid sort direction: ${JSON.stringify(direction)}`);
	    }
	}
	/** @internal */
	function isMeta(t) {
	    return typeof t === 'object' && t != null && '$meta' in t && typeof t.$meta === 'string';
	}
	/** @internal */
	function isPair(t) {
	    if (Array.isArray(t) && t.length === 2) {
	        try {
	            prepareDirection(t[1]);
	            return true;
	        }
	        catch {
	            return false;
	        }
	    }
	    return false;
	}
	function isDeep(t) {
	    return Array.isArray(t) && Array.isArray(t[0]);
	}
	function isMap(t) {
	    return t instanceof Map && t.size > 0;
	}
	/** @internal */
	function pairToMap(v) {
	    return new Map([[`${v[0]}`, prepareDirection([v[1]])]]);
	}
	/** @internal */
	function deepToMap(t) {
	    const sortEntries = t.map(([k, v]) => [`${k}`, prepareDirection(v)]);
	    return new Map(sortEntries);
	}
	/** @internal */
	function stringsToMap(t) {
	    const sortEntries = t.map(key => [`${key}`, 1]);
	    return new Map(sortEntries);
	}
	/** @internal */
	function objectToMap(t) {
	    const sortEntries = Object.entries(t).map(([k, v]) => [
	        `${k}`,
	        prepareDirection(v)
	    ]);
	    return new Map(sortEntries);
	}
	/** @internal */
	function mapToMap(t) {
	    const sortEntries = Array.from(t).map(([k, v]) => [
	        `${k}`,
	        prepareDirection(v)
	    ]);
	    return new Map(sortEntries);
	}
	/** converts a Sort type into a type that is valid for the server (SortForCmd) */
	function formatSort(sort, direction) {
	    if (sort == null)
	        return undefined;
	    if (typeof sort === 'string')
	        return new Map([[sort, prepareDirection(direction)]]);
	    if (typeof sort !== 'object') {
	        throw new error_1.MongoInvalidArgumentError(`Invalid sort format: ${JSON.stringify(sort)} Sort must be a valid object`);
	    }
	    if (!Array.isArray(sort)) {
	        return isMap(sort) ? mapToMap(sort) : Object.keys(sort).length ? objectToMap(sort) : undefined;
	    }
	    if (!sort.length)
	        return undefined;
	    if (isDeep(sort))
	        return deepToMap(sort);
	    if (isPair(sort))
	        return pairToMap(sort);
	    return stringsToMap(sort);
	}
	
	return sort;
}

var hasRequiredFind;

function requireFind () {
	if (hasRequiredFind) return find;
	hasRequiredFind = 1;
	Object.defineProperty(find, "__esModule", { value: true });
	find.FindOperation = void 0;
	const responses_1 = requireResponses();
	const error_1 = requireError();
	const read_concern_1 = requireRead_concern();
	const sort_1 = requireSort();
	const utils_1 = requireUtils$1();
	const command_1 = requireCommand();
	const operation_1 = requireOperation();
	/** @internal */
	class FindOperation extends command_1.CommandOperation {
	    constructor(ns, filter = {}, options = {}) {
	        super(undefined, options);
	        this.options = { ...options };
	        delete this.options.writeConcern;
	        this.ns = ns;
	        if (typeof filter !== 'object' || Array.isArray(filter)) {
	            throw new error_1.MongoInvalidArgumentError('Query filter must be a plain object or ObjectId');
	        }
	        // special case passing in an ObjectId as a filter
	        this.filter = filter != null && filter._bsontype === 'ObjectId' ? { _id: filter } : filter;
	    }
	    get commandName() {
	        return 'find';
	    }
	    async execute(server, session) {
	        this.server = server;
	        const options = this.options;
	        let findCommand = makeFindCommand(this.ns, this.filter, options);
	        if (this.explain) {
	            findCommand = (0, utils_1.decorateWithExplain)(findCommand, this.explain);
	        }
	        return await server.command(this.ns, findCommand, {
	            ...this.options,
	            ...this.bsonOptions,
	            documentsReturnedIn: 'firstBatch',
	            session
	        }, this.explain ? responses_1.ExplainedCursorResponse : responses_1.CursorResponse);
	    }
	}
	find.FindOperation = FindOperation;
	function makeFindCommand(ns, filter, options) {
	    const findCommand = {
	        find: ns.collection,
	        filter
	    };
	    if (options.sort) {
	        findCommand.sort = (0, sort_1.formatSort)(options.sort);
	    }
	    if (options.projection) {
	        let projection = options.projection;
	        if (projection && Array.isArray(projection)) {
	            projection = projection.length
	                ? projection.reduce((result, field) => {
	                    result[field] = 1;
	                    return result;
	                }, {})
	                : { _id: 1 };
	        }
	        findCommand.projection = projection;
	    }
	    if (options.hint) {
	        findCommand.hint = (0, utils_1.normalizeHintField)(options.hint);
	    }
	    if (typeof options.skip === 'number') {
	        findCommand.skip = options.skip;
	    }
	    if (typeof options.limit === 'number') {
	        if (options.limit < 0) {
	            findCommand.limit = -options.limit;
	            findCommand.singleBatch = true;
	        }
	        else {
	            findCommand.limit = options.limit;
	        }
	    }
	    if (typeof options.batchSize === 'number') {
	        if (options.batchSize < 0) {
	            if (options.limit &&
	                options.limit !== 0 &&
	                Math.abs(options.batchSize) < Math.abs(options.limit)) {
	                findCommand.limit = -options.batchSize;
	            }
	            findCommand.singleBatch = true;
	        }
	        else {
	            findCommand.batchSize = options.batchSize;
	        }
	    }
	    if (typeof options.singleBatch === 'boolean') {
	        findCommand.singleBatch = options.singleBatch;
	    }
	    // we check for undefined specifically here to allow falsy values
	    // eslint-disable-next-line no-restricted-syntax
	    if (options.comment !== undefined) {
	        findCommand.comment = options.comment;
	    }
	    if (typeof options.maxTimeMS === 'number') {
	        findCommand.maxTimeMS = options.maxTimeMS;
	    }
	    const readConcern = read_concern_1.ReadConcern.fromOptions(options);
	    if (readConcern) {
	        findCommand.readConcern = readConcern.toJSON();
	    }
	    if (options.max) {
	        findCommand.max = options.max;
	    }
	    if (options.min) {
	        findCommand.min = options.min;
	    }
	    if (typeof options.returnKey === 'boolean') {
	        findCommand.returnKey = options.returnKey;
	    }
	    if (typeof options.showRecordId === 'boolean') {
	        findCommand.showRecordId = options.showRecordId;
	    }
	    if (typeof options.tailable === 'boolean') {
	        findCommand.tailable = options.tailable;
	    }
	    if (typeof options.oplogReplay === 'boolean') {
	        findCommand.oplogReplay = options.oplogReplay;
	    }
	    if (typeof options.timeout === 'boolean') {
	        findCommand.noCursorTimeout = !options.timeout;
	    }
	    else if (typeof options.noCursorTimeout === 'boolean') {
	        findCommand.noCursorTimeout = options.noCursorTimeout;
	    }
	    if (typeof options.awaitData === 'boolean') {
	        findCommand.awaitData = options.awaitData;
	    }
	    if (typeof options.allowPartialResults === 'boolean') {
	        findCommand.allowPartialResults = options.allowPartialResults;
	    }
	    if (options.collation) {
	        findCommand.collation = options.collation;
	    }
	    if (typeof options.allowDiskUse === 'boolean') {
	        findCommand.allowDiskUse = options.allowDiskUse;
	    }
	    if (options.let) {
	        findCommand.let = options.let;
	    }
	    return findCommand;
	}
	(0, operation_1.defineAspects)(FindOperation, [
	    operation_1.Aspect.READ_OPERATION,
	    operation_1.Aspect.RETRYABLE,
	    operation_1.Aspect.EXPLAINABLE,
	    operation_1.Aspect.CURSOR_CREATING
	]);
	
	return find;
}

var hasRequiredFind_cursor;

function requireFind_cursor () {
	if (hasRequiredFind_cursor) return find_cursor;
	hasRequiredFind_cursor = 1;
	Object.defineProperty(find_cursor, "__esModule", { value: true });
	find_cursor.FindCursor = find_cursor.FLAGS = void 0;
	const responses_1 = requireResponses();
	const error_1 = requireError();
	const count_1 = requireCount();
	const execute_operation_1 = requireExecute_operation();
	const find_1 = requireFind();
	const sort_1 = requireSort();
	const utils_1 = requireUtils$1();
	const abstract_cursor_1 = requireAbstract_cursor();
	/** @public Flags allowed for cursor */
	find_cursor.FLAGS = [
	    'tailable',
	    'oplogReplay',
	    'noCursorTimeout',
	    'awaitData',
	    'exhaust',
	    'partial'
	];
	/** @public */
	class FindCursor extends abstract_cursor_1.AbstractCursor {
	    /** @internal */
	    constructor(client, namespace, filter = {}, options = {}) {
	        super(client, namespace, options);
	        /** @internal */
	        this.numReturned = 0;
	        this.cursorFilter = filter;
	        this.findOptions = options;
	        if (options.sort != null) {
	            this.findOptions.sort = (0, sort_1.formatSort)(options.sort);
	        }
	    }
	    clone() {
	        const clonedOptions = (0, utils_1.mergeOptions)({}, this.findOptions);
	        delete clonedOptions.session;
	        return new FindCursor(this.client, this.namespace, this.cursorFilter, {
	            ...clonedOptions
	        });
	    }
	    map(transform) {
	        return super.map(transform);
	    }
	    /** @internal */
	    async _initialize(session) {
	        const findOperation = new find_1.FindOperation(this.namespace, this.cursorFilter, {
	            ...this.findOptions, // NOTE: order matters here, we may need to refine this
	            ...this.cursorOptions,
	            session
	        });
	        const response = await (0, execute_operation_1.executeOperation)(this.client, findOperation);
	        // the response is not a cursor when `explain` is enabled
	        this.numReturned = response.batchSize;
	        return { server: findOperation.server, session, response };
	    }
	    /** @internal */
	    async getMore(batchSize) {
	        const numReturned = this.numReturned;
	        if (numReturned) {
	            // TODO(DRIVERS-1448): Remove logic to enforce `limit` in the driver
	            const limit = this.findOptions.limit;
	            batchSize =
	                limit && limit > 0 && numReturned + batchSize > limit ? limit - numReturned : batchSize;
	            if (batchSize <= 0) {
	                try {
	                    await this.close();
	                }
	                catch (error) {
	                    (0, utils_1.squashError)(error);
	                    // this is an optimization for the special case of a limit for a find command to avoid an
	                    // extra getMore when the limit has been reached and the limit is a multiple of the batchSize.
	                    // This is a consequence of the new query engine in 5.0 having no knowledge of the limit as it
	                    // produces results for the find command.  Once a batch is filled up, it is returned and only
	                    // on the subsequent getMore will the query framework consider the limit, determine the cursor
	                    // is exhausted and return a cursorId of zero.
	                    // instead, if we determine there are no more documents to request from the server, we preemptively
	                    // close the cursor
	                }
	                return responses_1.CursorResponse.emptyGetMore;
	            }
	        }
	        const response = await super.getMore(batchSize);
	        // TODO: wrap this in some logic to prevent it from happening if we don't need this support
	        this.numReturned = this.numReturned + response.batchSize;
	        return response;
	    }
	    /**
	     * Get the count of documents for this cursor
	     * @deprecated Use `collection.estimatedDocumentCount` or `collection.countDocuments` instead
	     */
	    async count(options) {
	        (0, utils_1.emitWarningOnce)('cursor.count is deprecated and will be removed in the next major version, please use `collection.estimatedDocumentCount` or `collection.countDocuments` instead ');
	        if (typeof options === 'boolean') {
	            throw new error_1.MongoInvalidArgumentError('Invalid first parameter to count');
	        }
	        return await (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.namespace, this.cursorFilter, {
	            ...this.findOptions, // NOTE: order matters here, we may need to refine this
	            ...this.cursorOptions,
	            ...options
	        }));
	    }
	    /** Execute the explain for the cursor */
	    async explain(verbosity) {
	        return (await (0, execute_operation_1.executeOperation)(this.client, new find_1.FindOperation(this.namespace, this.cursorFilter, {
	            ...this.findOptions, // NOTE: order matters here, we may need to refine this
	            ...this.cursorOptions,
	            explain: verbosity ?? true
	        }))).shift(this.deserializationOptions);
	    }
	    /** Set the cursor query */
	    filter(filter) {
	        this.throwIfInitialized();
	        this.cursorFilter = filter;
	        return this;
	    }
	    /**
	     * Set the cursor hint
	     *
	     * @param hint - If specified, then the query system will only consider plans using the hinted index.
	     */
	    hint(hint) {
	        this.throwIfInitialized();
	        this.findOptions.hint = hint;
	        return this;
	    }
	    /**
	     * Set the cursor min
	     *
	     * @param min - Specify a $min value to specify the inclusive lower bound for a specific index in order to constrain the results of find(). The $min specifies the lower bound for all keys of a specific index in order.
	     */
	    min(min) {
	        this.throwIfInitialized();
	        this.findOptions.min = min;
	        return this;
	    }
	    /**
	     * Set the cursor max
	     *
	     * @param max - Specify a $max value to specify the exclusive upper bound for a specific index in order to constrain the results of find(). The $max specifies the upper bound for all keys of a specific index in order.
	     */
	    max(max) {
	        this.throwIfInitialized();
	        this.findOptions.max = max;
	        return this;
	    }
	    /**
	     * Set the cursor returnKey.
	     * If set to true, modifies the cursor to only return the index field or fields for the results of the query, rather than documents.
	     * If set to true and the query does not use an index to perform the read operation, the returned documents will not contain any fields.
	     *
	     * @param value - the returnKey value.
	     */
	    returnKey(value) {
	        this.throwIfInitialized();
	        this.findOptions.returnKey = value;
	        return this;
	    }
	    /**
	     * Modifies the output of a query by adding a field $recordId to matching documents. $recordId is the internal key which uniquely identifies a document in a collection.
	     *
	     * @param value - The $showDiskLoc option has now been deprecated and replaced with the showRecordId field. $showDiskLoc will still be accepted for OP_QUERY stye find.
	     */
	    showRecordId(value) {
	        this.throwIfInitialized();
	        this.findOptions.showRecordId = value;
	        return this;
	    }
	    /**
	     * Add a query modifier to the cursor query
	     *
	     * @param name - The query modifier (must start with $, such as $orderby etc)
	     * @param value - The modifier value.
	     */
	    addQueryModifier(name, value) {
	        this.throwIfInitialized();
	        if (name[0] !== '$') {
	            throw new error_1.MongoInvalidArgumentError(`${name} is not a valid query modifier`);
	        }
	        // Strip of the $
	        const field = name.substr(1);
	        // NOTE: consider some TS magic for this
	        switch (field) {
	            case 'comment':
	                this.findOptions.comment = value;
	                break;
	            case 'explain':
	                this.findOptions.explain = value;
	                break;
	            case 'hint':
	                this.findOptions.hint = value;
	                break;
	            case 'max':
	                this.findOptions.max = value;
	                break;
	            case 'maxTimeMS':
	                this.findOptions.maxTimeMS = value;
	                break;
	            case 'min':
	                this.findOptions.min = value;
	                break;
	            case 'orderby':
	                this.findOptions.sort = (0, sort_1.formatSort)(value);
	                break;
	            case 'query':
	                this.cursorFilter = value;
	                break;
	            case 'returnKey':
	                this.findOptions.returnKey = value;
	                break;
	            case 'showDiskLoc':
	                this.findOptions.showRecordId = value;
	                break;
	            default:
	                throw new error_1.MongoInvalidArgumentError(`Invalid query modifier: ${name}`);
	        }
	        return this;
	    }
	    /**
	     * Add a comment to the cursor query allowing for tracking the comment in the log.
	     *
	     * @param value - The comment attached to this query.
	     */
	    comment(value) {
	        this.throwIfInitialized();
	        this.findOptions.comment = value;
	        return this;
	    }
	    /**
	     * Set a maxAwaitTimeMS on a tailing cursor query to allow to customize the timeout value for the option awaitData (Only supported on MongoDB 3.2 or higher, ignored otherwise)
	     *
	     * @param value - Number of milliseconds to wait before aborting the tailed query.
	     */
	    maxAwaitTimeMS(value) {
	        this.throwIfInitialized();
	        if (typeof value !== 'number') {
	            throw new error_1.MongoInvalidArgumentError('Argument for maxAwaitTimeMS must be a number');
	        }
	        this.findOptions.maxAwaitTimeMS = value;
	        return this;
	    }
	    /**
	     * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)
	     *
	     * @param value - Number of milliseconds to wait before aborting the query.
	     */
	    maxTimeMS(value) {
	        this.throwIfInitialized();
	        if (typeof value !== 'number') {
	            throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');
	        }
	        this.findOptions.maxTimeMS = value;
	        return this;
	    }
	    /**
	     * Add a project stage to the aggregation pipeline
	     *
	     * @remarks
	     * In order to strictly type this function you must provide an interface
	     * that represents the effect of your projection on the result documents.
	     *
	     * By default chaining a projection to your cursor changes the returned type to the generic
	     * {@link Document} type.
	     * You should specify a parameterized type to have assertions on your final results.
	     *
	     * @example
	     * ```typescript
	     * // Best way
	     * const docs: FindCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });
	     * // Flexible way
	     * const docs: FindCursor<Document> = cursor.project({ _id: 0, a: true });
	     * ```
	     *
	     * @remarks
	     *
	     * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
	     * it **does not** return a new instance of a cursor. This means when calling project,
	     * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
	     * Take note of the following example:
	     *
	     * @example
	     * ```typescript
	     * const cursor: FindCursor<{ a: number; b: string }> = coll.find();
	     * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });
	     * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();
	     *
	     * // or always use chaining and save the final cursor
	     *
	     * const cursor = coll.find().project<{ a: string }>({
	     *   _id: 0,
	     *   a: { $convert: { input: '$a', to: 'string' }
	     * }});
	     * ```
	     */
	    project(value) {
	        this.throwIfInitialized();
	        this.findOptions.projection = value;
	        return this;
	    }
	    /**
	     * Sets the sort order of the cursor query.
	     *
	     * @param sort - The key or keys set for the sort.
	     * @param direction - The direction of the sorting (1 or -1).
	     */
	    sort(sort, direction) {
	        this.throwIfInitialized();
	        if (this.findOptions.tailable) {
	            throw new error_1.MongoTailableCursorError('Tailable cursor does not support sorting');
	        }
	        this.findOptions.sort = (0, sort_1.formatSort)(sort, direction);
	        return this;
	    }
	    /**
	     * Allows disk use for blocking sort operations exceeding 100MB memory. (MongoDB 3.2 or higher)
	     *
	     * @remarks
	     * {@link https://www.mongodb.com/docs/manual/reference/command/find/#find-cmd-allowdiskuse | find command allowDiskUse documentation}
	     */
	    allowDiskUse(allow = true) {
	        this.throwIfInitialized();
	        if (!this.findOptions.sort) {
	            throw new error_1.MongoInvalidArgumentError('Option "allowDiskUse" requires a sort specification');
	        }
	        // As of 6.0 the default is true. This allows users to get back to the old behavior.
	        if (!allow) {
	            this.findOptions.allowDiskUse = false;
	            return this;
	        }
	        this.findOptions.allowDiskUse = true;
	        return this;
	    }
	    /**
	     * Set the collation options for the cursor.
	     *
	     * @param value - The cursor collation options (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
	     */
	    collation(value) {
	        this.throwIfInitialized();
	        this.findOptions.collation = value;
	        return this;
	    }
	    /**
	     * Set the limit for the cursor.
	     *
	     * @param value - The limit for the cursor query.
	     */
	    limit(value) {
	        this.throwIfInitialized();
	        if (this.findOptions.tailable) {
	            throw new error_1.MongoTailableCursorError('Tailable cursor does not support limit');
	        }
	        if (typeof value !== 'number') {
	            throw new error_1.MongoInvalidArgumentError('Operation "limit" requires an integer');
	        }
	        this.findOptions.limit = value;
	        return this;
	    }
	    /**
	     * Set the skip for the cursor.
	     *
	     * @param value - The skip for the cursor query.
	     */
	    skip(value) {
	        this.throwIfInitialized();
	        if (this.findOptions.tailable) {
	            throw new error_1.MongoTailableCursorError('Tailable cursor does not support skip');
	        }
	        if (typeof value !== 'number') {
	            throw new error_1.MongoInvalidArgumentError('Operation "skip" requires an integer');
	        }
	        this.findOptions.skip = value;
	        return this;
	    }
	}
	find_cursor.FindCursor = FindCursor;
	
	return find_cursor;
}

var list_indexes_cursor = {};

var hasRequiredList_indexes_cursor;

function requireList_indexes_cursor () {
	if (hasRequiredList_indexes_cursor) return list_indexes_cursor;
	hasRequiredList_indexes_cursor = 1;
	Object.defineProperty(list_indexes_cursor, "__esModule", { value: true });
	list_indexes_cursor.ListIndexesCursor = void 0;
	const execute_operation_1 = requireExecute_operation();
	const indexes_1 = requireIndexes();
	const abstract_cursor_1 = requireAbstract_cursor();
	/** @public */
	class ListIndexesCursor extends abstract_cursor_1.AbstractCursor {
	    constructor(collection, options) {
	        super(collection.client, collection.s.namespace, options);
	        this.parent = collection;
	        this.options = options;
	    }
	    clone() {
	        return new ListIndexesCursor(this.parent, {
	            ...this.options,
	            ...this.cursorOptions
	        });
	    }
	    /** @internal */
	    async _initialize(session) {
	        const operation = new indexes_1.ListIndexesOperation(this.parent, {
	            ...this.cursorOptions,
	            ...this.options,
	            session
	        });
	        const response = await (0, execute_operation_1.executeOperation)(this.parent.client, operation);
	        return { server: operation.server, session, response };
	    }
	}
	list_indexes_cursor.ListIndexesCursor = ListIndexesCursor;
	
	return list_indexes_cursor;
}

var list_search_indexes_cursor = {};

var hasRequiredList_search_indexes_cursor;

function requireList_search_indexes_cursor () {
	if (hasRequiredList_search_indexes_cursor) return list_search_indexes_cursor;
	hasRequiredList_search_indexes_cursor = 1;
	Object.defineProperty(list_search_indexes_cursor, "__esModule", { value: true });
	list_search_indexes_cursor.ListSearchIndexesCursor = void 0;
	const aggregation_cursor_1 = requireAggregation_cursor();
	/** @public */
	class ListSearchIndexesCursor extends aggregation_cursor_1.AggregationCursor {
	    /** @internal */
	    constructor({ fullNamespace: ns, client }, name, options = {}) {
	        const pipeline = name == null ? [{ $listSearchIndexes: {} }] : [{ $listSearchIndexes: { name } }];
	        super(client, ns, pipeline, options);
	    }
	}
	list_search_indexes_cursor.ListSearchIndexesCursor = ListSearchIndexesCursor;
	
	return list_search_indexes_cursor;
}

var distinct = {};

var hasRequiredDistinct;

function requireDistinct () {
	if (hasRequiredDistinct) return distinct;
	hasRequiredDistinct = 1;
	Object.defineProperty(distinct, "__esModule", { value: true });
	distinct.DistinctOperation = void 0;
	const utils_1 = requireUtils$1();
	const command_1 = requireCommand();
	const operation_1 = requireOperation();
	/**
	 * Return a list of distinct values for the given key across a collection.
	 * @internal
	 */
	class DistinctOperation extends command_1.CommandOperation {
	    /**
	     * Construct a Distinct operation.
	     *
	     * @param collection - Collection instance.
	     * @param key - Field of the document to find distinct values for.
	     * @param query - The query for filtering the set of documents to which we apply the distinct filter.
	     * @param options - Optional settings. See Collection.prototype.distinct for a list of options.
	     */
	    constructor(collection, key, query, options) {
	        super(collection, options);
	        this.options = options ?? {};
	        this.collection = collection;
	        this.key = key;
	        this.query = query;
	    }
	    get commandName() {
	        return 'distinct';
	    }
	    async execute(server, session) {
	        const coll = this.collection;
	        const key = this.key;
	        const query = this.query;
	        const options = this.options;
	        // Distinct command
	        const cmd = {
	            distinct: coll.collectionName,
	            key: key,
	            query: query
	        };
	        // Add maxTimeMS if defined
	        if (typeof options.maxTimeMS === 'number') {
	            cmd.maxTimeMS = options.maxTimeMS;
	        }
	        // we check for undefined specifically here to allow falsy values
	        // eslint-disable-next-line no-restricted-syntax
	        if (typeof options.comment !== 'undefined') {
	            cmd.comment = options.comment;
	        }
	        // Do we have a readConcern specified
	        (0, utils_1.decorateWithReadConcern)(cmd, coll, options);
	        // Have we specified collation
	        (0, utils_1.decorateWithCollation)(cmd, coll, options);
	        const result = await super.executeCommand(server, session, cmd);
	        return this.explain ? result : result.values;
	    }
	}
	distinct.DistinctOperation = DistinctOperation;
	(0, operation_1.defineAspects)(DistinctOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE]);
	
	return distinct;
}

var estimated_document_count = {};

var hasRequiredEstimated_document_count;

function requireEstimated_document_count () {
	if (hasRequiredEstimated_document_count) return estimated_document_count;
	hasRequiredEstimated_document_count = 1;
	Object.defineProperty(estimated_document_count, "__esModule", { value: true });
	estimated_document_count.EstimatedDocumentCountOperation = void 0;
	const command_1 = requireCommand();
	const operation_1 = requireOperation();
	/** @internal */
	class EstimatedDocumentCountOperation extends command_1.CommandOperation {
	    constructor(collection, options = {}) {
	        super(collection, options);
	        this.options = options;
	        this.collectionName = collection.collectionName;
	    }
	    get commandName() {
	        return 'count';
	    }
	    async execute(server, session) {
	        const cmd = { count: this.collectionName };
	        if (typeof this.options.maxTimeMS === 'number') {
	            cmd.maxTimeMS = this.options.maxTimeMS;
	        }
	        // we check for undefined specifically here to allow falsy values
	        // eslint-disable-next-line no-restricted-syntax
	        if (this.options.comment !== undefined) {
	            cmd.comment = this.options.comment;
	        }
	        const response = await super.executeCommand(server, session, cmd);
	        return response?.n || 0;
	    }
	}
	estimated_document_count.EstimatedDocumentCountOperation = EstimatedDocumentCountOperation;
	(0, operation_1.defineAspects)(EstimatedDocumentCountOperation, [
	    operation_1.Aspect.READ_OPERATION,
	    operation_1.Aspect.RETRYABLE,
	    operation_1.Aspect.CURSOR_CREATING
	]);
	
	return estimated_document_count;
}

var find_and_modify = {};

var hasRequiredFind_and_modify;

function requireFind_and_modify () {
	if (hasRequiredFind_and_modify) return find_and_modify;
	hasRequiredFind_and_modify = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.FindOneAndUpdateOperation = exports.FindOneAndReplaceOperation = exports.FindOneAndDeleteOperation = exports.FindAndModifyOperation = exports.ReturnDocument = void 0;
		const error_1 = requireError();
		const read_preference_1 = requireRead_preference();
		const sort_1 = requireSort();
		const utils_1 = requireUtils$1();
		const command_1 = requireCommand();
		const operation_1 = requireOperation();
		/** @public */
		exports.ReturnDocument = Object.freeze({
		    BEFORE: 'before',
		    AFTER: 'after'
		});
		function configureFindAndModifyCmdBaseUpdateOpts(cmdBase, options) {
		    cmdBase.new = options.returnDocument === exports.ReturnDocument.AFTER;
		    cmdBase.upsert = options.upsert === true;
		    if (options.bypassDocumentValidation === true) {
		        cmdBase.bypassDocumentValidation = options.bypassDocumentValidation;
		    }
		    return cmdBase;
		}
		/** @internal */
		class FindAndModifyOperation extends command_1.CommandOperation {
		    constructor(collection, query, options) {
		        super(collection, options);
		        this.options = options ?? {};
		        this.cmdBase = {
		            remove: false,
		            new: false,
		            upsert: false
		        };
		        options.includeResultMetadata ??= false;
		        const sort = (0, sort_1.formatSort)(options.sort);
		        if (sort) {
		            this.cmdBase.sort = sort;
		        }
		        if (options.projection) {
		            this.cmdBase.fields = options.projection;
		        }
		        if (options.maxTimeMS) {
		            this.cmdBase.maxTimeMS = options.maxTimeMS;
		        }
		        // Decorate the findAndModify command with the write Concern
		        if (options.writeConcern) {
		            this.cmdBase.writeConcern = options.writeConcern;
		        }
		        if (options.let) {
		            this.cmdBase.let = options.let;
		        }
		        // we check for undefined specifically here to allow falsy values
		        // eslint-disable-next-line no-restricted-syntax
		        if (options.comment !== undefined) {
		            this.cmdBase.comment = options.comment;
		        }
		        // force primary read preference
		        this.readPreference = read_preference_1.ReadPreference.primary;
		        this.collection = collection;
		        this.query = query;
		    }
		    get commandName() {
		        return 'findAndModify';
		    }
		    async execute(server, session) {
		        const coll = this.collection;
		        const query = this.query;
		        const options = { ...this.options, ...this.bsonOptions };
		        // Create findAndModify command object
		        const cmd = {
		            findAndModify: coll.collectionName,
		            query: query,
		            ...this.cmdBase
		        };
		        (0, utils_1.decorateWithCollation)(cmd, coll, options);
		        if (options.hint) {
		            // TODO: once this method becomes a CommandOperation we will have the server
		            // in place to check.
		            const unacknowledgedWrite = this.writeConcern?.w === 0;
		            if (unacknowledgedWrite || (0, utils_1.maxWireVersion)(server) < 8) {
		                throw new error_1.MongoCompatibilityError('The current topology does not support a hint on findAndModify commands');
		            }
		            cmd.hint = options.hint;
		        }
		        // Execute the command
		        const result = await super.executeCommand(server, session, cmd);
		        return options.includeResultMetadata ? result : (result.value ?? null);
		    }
		}
		exports.FindAndModifyOperation = FindAndModifyOperation;
		/** @internal */
		class FindOneAndDeleteOperation extends FindAndModifyOperation {
		    constructor(collection, filter, options) {
		        // Basic validation
		        if (filter == null || typeof filter !== 'object') {
		            throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
		        }
		        super(collection, filter, options);
		        this.cmdBase.remove = true;
		    }
		}
		exports.FindOneAndDeleteOperation = FindOneAndDeleteOperation;
		/** @internal */
		class FindOneAndReplaceOperation extends FindAndModifyOperation {
		    constructor(collection, filter, replacement, options) {
		        if (filter == null || typeof filter !== 'object') {
		            throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
		        }
		        if (replacement == null || typeof replacement !== 'object') {
		            throw new error_1.MongoInvalidArgumentError('Argument "replacement" must be an object');
		        }
		        if ((0, utils_1.hasAtomicOperators)(replacement)) {
		            throw new error_1.MongoInvalidArgumentError('Replacement document must not contain atomic operators');
		        }
		        super(collection, filter, options);
		        this.cmdBase.update = replacement;
		        configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);
		    }
		}
		exports.FindOneAndReplaceOperation = FindOneAndReplaceOperation;
		/** @internal */
		class FindOneAndUpdateOperation extends FindAndModifyOperation {
		    constructor(collection, filter, update, options) {
		        if (filter == null || typeof filter !== 'object') {
		            throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
		        }
		        if (update == null || typeof update !== 'object') {
		            throw new error_1.MongoInvalidArgumentError('Argument "update" must be an object');
		        }
		        if (!(0, utils_1.hasAtomicOperators)(update)) {
		            throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');
		        }
		        super(collection, filter, options);
		        this.cmdBase.update = update;
		        configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);
		        if (options.arrayFilters) {
		            this.cmdBase.arrayFilters = options.arrayFilters;
		        }
		    }
		}
		exports.FindOneAndUpdateOperation = FindOneAndUpdateOperation;
		(0, operation_1.defineAspects)(FindAndModifyOperation, [
		    operation_1.Aspect.WRITE_OPERATION,
		    operation_1.Aspect.RETRYABLE,
		    operation_1.Aspect.EXPLAINABLE
		]);
		
	} (find_and_modify));
	return find_and_modify;
}

var is_capped = {};

var hasRequiredIs_capped;

function requireIs_capped () {
	if (hasRequiredIs_capped) return is_capped;
	hasRequiredIs_capped = 1;
	Object.defineProperty(is_capped, "__esModule", { value: true });
	is_capped.IsCappedOperation = void 0;
	const error_1 = requireError();
	const operation_1 = requireOperation();
	/** @internal */
	class IsCappedOperation extends operation_1.AbstractOperation {
	    constructor(collection, options) {
	        super(options);
	        this.options = options;
	        this.collection = collection;
	    }
	    get commandName() {
	        return 'listCollections';
	    }
	    async execute(server, session) {
	        const coll = this.collection;
	        const [collection] = await coll.s.db
	            .listCollections({ name: coll.collectionName }, { ...this.options, nameOnly: false, readPreference: this.readPreference, session })
	            .toArray();
	        if (collection == null || collection.options == null) {
	            throw new error_1.MongoAPIError(`collection ${coll.namespace} not found`);
	        }
	        return !!collection.options?.capped;
	    }
	}
	is_capped.IsCappedOperation = IsCappedOperation;
	
	return is_capped;
}

var options_operation = {};

var hasRequiredOptions_operation;

function requireOptions_operation () {
	if (hasRequiredOptions_operation) return options_operation;
	hasRequiredOptions_operation = 1;
	Object.defineProperty(options_operation, "__esModule", { value: true });
	options_operation.OptionsOperation = void 0;
	const error_1 = requireError();
	const operation_1 = requireOperation();
	/** @internal */
	class OptionsOperation extends operation_1.AbstractOperation {
	    constructor(collection, options) {
	        super(options);
	        this.options = options;
	        this.collection = collection;
	    }
	    get commandName() {
	        return 'listCollections';
	    }
	    async execute(server, session) {
	        const coll = this.collection;
	        const [collection] = await coll.s.db
	            .listCollections({ name: coll.collectionName }, { ...this.options, nameOnly: false, readPreference: this.readPreference, session })
	            .toArray();
	        if (collection == null || collection.options == null) {
	            throw new error_1.MongoAPIError(`collection ${coll.namespace} not found`);
	        }
	        return collection.options;
	    }
	}
	options_operation.OptionsOperation = OptionsOperation;
	
	return options_operation;
}

var create = {};

var hasRequiredCreate;

function requireCreate () {
	if (hasRequiredCreate) return create;
	hasRequiredCreate = 1;
	Object.defineProperty(create, "__esModule", { value: true });
	create.CreateSearchIndexesOperation = void 0;
	const operation_1 = requireOperation();
	/** @internal */
	class CreateSearchIndexesOperation extends operation_1.AbstractOperation {
	    constructor(collection, descriptions) {
	        super();
	        this.collection = collection;
	        this.descriptions = descriptions;
	    }
	    get commandName() {
	        return 'createSearchIndexes';
	    }
	    async execute(server, session) {
	        const namespace = this.collection.fullNamespace;
	        const command = {
	            createSearchIndexes: namespace.collection,
	            indexes: this.descriptions
	        };
	        const res = await server.command(namespace, command, { session });
	        const indexesCreated = res?.indexesCreated ?? [];
	        return indexesCreated.map(({ name }) => name);
	    }
	}
	create.CreateSearchIndexesOperation = CreateSearchIndexesOperation;
	
	return create;
}

var drop = {};

var hasRequiredDrop;

function requireDrop () {
	if (hasRequiredDrop) return drop;
	hasRequiredDrop = 1;
	Object.defineProperty(drop, "__esModule", { value: true });
	drop.DropSearchIndexOperation = void 0;
	const error_1 = requireError();
	const operation_1 = requireOperation();
	/** @internal */
	class DropSearchIndexOperation extends operation_1.AbstractOperation {
	    constructor(collection, name) {
	        super();
	        this.collection = collection;
	        this.name = name;
	    }
	    get commandName() {
	        return 'dropSearchIndex';
	    }
	    async execute(server, session) {
	        const namespace = this.collection.fullNamespace;
	        const command = {
	            dropSearchIndex: namespace.collection
	        };
	        if (typeof this.name === 'string') {
	            command.name = this.name;
	        }
	        try {
	            await server.command(namespace, command, { session });
	        }
	        catch (error) {
	            const isNamespaceNotFoundError = error instanceof error_1.MongoServerError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound;
	            if (!isNamespaceNotFoundError) {
	                throw error;
	            }
	        }
	    }
	}
	drop.DropSearchIndexOperation = DropSearchIndexOperation;
	
	return drop;
}

var update = {};

var hasRequiredUpdate;

function requireUpdate () {
	if (hasRequiredUpdate) return update;
	hasRequiredUpdate = 1;
	Object.defineProperty(update, "__esModule", { value: true });
	update.UpdateSearchIndexOperation = void 0;
	const operation_1 = requireOperation();
	/** @internal */
	class UpdateSearchIndexOperation extends operation_1.AbstractOperation {
	    constructor(collection, name, definition) {
	        super();
	        this.collection = collection;
	        this.name = name;
	        this.definition = definition;
	    }
	    get commandName() {
	        return 'updateSearchIndex';
	    }
	    async execute(server, session) {
	        const namespace = this.collection.fullNamespace;
	        const command = {
	            updateSearchIndex: namespace.collection,
	            name: this.name,
	            definition: this.definition
	        };
	        await server.command(namespace, command, { session });
	        return;
	    }
	}
	update.UpdateSearchIndexOperation = UpdateSearchIndexOperation;
	
	return update;
}

var hasRequiredCollection;

function requireCollection () {
	if (hasRequiredCollection) return collection;
	hasRequiredCollection = 1;
	Object.defineProperty(collection, "__esModule", { value: true });
	collection.Collection = void 0;
	const bson_1 = requireBson();
	const ordered_1 = requireOrdered();
	const unordered_1 = requireUnordered();
	const change_stream_1 = requireChange_stream();
	const aggregation_cursor_1 = requireAggregation_cursor();
	const find_cursor_1 = requireFind_cursor();
	const list_indexes_cursor_1 = requireList_indexes_cursor();
	const list_search_indexes_cursor_1 = requireList_search_indexes_cursor();
	const error_1 = requireError();
	const bulk_write_1 = requireBulk_write();
	const count_1 = requireCount();
	const delete_1 = require_delete();
	const distinct_1 = requireDistinct();
	const drop_1 = requireDrop$1();
	const estimated_document_count_1 = requireEstimated_document_count();
	const execute_operation_1 = requireExecute_operation();
	const find_and_modify_1 = requireFind_and_modify();
	const indexes_1 = requireIndexes();
	const insert_1 = requireInsert();
	const is_capped_1 = requireIs_capped();
	const options_operation_1 = requireOptions_operation();
	const rename_1 = requireRename();
	const create_1 = requireCreate();
	const drop_2 = requireDrop();
	const update_1 = requireUpdate();
	const update_2 = requireUpdate$1();
	const read_concern_1 = requireRead_concern();
	const read_preference_1 = requireRead_preference();
	const utils_1 = requireUtils$1();
	const write_concern_1 = requireWrite_concern();
	/**
	 * The **Collection** class is an internal class that embodies a MongoDB collection
	 * allowing for insert/find/update/delete and other command operation on that MongoDB collection.
	 *
	 * **COLLECTION Cannot directly be instantiated**
	 * @public
	 *
	 * @example
	 * ```ts
	 * import { MongoClient } from 'mongodb';
	 *
	 * interface Pet {
	 *   name: string;
	 *   kind: 'dog' | 'cat' | 'fish';
	 * }
	 *
	 * const client = new MongoClient('mongodb://localhost:27017');
	 * const pets = client.db().collection<Pet>('pets');
	 *
	 * const petCursor = pets.find();
	 *
	 * for await (const pet of petCursor) {
	 *   console.log(`${pet.name} is a ${pet.kind}!`);
	 * }
	 * ```
	 */
	class Collection {
	    /**
	     * Create a new Collection instance
	     * @internal
	     */
	    constructor(db, name, options) {
	        // Internal state
	        this.s = {
	            db,
	            options,
	            namespace: new utils_1.MongoDBCollectionNamespace(db.databaseName, name),
	            pkFactory: db.options?.pkFactory ?? utils_1.DEFAULT_PK_FACTORY,
	            readPreference: read_preference_1.ReadPreference.fromOptions(options),
	            bsonOptions: (0, bson_1.resolveBSONOptions)(options, db),
	            readConcern: read_concern_1.ReadConcern.fromOptions(options),
	            writeConcern: write_concern_1.WriteConcern.fromOptions(options)
	        };
	        this.client = db.client;
	    }
	    /**
	     * The name of the database this collection belongs to
	     */
	    get dbName() {
	        return this.s.namespace.db;
	    }
	    /**
	     * The name of this collection
	     */
	    get collectionName() {
	        return this.s.namespace.collection;
	    }
	    /**
	     * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`
	     */
	    get namespace() {
	        return this.fullNamespace.toString();
	    }
	    /**
	     *  @internal
	     *
	     * The `MongoDBNamespace` for the collection.
	     */
	    get fullNamespace() {
	        return this.s.namespace;
	    }
	    /**
	     * The current readConcern of the collection. If not explicitly defined for
	     * this collection, will be inherited from the parent DB
	     */
	    get readConcern() {
	        if (this.s.readConcern == null) {
	            return this.s.db.readConcern;
	        }
	        return this.s.readConcern;
	    }
	    /**
	     * The current readPreference of the collection. If not explicitly defined for
	     * this collection, will be inherited from the parent DB
	     */
	    get readPreference() {
	        if (this.s.readPreference == null) {
	            return this.s.db.readPreference;
	        }
	        return this.s.readPreference;
	    }
	    get bsonOptions() {
	        return this.s.bsonOptions;
	    }
	    /**
	     * The current writeConcern of the collection. If not explicitly defined for
	     * this collection, will be inherited from the parent DB
	     */
	    get writeConcern() {
	        if (this.s.writeConcern == null) {
	            return this.s.db.writeConcern;
	        }
	        return this.s.writeConcern;
	    }
	    /** The current index hint for the collection */
	    get hint() {
	        return this.s.collectionHint;
	    }
	    set hint(v) {
	        this.s.collectionHint = (0, utils_1.normalizeHintField)(v);
	    }
	    /**
	     * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,
	     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
	     * can be overridden by setting the **forceServerObjectId** flag.
	     *
	     * @param doc - The document to insert
	     * @param options - Optional settings for the command
	     */
	    async insertOne(doc, options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertOneOperation(this, doc, (0, utils_1.resolveOptions)(this, options)));
	    }
	    /**
	     * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,
	     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
	     * can be overridden by setting the **forceServerObjectId** flag.
	     *
	     * @param docs - The documents to insert
	     * @param options - Optional settings for the command
	     */
	    async insertMany(docs, options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertManyOperation(this, docs, (0, utils_1.resolveOptions)(this, options ?? { ordered: true })));
	    }
	    /**
	     * Perform a bulkWrite operation without a fluent API
	     *
	     * Legal operation types are
	     * - `insertOne`
	     * - `replaceOne`
	     * - `updateOne`
	     * - `updateMany`
	     * - `deleteOne`
	     * - `deleteMany`
	     *
	     * If documents passed in do not contain the **_id** field,
	     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
	     * can be overridden by setting the **forceServerObjectId** flag.
	     *
	     * @param operations - Bulk operations to perform
	     * @param options - Optional settings for the command
	     * @throws MongoDriverError if operations is not an array
	     */
	    async bulkWrite(operations, options) {
	        if (!Array.isArray(operations)) {
	            throw new error_1.MongoInvalidArgumentError('Argument "operations" must be an array of documents');
	        }
	        return await (0, execute_operation_1.executeOperation)(this.client, new bulk_write_1.BulkWriteOperation(this, operations, (0, utils_1.resolveOptions)(this, options ?? { ordered: true })));
	    }
	    /**
	     * Update a single document in a collection
	     *
	     * The value of `update` can be either:
	     * - UpdateFilter<TSchema> - A document that contains update operator expressions,
	     * - Document[] - an aggregation pipeline.
	     *
	     * @param filter - The filter used to select the document to update
	     * @param update - The modifications to apply
	     * @param options - Optional settings for the command
	     */
	    async updateOne(filter, update, options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateOneOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));
	    }
	    /**
	     * Replace a document in a collection with another document
	     *
	     * @param filter - The filter used to select the document to replace
	     * @param replacement - The Document that replaces the matching document
	     * @param options - Optional settings for the command
	     */
	    async replaceOne(filter, replacement, options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new update_2.ReplaceOneOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)));
	    }
	    /**
	     * Update multiple documents in a collection
	     *
	     * The value of `update` can be either:
	     * - UpdateFilter<TSchema> - A document that contains update operator expressions,
	     * - Document[] - an aggregation pipeline.
	     *
	     * @param filter - The filter used to select the document to update
	     * @param update - The modifications to apply
	     * @param options - Optional settings for the command
	     */
	    async updateMany(filter, update, options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateManyOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));
	    }
	    /**
	     * Delete a document from a collection
	     *
	     * @param filter - The filter used to select the document to remove
	     * @param options - Optional settings for the command
	     */
	    async deleteOne(filter = {}, options = {}) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteOneOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));
	    }
	    /**
	     * Delete multiple documents from a collection
	     *
	     * @param filter - The filter used to select the documents to remove
	     * @param options - Optional settings for the command
	     */
	    async deleteMany(filter = {}, options = {}) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteManyOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));
	    }
	    /**
	     * Rename the collection.
	     *
	     * @remarks
	     * This operation does not inherit options from the Db or MongoClient.
	     *
	     * @param newName - New name of of the collection.
	     * @param options - Optional settings for the command
	     */
	    async rename(newName, options) {
	        // Intentionally, we do not inherit options from parent for this operation.
	        return await (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this, newName, {
	            ...options,
	            readPreference: read_preference_1.ReadPreference.PRIMARY
	        }));
	    }
	    /**
	     * Drop the collection from the database, removing it permanently. New accesses will create a new collection.
	     *
	     * @param options - Optional settings for the command
	     */
	    async drop(options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options));
	    }
	    async findOne(filter = {}, options = {}) {
	        const cursor = this.find(filter, options).limit(-1).batchSize(1);
	        const res = await cursor.next();
	        await cursor.close();
	        return res;
	    }
	    find(filter = {}, options = {}) {
	        return new find_cursor_1.FindCursor(this.client, this.s.namespace, filter, (0, utils_1.resolveOptions)(this, options));
	    }
	    /**
	     * Returns the options of the collection.
	     *
	     * @param options - Optional settings for the command
	     */
	    async options(options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new options_operation_1.OptionsOperation(this, (0, utils_1.resolveOptions)(this, options)));
	    }
	    /**
	     * Returns if the collection is a capped collection
	     *
	     * @param options - Optional settings for the command
	     */
	    async isCapped(options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new is_capped_1.IsCappedOperation(this, (0, utils_1.resolveOptions)(this, options)));
	    }
	    /**
	     * Creates an index on the db and collection collection.
	     *
	     * @param indexSpec - The field name or index specification to create an index for
	     * @param options - Optional settings for the command
	     *
	     * @example
	     * ```ts
	     * const collection = client.db('foo').collection('bar');
	     *
	     * await collection.createIndex({ a: 1, b: -1 });
	     *
	     * // Alternate syntax for { c: 1, d: -1 } that ensures order of indexes
	     * await collection.createIndex([ [c, 1], [d, -1] ]);
	     *
	     * // Equivalent to { e: 1 }
	     * await collection.createIndex('e');
	     *
	     * // Equivalent to { f: 1, g: 1 }
	     * await collection.createIndex(['f', 'g'])
	     *
	     * // Equivalent to { h: 1, i: -1 }
	     * await collection.createIndex([ { h: 1 }, { i: -1 } ]);
	     *
	     * // Equivalent to { j: 1, k: -1, l: 2d }
	     * await collection.createIndex(['j', ['k', -1], { l: '2d' }])
	     * ```
	     */
	    async createIndex(indexSpec, options) {
	        const indexes = await (0, execute_operation_1.executeOperation)(this.client, indexes_1.CreateIndexesOperation.fromIndexSpecification(this, this.collectionName, indexSpec, (0, utils_1.resolveOptions)(this, options)));
	        return indexes[0];
	    }
	    /**
	     * Creates multiple indexes in the collection, this method is only supported for
	     * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported
	     * error.
	     *
	     * **Note**: Unlike {@link Collection#createIndex| createIndex}, this function takes in raw index specifications.
	     * Index specifications are defined {@link https://www.mongodb.com/docs/manual/reference/command/createIndexes/| here}.
	     *
	     * @param indexSpecs - An array of index specifications to be created
	     * @param options - Optional settings for the command
	     *
	     * @example
	     * ```ts
	     * const collection = client.db('foo').collection('bar');
	     * await collection.createIndexes([
	     *   // Simple index on field fizz
	     *   {
	     *     key: { fizz: 1 },
	     *   }
	     *   // wildcard index
	     *   {
	     *     key: { '$**': 1 }
	     *   },
	     *   // named index on darmok and jalad
	     *   {
	     *     key: { darmok: 1, jalad: -1 }
	     *     name: 'tanagra'
	     *   }
	     * ]);
	     * ```
	     */
	    async createIndexes(indexSpecs, options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, indexes_1.CreateIndexesOperation.fromIndexDescriptionArray(this, this.collectionName, indexSpecs, (0, utils_1.resolveOptions)(this, { ...options, maxTimeMS: undefined })));
	    }
	    /**
	     * Drops an index from this collection.
	     *
	     * @param indexName - Name of the index to drop.
	     * @param options - Optional settings for the command
	     */
	    async dropIndex(indexName, options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, indexName, {
	            ...(0, utils_1.resolveOptions)(this, options),
	            readPreference: read_preference_1.ReadPreference.primary
	        }));
	    }
	    /**
	     * Drops all indexes from this collection.
	     *
	     * @param options - Optional settings for the command
	     */
	    async dropIndexes(options) {
	        try {
	            await (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, '*', (0, utils_1.resolveOptions)(this, options)));
	            return true;
	        }
	        catch {
	            return false;
	        }
	    }
	    /**
	     * Get the list of all indexes information for the collection.
	     *
	     * @param options - Optional settings for the command
	     */
	    listIndexes(options) {
	        return new list_indexes_cursor_1.ListIndexesCursor(this, (0, utils_1.resolveOptions)(this, options));
	    }
	    /**
	     * Checks if one or more indexes exist on the collection, fails on first non-existing index
	     *
	     * @param indexes - One or more index names to check.
	     * @param options - Optional settings for the command
	     */
	    async indexExists(indexes, options) {
	        const indexNames = Array.isArray(indexes) ? indexes : [indexes];
	        const allIndexes = new Set(await this.listIndexes(options)
	            .map(({ name }) => name)
	            .toArray());
	        return indexNames.every(name => allIndexes.has(name));
	    }
	    async indexInformation(options) {
	        return await this.indexes({
	            ...options,
	            full: options?.full ?? false
	        });
	    }
	    /**
	     * Gets an estimate of the count of documents in a collection using collection metadata.
	     * This will always run a count command on all server versions.
	     *
	     * due to an oversight in versions 5.0.0-5.0.8 of MongoDB, the count command,
	     * which estimatedDocumentCount uses in its implementation, was not included in v1 of
	     * the Stable API, and so users of the Stable API with estimatedDocumentCount are
	     * recommended to upgrade their server version to 5.0.9+ or set apiStrict: false to avoid
	     * encountering errors.
	     *
	     * @see {@link https://www.mongodb.com/docs/manual/reference/command/count/#behavior|Count: Behavior}
	     * @param options - Optional settings for the command
	     */
	    async estimatedDocumentCount(options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, (0, utils_1.resolveOptions)(this, options)));
	    }
	    /**
	     * Gets the number of documents matching the filter.
	     * For a fast count of the total documents in a collection see {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.
	     * **Note**: When migrating from {@link Collection#count| count} to {@link Collection#countDocuments| countDocuments}
	     * the following query operators must be replaced:
	     *
	     * | Operator | Replacement |
	     * | -------- | ----------- |
	     * | `$where`   | [`$expr`][1] |
	     * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |
	     * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |
	     *
	     * [1]: https://www.mongodb.com/docs/manual/reference/operator/query/expr/
	     * [2]: https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/
	     * [3]: https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center
	     * [4]: https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere
	     *
	     * @param filter - The filter for the count
	     * @param options - Optional settings for the command
	     *
	     * @see https://www.mongodb.com/docs/manual/reference/operator/query/expr/
	     * @see https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/
	     * @see https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center
	     * @see https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere
	     */
	    async countDocuments(filter = {}, options = {}) {
	        const pipeline = [];
	        pipeline.push({ $match: filter });
	        if (typeof options.skip === 'number') {
	            pipeline.push({ $skip: options.skip });
	        }
	        if (typeof options.limit === 'number') {
	            pipeline.push({ $limit: options.limit });
	        }
	        pipeline.push({ $group: { _id: 1, n: { $sum: 1 } } });
	        const cursor = this.aggregate(pipeline, options);
	        const doc = await cursor.next();
	        await cursor.close();
	        return doc?.n ?? 0;
	    }
	    async distinct(key, filter = {}, options = {}) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new distinct_1.DistinctOperation(this, key, filter, (0, utils_1.resolveOptions)(this, options)));
	    }
	    async indexes(options) {
	        const indexes = await this.listIndexes(options).toArray();
	        const full = options?.full ?? true;
	        if (full) {
	            return indexes;
	        }
	        const object = Object.fromEntries(indexes.map(({ name, key }) => [name, Object.entries(key)]));
	        return object;
	    }
	    async findOneAndDelete(filter, options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));
	    }
	    async findOneAndReplace(filter, replacement, options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)));
	    }
	    async findOneAndUpdate(filter, update, options) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));
	    }
	    /**
	     * Execute an aggregation framework pipeline against the collection, needs MongoDB \>= 2.2
	     *
	     * @param pipeline - An array of aggregation pipelines to execute
	     * @param options - Optional settings for the command
	     */
	    aggregate(pipeline = [], options) {
	        if (!Array.isArray(pipeline)) {
	            throw new error_1.MongoInvalidArgumentError('Argument "pipeline" must be an array of aggregation stages');
	        }
	        return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));
	    }
	    /**
	     * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.
	     *
	     * @remarks
	     * watch() accepts two generic arguments for distinct use cases:
	     * - The first is to override the schema that may be defined for this specific collection
	     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
	     * @example
	     * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`
	     * ```ts
	     * collection.watch<{ _id: number }>()
	     *   .on('change', change => console.log(change._id.toFixed(4)));
	     * ```
	     *
	     * @example
	     * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.
	     * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.
	     * No need start from scratch on the ChangeStreamInsertDocument type!
	     * By using an intersection we can save time and ensure defaults remain the same type!
	     * ```ts
	     * collection
	     *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([
	     *     { $addFields: { comment: 'big changes' } },
	     *     { $match: { operationType: 'insert' } }
	     *   ])
	     *   .on('change', change => {
	     *     change.comment.startsWith('big');
	     *     change.operationType === 'insert';
	     *     // No need to narrow in code because the generics did that for us!
	     *     expectType<Schema>(change.fullDocument);
	     *   });
	     * ```
	     *
	     * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
	     * @param options - Optional settings for the command
	     * @typeParam TLocal - Type of the data being detected by the change stream
	     * @typeParam TChange - Type of the whole change stream document emitted
	     */
	    watch(pipeline = [], options = {}) {
	        // Allow optionally not specifying a pipeline
	        if (!Array.isArray(pipeline)) {
	            options = pipeline;
	            pipeline = [];
	        }
	        return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
	    }
	    /**
	     * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
	     *
	     * @throws MongoNotConnectedError
	     * @remarks
	     * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.
	     * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.
	     */
	    initializeUnorderedBulkOp(options) {
	        return new unordered_1.UnorderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));
	    }
	    /**
	     * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.
	     *
	     * @throws MongoNotConnectedError
	     * @remarks
	     * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.
	     * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.
	     */
	    initializeOrderedBulkOp(options) {
	        return new ordered_1.OrderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));
	    }
	    /**
	     * An estimated count of matching documents in the db to a filter.
	     *
	     * **NOTE:** This method has been deprecated, since it does not provide an accurate count of the documents
	     * in a collection. To obtain an accurate count of documents in the collection, use {@link Collection#countDocuments| countDocuments}.
	     * To obtain an estimated count of all documents in the collection, use {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.
	     *
	     * @deprecated use {@link Collection#countDocuments| countDocuments} or {@link Collection#estimatedDocumentCount| estimatedDocumentCount} instead
	     *
	     * @param filter - The filter for the count.
	     * @param options - Optional settings for the command
	     */
	    async count(filter = {}, options = {}) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.fullNamespace, filter, (0, utils_1.resolveOptions)(this, options)));
	    }
	    listSearchIndexes(indexNameOrOptions, options) {
	        options =
	            typeof indexNameOrOptions === 'object' ? indexNameOrOptions : options == null ? {} : options;
	        const indexName = indexNameOrOptions == null
	            ? null
	            : typeof indexNameOrOptions === 'object'
	                ? null
	                : indexNameOrOptions;
	        return new list_search_indexes_cursor_1.ListSearchIndexesCursor(this, indexName, options);
	    }
	    /**
	     * Creates a single search index for the collection.
	     *
	     * @param description - The index description for the new search index.
	     * @returns A promise that resolves to the name of the new search index.
	     *
	     * @remarks Only available when used against a 7.0+ Atlas cluster.
	     */
	    async createSearchIndex(description) {
	        const [index] = await this.createSearchIndexes([description]);
	        return index;
	    }
	    /**
	     * Creates multiple search indexes for the current collection.
	     *
	     * @param descriptions - An array of `SearchIndexDescription`s for the new search indexes.
	     * @returns A promise that resolves to an array of the newly created search index names.
	     *
	     * @remarks Only available when used against a 7.0+ Atlas cluster.
	     * @returns
	     */
	    async createSearchIndexes(descriptions) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new create_1.CreateSearchIndexesOperation(this, descriptions));
	    }
	    /**
	     * Deletes a search index by index name.
	     *
	     * @param name - The name of the search index to be deleted.
	     *
	     * @remarks Only available when used against a 7.0+ Atlas cluster.
	     */
	    async dropSearchIndex(name) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new drop_2.DropSearchIndexOperation(this, name));
	    }
	    /**
	     * Updates a search index by replacing the existing index definition with the provided definition.
	     *
	     * @param name - The name of the search index to update.
	     * @param definition - The new search index definition.
	     *
	     * @remarks Only available when used against a 7.0+ Atlas cluster.
	     */
	    async updateSearchIndex(name, definition) {
	        return await (0, execute_operation_1.executeOperation)(this.client, new update_1.UpdateSearchIndexOperation(this, name, definition));
	    }
	}
	collection.Collection = Collection;
	
	return collection;
}

var change_stream_cursor = {};

var hasRequiredChange_stream_cursor;

function requireChange_stream_cursor () {
	if (hasRequiredChange_stream_cursor) return change_stream_cursor;
	hasRequiredChange_stream_cursor = 1;
	Object.defineProperty(change_stream_cursor, "__esModule", { value: true });
	change_stream_cursor.ChangeStreamCursor = void 0;
	const change_stream_1 = requireChange_stream();
	const constants_1 = requireConstants();
	const aggregate_1 = requireAggregate();
	const execute_operation_1 = requireExecute_operation();
	const utils_1 = requireUtils$1();
	const abstract_cursor_1 = requireAbstract_cursor();
	/** @internal */
	class ChangeStreamCursor extends abstract_cursor_1.AbstractCursor {
	    constructor(client, namespace, pipeline = [], options = {}) {
	        super(client, namespace, options);
	        this.pipeline = pipeline;
	        this.changeStreamCursorOptions = options;
	        this._resumeToken = null;
	        this.startAtOperationTime = options.startAtOperationTime ?? null;
	        if (options.startAfter) {
	            this.resumeToken = options.startAfter;
	        }
	        else if (options.resumeAfter) {
	            this.resumeToken = options.resumeAfter;
	        }
	    }
	    set resumeToken(token) {
	        this._resumeToken = token;
	        this.emit(change_stream_1.ChangeStream.RESUME_TOKEN_CHANGED, token);
	    }
	    get resumeToken() {
	        return this._resumeToken;
	    }
	    get resumeOptions() {
	        const options = {
	            ...this.changeStreamCursorOptions
	        };
	        for (const key of ['resumeAfter', 'startAfter', 'startAtOperationTime']) {
	            delete options[key];
	        }
	        if (this.resumeToken != null) {
	            if (this.changeStreamCursorOptions.startAfter && !this.hasReceived) {
	                options.startAfter = this.resumeToken;
	            }
	            else {
	                options.resumeAfter = this.resumeToken;
	            }
	        }
	        else if (this.startAtOperationTime != null && (0, utils_1.maxWireVersion)(this.server) >= 7) {
	            options.startAtOperationTime = this.startAtOperationTime;
	        }
	        return options;
	    }
	    cacheResumeToken(resumeToken) {
	        if (this.bufferedCount() === 0 && this.postBatchResumeToken) {
	            this.resumeToken = this.postBatchResumeToken;
	        }
	        else {
	            this.resumeToken = resumeToken;
	        }
	        this.hasReceived = true;
	    }
	    _processBatch(response) {
	        const { postBatchResumeToken } = response;
	        if (postBatchResumeToken) {
	            this.postBatchResumeToken = postBatchResumeToken;
	            if (response.batchSize === 0) {
	                this.resumeToken = postBatchResumeToken;
	            }
	        }
	    }
	    clone() {
	        return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, {
	            ...this.cursorOptions
	        });
	    }
	    async _initialize(session) {
	        const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {
	            ...this.cursorOptions,
	            ...this.changeStreamCursorOptions,
	            session
	        });
	        const response = await (0, execute_operation_1.executeOperation)(session.client, aggregateOperation);
	        const server = aggregateOperation.server;
	        this.maxWireVersion = (0, utils_1.maxWireVersion)(server);
	        if (this.startAtOperationTime == null &&
	            this.changeStreamCursorOptions.resumeAfter == null &&
	            this.changeStreamCursorOptions.startAfter == null &&
	            this.maxWireVersion >= 7) {
	            this.startAtOperationTime = response.operationTime;
	        }
	        this._processBatch(response);
	        this.emit(constants_1.INIT, response);
	        this.emit(constants_1.RESPONSE);
	        return { server, session, response };
	    }
	    async getMore(batchSize) {
	        const response = await super.getMore(batchSize);
	        this.maxWireVersion = (0, utils_1.maxWireVersion)(this.server);
	        this._processBatch(response);
	        this.emit(change_stream_1.ChangeStream.MORE, response);
	        this.emit(change_stream_1.ChangeStream.RESPONSE);
	        return response;
	    }
	}
	change_stream_cursor.ChangeStreamCursor = ChangeStreamCursor;
	
	return change_stream_cursor;
}

var hasRequiredChange_stream;

function requireChange_stream () {
	if (hasRequiredChange_stream) return change_stream;
	hasRequiredChange_stream = 1;
	Object.defineProperty(change_stream, "__esModule", { value: true });
	change_stream.ChangeStream = void 0;
	const collection_1 = requireCollection();
	const constants_1 = requireConstants();
	const change_stream_cursor_1 = requireChange_stream_cursor();
	const db_1 = requireDb();
	const error_1 = requireError();
	const mongo_client_1 = requireMongo_client();
	const mongo_types_1 = requireMongo_types();
	const resource_management_1 = requireResource_management();
	const utils_1 = requireUtils$1();
	/** @internal */
	const kCursorStream = Symbol('cursorStream');
	/** @internal */
	const kClosed = Symbol('closed');
	/** @internal */
	const kMode = Symbol('mode');
	const CHANGE_STREAM_OPTIONS = [
	    'resumeAfter',
	    'startAfter',
	    'startAtOperationTime',
	    'fullDocument',
	    'fullDocumentBeforeChange',
	    'showExpandedEvents'
	];
	const CHANGE_DOMAIN_TYPES = {
	    COLLECTION: Symbol('Collection'),
	    DATABASE: Symbol('Database'),
	    CLUSTER: Symbol('Cluster')
	};
	const CHANGE_STREAM_EVENTS = [constants_1.RESUME_TOKEN_CHANGED, constants_1.END, constants_1.CLOSE];
	const NO_RESUME_TOKEN_ERROR = 'A change stream document has been received that lacks a resume token (_id).';
	const CHANGESTREAM_CLOSED_ERROR = 'ChangeStream is closed';
	/**
	 * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.
	 * @public
	 */
	class ChangeStream extends mongo_types_1.TypedEventEmitter {
	    /** @internal */
	    async asyncDispose() {
	        await this.close();
	    }
	    /**
	     * @internal
	     *
	     * @param parent - The parent object that created this change stream
	     * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents
	     */
	    constructor(parent, pipeline = [], options = {}) {
	        super();
	        this.pipeline = pipeline;
	        this.options = { ...options };
	        delete this.options.writeConcern;
	        if (parent instanceof collection_1.Collection) {
	            this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
	        }
	        else if (parent instanceof db_1.Db) {
	            this.type = CHANGE_DOMAIN_TYPES.DATABASE;
	        }
	        else if (parent instanceof mongo_client_1.MongoClient) {
	            this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
	        }
	        else {
	            throw new error_1.MongoChangeStreamError('Parent provided to ChangeStream constructor must be an instance of Collection, Db, or MongoClient');
	        }
	        this.parent = parent;
	        this.namespace = parent.s.namespace;
	        if (!this.options.readPreference && parent.readPreference) {
	            this.options.readPreference = parent.readPreference;
	        }
	        // Create contained Change Stream cursor
	        this.cursor = this._createChangeStreamCursor(options);
	        this[kClosed] = false;
	        this[kMode] = false;
	        // Listen for any `change` listeners being added to ChangeStream
	        this.on('newListener', eventName => {
	            if (eventName === 'change' && this.cursor && this.listenerCount('change') === 0) {
	                this._streamEvents(this.cursor);
	            }
	        });
	        this.on('removeListener', eventName => {
	            if (eventName === 'change' && this.listenerCount('change') === 0 && this.cursor) {
	                this[kCursorStream]?.removeAllListeners('data');
	            }
	        });
	    }
	    /** @internal */
	    get cursorStream() {
	        return this[kCursorStream];
	    }
	    /** The cached resume token that is used to resume after the most recently returned change. */
	    get resumeToken() {
	        return this.cursor?.resumeToken;
	    }
	    /** Check if there is any document still available in the Change Stream */
	    async hasNext() {
	        this._setIsIterator();
	        // Change streams must resume indefinitely while each resume event succeeds.
	        // This loop continues until either a change event is received or until a resume attempt
	        // fails.
	        while (true) {
	            try {
	                const hasNext = await this.cursor.hasNext();
	                return hasNext;
	            }
	            catch (error) {
	                try {
	                    await this._processErrorIteratorMode(error);
	                }
	                catch (error) {
	                    try {
	                        await this.close();
	                    }
	                    catch (error) {
	                        (0, utils_1.squashError)(error);
	                    }
	                    throw error;
	                }
	            }
	        }
	    }
	    /** Get the next available document from the Change Stream. */
	    async next() {
	        this._setIsIterator();
	        // Change streams must resume indefinitely while each resume event succeeds.
	        // This loop continues until either a change event is received or until a resume attempt
	        // fails.
	        while (true) {
	            try {
	                const change = await this.cursor.next();
	                const processedChange = this._processChange(change ?? null);
	                return processedChange;
	            }
	            catch (error) {
	                try {
	                    await this._processErrorIteratorMode(error);
	                }
	                catch (error) {
	                    try {
	                        await this.close();
	                    }
	                    catch (error) {
	                        (0, utils_1.squashError)(error);
	                    }
	                    throw error;
	                }
	            }
	        }
	    }
	    /**
	     * Try to get the next available document from the Change Stream's cursor or `null` if an empty batch is returned
	     */
	    async tryNext() {
	        this._setIsIterator();
	        // Change streams must resume indefinitely while each resume event succeeds.
	        // This loop continues until either a change event is received or until a resume attempt
	        // fails.
	        while (true) {
	            try {
	                const change = await this.cursor.tryNext();
	                return change ?? null;
	            }
	            catch (error) {
	                try {
	                    await this._processErrorIteratorMode(error);
	                }
	                catch (error) {
	                    try {
	                        await this.close();
	                    }
	                    catch (error) {
	                        (0, utils_1.squashError)(error);
	                    }
	                    throw error;
	                }
	            }
	        }
	    }
	    async *[Symbol.asyncIterator]() {
	        if (this.closed) {
	            return;
	        }
	        try {
	            // Change streams run indefinitely as long as errors are resumable
	            // So the only loop breaking condition is if `next()` throws
	            while (true) {
	                yield await this.next();
	            }
	        }
	        finally {
	            try {
	                await this.close();
	            }
	            catch (error) {
	                (0, utils_1.squashError)(error);
	            }
	        }
	    }
	    /** Is the cursor closed */
	    get closed() {
	        return this[kClosed] || this.cursor.closed;
	    }
	    /**
	     * Frees the internal resources used by the change stream.
	     */
	    async close() {
	        this[kClosed] = true;
	        const cursor = this.cursor;
	        try {
	            await cursor.close();
	        }
	        finally {
	            this._endStream();
	        }
	    }
	    /**
	     * Return a modified Readable stream including a possible transform method.
	     *
	     * NOTE: When using a Stream to process change stream events, the stream will
	     * NOT automatically resume in the case a resumable error is encountered.
	     *
	     * @throws MongoChangeStreamError if the underlying cursor or the change stream is closed
	     */
	    stream(options) {
	        if (this.closed) {
	            throw new error_1.MongoChangeStreamError(CHANGESTREAM_CLOSED_ERROR);
	        }
	        this.streamOptions = options;
	        return this.cursor.stream(options);
	    }
	    /** @internal */
	    _setIsEmitter() {
	        if (this[kMode] === 'iterator') {
	            // TODO(NODE-3485): Replace with MongoChangeStreamModeError
	            throw new error_1.MongoAPIError('ChangeStream cannot be used as an EventEmitter after being used as an iterator');
	        }
	        this[kMode] = 'emitter';
	    }
	    /** @internal */
	    _setIsIterator() {
	        if (this[kMode] === 'emitter') {
	            // TODO(NODE-3485): Replace with MongoChangeStreamModeError
	            throw new error_1.MongoAPIError('ChangeStream cannot be used as an iterator after being used as an EventEmitter');
	        }
	        this[kMode] = 'iterator';
	    }
	    /**
	     * Create a new change stream cursor based on self's configuration
	     * @internal
	     */
	    _createChangeStreamCursor(options) {
	        const changeStreamStageOptions = (0, utils_1.filterOptions)(options, CHANGE_STREAM_OPTIONS);
	        if (this.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
	            changeStreamStageOptions.allChangesForCluster = true;
	        }
	        const pipeline = [{ $changeStream: changeStreamStageOptions }, ...this.pipeline];
	        const client = this.type === CHANGE_DOMAIN_TYPES.CLUSTER
	            ? this.parent
	            : this.type === CHANGE_DOMAIN_TYPES.DATABASE
	                ? this.parent.client
	                : this.type === CHANGE_DOMAIN_TYPES.COLLECTION
	                    ? this.parent.client
	                    : null;
	        if (client == null) {
	            // This should never happen because of the assertion in the constructor
	            throw new error_1.MongoRuntimeError(`Changestream type should only be one of cluster, database, collection. Found ${this.type.toString()}`);
	        }
	        const changeStreamCursor = new change_stream_cursor_1.ChangeStreamCursor(client, this.namespace, pipeline, options);
	        for (const event of CHANGE_STREAM_EVENTS) {
	            changeStreamCursor.on(event, e => this.emit(event, e));
	        }
	        if (this.listenerCount(ChangeStream.CHANGE) > 0) {
	            this._streamEvents(changeStreamCursor);
	        }
	        return changeStreamCursor;
	    }
	    /** @internal */
	    _closeEmitterModeWithError(error) {
	        this.emit(ChangeStream.ERROR, error);
	        this.close().then(undefined, utils_1.squashError);
	    }
	    /** @internal */
	    _streamEvents(cursor) {
	        this._setIsEmitter();
	        const stream = this[kCursorStream] ?? cursor.stream();
	        this[kCursorStream] = stream;
	        stream.on('data', change => {
	            try {
	                const processedChange = this._processChange(change);
	                this.emit(ChangeStream.CHANGE, processedChange);
	            }
	            catch (error) {
	                this.emit(ChangeStream.ERROR, error);
	            }
	        });
	        stream.on('error', error => this._processErrorStreamMode(error));
	    }
	    /** @internal */
	    _endStream() {
	        const cursorStream = this[kCursorStream];
	        if (cursorStream) {
	            ['data', 'close', 'end', 'error'].forEach(event => cursorStream.removeAllListeners(event));
	            cursorStream.destroy();
	        }
	        this[kCursorStream] = undefined;
	    }
	    /** @internal */
	    _processChange(change) {
	        if (this[kClosed]) {
	            // TODO(NODE-3485): Replace with MongoChangeStreamClosedError
	            throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
	        }
	        // a null change means the cursor has been notified, implicitly closing the change stream
	        if (change == null) {
	            // TODO(NODE-3485): Replace with MongoChangeStreamClosedError
	            throw new error_1.MongoRuntimeError(CHANGESTREAM_CLOSED_ERROR);
	        }
	        if (change && !change._id) {
	            throw new error_1.MongoChangeStreamError(NO_RESUME_TOKEN_ERROR);
	        }
	        // cache the resume token
	        this.cursor.cacheResumeToken(change._id);
	        // wipe the startAtOperationTime if there was one so that there won't be a conflict
	        // between resumeToken and startAtOperationTime if we need to reconnect the cursor
	        this.options.startAtOperationTime = undefined;
	        return change;
	    }
	    /** @internal */
	    _processErrorStreamMode(changeStreamError) {
	        // If the change stream has been closed explicitly, do not process error.
	        if (this[kClosed])
	            return;
	        if ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion)) {
	            this._endStream();
	            this.cursor.close().then(undefined, utils_1.squashError);
	            const topology = (0, utils_1.getTopology)(this.parent);
	            topology
	                .selectServer(this.cursor.readPreference, {
	                operationName: 'reconnect topology in change stream'
	            })
	                .then(() => {
	                this.cursor = this._createChangeStreamCursor(this.cursor.resumeOptions);
	            }, () => this._closeEmitterModeWithError(changeStreamError));
	        }
	        else {
	            this._closeEmitterModeWithError(changeStreamError);
	        }
	    }
	    /** @internal */
	    async _processErrorIteratorMode(changeStreamError) {
	        if (this[kClosed]) {
	            // TODO(NODE-3485): Replace with MongoChangeStreamClosedError
	            throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
	        }
	        if (!(0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion)) {
	            try {
	                await this.close();
	            }
	            catch (error) {
	                (0, utils_1.squashError)(error);
	            }
	            throw changeStreamError;
	        }
	        try {
	            await this.cursor.close();
	        }
	        catch (error) {
	            (0, utils_1.squashError)(error);
	        }
	        const topology = (0, utils_1.getTopology)(this.parent);
	        try {
	            await topology.selectServer(this.cursor.readPreference, {
	                operationName: 'reconnect topology in change stream'
	            });
	            this.cursor = this._createChangeStreamCursor(this.cursor.resumeOptions);
	        }
	        catch {
	            // if the topology can't reconnect, close the stream
	            await this.close();
	            throw changeStreamError;
	        }
	    }
	}
	change_stream.ChangeStream = ChangeStream;
	/** @event */
	ChangeStream.RESPONSE = constants_1.RESPONSE;
	/** @event */
	ChangeStream.MORE = constants_1.MORE;
	/** @event */
	ChangeStream.INIT = constants_1.INIT;
	/** @event */
	ChangeStream.CLOSE = constants_1.CLOSE;
	/**
	 * Fired for each new matching change in the specified namespace. Attaching a `change`
	 * event listener to a Change Stream will switch the stream into flowing mode. Data will
	 * then be passed as soon as it is available.
	 * @event
	 */
	ChangeStream.CHANGE = constants_1.CHANGE;
	/** @event */
	ChangeStream.END = constants_1.END;
	/** @event */
	ChangeStream.ERROR = constants_1.ERROR;
	/**
	 * Emitted each time the change stream stores a new resume token.
	 * @event
	 */
	ChangeStream.RESUME_TOKEN_CHANGED = constants_1.RESUME_TOKEN_CHANGED;
	(0, resource_management_1.configureResourceManagement)(ChangeStream.prototype);
	
	return change_stream;
}

var gridfs = {};

var download = {};

var hasRequiredDownload;

function requireDownload () {
	if (hasRequiredDownload) return download;
	hasRequiredDownload = 1;
	Object.defineProperty(download, "__esModule", { value: true });
	download.GridFSBucketReadStream = void 0;
	const stream_1 = require$$0$9;
	const error_1 = requireError();
	/**
	 * A readable stream that enables you to read buffers from GridFS.
	 *
	 * Do not instantiate this class directly. Use `openDownloadStream()` instead.
	 * @public
	 */
	class GridFSBucketReadStream extends stream_1.Readable {
	    /**
	     * @param chunks - Handle for chunks collection
	     * @param files - Handle for files collection
	     * @param readPreference - The read preference to use
	     * @param filter - The filter to use to find the file document
	     * @internal
	     */
	    constructor(chunks, files, readPreference, filter, options) {
	        super({ emitClose: true });
	        this.s = {
	            bytesToTrim: 0,
	            bytesToSkip: 0,
	            bytesRead: 0,
	            chunks,
	            expected: 0,
	            files,
	            filter,
	            init: false,
	            expectedEnd: 0,
	            options: {
	                start: 0,
	                end: 0,
	                ...options
	            },
	            readPreference
	        };
	    }
	    /**
	     * Reads from the cursor and pushes to the stream.
	     * Private Impl, do not call directly
	     * @internal
	     */
	    _read() {
	        if (this.destroyed)
	            return;
	        waitForFile(this, () => doRead(this));
	    }
	    /**
	     * Sets the 0-based offset in bytes to start streaming from. Throws
	     * an error if this stream has entered flowing mode
	     * (e.g. if you've already called `on('data')`)
	     *
	     * @param start - 0-based offset in bytes to start streaming from
	     */
	    start(start = 0) {
	        throwIfInitialized(this);
	        this.s.options.start = start;
	        return this;
	    }
	    /**
	     * Sets the 0-based offset in bytes to start streaming from. Throws
	     * an error if this stream has entered flowing mode
	     * (e.g. if you've already called `on('data')`)
	     *
	     * @param end - Offset in bytes to stop reading at
	     */
	    end(end = 0) {
	        throwIfInitialized(this);
	        this.s.options.end = end;
	        return this;
	    }
	    /**
	     * Marks this stream as aborted (will never push another `data` event)
	     * and kills the underlying cursor. Will emit the 'end' event, and then
	     * the 'close' event once the cursor is successfully killed.
	     */
	    async abort() {
	        this.push(null);
	        this.destroy();
	        await this.s.cursor?.close();
	    }
	}
	download.GridFSBucketReadStream = GridFSBucketReadStream;
	/**
	 * Fires when the stream loaded the file document corresponding to the provided id.
	 * @event
	 */
	GridFSBucketReadStream.FILE = 'file';
	function throwIfInitialized(stream) {
	    if (stream.s.init) {
	        throw new error_1.MongoGridFSStreamError('Options cannot be changed after the stream is initialized');
	    }
	}
	function doRead(stream) {
	    if (stream.destroyed)
	        return;
	    if (!stream.s.cursor)
	        return;
	    if (!stream.s.file)
	        return;
	    const handleReadResult = (doc) => {
	        if (stream.destroyed)
	            return;
	        if (!doc) {
	            stream.push(null);
	            stream.s.cursor?.close().then(undefined, error => stream.destroy(error));
	            return;
	        }
	        if (!stream.s.file)
	            return;
	        const bytesRemaining = stream.s.file.length - stream.s.bytesRead;
	        const expectedN = stream.s.expected++;
	        const expectedLength = Math.min(stream.s.file.chunkSize, bytesRemaining);
	        if (doc.n > expectedN) {
	            return stream.destroy(new error_1.MongoGridFSChunkError(`ChunkIsMissing: Got unexpected n: ${doc.n}, expected: ${expectedN}`));
	        }
	        if (doc.n < expectedN) {
	            return stream.destroy(new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}, expected: ${expectedN}`));
	        }
	        let buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;
	        if (buf.byteLength !== expectedLength) {
	            if (bytesRemaining <= 0) {
	                return stream.destroy(new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}, expected file length ${stream.s.file.length} bytes but already read ${stream.s.bytesRead} bytes`));
	            }
	            return stream.destroy(new error_1.MongoGridFSChunkError(`ChunkIsWrongSize: Got unexpected length: ${buf.byteLength}, expected: ${expectedLength}`));
	        }
	        stream.s.bytesRead += buf.byteLength;
	        if (buf.byteLength === 0) {
	            return stream.push(null);
	        }
	        let sliceStart = null;
	        let sliceEnd = null;
	        if (stream.s.bytesToSkip != null) {
	            sliceStart = stream.s.bytesToSkip;
	            stream.s.bytesToSkip = 0;
	        }
	        const atEndOfStream = expectedN === stream.s.expectedEnd - 1;
	        const bytesLeftToRead = stream.s.options.end - stream.s.bytesToSkip;
	        if (atEndOfStream && stream.s.bytesToTrim != null) {
	            sliceEnd = stream.s.file.chunkSize - stream.s.bytesToTrim;
	        }
	        else if (stream.s.options.end && bytesLeftToRead < doc.data.byteLength) {
	            sliceEnd = bytesLeftToRead;
	        }
	        if (sliceStart != null || sliceEnd != null) {
	            buf = buf.slice(sliceStart || 0, sliceEnd || buf.byteLength);
	        }
	        stream.push(buf);
	        return;
	    };
	    stream.s.cursor.next().then(handleReadResult, error => {
	        if (stream.destroyed)
	            return;
	        stream.destroy(error);
	    });
	}
	function init(stream) {
	    const findOneOptions = {};
	    if (stream.s.readPreference) {
	        findOneOptions.readPreference = stream.s.readPreference;
	    }
	    if (stream.s.options && stream.s.options.sort) {
	        findOneOptions.sort = stream.s.options.sort;
	    }
	    if (stream.s.options && stream.s.options.skip) {
	        findOneOptions.skip = stream.s.options.skip;
	    }
	    const handleReadResult = (doc) => {
	        if (stream.destroyed)
	            return;
	        if (!doc) {
	            const identifier = stream.s.filter._id
	                ? stream.s.filter._id.toString()
	                : stream.s.filter.filename;
	            const errmsg = `FileNotFound: file ${identifier} was not found`;
	            // TODO(NODE-3483)
	            const err = new error_1.MongoRuntimeError(errmsg);
	            err.code = 'ENOENT'; // TODO: NODE-3338 set property as part of constructor
	            return stream.destroy(err);
	        }
	        // If document is empty, kill the stream immediately and don't
	        // execute any reads
	        if (doc.length <= 0) {
	            stream.push(null);
	            return;
	        }
	        if (stream.destroyed) {
	            // If user destroys the stream before we have a cursor, wait
	            // until the query is done to say we're 'closed' because we can't
	            // cancel a query.
	            stream.destroy();
	            return;
	        }
	        try {
	            stream.s.bytesToSkip = handleStartOption(stream, doc, stream.s.options);
	        }
	        catch (error) {
	            return stream.destroy(error);
	        }
	        const filter = { files_id: doc._id };
	        // Currently (MongoDB 3.4.4) skip function does not support the index,
	        // it needs to retrieve all the documents first and then skip them. (CS-25811)
	        // As work around we use $gte on the "n" field.
	        if (stream.s.options && stream.s.options.start != null) {
	            const skip = Math.floor(stream.s.options.start / doc.chunkSize);
	            if (skip > 0) {
	                filter['n'] = { $gte: skip };
	            }
	        }
	        stream.s.cursor = stream.s.chunks.find(filter).sort({ n: 1 });
	        if (stream.s.readPreference) {
	            stream.s.cursor.withReadPreference(stream.s.readPreference);
	        }
	        stream.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
	        stream.s.file = doc;
	        try {
	            stream.s.bytesToTrim = handleEndOption(stream, doc, stream.s.cursor, stream.s.options);
	        }
	        catch (error) {
	            return stream.destroy(error);
	        }
	        stream.emit(GridFSBucketReadStream.FILE, doc);
	        return;
	    };
	    stream.s.files.findOne(stream.s.filter, findOneOptions).then(handleReadResult, error => {
	        if (stream.destroyed)
	            return;
	        stream.destroy(error);
	    });
	}
	function waitForFile(stream, callback) {
	    if (stream.s.file) {
	        return callback();
	    }
	    if (!stream.s.init) {
	        init(stream);
	        stream.s.init = true;
	    }
	    stream.once('file', () => {
	        callback();
	    });
	}
	function handleStartOption(stream, doc, options) {
	    if (options && options.start != null) {
	        if (options.start > doc.length) {
	            throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be more than the length of the file (${doc.length})`);
	        }
	        if (options.start < 0) {
	            throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be negative`);
	        }
	        if (options.end != null && options.end < options.start) {
	            throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be greater than stream end (${options.end})`);
	        }
	        stream.s.bytesRead = Math.floor(options.start / doc.chunkSize) * doc.chunkSize;
	        stream.s.expected = Math.floor(options.start / doc.chunkSize);
	        return options.start - stream.s.bytesRead;
	    }
	    throw new error_1.MongoInvalidArgumentError('Start option must be defined');
	}
	function handleEndOption(stream, doc, cursor, options) {
	    if (options && options.end != null) {
	        if (options.end > doc.length) {
	            throw new error_1.MongoInvalidArgumentError(`Stream end (${options.end}) must not be more than the length of the file (${doc.length})`);
	        }
	        if (options.start == null || options.start < 0) {
	            throw new error_1.MongoInvalidArgumentError(`Stream end (${options.end}) must not be negative`);
	        }
	        const start = options.start != null ? Math.floor(options.start / doc.chunkSize) : 0;
	        cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);
	        stream.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);
	        return Math.ceil(options.end / doc.chunkSize) * doc.chunkSize - options.end;
	    }
	    throw new error_1.MongoInvalidArgumentError('End option must be defined');
	}
	
	return download;
}

var upload = {};

var hasRequiredUpload;

function requireUpload () {
	if (hasRequiredUpload) return upload;
	hasRequiredUpload = 1;
	Object.defineProperty(upload, "__esModule", { value: true });
	upload.GridFSBucketWriteStream = void 0;
	const stream_1 = require$$0$9;
	const bson_1 = requireBson();
	const error_1 = requireError();
	const utils_1 = requireUtils$1();
	const write_concern_1 = requireWrite_concern();
	/**
	 * A writable stream that enables you to write buffers to GridFS.
	 *
	 * Do not instantiate this class directly. Use `openUploadStream()` instead.
	 * @public
	 */
	class GridFSBucketWriteStream extends stream_1.Writable {
	    /**
	     * @param bucket - Handle for this stream's corresponding bucket
	     * @param filename - The value of the 'filename' key in the files doc
	     * @param options - Optional settings.
	     * @internal
	     */
	    constructor(bucket, filename, options) {
	        super();
	        /**
	         * The document containing information about the inserted file.
	         * This property is defined _after_ the finish event has been emitted.
	         * It will remain `null` if an error occurs.
	         *
	         * @example
	         * ```ts
	         * fs.createReadStream('file.txt')
	         *   .pipe(bucket.openUploadStream('file.txt'))
	         *   .on('finish', function () {
	         *     console.log(this.gridFSFile)
	         *   })
	         * ```
	         */
	        this.gridFSFile = null;
	        options = options ?? {};
	        this.bucket = bucket;
	        this.chunks = bucket.s._chunksCollection;
	        this.filename = filename;
	        this.files = bucket.s._filesCollection;
	        this.options = options;
	        this.writeConcern = write_concern_1.WriteConcern.fromOptions(options) || bucket.s.options.writeConcern;
	        // Signals the write is all done
	        this.done = false;
	        this.id = options.id ? options.id : new bson_1.ObjectId();
	        // properly inherit the default chunksize from parent
	        this.chunkSizeBytes = options.chunkSizeBytes || this.bucket.s.options.chunkSizeBytes;
	        this.bufToStore = Buffer.alloc(this.chunkSizeBytes);
	        this.length = 0;
	        this.n = 0;
	        this.pos = 0;
	        this.state = {
	            streamEnd: false,
	            outstandingRequests: 0,
	            errored: false,
	            aborted: false
	        };
	        if (!this.bucket.s.calledOpenUploadStream) {
	            this.bucket.s.calledOpenUploadStream = true;
	            checkIndexes(this).then(() => {
	                this.bucket.s.checkedIndexes = true;
	                this.bucket.emit('index');
	            }, utils_1.squashError);
	        }
	    }
	    /**
	     * @internal
	     *
	     * The stream is considered constructed when the indexes are done being created
	     */
	    _construct(callback) {
	        if (this.bucket.s.checkedIndexes) {
	            return process.nextTick(callback);
	        }
	        this.bucket.once('index', callback);
	    }
	    /**
	     * @internal
	     * Write a buffer to the stream.
	     *
	     * @param chunk - Buffer to write
	     * @param encoding - Optional encoding for the buffer
	     * @param callback - Function to call when the chunk was added to the buffer, or if the entire chunk was persisted to MongoDB if this chunk caused a flush.
	     */
	    _write(chunk, encoding, callback) {
	        doWrite(this, chunk, encoding, callback);
	    }
	    /** @internal */
	    _final(callback) {
	        if (this.state.streamEnd) {
	            return process.nextTick(callback);
	        }
	        this.state.streamEnd = true;
	        writeRemnant(this, callback);
	    }
	    /**
	     * Places this write stream into an aborted state (all future writes fail)
	     * and deletes all chunks that have already been written.
	     */
	    async abort() {
	        if (this.state.streamEnd) {
	            // TODO(NODE-3485): Replace with MongoGridFSStreamClosed
	            throw new error_1.MongoAPIError('Cannot abort a stream that has already completed');
	        }
	        if (this.state.aborted) {
	            // TODO(NODE-3485): Replace with MongoGridFSStreamClosed
	            throw new error_1.MongoAPIError('Cannot call abort() on a stream twice');
	        }
	        this.state.aborted = true;
	        await this.chunks.deleteMany({ files_id: this.id });
	    }
	}
	upload.GridFSBucketWriteStream = GridFSBucketWriteStream;
	function handleError(stream, error, callback) {
	    if (stream.state.errored) {
	        process.nextTick(callback);
	        return;
	    }
	    stream.state.errored = true;
	    process.nextTick(callback, error);
	}
	function createChunkDoc(filesId, n, data) {
	    return {
	        _id: new bson_1.ObjectId(),
	        files_id: filesId,
	        n,
	        data
	    };
	}
	async function checkChunksIndex(stream) {
	    const index = { files_id: 1, n: 1 };
	    let indexes;
	    try {
	        indexes = await stream.chunks.listIndexes().toArray();
	    }
	    catch (error) {
	        if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
	            indexes = [];
	        }
	        else {
	            throw error;
	        }
	    }
	    const hasChunksIndex = !!indexes.find(index => {
	        const keys = Object.keys(index.key);
	        if (keys.length === 2 && index.key.files_id === 1 && index.key.n === 1) {
	            return true;
	        }
	        return false;
	    });
	    if (!hasChunksIndex) {
	        await stream.chunks.createIndex(index, {
	            ...stream.writeConcern,
	            background: true,
	            unique: true
	        });
	    }
	}
	function checkDone(stream, callback) {
	    if (stream.done) {
	        return process.nextTick(callback);
	    }
	    if (stream.state.streamEnd && stream.state.outstandingRequests === 0 && !stream.state.errored) {
	        // Set done so we do not trigger duplicate createFilesDoc
	        stream.done = true;
	        // Create a new files doc
	        const gridFSFile = createFilesDoc(stream.id, stream.length, stream.chunkSizeBytes, stream.filename, stream.options.contentType, stream.options.aliases, stream.options.metadata);
	        if (isAborted(stream, callback)) {
	            return;
	        }
	        stream.files.insertOne(gridFSFile, { writeConcern: stream.writeConcern }).then(() => {
	            stream.gridFSFile = gridFSFile;
	            callback();
	        }, error => handleError(stream, error, callback));
	        return;
	    }
	    process.nextTick(callback);
	}
	async function checkIndexes(stream) {
	    const doc = await stream.files.findOne({}, { projection: { _id: 1 } });
	    if (doc != null) {
	        // If at least one document exists assume the collection has the required index
	        return;
	    }
	    const index = { filename: 1, uploadDate: 1 };
	    let indexes;
	    try {
	        indexes = await stream.files.listIndexes().toArray();
	    }
	    catch (error) {
	        if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
	            indexes = [];
	        }
	        else {
	            throw error;
	        }
	    }
	    const hasFileIndex = !!indexes.find(index => {
	        const keys = Object.keys(index.key);
	        if (keys.length === 2 && index.key.filename === 1 && index.key.uploadDate === 1) {
	            return true;
	        }
	        return false;
	    });
	    if (!hasFileIndex) {
	        await stream.files.createIndex(index, { background: false });
	    }
	    await checkChunksIndex(stream);
	}
	function createFilesDoc(_id, length, chunkSize, filename, contentType, aliases, metadata) {
	    const ret = {
	        _id,
	        length,
	        chunkSize,
	        uploadDate: new Date(),
	        filename
	    };
	    if (contentType) {
	        ret.contentType = contentType;
	    }
	    if (aliases) {
	        ret.aliases = aliases;
	    }
	    if (metadata) {
	        ret.metadata = metadata;
	    }
	    return ret;
	}
	function doWrite(stream, chunk, encoding, callback) {
	    if (isAborted(stream, callback)) {
	        return;
	    }
	    const inputBuf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);
	    stream.length += inputBuf.length;
	    // Input is small enough to fit in our buffer
	    if (stream.pos + inputBuf.length < stream.chunkSizeBytes) {
	        inputBuf.copy(stream.bufToStore, stream.pos);
	        stream.pos += inputBuf.length;
	        process.nextTick(callback);
	        return;
	    }
	    // Otherwise, buffer is too big for current chunk, so we need to flush
	    // to MongoDB.
	    let inputBufRemaining = inputBuf.length;
	    let spaceRemaining = stream.chunkSizeBytes - stream.pos;
	    let numToCopy = Math.min(spaceRemaining, inputBuf.length);
	    let outstandingRequests = 0;
	    while (inputBufRemaining > 0) {
	        const inputBufPos = inputBuf.length - inputBufRemaining;
	        inputBuf.copy(stream.bufToStore, stream.pos, inputBufPos, inputBufPos + numToCopy);
	        stream.pos += numToCopy;
	        spaceRemaining -= numToCopy;
	        let doc;
	        if (spaceRemaining === 0) {
	            doc = createChunkDoc(stream.id, stream.n, Buffer.from(stream.bufToStore));
	            ++stream.state.outstandingRequests;
	            ++outstandingRequests;
	            if (isAborted(stream, callback)) {
	                return;
	            }
	            stream.chunks.insertOne(doc, { writeConcern: stream.writeConcern }).then(() => {
	                --stream.state.outstandingRequests;
	                --outstandingRequests;
	                if (!outstandingRequests) {
	                    checkDone(stream, callback);
	                }
	            }, error => handleError(stream, error, callback));
	            spaceRemaining = stream.chunkSizeBytes;
	            stream.pos = 0;
	            ++stream.n;
	        }
	        inputBufRemaining -= numToCopy;
	        numToCopy = Math.min(spaceRemaining, inputBufRemaining);
	    }
	}
	function writeRemnant(stream, callback) {
	    // Buffer is empty, so don't bother to insert
	    if (stream.pos === 0) {
	        return checkDone(stream, callback);
	    }
	    ++stream.state.outstandingRequests;
	    // Create a new buffer to make sure the buffer isn't bigger than it needs
	    // to be.
	    const remnant = Buffer.alloc(stream.pos);
	    stream.bufToStore.copy(remnant, 0, 0, stream.pos);
	    const doc = createChunkDoc(stream.id, stream.n, remnant);
	    // If the stream was aborted, do not write remnant
	    if (isAborted(stream, callback)) {
	        return;
	    }
	    stream.chunks.insertOne(doc, { writeConcern: stream.writeConcern }).then(() => {
	        --stream.state.outstandingRequests;
	        checkDone(stream, callback);
	    }, error => handleError(stream, error, callback));
	}
	function isAborted(stream, callback) {
	    if (stream.state.aborted) {
	        process.nextTick(callback, new error_1.MongoAPIError('Stream has been aborted'));
	        return true;
	    }
	    return false;
	}
	
	return upload;
}

var hasRequiredGridfs;

function requireGridfs () {
	if (hasRequiredGridfs) return gridfs;
	hasRequiredGridfs = 1;
	Object.defineProperty(gridfs, "__esModule", { value: true });
	gridfs.GridFSBucket = void 0;
	const error_1 = requireError();
	const mongo_types_1 = requireMongo_types();
	const write_concern_1 = requireWrite_concern();
	const download_1 = requireDownload();
	const upload_1 = requireUpload();
	const DEFAULT_GRIDFS_BUCKET_OPTIONS = {
	    bucketName: 'fs',
	    chunkSizeBytes: 255 * 1024
	};
	/**
	 * Constructor for a streaming GridFS interface
	 * @public
	 */
	class GridFSBucket extends mongo_types_1.TypedEventEmitter {
	    constructor(db, options) {
	        super();
	        this.setMaxListeners(0);
	        const privateOptions = {
	            ...DEFAULT_GRIDFS_BUCKET_OPTIONS,
	            ...options,
	            writeConcern: write_concern_1.WriteConcern.fromOptions(options)
	        };
	        this.s = {
	            db,
	            options: privateOptions,
	            _chunksCollection: db.collection(privateOptions.bucketName + '.chunks'),
	            _filesCollection: db.collection(privateOptions.bucketName + '.files'),
	            checkedIndexes: false,
	            calledOpenUploadStream: false
	        };
	    }
	    /**
	     * Returns a writable stream (GridFSBucketWriteStream) for writing
	     * buffers to GridFS. The stream's 'id' property contains the resulting
	     * file's id.
	     *
	     * @param filename - The value of the 'filename' key in the files doc
	     * @param options - Optional settings.
	     */
	    openUploadStream(filename, options) {
	        return new upload_1.GridFSBucketWriteStream(this, filename, options);
	    }
	    /**
	     * Returns a writable stream (GridFSBucketWriteStream) for writing
	     * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting
	     * file's id.
	     */
	    openUploadStreamWithId(id, filename, options) {
	        return new upload_1.GridFSBucketWriteStream(this, filename, { ...options, id });
	    }
	    /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */
	    openDownloadStream(id, options) {
	        return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { _id: id }, options);
	    }
	    /**
	     * Deletes a file with the given id
	     *
	     * @param id - The id of the file doc
	     */
	    async delete(id) {
	        const { deletedCount } = await this.s._filesCollection.deleteOne({ _id: id });
	        // Delete orphaned chunks before returning FileNotFound
	        await this.s._chunksCollection.deleteMany({ files_id: id });
	        if (deletedCount === 0) {
	            // TODO(NODE-3483): Replace with more appropriate error
	            // Consider creating new error MongoGridFSFileNotFoundError
	            throw new error_1.MongoRuntimeError(`File not found for id ${id}`);
	        }
	    }
	    /** Convenience wrapper around find on the files collection */
	    find(filter = {}, options = {}) {
	        return this.s._filesCollection.find(filter, options);
	    }
	    /**
	     * Returns a readable stream (GridFSBucketReadStream) for streaming the
	     * file with the given name from GridFS. If there are multiple files with
	     * the same name, this will stream the most recent file with the given name
	     * (as determined by the `uploadDate` field). You can set the `revision`
	     * option to change this behavior.
	     */
	    openDownloadStreamByName(filename, options) {
	        let sort = { uploadDate: -1 };
	        let skip = undefined;
	        if (options && options.revision != null) {
	            if (options.revision >= 0) {
	                sort = { uploadDate: 1 };
	                skip = options.revision;
	            }
	            else {
	                skip = -options.revision - 1;
	            }
	        }
	        return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { filename }, { ...options, sort, skip });
	    }
	    /**
	     * Renames the file with the given _id to the given string
	     *
	     * @param id - the id of the file to rename
	     * @param filename - new name for the file
	     */
	    async rename(id, filename) {
	        const filter = { _id: id };
	        const update = { $set: { filename } };
	        const { matchedCount } = await this.s._filesCollection.updateOne(filter, update);
	        if (matchedCount === 0) {
	            throw new error_1.MongoRuntimeError(`File with id ${id} not found`);
	        }
	    }
	    /** Removes this bucket's files collection, followed by its chunks collection. */
	    async drop() {
	        await this.s._filesCollection.drop();
	        await this.s._chunksCollection.drop();
	    }
	}
	gridfs.GridFSBucket = GridFSBucket;
	/**
	 * When the first call to openUploadStream is made, the upload stream will
	 * check to see if it needs to create the proper indexes on the chunks and
	 * files collections. This event is fired either when 1) it determines that
	 * no index creation is necessary, 2) when it successfully creates the
	 * necessary indexes.
	 * @event
	 */
	GridFSBucket.INDEX = 'index';
	
	return gridfs;
}

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib$2;
	hasRequiredLib = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.MongoTopologyClosedError = exports.MongoTailableCursorError = exports.MongoSystemError = exports.MongoServerSelectionError = exports.MongoServerError = exports.MongoServerClosedError = exports.MongoRuntimeError = exports.MongoParseError = exports.MongoOIDCError = exports.MongoNotConnectedError = exports.MongoNetworkTimeoutError = exports.MongoNetworkError = exports.MongoMissingDependencyError = exports.MongoMissingCredentialsError = exports.MongoKerberosError = exports.MongoInvalidArgumentError = exports.MongoGridFSStreamError = exports.MongoGridFSChunkError = exports.MongoGCPError = exports.MongoExpiredSessionError = exports.MongoError = exports.MongoDriverError = exports.MongoDecompressionError = exports.MongoCursorInUseError = exports.MongoCursorExhaustedError = exports.MongoCompatibilityError = exports.MongoChangeStreamError = exports.MongoBatchReExecutionError = exports.MongoAzureError = exports.MongoAWSError = exports.MongoAPIError = exports.ChangeStreamCursor = exports.ClientEncryption = exports.MongoBulkWriteError = exports.UUID = exports.Timestamp = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Long = exports.Int32 = exports.Double = exports.Decimal128 = exports.DBRef = exports.Code = exports.BSONType = exports.BSONSymbol = exports.BSONRegExp = exports.Binary = exports.BSON = void 0;
		exports.ConnectionPoolClosedEvent = exports.ConnectionPoolClearedEvent = exports.ConnectionCreatedEvent = exports.ConnectionClosedEvent = exports.ConnectionCheckOutStartedEvent = exports.ConnectionCheckOutFailedEvent = exports.ConnectionCheckedOutEvent = exports.ConnectionCheckedInEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = exports.CommandFailedEvent = exports.WriteConcern = exports.ReadPreference = exports.ReadConcern = exports.TopologyType = exports.ServerType = exports.ReadPreferenceMode = exports.ReadConcernLevel = exports.ProfilingLevel = exports.ReturnDocument = exports.ServerApiVersion = exports.ExplainVerbosity = exports.MongoErrorLabel = exports.CURSOR_FLAGS = exports.Compressor = exports.AuthMechanism = exports.GSSAPICanonicalizationValue = exports.AutoEncryptionLoggerLevel = exports.BatchType = exports.UnorderedBulkOperation = exports.OrderedBulkOperation = exports.MongoClient = exports.ListIndexesCursor = exports.ListCollectionsCursor = exports.GridFSBucketWriteStream = exports.GridFSBucketReadStream = exports.GridFSBucket = exports.FindCursor = exports.Db = exports.Collection = exports.ClientSession = exports.ChangeStream = exports.CancellationToken = exports.AggregationCursor = exports.Admin = exports.AbstractCursor = exports.configureExplicitResourceManagement = exports.MongoWriteConcernError = exports.MongoUnexpectedServerResponseError = exports.MongoTransactionError = void 0;
		exports.MongoClientAuthProviders = exports.MongoCryptKMSRequestNetworkTimeoutError = exports.MongoCryptInvalidArgumentError = exports.MongoCryptError = exports.MongoCryptCreateEncryptedCollectionError = exports.MongoCryptCreateDataKeyError = exports.MongoCryptAzureKMSRequestError = exports.SrvPollingEvent = exports.WaitingForSuitableServerEvent = exports.ServerSelectionSucceededEvent = exports.ServerSelectionStartedEvent = exports.ServerSelectionFailedEvent = exports.ServerSelectionEvent = exports.TopologyOpeningEvent = exports.TopologyDescriptionChangedEvent = exports.TopologyClosedEvent = exports.ServerOpeningEvent = exports.ServerHeartbeatSucceededEvent = exports.ServerHeartbeatStartedEvent = exports.ServerHeartbeatFailedEvent = exports.ServerDescriptionChangedEvent = exports.ServerClosedEvent = exports.ConnectionReadyEvent = exports.ConnectionPoolReadyEvent = exports.ConnectionPoolMonitoringEvent = exports.ConnectionPoolCreatedEvent = void 0;
		const admin_1 = requireAdmin();
		Object.defineProperty(exports, "Admin", { enumerable: true, get: function () { return admin_1.Admin; } });
		const ordered_1 = requireOrdered();
		Object.defineProperty(exports, "OrderedBulkOperation", { enumerable: true, get: function () { return ordered_1.OrderedBulkOperation; } });
		const unordered_1 = requireUnordered();
		Object.defineProperty(exports, "UnorderedBulkOperation", { enumerable: true, get: function () { return unordered_1.UnorderedBulkOperation; } });
		const change_stream_1 = requireChange_stream();
		Object.defineProperty(exports, "ChangeStream", { enumerable: true, get: function () { return change_stream_1.ChangeStream; } });
		const collection_1 = requireCollection();
		Object.defineProperty(exports, "Collection", { enumerable: true, get: function () { return collection_1.Collection; } });
		const abstract_cursor_1 = requireAbstract_cursor();
		Object.defineProperty(exports, "AbstractCursor", { enumerable: true, get: function () { return abstract_cursor_1.AbstractCursor; } });
		const aggregation_cursor_1 = requireAggregation_cursor();
		Object.defineProperty(exports, "AggregationCursor", { enumerable: true, get: function () { return aggregation_cursor_1.AggregationCursor; } });
		const find_cursor_1 = requireFind_cursor();
		Object.defineProperty(exports, "FindCursor", { enumerable: true, get: function () { return find_cursor_1.FindCursor; } });
		const list_collections_cursor_1 = requireList_collections_cursor();
		Object.defineProperty(exports, "ListCollectionsCursor", { enumerable: true, get: function () { return list_collections_cursor_1.ListCollectionsCursor; } });
		const list_indexes_cursor_1 = requireList_indexes_cursor();
		Object.defineProperty(exports, "ListIndexesCursor", { enumerable: true, get: function () { return list_indexes_cursor_1.ListIndexesCursor; } });
		const db_1 = requireDb();
		Object.defineProperty(exports, "Db", { enumerable: true, get: function () { return db_1.Db; } });
		const gridfs_1 = requireGridfs();
		Object.defineProperty(exports, "GridFSBucket", { enumerable: true, get: function () { return gridfs_1.GridFSBucket; } });
		const download_1 = requireDownload();
		Object.defineProperty(exports, "GridFSBucketReadStream", { enumerable: true, get: function () { return download_1.GridFSBucketReadStream; } });
		const upload_1 = requireUpload();
		Object.defineProperty(exports, "GridFSBucketWriteStream", { enumerable: true, get: function () { return upload_1.GridFSBucketWriteStream; } });
		const mongo_client_1 = requireMongo_client();
		Object.defineProperty(exports, "MongoClient", { enumerable: true, get: function () { return mongo_client_1.MongoClient; } });
		const mongo_types_1 = requireMongo_types();
		Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function () { return mongo_types_1.CancellationToken; } });
		const sessions_1 = requireSessions();
		Object.defineProperty(exports, "ClientSession", { enumerable: true, get: function () { return sessions_1.ClientSession; } });
		/** @public */
		var bson_1 = requireBson();
		Object.defineProperty(exports, "BSON", { enumerable: true, get: function () { return bson_1.BSON; } });
		var bson_2 = requireBson();
		Object.defineProperty(exports, "Binary", { enumerable: true, get: function () { return bson_2.Binary; } });
		Object.defineProperty(exports, "BSONRegExp", { enumerable: true, get: function () { return bson_2.BSONRegExp; } });
		Object.defineProperty(exports, "BSONSymbol", { enumerable: true, get: function () { return bson_2.BSONSymbol; } });
		Object.defineProperty(exports, "BSONType", { enumerable: true, get: function () { return bson_2.BSONType; } });
		Object.defineProperty(exports, "Code", { enumerable: true, get: function () { return bson_2.Code; } });
		Object.defineProperty(exports, "DBRef", { enumerable: true, get: function () { return bson_2.DBRef; } });
		Object.defineProperty(exports, "Decimal128", { enumerable: true, get: function () { return bson_2.Decimal128; } });
		Object.defineProperty(exports, "Double", { enumerable: true, get: function () { return bson_2.Double; } });
		Object.defineProperty(exports, "Int32", { enumerable: true, get: function () { return bson_2.Int32; } });
		Object.defineProperty(exports, "Long", { enumerable: true, get: function () { return bson_2.Long; } });
		Object.defineProperty(exports, "MaxKey", { enumerable: true, get: function () { return bson_2.MaxKey; } });
		Object.defineProperty(exports, "MinKey", { enumerable: true, get: function () { return bson_2.MinKey; } });
		Object.defineProperty(exports, "ObjectId", { enumerable: true, get: function () { return bson_2.ObjectId; } });
		Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function () { return bson_2.Timestamp; } });
		Object.defineProperty(exports, "UUID", { enumerable: true, get: function () { return bson_2.UUID; } });
		var common_1 = requireCommon();
		Object.defineProperty(exports, "MongoBulkWriteError", { enumerable: true, get: function () { return common_1.MongoBulkWriteError; } });
		var client_encryption_1 = requireClient_encryption();
		Object.defineProperty(exports, "ClientEncryption", { enumerable: true, get: function () { return client_encryption_1.ClientEncryption; } });
		var change_stream_cursor_1 = requireChange_stream_cursor();
		Object.defineProperty(exports, "ChangeStreamCursor", { enumerable: true, get: function () { return change_stream_cursor_1.ChangeStreamCursor; } });
		var error_1 = requireError();
		Object.defineProperty(exports, "MongoAPIError", { enumerable: true, get: function () { return error_1.MongoAPIError; } });
		Object.defineProperty(exports, "MongoAWSError", { enumerable: true, get: function () { return error_1.MongoAWSError; } });
		Object.defineProperty(exports, "MongoAzureError", { enumerable: true, get: function () { return error_1.MongoAzureError; } });
		Object.defineProperty(exports, "MongoBatchReExecutionError", { enumerable: true, get: function () { return error_1.MongoBatchReExecutionError; } });
		Object.defineProperty(exports, "MongoChangeStreamError", { enumerable: true, get: function () { return error_1.MongoChangeStreamError; } });
		Object.defineProperty(exports, "MongoCompatibilityError", { enumerable: true, get: function () { return error_1.MongoCompatibilityError; } });
		Object.defineProperty(exports, "MongoCursorExhaustedError", { enumerable: true, get: function () { return error_1.MongoCursorExhaustedError; } });
		Object.defineProperty(exports, "MongoCursorInUseError", { enumerable: true, get: function () { return error_1.MongoCursorInUseError; } });
		Object.defineProperty(exports, "MongoDecompressionError", { enumerable: true, get: function () { return error_1.MongoDecompressionError; } });
		Object.defineProperty(exports, "MongoDriverError", { enumerable: true, get: function () { return error_1.MongoDriverError; } });
		Object.defineProperty(exports, "MongoError", { enumerable: true, get: function () { return error_1.MongoError; } });
		Object.defineProperty(exports, "MongoExpiredSessionError", { enumerable: true, get: function () { return error_1.MongoExpiredSessionError; } });
		Object.defineProperty(exports, "MongoGCPError", { enumerable: true, get: function () { return error_1.MongoGCPError; } });
		Object.defineProperty(exports, "MongoGridFSChunkError", { enumerable: true, get: function () { return error_1.MongoGridFSChunkError; } });
		Object.defineProperty(exports, "MongoGridFSStreamError", { enumerable: true, get: function () { return error_1.MongoGridFSStreamError; } });
		Object.defineProperty(exports, "MongoInvalidArgumentError", { enumerable: true, get: function () { return error_1.MongoInvalidArgumentError; } });
		Object.defineProperty(exports, "MongoKerberosError", { enumerable: true, get: function () { return error_1.MongoKerberosError; } });
		Object.defineProperty(exports, "MongoMissingCredentialsError", { enumerable: true, get: function () { return error_1.MongoMissingCredentialsError; } });
		Object.defineProperty(exports, "MongoMissingDependencyError", { enumerable: true, get: function () { return error_1.MongoMissingDependencyError; } });
		Object.defineProperty(exports, "MongoNetworkError", { enumerable: true, get: function () { return error_1.MongoNetworkError; } });
		Object.defineProperty(exports, "MongoNetworkTimeoutError", { enumerable: true, get: function () { return error_1.MongoNetworkTimeoutError; } });
		Object.defineProperty(exports, "MongoNotConnectedError", { enumerable: true, get: function () { return error_1.MongoNotConnectedError; } });
		Object.defineProperty(exports, "MongoOIDCError", { enumerable: true, get: function () { return error_1.MongoOIDCError; } });
		Object.defineProperty(exports, "MongoParseError", { enumerable: true, get: function () { return error_1.MongoParseError; } });
		Object.defineProperty(exports, "MongoRuntimeError", { enumerable: true, get: function () { return error_1.MongoRuntimeError; } });
		Object.defineProperty(exports, "MongoServerClosedError", { enumerable: true, get: function () { return error_1.MongoServerClosedError; } });
		Object.defineProperty(exports, "MongoServerError", { enumerable: true, get: function () { return error_1.MongoServerError; } });
		Object.defineProperty(exports, "MongoServerSelectionError", { enumerable: true, get: function () { return error_1.MongoServerSelectionError; } });
		Object.defineProperty(exports, "MongoSystemError", { enumerable: true, get: function () { return error_1.MongoSystemError; } });
		Object.defineProperty(exports, "MongoTailableCursorError", { enumerable: true, get: function () { return error_1.MongoTailableCursorError; } });
		Object.defineProperty(exports, "MongoTopologyClosedError", { enumerable: true, get: function () { return error_1.MongoTopologyClosedError; } });
		Object.defineProperty(exports, "MongoTransactionError", { enumerable: true, get: function () { return error_1.MongoTransactionError; } });
		Object.defineProperty(exports, "MongoUnexpectedServerResponseError", { enumerable: true, get: function () { return error_1.MongoUnexpectedServerResponseError; } });
		Object.defineProperty(exports, "MongoWriteConcernError", { enumerable: true, get: function () { return error_1.MongoWriteConcernError; } });
		var resource_management_1 = requireResource_management();
		Object.defineProperty(exports, "configureExplicitResourceManagement", { enumerable: true, get: function () { return resource_management_1.configureExplicitResourceManagement; } });
		// enums
		var common_2 = requireCommon();
		Object.defineProperty(exports, "BatchType", { enumerable: true, get: function () { return common_2.BatchType; } });
		var auto_encrypter_1 = requireAuto_encrypter();
		Object.defineProperty(exports, "AutoEncryptionLoggerLevel", { enumerable: true, get: function () { return auto_encrypter_1.AutoEncryptionLoggerLevel; } });
		var gssapi_1 = requireGssapi();
		Object.defineProperty(exports, "GSSAPICanonicalizationValue", { enumerable: true, get: function () { return gssapi_1.GSSAPICanonicalizationValue; } });
		var providers_1 = requireProviders$1();
		Object.defineProperty(exports, "AuthMechanism", { enumerable: true, get: function () { return providers_1.AuthMechanism; } });
		var compression_1 = requireCompression();
		Object.defineProperty(exports, "Compressor", { enumerable: true, get: function () { return compression_1.Compressor; } });
		var abstract_cursor_2 = requireAbstract_cursor();
		Object.defineProperty(exports, "CURSOR_FLAGS", { enumerable: true, get: function () { return abstract_cursor_2.CURSOR_FLAGS; } });
		var error_2 = requireError();
		Object.defineProperty(exports, "MongoErrorLabel", { enumerable: true, get: function () { return error_2.MongoErrorLabel; } });
		var explain_1 = requireExplain();
		Object.defineProperty(exports, "ExplainVerbosity", { enumerable: true, get: function () { return explain_1.ExplainVerbosity; } });
		var mongo_client_2 = requireMongo_client();
		Object.defineProperty(exports, "ServerApiVersion", { enumerable: true, get: function () { return mongo_client_2.ServerApiVersion; } });
		var find_and_modify_1 = requireFind_and_modify();
		Object.defineProperty(exports, "ReturnDocument", { enumerable: true, get: function () { return find_and_modify_1.ReturnDocument; } });
		var set_profiling_level_1 = requireSet_profiling_level();
		Object.defineProperty(exports, "ProfilingLevel", { enumerable: true, get: function () { return set_profiling_level_1.ProfilingLevel; } });
		var read_concern_1 = requireRead_concern();
		Object.defineProperty(exports, "ReadConcernLevel", { enumerable: true, get: function () { return read_concern_1.ReadConcernLevel; } });
		var read_preference_1 = requireRead_preference();
		Object.defineProperty(exports, "ReadPreferenceMode", { enumerable: true, get: function () { return read_preference_1.ReadPreferenceMode; } });
		var common_3 = requireCommon$1();
		Object.defineProperty(exports, "ServerType", { enumerable: true, get: function () { return common_3.ServerType; } });
		Object.defineProperty(exports, "TopologyType", { enumerable: true, get: function () { return common_3.TopologyType; } });
		// Helper classes
		var read_concern_2 = requireRead_concern();
		Object.defineProperty(exports, "ReadConcern", { enumerable: true, get: function () { return read_concern_2.ReadConcern; } });
		var read_preference_2 = requireRead_preference();
		Object.defineProperty(exports, "ReadPreference", { enumerable: true, get: function () { return read_preference_2.ReadPreference; } });
		var write_concern_1 = requireWrite_concern();
		Object.defineProperty(exports, "WriteConcern", { enumerable: true, get: function () { return write_concern_1.WriteConcern; } });
		// events
		var command_monitoring_events_1 = requireCommand_monitoring_events();
		Object.defineProperty(exports, "CommandFailedEvent", { enumerable: true, get: function () { return command_monitoring_events_1.CommandFailedEvent; } });
		Object.defineProperty(exports, "CommandStartedEvent", { enumerable: true, get: function () { return command_monitoring_events_1.CommandStartedEvent; } });
		Object.defineProperty(exports, "CommandSucceededEvent", { enumerable: true, get: function () { return command_monitoring_events_1.CommandSucceededEvent; } });
		var connection_pool_events_1 = requireConnection_pool_events();
		Object.defineProperty(exports, "ConnectionCheckedInEvent", { enumerable: true, get: function () { return connection_pool_events_1.ConnectionCheckedInEvent; } });
		Object.defineProperty(exports, "ConnectionCheckedOutEvent", { enumerable: true, get: function () { return connection_pool_events_1.ConnectionCheckedOutEvent; } });
		Object.defineProperty(exports, "ConnectionCheckOutFailedEvent", { enumerable: true, get: function () { return connection_pool_events_1.ConnectionCheckOutFailedEvent; } });
		Object.defineProperty(exports, "ConnectionCheckOutStartedEvent", { enumerable: true, get: function () { return connection_pool_events_1.ConnectionCheckOutStartedEvent; } });
		Object.defineProperty(exports, "ConnectionClosedEvent", { enumerable: true, get: function () { return connection_pool_events_1.ConnectionClosedEvent; } });
		Object.defineProperty(exports, "ConnectionCreatedEvent", { enumerable: true, get: function () { return connection_pool_events_1.ConnectionCreatedEvent; } });
		Object.defineProperty(exports, "ConnectionPoolClearedEvent", { enumerable: true, get: function () { return connection_pool_events_1.ConnectionPoolClearedEvent; } });
		Object.defineProperty(exports, "ConnectionPoolClosedEvent", { enumerable: true, get: function () { return connection_pool_events_1.ConnectionPoolClosedEvent; } });
		Object.defineProperty(exports, "ConnectionPoolCreatedEvent", { enumerable: true, get: function () { return connection_pool_events_1.ConnectionPoolCreatedEvent; } });
		Object.defineProperty(exports, "ConnectionPoolMonitoringEvent", { enumerable: true, get: function () { return connection_pool_events_1.ConnectionPoolMonitoringEvent; } });
		Object.defineProperty(exports, "ConnectionPoolReadyEvent", { enumerable: true, get: function () { return connection_pool_events_1.ConnectionPoolReadyEvent; } });
		Object.defineProperty(exports, "ConnectionReadyEvent", { enumerable: true, get: function () { return connection_pool_events_1.ConnectionReadyEvent; } });
		var events_1 = requireEvents();
		Object.defineProperty(exports, "ServerClosedEvent", { enumerable: true, get: function () { return events_1.ServerClosedEvent; } });
		Object.defineProperty(exports, "ServerDescriptionChangedEvent", { enumerable: true, get: function () { return events_1.ServerDescriptionChangedEvent; } });
		Object.defineProperty(exports, "ServerHeartbeatFailedEvent", { enumerable: true, get: function () { return events_1.ServerHeartbeatFailedEvent; } });
		Object.defineProperty(exports, "ServerHeartbeatStartedEvent", { enumerable: true, get: function () { return events_1.ServerHeartbeatStartedEvent; } });
		Object.defineProperty(exports, "ServerHeartbeatSucceededEvent", { enumerable: true, get: function () { return events_1.ServerHeartbeatSucceededEvent; } });
		Object.defineProperty(exports, "ServerOpeningEvent", { enumerable: true, get: function () { return events_1.ServerOpeningEvent; } });
		Object.defineProperty(exports, "TopologyClosedEvent", { enumerable: true, get: function () { return events_1.TopologyClosedEvent; } });
		Object.defineProperty(exports, "TopologyDescriptionChangedEvent", { enumerable: true, get: function () { return events_1.TopologyDescriptionChangedEvent; } });
		Object.defineProperty(exports, "TopologyOpeningEvent", { enumerable: true, get: function () { return events_1.TopologyOpeningEvent; } });
		var server_selection_events_1 = requireServer_selection_events();
		Object.defineProperty(exports, "ServerSelectionEvent", { enumerable: true, get: function () { return server_selection_events_1.ServerSelectionEvent; } });
		Object.defineProperty(exports, "ServerSelectionFailedEvent", { enumerable: true, get: function () { return server_selection_events_1.ServerSelectionFailedEvent; } });
		Object.defineProperty(exports, "ServerSelectionStartedEvent", { enumerable: true, get: function () { return server_selection_events_1.ServerSelectionStartedEvent; } });
		Object.defineProperty(exports, "ServerSelectionSucceededEvent", { enumerable: true, get: function () { return server_selection_events_1.ServerSelectionSucceededEvent; } });
		Object.defineProperty(exports, "WaitingForSuitableServerEvent", { enumerable: true, get: function () { return server_selection_events_1.WaitingForSuitableServerEvent; } });
		var srv_polling_1 = requireSrv_polling();
		Object.defineProperty(exports, "SrvPollingEvent", { enumerable: true, get: function () { return srv_polling_1.SrvPollingEvent; } });
		var errors_1 = requireErrors$1();
		Object.defineProperty(exports, "MongoCryptAzureKMSRequestError", { enumerable: true, get: function () { return errors_1.MongoCryptAzureKMSRequestError; } });
		Object.defineProperty(exports, "MongoCryptCreateDataKeyError", { enumerable: true, get: function () { return errors_1.MongoCryptCreateDataKeyError; } });
		Object.defineProperty(exports, "MongoCryptCreateEncryptedCollectionError", { enumerable: true, get: function () { return errors_1.MongoCryptCreateEncryptedCollectionError; } });
		Object.defineProperty(exports, "MongoCryptError", { enumerable: true, get: function () { return errors_1.MongoCryptError; } });
		Object.defineProperty(exports, "MongoCryptInvalidArgumentError", { enumerable: true, get: function () { return errors_1.MongoCryptInvalidArgumentError; } });
		Object.defineProperty(exports, "MongoCryptKMSRequestNetworkTimeoutError", { enumerable: true, get: function () { return errors_1.MongoCryptKMSRequestNetworkTimeoutError; } });
		var mongo_client_auth_providers_1 = requireMongo_client_auth_providers();
		Object.defineProperty(exports, "MongoClientAuthProviders", { enumerable: true, get: function () { return mongo_client_auth_providers_1.MongoClientAuthProviders; } });
		
	} (lib$2));
	return lib$2;
}

var libExports = requireLib();

const safeResponse = (callback) => async (req, res, next) => {
    try {
        await callback(req, res, next);
    }
    catch (error) {
        log(LogLevel.ERROR)('safeResponse', { error });
        return res.sendError(toJkError(error));
    }
};

/**
 * @module constants
 * @summary Useful constants
 * @description
 * Collection of useful date constants.
 *
 * The constants could be imported from `date-fns/constants`:
 *
 * ```ts
 * import { maxTime, minTime } from "./constants/date-fns/constants";
 *
 * function isAllowedTime(time) {
 *   return time <= maxTime && time >= minTime;
 * }
 * ```
 */


/**
 * @constant
 * @name constructFromSymbol
 * @summary Symbol enabling Date extensions to inherit properties from the reference date.
 *
 * The symbol is used to enable the `constructFrom` function to construct a date
 * using a reference date and a value. It allows to transfer extra properties
 * from the reference date to the new date. It's useful for extensions like
 * [`TZDate`](https://github.com/date-fns/tz) that accept a time zone as
 * a constructor argument.
 */
const constructFromSymbol = Symbol.for("constructDateFrom");

/**
 * @name constructFrom
 * @category Generic Helpers
 * @summary Constructs a date using the reference date and the value
 *
 * @description
 * The function constructs a new date using the constructor from the reference
 * date and the given value. It helps to build generic functions that accept
 * date extensions.
 *
 * It defaults to `Date` if the passed reference date is a number or a string.
 *
 * Starting from v3.7.0, it allows to construct a date using `[Symbol.for("constructDateFrom")]`
 * enabling to transfer extra properties from the reference date to the new date.
 * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)
 * that accept a time zone as a constructor argument.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The reference date to take constructor from
 * @param value - The value to create the date
 *
 * @returns Date initialized using the given date and value
 *
 * @example
 * import { constructFrom } from "./constructFrom/date-fns";
 *
 * // A function that clones a date preserving the original type
 * function cloneDate<DateType extends Date>(date: DateType): DateType {
 *   return constructFrom(
 *     date, // Use constructor from the given date
 *     date.getTime() // Use the date value to create a new date
 *   );
 * }
 */
function constructFrom(date, value) {
  if (typeof date === "function") return date(value);

  if (date && typeof date === "object" && constructFromSymbol in date)
    return date[constructFromSymbol](value);

  if (date instanceof Date) return new date.constructor(value);

  return new Date(value);
}

/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * Starting from v3.7.0, it clones a date using `[Symbol.for("constructDateFrom")]`
 * enabling to transfer extra properties from the reference date to the new date.
 * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)
 * that accept a time zone as a constructor argument.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param argument - The value to convert
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */
function toDate(argument, context) {
  // [TODO] Get rid of `toDate` or `constructFrom`?
  return constructFrom(argument, argument);
}

/**
 * The {@link addDays} function options.
 */

/**
 * @name addDays
 * @category Day Helpers
 * @summary Add the specified number of days to the given date.
 *
 * @description
 * Add the specified number of days to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of days to be added.
 * @param options - An object with options
 *
 * @returns The new date with the days added
 *
 * @example
 * // Add 10 days to 1 September 2014:
 * const result = addDays(new Date(2014, 8, 1), 10)
 * //=> Thu Sep 11 2014 00:00:00
 */
function addDays(date, amount, options) {
  const _date = toDate(date);
  if (isNaN(amount)) return constructFrom(date, NaN);

  // If 0 days, no-op to avoid changing times in the hour before end of DST
  if (!amount) return _date;

  _date.setDate(_date.getDate() + amount);
  return _date;
}

/**
 * The {@link addMonths} function options.
 */

/**
 * @name addMonths
 * @category Month Helpers
 * @summary Add the specified number of months to the given date.
 *
 * @description
 * Add the specified number of months to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of months to be added.
 * @param options - The options object
 *
 * @returns The new date with the months added
 *
 * @example
 * // Add 5 months to 1 September 2014:
 * const result = addMonths(new Date(2014, 8, 1), 5)
 * //=> Sun Feb 01 2015 00:00:00
 *
 * // Add one month to 30 January 2023:
 * const result = addMonths(new Date(2023, 0, 30), 1)
 * //=> Tue Feb 28 2023 00:00:00
 */
function addMonths(date, amount, options) {
  const _date = toDate(date);
  if (isNaN(amount)) return constructFrom(date, NaN);
  if (!amount) {
    // If 0 months, no-op to avoid changing times in the hour before end of DST
    return _date;
  }
  const dayOfMonth = _date.getDate();

  // The JS Date object supports date math by accepting out-of-bounds values for
  // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
  // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
  // want except that dates will wrap around the end of a month, meaning that
  // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
  // we'll default to the end of the desired month by adding 1 to the desired
  // month and using a date of 0 to back up one day to the end of the desired
  // month.
  const endOfDesiredMonth = constructFrom(date, _date.getTime());
  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
  const daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    // If we're already at the end of the month, then this is the correct date
    // and we're done.
    return endOfDesiredMonth;
  } else {
    // Otherwise, we now know that setting the original day-of-month value won't
    // cause an overflow, so set the desired day-of-month. Note that we can't
    // just set the date of `endOfDesiredMonth` because that object may have had
    // its time changed in the unusual case where where a DST transition was on
    // the last day of the month and its local time was in the hour skipped or
    // repeated next to a DST transition.  So we use `date` instead which is
    // guaranteed to still have the original time.
    _date.setFullYear(
      endOfDesiredMonth.getFullYear(),
      endOfDesiredMonth.getMonth(),
      dayOfMonth,
    );
    return _date;
  }
}

/**
 * The {@link addWeeks} function options.
 */

/**
 * @name addWeeks
 * @category Week Helpers
 * @summary Add the specified number of weeks to the given date.
 *
 * @description
 * Add the specified number of weeks to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of weeks to be added.
 * @param options - An object with options
 *
 * @returns The new date with the weeks added
 *
 * @example
 * // Add 4 weeks to 1 September 2014:
 * const result = addWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Sep 29 2014 00:00:00
 */
function addWeeks(date, amount, options) {
  return addDays(date, amount * 7);
}

const getGroupStatus = (group, myWithdrawals, customerPublicKey) => {
    let depositedCollaterals = 0;
    for (const member of Object.values(group.members || {})) {
        if (member.deposits?.[0]?.round === 0 &&
            member.deposits?.[0]?.amount === group.collateralAmount) {
            depositedCollaterals++;
        }
    }
    if (depositedCollaterals < group.totalMembers) {
        // pending, abandoned
        if (group.startsOnTimestamp >= Date.now()) {
            return GroupStatus.PENDING;
        }
        return GroupStatus.ABANDONED;
    }
    else if (depositedCollaterals === group.totalMembers) {
        // active, concluded
        const endDate = group.period === GroupPeriod.MONTHLY
            ? addMonths(new Date(group.startsOnTimestamp), group.totalMembers)
            : addWeeks(new Date(group.startsOnTimestamp), group.totalMembers);
        const allWithdrawals = myWithdrawals.round.successfullyWithdrawn
            && myWithdrawals.collateral.successfullyWithdrawn
            && myWithdrawals.interest.successfullyWithdrawn;
        if (group.startsOnTimestamp > Date.now() && !allWithdrawals) {
            return GroupStatus.PENDING;
        }
        if (endDate.getTime() > Date.now() && !allWithdrawals) {
            return GroupStatus.ACTIVE;
        }
        return GroupStatus.CONCLUDED;
    }
    return GroupStatus.ABANDONED;
};
const getGroupSlots = (group) => {
    let depositedCollaterals = 0;
    for (const member of Object.values(group.members || {})) {
        if (member.deposits?.[0]?.round === 0 &&
            member.deposits?.[0]?.amount === group.collateralAmount) {
            depositedCollaterals++;
        }
    }
    return group.totalMembers - depositedCollaterals;
};
const isSuccessTransaction = (deposit, amount) => {
    return (typeof amount === 'number' ? !!deposit?.amount && +deposit?.amount === +amount : true) && !!deposit?.timestamp && !!deposit?.transactionSignature;
};
const toGroupResponseDTO = (group, customerPublicKey) => {
    const me = group.members?.[customerPublicKey];
    const countSuccessDeposits = {};
    let countSuccessRounds = 0;
    for (const member of Object.values(group.members || {})) {
        for (const deposit of Object.values(member.deposits || {})) {
            if (isSuccessTransaction(deposit, +deposit.round === 0 ? group.amount * group.totalMembers : group.amount)) {
                countSuccessDeposits[deposit.round] = (countSuccessDeposits[deposit.round] ?? 0) + 1;
            }
        }
    }
    for (let i = 0; i <= group.totalMembers; i++) {
        countSuccessRounds += +(countSuccessDeposits[i] === group.totalMembers - (i === 0 ? 0 : 1));
    }
    const myDeposits = {};
    for (const deposit of Object.values(me?.deposits || {})) {
        myDeposits[deposit.round] = {
            round: deposit.round,
            successfullyDeposited: deposit.round === 0
                ? deposit.amount === group.collateralAmount
                : deposit.amount === group.amount,
            amount: deposit.amount,
            timestamp: deposit.timestamp,
        };
    }
    // TODO: valid with dates
    const myWithdrawals = {
        [GroupWithdrawalType.COLLATERAL]: {
            amount: me?.withdrawals?.collateral?.amount ?? 0,
            type: GroupWithdrawalType.COLLATERAL,
            timestamp: me?.withdrawals?.collateral?.timestamp ?? 0,
            successfullyWithdrawn: isSuccessTransaction(me?.withdrawals?.collateral, group.collateralAmount),
            enabled: countSuccessRounds === group.totalMembers + 1,
        },
        [GroupWithdrawalType.ROUND]: {
            amount: me?.withdrawals?.round?.amount ?? 0,
            type: GroupWithdrawalType.ROUND,
            timestamp: me?.withdrawals?.round?.timestamp ?? 0,
            successfullyWithdrawn: isSuccessTransaction(me?.withdrawals?.round, group.amount),
            enabled: // group.myPosition <= group.currentPosition &&
            countSuccessDeposits[me?.position || 0] === group.totalMembers - 1,
        },
        [GroupWithdrawalType.INTEREST]: {
            amount: me?.withdrawals?.interest?.amount ?? 0,
            type: GroupWithdrawalType.INTEREST,
            timestamp: me?.withdrawals?.interest?.timestamp ?? 0,
            successfullyWithdrawn: isSuccessTransaction(me?.withdrawals?.interest, undefined),
            enabled: countSuccessRounds === group.totalMembers + 1,
        },
    };
    myWithdrawals.collateral.enabled = myWithdrawals.collateral.enabled && !myWithdrawals.collateral.successfullyWithdrawn;
    myWithdrawals.round.enabled = myWithdrawals.round.enabled && !myWithdrawals.round.successfullyWithdrawn;
    myWithdrawals.interest.enabled = myWithdrawals.interest.enabled && !myWithdrawals.interest.successfullyWithdrawn;
    const response = {
        amount: group.amount,
        myDeposits,
        totalMembers: group.totalMembers,
        period: group.period,
        startsOnTimestamp: group.startsOnTimestamp,
        myPosition: me?.position || 0,
    };
    const { currentPosition } = getPaymentsTable(response);
    return {
        id: group._id.toString(),
        crypto: group.crypto,
        name: group.name,
        amount: group.amount,
        collateralAmount: group.collateralAmount,
        myDeposits,
        myWithdrawals,
        totalMembers: group.totalMembers,
        slots: getGroupSlots(group),
        joinedUsers: Object.values(group.members || {}).length,
        period: group.period,
        startsOnTimestamp: group.startsOnTimestamp,
        status: getGroupStatus(group, myWithdrawals),
        isOwner: !!group.members?.[customerPublicKey]?.isOwner,
        myPosition: me?.position || 0,
        currentPosition,
    };
};
const getPaymentsTable = (group) => {
    const items = [];
    let startDate = new Date(group.startsOnTimestamp || 0);
    let endDate = startDate;
    let firstUnpaidItemIndex = -1;
    let currentPosition = -1;
    for (let i = 0; i < (group.totalMembers || 0); i++) {
        if (group.period === GroupPeriod.MONTHLY) {
            endDate = addMonths(startDate, 1);
        }
        else {
            endDate = addWeeks(startDate, 1);
        }
        if (startDate.getTime() <= Date.now() && Date.now() < endDate.getTime()) {
            currentPosition = i + 1;
        }
        const round = i + 1;
        items.push({
            round,
            amount: group.amount || 0,
            paymentDeadlineTimestamp: endDate.getTime(),
            status: group.myDeposits[round]?.successfullyDeposited
                ? 'Paid'
                : firstUnpaidItemIndex === -1
                    ? 'Pay'
                    : 'Pending',
        });
        if (firstUnpaidItemIndex === -1 &&
            round !== group.myPosition &&
            !group.myDeposits[round]?.successfullyDeposited) {
            firstUnpaidItemIndex = i;
        }
        startDate = endDate;
    }
    return { items, firstUnpaidItemIndex, currentPosition };
};

const MONGO_DATABASE_URI = process__namespace.env.MONGO_DATABASE_URI || '';
const MONGO_DATABASE_NAME = process__namespace.env.MONGO_DATABASE_NAME || '';
const COMPANY_HOSTS = (process__namespace.env.COMPANY_HOSTS || '').split(',,').map(hosts => hosts.split(','));

var lodash$1 = {exports: {}};

/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash = lodash$1.exports;

var hasRequiredLodash;

function requireLodash () {
	if (hasRequiredLodash) return lodash$1.exports;
	hasRequiredLodash = 1;
	(function (module, exports) {
(function() {

		  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
		  var undefined$1;

		  /** Used as the semantic version number. */
		  var VERSION = '4.17.21';

		  /** Used as the size to enable large array optimizations. */
		  var LARGE_ARRAY_SIZE = 200;

		  /** Error message constants. */
		  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
		      FUNC_ERROR_TEXT = 'Expected a function',
		      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

		  /** Used to stand-in for `undefined` hash values. */
		  var HASH_UNDEFINED = '__lodash_hash_undefined__';

		  /** Used as the maximum memoize cache size. */
		  var MAX_MEMOIZE_SIZE = 500;

		  /** Used as the internal argument placeholder. */
		  var PLACEHOLDER = '__lodash_placeholder__';

		  /** Used to compose bitmasks for cloning. */
		  var CLONE_DEEP_FLAG = 1,
		      CLONE_FLAT_FLAG = 2,
		      CLONE_SYMBOLS_FLAG = 4;

		  /** Used to compose bitmasks for value comparisons. */
		  var COMPARE_PARTIAL_FLAG = 1,
		      COMPARE_UNORDERED_FLAG = 2;

		  /** Used to compose bitmasks for function metadata. */
		  var WRAP_BIND_FLAG = 1,
		      WRAP_BIND_KEY_FLAG = 2,
		      WRAP_CURRY_BOUND_FLAG = 4,
		      WRAP_CURRY_FLAG = 8,
		      WRAP_CURRY_RIGHT_FLAG = 16,
		      WRAP_PARTIAL_FLAG = 32,
		      WRAP_PARTIAL_RIGHT_FLAG = 64,
		      WRAP_ARY_FLAG = 128,
		      WRAP_REARG_FLAG = 256,
		      WRAP_FLIP_FLAG = 512;

		  /** Used as default options for `_.truncate`. */
		  var DEFAULT_TRUNC_LENGTH = 30,
		      DEFAULT_TRUNC_OMISSION = '...';

		  /** Used to detect hot functions by number of calls within a span of milliseconds. */
		  var HOT_COUNT = 800,
		      HOT_SPAN = 16;

		  /** Used to indicate the type of lazy iteratees. */
		  var LAZY_FILTER_FLAG = 1,
		      LAZY_MAP_FLAG = 2,
		      LAZY_WHILE_FLAG = 3;

		  /** Used as references for various `Number` constants. */
		  var INFINITY = 1 / 0,
		      MAX_SAFE_INTEGER = 9007199254740991,
		      MAX_INTEGER = 1.7976931348623157e+308,
		      NAN = 0 / 0;

		  /** Used as references for the maximum length and index of an array. */
		  var MAX_ARRAY_LENGTH = 4294967295,
		      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
		      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

		  /** Used to associate wrap methods with their bit flags. */
		  var wrapFlags = [
		    ['ary', WRAP_ARY_FLAG],
		    ['bind', WRAP_BIND_FLAG],
		    ['bindKey', WRAP_BIND_KEY_FLAG],
		    ['curry', WRAP_CURRY_FLAG],
		    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
		    ['flip', WRAP_FLIP_FLAG],
		    ['partial', WRAP_PARTIAL_FLAG],
		    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
		    ['rearg', WRAP_REARG_FLAG]
		  ];

		  /** `Object#toString` result references. */
		  var argsTag = '[object Arguments]',
		      arrayTag = '[object Array]',
		      asyncTag = '[object AsyncFunction]',
		      boolTag = '[object Boolean]',
		      dateTag = '[object Date]',
		      domExcTag = '[object DOMException]',
		      errorTag = '[object Error]',
		      funcTag = '[object Function]',
		      genTag = '[object GeneratorFunction]',
		      mapTag = '[object Map]',
		      numberTag = '[object Number]',
		      nullTag = '[object Null]',
		      objectTag = '[object Object]',
		      promiseTag = '[object Promise]',
		      proxyTag = '[object Proxy]',
		      regexpTag = '[object RegExp]',
		      setTag = '[object Set]',
		      stringTag = '[object String]',
		      symbolTag = '[object Symbol]',
		      undefinedTag = '[object Undefined]',
		      weakMapTag = '[object WeakMap]',
		      weakSetTag = '[object WeakSet]';

		  var arrayBufferTag = '[object ArrayBuffer]',
		      dataViewTag = '[object DataView]',
		      float32Tag = '[object Float32Array]',
		      float64Tag = '[object Float64Array]',
		      int8Tag = '[object Int8Array]',
		      int16Tag = '[object Int16Array]',
		      int32Tag = '[object Int32Array]',
		      uint8Tag = '[object Uint8Array]',
		      uint8ClampedTag = '[object Uint8ClampedArray]',
		      uint16Tag = '[object Uint16Array]',
		      uint32Tag = '[object Uint32Array]';

		  /** Used to match empty string literals in compiled template source. */
		  var reEmptyStringLeading = /\b__p \+= '';/g,
		      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
		      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

		  /** Used to match HTML entities and HTML characters. */
		  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
		      reUnescapedHtml = /[&<>"']/g,
		      reHasEscapedHtml = RegExp(reEscapedHtml.source),
		      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

		  /** Used to match template delimiters. */
		  var reEscape = /<%-([\s\S]+?)%>/g,
		      reEvaluate = /<%([\s\S]+?)%>/g,
		      reInterpolate = /<%=([\s\S]+?)%>/g;

		  /** Used to match property names within property paths. */
		  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
		      reIsPlainProp = /^\w*$/,
		      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

		  /**
		   * Used to match `RegExp`
		   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
		   */
		  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
		      reHasRegExpChar = RegExp(reRegExpChar.source);

		  /** Used to match leading whitespace. */
		  var reTrimStart = /^\s+/;

		  /** Used to match a single whitespace character. */
		  var reWhitespace = /\s/;

		  /** Used to match wrap detail comments. */
		  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
		      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
		      reSplitDetails = /,? & /;

		  /** Used to match words composed of alphanumeric characters. */
		  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

		  /**
		   * Used to validate the `validate` option in `_.template` variable.
		   *
		   * Forbids characters which could potentially change the meaning of the function argument definition:
		   * - "()," (modification of function parameters)
		   * - "=" (default value)
		   * - "[]{}" (destructuring of function parameters)
		   * - "/" (beginning of a comment)
		   * - whitespace
		   */
		  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

		  /** Used to match backslashes in property paths. */
		  var reEscapeChar = /\\(\\)?/g;

		  /**
		   * Used to match
		   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
		   */
		  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

		  /** Used to match `RegExp` flags from their coerced string values. */
		  var reFlags = /\w*$/;

		  /** Used to detect bad signed hexadecimal string values. */
		  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

		  /** Used to detect binary string values. */
		  var reIsBinary = /^0b[01]+$/i;

		  /** Used to detect host constructors (Safari). */
		  var reIsHostCtor = /^\[object .+?Constructor\]$/;

		  /** Used to detect octal string values. */
		  var reIsOctal = /^0o[0-7]+$/i;

		  /** Used to detect unsigned integer values. */
		  var reIsUint = /^(?:0|[1-9]\d*)$/;

		  /** Used to match Latin Unicode letters (excluding mathematical operators). */
		  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

		  /** Used to ensure capturing order of template delimiters. */
		  var reNoMatch = /($^)/;

		  /** Used to match unescaped characters in compiled string literals. */
		  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

		  /** Used to compose unicode character classes. */
		  var rsAstralRange = '\\ud800-\\udfff',
		      rsComboMarksRange = '\\u0300-\\u036f',
		      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
		      rsComboSymbolsRange = '\\u20d0-\\u20ff',
		      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
		      rsDingbatRange = '\\u2700-\\u27bf',
		      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
		      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
		      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
		      rsPunctuationRange = '\\u2000-\\u206f',
		      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
		      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
		      rsVarRange = '\\ufe0e\\ufe0f',
		      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

		  /** Used to compose unicode capture groups. */
		  var rsApos = "['\u2019]",
		      rsAstral = '[' + rsAstralRange + ']',
		      rsBreak = '[' + rsBreakRange + ']',
		      rsCombo = '[' + rsComboRange + ']',
		      rsDigits = '\\d+',
		      rsDingbat = '[' + rsDingbatRange + ']',
		      rsLower = '[' + rsLowerRange + ']',
		      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
		      rsFitz = '\\ud83c[\\udffb-\\udfff]',
		      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
		      rsNonAstral = '[^' + rsAstralRange + ']',
		      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
		      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
		      rsUpper = '[' + rsUpperRange + ']',
		      rsZWJ = '\\u200d';

		  /** Used to compose unicode regexes. */
		  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
		      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
		      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
		      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
		      reOptMod = rsModifier + '?',
		      rsOptVar = '[' + rsVarRange + ']?',
		      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
		      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
		      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
		      rsSeq = rsOptVar + reOptMod + rsOptJoin,
		      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
		      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

		  /** Used to match apostrophes. */
		  var reApos = RegExp(rsApos, 'g');

		  /**
		   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
		   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
		   */
		  var reComboMark = RegExp(rsCombo, 'g');

		  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
		  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

		  /** Used to match complex or compound words. */
		  var reUnicodeWord = RegExp([
		    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
		    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
		    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
		    rsUpper + '+' + rsOptContrUpper,
		    rsOrdUpper,
		    rsOrdLower,
		    rsDigits,
		    rsEmoji
		  ].join('|'), 'g');

		  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
		  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

		  /** Used to detect strings that need a more robust regexp to match words. */
		  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

		  /** Used to assign default `context` object properties. */
		  var contextProps = [
		    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
		    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
		    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
		    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
		    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
		  ];

		  /** Used to make template sourceURLs easier to identify. */
		  var templateCounter = -1;

		  /** Used to identify `toStringTag` values of typed arrays. */
		  var typedArrayTags = {};
		  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
		  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
		  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
		  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
		  typedArrayTags[uint32Tag] = true;
		  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
		  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
		  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
		  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
		  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
		  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
		  typedArrayTags[setTag] = typedArrayTags[stringTag] =
		  typedArrayTags[weakMapTag] = false;

		  /** Used to identify `toStringTag` values supported by `_.clone`. */
		  var cloneableTags = {};
		  cloneableTags[argsTag] = cloneableTags[arrayTag] =
		  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
		  cloneableTags[boolTag] = cloneableTags[dateTag] =
		  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
		  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
		  cloneableTags[int32Tag] = cloneableTags[mapTag] =
		  cloneableTags[numberTag] = cloneableTags[objectTag] =
		  cloneableTags[regexpTag] = cloneableTags[setTag] =
		  cloneableTags[stringTag] = cloneableTags[symbolTag] =
		  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
		  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
		  cloneableTags[errorTag] = cloneableTags[funcTag] =
		  cloneableTags[weakMapTag] = false;

		  /** Used to map Latin Unicode letters to basic Latin letters. */
		  var deburredLetters = {
		    // Latin-1 Supplement block.
		    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
		    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
		    '\xc7': 'C',  '\xe7': 'c',
		    '\xd0': 'D',  '\xf0': 'd',
		    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
		    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
		    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
		    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
		    '\xd1': 'N',  '\xf1': 'n',
		    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
		    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
		    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
		    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
		    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
		    '\xc6': 'Ae', '\xe6': 'ae',
		    '\xde': 'Th', '\xfe': 'th',
		    '\xdf': 'ss',
		    // Latin Extended-A block.
		    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
		    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
		    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
		    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
		    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
		    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
		    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
		    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
		    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
		    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
		    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
		    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
		    '\u0134': 'J',  '\u0135': 'j',
		    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
		    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
		    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
		    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
		    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
		    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
		    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
		    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
		    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
		    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
		    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
		    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
		    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
		    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
		    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
		    '\u0174': 'W',  '\u0175': 'w',
		    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
		    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
		    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
		    '\u0132': 'IJ', '\u0133': 'ij',
		    '\u0152': 'Oe', '\u0153': 'oe',
		    '\u0149': "'n", '\u017f': 's'
		  };

		  /** Used to map characters to HTML entities. */
		  var htmlEscapes = {
		    '&': '&amp;',
		    '<': '&lt;',
		    '>': '&gt;',
		    '"': '&quot;',
		    "'": '&#39;'
		  };

		  /** Used to map HTML entities to characters. */
		  var htmlUnescapes = {
		    '&amp;': '&',
		    '&lt;': '<',
		    '&gt;': '>',
		    '&quot;': '"',
		    '&#39;': "'"
		  };

		  /** Used to escape characters for inclusion in compiled string literals. */
		  var stringEscapes = {
		    '\\': '\\',
		    "'": "'",
		    '\n': 'n',
		    '\r': 'r',
		    '\u2028': 'u2028',
		    '\u2029': 'u2029'
		  };

		  /** Built-in method references without a dependency on `root`. */
		  var freeParseFloat = parseFloat,
		      freeParseInt = parseInt;

		  /** Detect free variable `global` from Node.js. */
		  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

		  /** Detect free variable `self`. */
		  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

		  /** Used as a reference to the global object. */
		  var root = freeGlobal || freeSelf || Function('return this')();

		  /** Detect free variable `exports`. */
		  var freeExports = exports && !exports.nodeType && exports;

		  /** Detect free variable `module`. */
		  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		  /** Detect the popular CommonJS extension `module.exports`. */
		  var moduleExports = freeModule && freeModule.exports === freeExports;

		  /** Detect free variable `process` from Node.js. */
		  var freeProcess = moduleExports && freeGlobal.process;

		  /** Used to access faster Node.js helpers. */
		  var nodeUtil = (function() {
		    try {
		      // Use `util.types` for Node.js 10+.
		      var types = freeModule && freeModule.require && freeModule.require('util').types;

		      if (types) {
		        return types;
		      }

		      // Legacy `process.binding('util')` for Node.js < 10.
		      return freeProcess && freeProcess.binding && freeProcess.binding('util');
		    } catch (e) {}
		  }());

		  /* Node.js helper references. */
		  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
		      nodeIsDate = nodeUtil && nodeUtil.isDate,
		      nodeIsMap = nodeUtil && nodeUtil.isMap,
		      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
		      nodeIsSet = nodeUtil && nodeUtil.isSet,
		      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

		  /*--------------------------------------------------------------------------*/

		  /**
		   * A faster alternative to `Function#apply`, this function invokes `func`
		   * with the `this` binding of `thisArg` and the arguments of `args`.
		   *
		   * @private
		   * @param {Function} func The function to invoke.
		   * @param {*} thisArg The `this` binding of `func`.
		   * @param {Array} args The arguments to invoke `func` with.
		   * @returns {*} Returns the result of `func`.
		   */
		  function apply(func, thisArg, args) {
		    switch (args.length) {
		      case 0: return func.call(thisArg);
		      case 1: return func.call(thisArg, args[0]);
		      case 2: return func.call(thisArg, args[0], args[1]);
		      case 3: return func.call(thisArg, args[0], args[1], args[2]);
		    }
		    return func.apply(thisArg, args);
		  }

		  /**
		   * A specialized version of `baseAggregator` for arrays.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} setter The function to set `accumulator` values.
		   * @param {Function} iteratee The iteratee to transform keys.
		   * @param {Object} accumulator The initial aggregated object.
		   * @returns {Function} Returns `accumulator`.
		   */
		  function arrayAggregator(array, setter, iteratee, accumulator) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      var value = array[index];
		      setter(accumulator, value, iteratee(value), array);
		    }
		    return accumulator;
		  }

		  /**
		   * A specialized version of `_.forEach` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns `array`.
		   */
		  function arrayEach(array, iteratee) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (iteratee(array[index], index, array) === false) {
		        break;
		      }
		    }
		    return array;
		  }

		  /**
		   * A specialized version of `_.forEachRight` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns `array`.
		   */
		  function arrayEachRight(array, iteratee) {
		    var length = array == null ? 0 : array.length;

		    while (length--) {
		      if (iteratee(array[length], length, array) === false) {
		        break;
		      }
		    }
		    return array;
		  }

		  /**
		   * A specialized version of `_.every` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} predicate The function invoked per iteration.
		   * @returns {boolean} Returns `true` if all elements pass the predicate check,
		   *  else `false`.
		   */
		  function arrayEvery(array, predicate) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (!predicate(array[index], index, array)) {
		        return false;
		      }
		    }
		    return true;
		  }

		  /**
		   * A specialized version of `_.filter` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} predicate The function invoked per iteration.
		   * @returns {Array} Returns the new filtered array.
		   */
		  function arrayFilter(array, predicate) {
		    var index = -1,
		        length = array == null ? 0 : array.length,
		        resIndex = 0,
		        result = [];

		    while (++index < length) {
		      var value = array[index];
		      if (predicate(value, index, array)) {
		        result[resIndex++] = value;
		      }
		    }
		    return result;
		  }

		  /**
		   * A specialized version of `_.includes` for arrays without support for
		   * specifying an index to search from.
		   *
		   * @private
		   * @param {Array} [array] The array to inspect.
		   * @param {*} target The value to search for.
		   * @returns {boolean} Returns `true` if `target` is found, else `false`.
		   */
		  function arrayIncludes(array, value) {
		    var length = array == null ? 0 : array.length;
		    return !!length && baseIndexOf(array, value, 0) > -1;
		  }

		  /**
		   * This function is like `arrayIncludes` except that it accepts a comparator.
		   *
		   * @private
		   * @param {Array} [array] The array to inspect.
		   * @param {*} target The value to search for.
		   * @param {Function} comparator The comparator invoked per element.
		   * @returns {boolean} Returns `true` if `target` is found, else `false`.
		   */
		  function arrayIncludesWith(array, value, comparator) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (comparator(value, array[index])) {
		        return true;
		      }
		    }
		    return false;
		  }

		  /**
		   * A specialized version of `_.map` for arrays without support for iteratee
		   * shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns the new mapped array.
		   */
		  function arrayMap(array, iteratee) {
		    var index = -1,
		        length = array == null ? 0 : array.length,
		        result = Array(length);

		    while (++index < length) {
		      result[index] = iteratee(array[index], index, array);
		    }
		    return result;
		  }

		  /**
		   * Appends the elements of `values` to `array`.
		   *
		   * @private
		   * @param {Array} array The array to modify.
		   * @param {Array} values The values to append.
		   * @returns {Array} Returns `array`.
		   */
		  function arrayPush(array, values) {
		    var index = -1,
		        length = values.length,
		        offset = array.length;

		    while (++index < length) {
		      array[offset + index] = values[index];
		    }
		    return array;
		  }

		  /**
		   * A specialized version of `_.reduce` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @param {*} [accumulator] The initial value.
		   * @param {boolean} [initAccum] Specify using the first element of `array` as
		   *  the initial value.
		   * @returns {*} Returns the accumulated value.
		   */
		  function arrayReduce(array, iteratee, accumulator, initAccum) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    if (initAccum && length) {
		      accumulator = array[++index];
		    }
		    while (++index < length) {
		      accumulator = iteratee(accumulator, array[index], index, array);
		    }
		    return accumulator;
		  }

		  /**
		   * A specialized version of `_.reduceRight` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @param {*} [accumulator] The initial value.
		   * @param {boolean} [initAccum] Specify using the last element of `array` as
		   *  the initial value.
		   * @returns {*} Returns the accumulated value.
		   */
		  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
		    var length = array == null ? 0 : array.length;
		    if (initAccum && length) {
		      accumulator = array[--length];
		    }
		    while (length--) {
		      accumulator = iteratee(accumulator, array[length], length, array);
		    }
		    return accumulator;
		  }

		  /**
		   * A specialized version of `_.some` for arrays without support for iteratee
		   * shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} predicate The function invoked per iteration.
		   * @returns {boolean} Returns `true` if any element passes the predicate check,
		   *  else `false`.
		   */
		  function arraySome(array, predicate) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (predicate(array[index], index, array)) {
		        return true;
		      }
		    }
		    return false;
		  }

		  /**
		   * Gets the size of an ASCII `string`.
		   *
		   * @private
		   * @param {string} string The string inspect.
		   * @returns {number} Returns the string size.
		   */
		  var asciiSize = baseProperty('length');

		  /**
		   * Converts an ASCII `string` to an array.
		   *
		   * @private
		   * @param {string} string The string to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function asciiToArray(string) {
		    return string.split('');
		  }

		  /**
		   * Splits an ASCII `string` into an array of its words.
		   *
		   * @private
		   * @param {string} The string to inspect.
		   * @returns {Array} Returns the words of `string`.
		   */
		  function asciiWords(string) {
		    return string.match(reAsciiWord) || [];
		  }

		  /**
		   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
		   * without support for iteratee shorthands, which iterates over `collection`
		   * using `eachFunc`.
		   *
		   * @private
		   * @param {Array|Object} collection The collection to inspect.
		   * @param {Function} predicate The function invoked per iteration.
		   * @param {Function} eachFunc The function to iterate over `collection`.
		   * @returns {*} Returns the found element or its key, else `undefined`.
		   */
		  function baseFindKey(collection, predicate, eachFunc) {
		    var result;
		    eachFunc(collection, function(value, key, collection) {
		      if (predicate(value, key, collection)) {
		        result = key;
		        return false;
		      }
		    });
		    return result;
		  }

		  /**
		   * The base implementation of `_.findIndex` and `_.findLastIndex` without
		   * support for iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {Function} predicate The function invoked per iteration.
		   * @param {number} fromIndex The index to search from.
		   * @param {boolean} [fromRight] Specify iterating from right to left.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function baseFindIndex(array, predicate, fromIndex, fromRight) {
		    var length = array.length,
		        index = fromIndex + (fromRight ? 1 : -1);

		    while ((fromRight ? index-- : ++index < length)) {
		      if (predicate(array[index], index, array)) {
		        return index;
		      }
		    }
		    return -1;
		  }

		  /**
		   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function baseIndexOf(array, value, fromIndex) {
		    return value === value
		      ? strictIndexOf(array, value, fromIndex)
		      : baseFindIndex(array, baseIsNaN, fromIndex);
		  }

		  /**
		   * This function is like `baseIndexOf` except that it accepts a comparator.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @param {Function} comparator The comparator invoked per element.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function baseIndexOfWith(array, value, fromIndex, comparator) {
		    var index = fromIndex - 1,
		        length = array.length;

		    while (++index < length) {
		      if (comparator(array[index], value)) {
		        return index;
		      }
		    }
		    return -1;
		  }

		  /**
		   * The base implementation of `_.isNaN` without support for number objects.
		   *
		   * @private
		   * @param {*} value The value to check.
		   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
		   */
		  function baseIsNaN(value) {
		    return value !== value;
		  }

		  /**
		   * The base implementation of `_.mean` and `_.meanBy` without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {number} Returns the mean.
		   */
		  function baseMean(array, iteratee) {
		    var length = array == null ? 0 : array.length;
		    return length ? (baseSum(array, iteratee) / length) : NAN;
		  }

		  /**
		   * The base implementation of `_.property` without support for deep paths.
		   *
		   * @private
		   * @param {string} key The key of the property to get.
		   * @returns {Function} Returns the new accessor function.
		   */
		  function baseProperty(key) {
		    return function(object) {
		      return object == null ? undefined$1 : object[key];
		    };
		  }

		  /**
		   * The base implementation of `_.propertyOf` without support for deep paths.
		   *
		   * @private
		   * @param {Object} object The object to query.
		   * @returns {Function} Returns the new accessor function.
		   */
		  function basePropertyOf(object) {
		    return function(key) {
		      return object == null ? undefined$1 : object[key];
		    };
		  }

		  /**
		   * The base implementation of `_.reduce` and `_.reduceRight`, without support
		   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
		   *
		   * @private
		   * @param {Array|Object} collection The collection to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @param {*} accumulator The initial value.
		   * @param {boolean} initAccum Specify using the first or last element of
		   *  `collection` as the initial value.
		   * @param {Function} eachFunc The function to iterate over `collection`.
		   * @returns {*} Returns the accumulated value.
		   */
		  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
		    eachFunc(collection, function(value, index, collection) {
		      accumulator = initAccum
		        ? (initAccum = false, value)
		        : iteratee(accumulator, value, index, collection);
		    });
		    return accumulator;
		  }

		  /**
		   * The base implementation of `_.sortBy` which uses `comparer` to define the
		   * sort order of `array` and replaces criteria objects with their corresponding
		   * values.
		   *
		   * @private
		   * @param {Array} array The array to sort.
		   * @param {Function} comparer The function to define sort order.
		   * @returns {Array} Returns `array`.
		   */
		  function baseSortBy(array, comparer) {
		    var length = array.length;

		    array.sort(comparer);
		    while (length--) {
		      array[length] = array[length].value;
		    }
		    return array;
		  }

		  /**
		   * The base implementation of `_.sum` and `_.sumBy` without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {number} Returns the sum.
		   */
		  function baseSum(array, iteratee) {
		    var result,
		        index = -1,
		        length = array.length;

		    while (++index < length) {
		      var current = iteratee(array[index]);
		      if (current !== undefined$1) {
		        result = result === undefined$1 ? current : (result + current);
		      }
		    }
		    return result;
		  }

		  /**
		   * The base implementation of `_.times` without support for iteratee shorthands
		   * or max array length checks.
		   *
		   * @private
		   * @param {number} n The number of times to invoke `iteratee`.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns the array of results.
		   */
		  function baseTimes(n, iteratee) {
		    var index = -1,
		        result = Array(n);

		    while (++index < n) {
		      result[index] = iteratee(index);
		    }
		    return result;
		  }

		  /**
		   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
		   * of key-value pairs for `object` corresponding to the property names of `props`.
		   *
		   * @private
		   * @param {Object} object The object to query.
		   * @param {Array} props The property names to get values for.
		   * @returns {Object} Returns the key-value pairs.
		   */
		  function baseToPairs(object, props) {
		    return arrayMap(props, function(key) {
		      return [key, object[key]];
		    });
		  }

		  /**
		   * The base implementation of `_.trim`.
		   *
		   * @private
		   * @param {string} string The string to trim.
		   * @returns {string} Returns the trimmed string.
		   */
		  function baseTrim(string) {
		    return string
		      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
		      : string;
		  }

		  /**
		   * The base implementation of `_.unary` without support for storing metadata.
		   *
		   * @private
		   * @param {Function} func The function to cap arguments for.
		   * @returns {Function} Returns the new capped function.
		   */
		  function baseUnary(func) {
		    return function(value) {
		      return func(value);
		    };
		  }

		  /**
		   * The base implementation of `_.values` and `_.valuesIn` which creates an
		   * array of `object` property values corresponding to the property names
		   * of `props`.
		   *
		   * @private
		   * @param {Object} object The object to query.
		   * @param {Array} props The property names to get values for.
		   * @returns {Object} Returns the array of property values.
		   */
		  function baseValues(object, props) {
		    return arrayMap(props, function(key) {
		      return object[key];
		    });
		  }

		  /**
		   * Checks if a `cache` value for `key` exists.
		   *
		   * @private
		   * @param {Object} cache The cache to query.
		   * @param {string} key The key of the entry to check.
		   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		   */
		  function cacheHas(cache, key) {
		    return cache.has(key);
		  }

		  /**
		   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
		   * that is not found in the character symbols.
		   *
		   * @private
		   * @param {Array} strSymbols The string symbols to inspect.
		   * @param {Array} chrSymbols The character symbols to find.
		   * @returns {number} Returns the index of the first unmatched string symbol.
		   */
		  function charsStartIndex(strSymbols, chrSymbols) {
		    var index = -1,
		        length = strSymbols.length;

		    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
		    return index;
		  }

		  /**
		   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
		   * that is not found in the character symbols.
		   *
		   * @private
		   * @param {Array} strSymbols The string symbols to inspect.
		   * @param {Array} chrSymbols The character symbols to find.
		   * @returns {number} Returns the index of the last unmatched string symbol.
		   */
		  function charsEndIndex(strSymbols, chrSymbols) {
		    var index = strSymbols.length;

		    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
		    return index;
		  }

		  /**
		   * Gets the number of `placeholder` occurrences in `array`.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} placeholder The placeholder to search for.
		   * @returns {number} Returns the placeholder count.
		   */
		  function countHolders(array, placeholder) {
		    var length = array.length,
		        result = 0;

		    while (length--) {
		      if (array[length] === placeholder) {
		        ++result;
		      }
		    }
		    return result;
		  }

		  /**
		   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
		   * letters to basic Latin letters.
		   *
		   * @private
		   * @param {string} letter The matched letter to deburr.
		   * @returns {string} Returns the deburred letter.
		   */
		  var deburrLetter = basePropertyOf(deburredLetters);

		  /**
		   * Used by `_.escape` to convert characters to HTML entities.
		   *
		   * @private
		   * @param {string} chr The matched character to escape.
		   * @returns {string} Returns the escaped character.
		   */
		  var escapeHtmlChar = basePropertyOf(htmlEscapes);

		  /**
		   * Used by `_.template` to escape characters for inclusion in compiled string literals.
		   *
		   * @private
		   * @param {string} chr The matched character to escape.
		   * @returns {string} Returns the escaped character.
		   */
		  function escapeStringChar(chr) {
		    return '\\' + stringEscapes[chr];
		  }

		  /**
		   * Gets the value at `key` of `object`.
		   *
		   * @private
		   * @param {Object} [object] The object to query.
		   * @param {string} key The key of the property to get.
		   * @returns {*} Returns the property value.
		   */
		  function getValue(object, key) {
		    return object == null ? undefined$1 : object[key];
		  }

		  /**
		   * Checks if `string` contains Unicode symbols.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
		   */
		  function hasUnicode(string) {
		    return reHasUnicode.test(string);
		  }

		  /**
		   * Checks if `string` contains a word composed of Unicode symbols.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {boolean} Returns `true` if a word is found, else `false`.
		   */
		  function hasUnicodeWord(string) {
		    return reHasUnicodeWord.test(string);
		  }

		  /**
		   * Converts `iterator` to an array.
		   *
		   * @private
		   * @param {Object} iterator The iterator to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function iteratorToArray(iterator) {
		    var data,
		        result = [];

		    while (!(data = iterator.next()).done) {
		      result.push(data.value);
		    }
		    return result;
		  }

		  /**
		   * Converts `map` to its key-value pairs.
		   *
		   * @private
		   * @param {Object} map The map to convert.
		   * @returns {Array} Returns the key-value pairs.
		   */
		  function mapToArray(map) {
		    var index = -1,
		        result = Array(map.size);

		    map.forEach(function(value, key) {
		      result[++index] = [key, value];
		    });
		    return result;
		  }

		  /**
		   * Creates a unary function that invokes `func` with its argument transformed.
		   *
		   * @private
		   * @param {Function} func The function to wrap.
		   * @param {Function} transform The argument transform.
		   * @returns {Function} Returns the new function.
		   */
		  function overArg(func, transform) {
		    return function(arg) {
		      return func(transform(arg));
		    };
		  }

		  /**
		   * Replaces all `placeholder` elements in `array` with an internal placeholder
		   * and returns an array of their indexes.
		   *
		   * @private
		   * @param {Array} array The array to modify.
		   * @param {*} placeholder The placeholder to replace.
		   * @returns {Array} Returns the new array of placeholder indexes.
		   */
		  function replaceHolders(array, placeholder) {
		    var index = -1,
		        length = array.length,
		        resIndex = 0,
		        result = [];

		    while (++index < length) {
		      var value = array[index];
		      if (value === placeholder || value === PLACEHOLDER) {
		        array[index] = PLACEHOLDER;
		        result[resIndex++] = index;
		      }
		    }
		    return result;
		  }

		  /**
		   * Converts `set` to an array of its values.
		   *
		   * @private
		   * @param {Object} set The set to convert.
		   * @returns {Array} Returns the values.
		   */
		  function setToArray(set) {
		    var index = -1,
		        result = Array(set.size);

		    set.forEach(function(value) {
		      result[++index] = value;
		    });
		    return result;
		  }

		  /**
		   * Converts `set` to its value-value pairs.
		   *
		   * @private
		   * @param {Object} set The set to convert.
		   * @returns {Array} Returns the value-value pairs.
		   */
		  function setToPairs(set) {
		    var index = -1,
		        result = Array(set.size);

		    set.forEach(function(value) {
		      result[++index] = [value, value];
		    });
		    return result;
		  }

		  /**
		   * A specialized version of `_.indexOf` which performs strict equality
		   * comparisons of values, i.e. `===`.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function strictIndexOf(array, value, fromIndex) {
		    var index = fromIndex - 1,
		        length = array.length;

		    while (++index < length) {
		      if (array[index] === value) {
		        return index;
		      }
		    }
		    return -1;
		  }

		  /**
		   * A specialized version of `_.lastIndexOf` which performs strict equality
		   * comparisons of values, i.e. `===`.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function strictLastIndexOf(array, value, fromIndex) {
		    var index = fromIndex + 1;
		    while (index--) {
		      if (array[index] === value) {
		        return index;
		      }
		    }
		    return index;
		  }

		  /**
		   * Gets the number of symbols in `string`.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {number} Returns the string size.
		   */
		  function stringSize(string) {
		    return hasUnicode(string)
		      ? unicodeSize(string)
		      : asciiSize(string);
		  }

		  /**
		   * Converts `string` to an array.
		   *
		   * @private
		   * @param {string} string The string to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function stringToArray(string) {
		    return hasUnicode(string)
		      ? unicodeToArray(string)
		      : asciiToArray(string);
		  }

		  /**
		   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
		   * character of `string`.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {number} Returns the index of the last non-whitespace character.
		   */
		  function trimmedEndIndex(string) {
		    var index = string.length;

		    while (index-- && reWhitespace.test(string.charAt(index))) {}
		    return index;
		  }

		  /**
		   * Used by `_.unescape` to convert HTML entities to characters.
		   *
		   * @private
		   * @param {string} chr The matched character to unescape.
		   * @returns {string} Returns the unescaped character.
		   */
		  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

		  /**
		   * Gets the size of a Unicode `string`.
		   *
		   * @private
		   * @param {string} string The string inspect.
		   * @returns {number} Returns the string size.
		   */
		  function unicodeSize(string) {
		    var result = reUnicode.lastIndex = 0;
		    while (reUnicode.test(string)) {
		      ++result;
		    }
		    return result;
		  }

		  /**
		   * Converts a Unicode `string` to an array.
		   *
		   * @private
		   * @param {string} string The string to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function unicodeToArray(string) {
		    return string.match(reUnicode) || [];
		  }

		  /**
		   * Splits a Unicode `string` into an array of its words.
		   *
		   * @private
		   * @param {string} The string to inspect.
		   * @returns {Array} Returns the words of `string`.
		   */
		  function unicodeWords(string) {
		    return string.match(reUnicodeWord) || [];
		  }

		  /*--------------------------------------------------------------------------*/

		  /**
		   * Create a new pristine `lodash` function using the `context` object.
		   *
		   * @static
		   * @memberOf _
		   * @since 1.1.0
		   * @category Util
		   * @param {Object} [context=root] The context object.
		   * @returns {Function} Returns a new `lodash` function.
		   * @example
		   *
		   * _.mixin({ 'foo': _.constant('foo') });
		   *
		   * var lodash = _.runInContext();
		   * lodash.mixin({ 'bar': lodash.constant('bar') });
		   *
		   * _.isFunction(_.foo);
		   * // => true
		   * _.isFunction(_.bar);
		   * // => false
		   *
		   * lodash.isFunction(lodash.foo);
		   * // => false
		   * lodash.isFunction(lodash.bar);
		   * // => true
		   *
		   * // Create a suped-up `defer` in Node.js.
		   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
		   */
		  var runInContext = (function runInContext(context) {
		    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

		    /** Built-in constructor references. */
		    var Array = context.Array,
		        Date = context.Date,
		        Error = context.Error,
		        Function = context.Function,
		        Math = context.Math,
		        Object = context.Object,
		        RegExp = context.RegExp,
		        String = context.String,
		        TypeError = context.TypeError;

		    /** Used for built-in method references. */
		    var arrayProto = Array.prototype,
		        funcProto = Function.prototype,
		        objectProto = Object.prototype;

		    /** Used to detect overreaching core-js shims. */
		    var coreJsData = context['__core-js_shared__'];

		    /** Used to resolve the decompiled source of functions. */
		    var funcToString = funcProto.toString;

		    /** Used to check objects for own properties. */
		    var hasOwnProperty = objectProto.hasOwnProperty;

		    /** Used to generate unique IDs. */
		    var idCounter = 0;

		    /** Used to detect methods masquerading as native. */
		    var maskSrcKey = (function() {
		      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
		      return uid ? ('Symbol(src)_1.' + uid) : '';
		    }());

		    /**
		     * Used to resolve the
		     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
		     * of values.
		     */
		    var nativeObjectToString = objectProto.toString;

		    /** Used to infer the `Object` constructor. */
		    var objectCtorString = funcToString.call(Object);

		    /** Used to restore the original `_` reference in `_.noConflict`. */
		    var oldDash = root._;

		    /** Used to detect if a method is native. */
		    var reIsNative = RegExp('^' +
		      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
		      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
		    );

		    /** Built-in value references. */
		    var Buffer = moduleExports ? context.Buffer : undefined$1,
		        Symbol = context.Symbol,
		        Uint8Array = context.Uint8Array,
		        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
		        getPrototype = overArg(Object.getPrototypeOf, Object),
		        objectCreate = Object.create,
		        propertyIsEnumerable = objectProto.propertyIsEnumerable,
		        splice = arrayProto.splice,
		        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1,
		        symIterator = Symbol ? Symbol.iterator : undefined$1,
		        symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;

		    var defineProperty = (function() {
		      try {
		        var func = getNative(Object, 'defineProperty');
		        func({}, '', {});
		        return func;
		      } catch (e) {}
		    }());

		    /** Mocked built-ins. */
		    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
		        ctxNow = Date && Date.now !== root.Date.now && Date.now,
		        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

		    /* Built-in method references for those with the same name as other `lodash` methods. */
		    var nativeCeil = Math.ceil,
		        nativeFloor = Math.floor,
		        nativeGetSymbols = Object.getOwnPropertySymbols,
		        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
		        nativeIsFinite = context.isFinite,
		        nativeJoin = arrayProto.join,
		        nativeKeys = overArg(Object.keys, Object),
		        nativeMax = Math.max,
		        nativeMin = Math.min,
		        nativeNow = Date.now,
		        nativeParseInt = context.parseInt,
		        nativeRandom = Math.random,
		        nativeReverse = arrayProto.reverse;

		    /* Built-in method references that are verified to be native. */
		    var DataView = getNative(context, 'DataView'),
		        Map = getNative(context, 'Map'),
		        Promise = getNative(context, 'Promise'),
		        Set = getNative(context, 'Set'),
		        WeakMap = getNative(context, 'WeakMap'),
		        nativeCreate = getNative(Object, 'create');

		    /** Used to store function metadata. */
		    var metaMap = WeakMap && new WeakMap;

		    /** Used to lookup unminified function names. */
		    var realNames = {};

		    /** Used to detect maps, sets, and weakmaps. */
		    var dataViewCtorString = toSource(DataView),
		        mapCtorString = toSource(Map),
		        promiseCtorString = toSource(Promise),
		        setCtorString = toSource(Set),
		        weakMapCtorString = toSource(WeakMap);

		    /** Used to convert symbols to primitives and strings. */
		    var symbolProto = Symbol ? Symbol.prototype : undefined$1,
		        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
		        symbolToString = symbolProto ? symbolProto.toString : undefined$1;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a `lodash` object which wraps `value` to enable implicit method
		     * chain sequences. Methods that operate on and return arrays, collections,
		     * and functions can be chained together. Methods that retrieve a single value
		     * or may return a primitive value will automatically end the chain sequence
		     * and return the unwrapped value. Otherwise, the value must be unwrapped
		     * with `_#value`.
		     *
		     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
		     * enabled using `_.chain`.
		     *
		     * The execution of chained methods is lazy, that is, it's deferred until
		     * `_#value` is implicitly or explicitly called.
		     *
		     * Lazy evaluation allows several methods to support shortcut fusion.
		     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
		     * the creation of intermediate arrays and can greatly reduce the number of
		     * iteratee executions. Sections of a chain sequence qualify for shortcut
		     * fusion if the section is applied to an array and iteratees accept only
		     * one argument. The heuristic for whether a section qualifies for shortcut
		     * fusion is subject to change.
		     *
		     * Chaining is supported in custom builds as long as the `_#value` method is
		     * directly or indirectly included in the build.
		     *
		     * In addition to lodash methods, wrappers have `Array` and `String` methods.
		     *
		     * The wrapper `Array` methods are:
		     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
		     *
		     * The wrapper `String` methods are:
		     * `replace` and `split`
		     *
		     * The wrapper methods that support shortcut fusion are:
		     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
		     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
		     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
		     *
		     * The chainable wrapper methods are:
		     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
		     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
		     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
		     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
		     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
		     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
		     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
		     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
		     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
		     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
		     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
		     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
		     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
		     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
		     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
		     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
		     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
		     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
		     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
		     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
		     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
		     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
		     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
		     * `zipObject`, `zipObjectDeep`, and `zipWith`
		     *
		     * The wrapper methods that are **not** chainable by default are:
		     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
		     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
		     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
		     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
		     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
		     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
		     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
		     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
		     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
		     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
		     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
		     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
		     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
		     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
		     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
		     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
		     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
		     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
		     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
		     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
		     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
		     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
		     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
		     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
		     * `upperFirst`, `value`, and `words`
		     *
		     * @name _
		     * @constructor
		     * @category Seq
		     * @param {*} value The value to wrap in a `lodash` instance.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var wrapped = _([1, 2, 3]);
		     *
		     * // Returns an unwrapped value.
		     * wrapped.reduce(_.add);
		     * // => 6
		     *
		     * // Returns a wrapped value.
		     * var squares = wrapped.map(square);
		     *
		     * _.isArray(squares);
		     * // => false
		     *
		     * _.isArray(squares.value());
		     * // => true
		     */
		    function lodash(value) {
		      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
		        if (value instanceof LodashWrapper) {
		          return value;
		        }
		        if (hasOwnProperty.call(value, '__wrapped__')) {
		          return wrapperClone(value);
		        }
		      }
		      return new LodashWrapper(value);
		    }

		    /**
		     * The base implementation of `_.create` without support for assigning
		     * properties to the created object.
		     *
		     * @private
		     * @param {Object} proto The object to inherit from.
		     * @returns {Object} Returns the new object.
		     */
		    var baseCreate = (function() {
		      function object() {}
		      return function(proto) {
		        if (!isObject(proto)) {
		          return {};
		        }
		        if (objectCreate) {
		          return objectCreate(proto);
		        }
		        object.prototype = proto;
		        var result = new object;
		        object.prototype = undefined$1;
		        return result;
		      };
		    }());

		    /**
		     * The function whose prototype chain sequence wrappers inherit from.
		     *
		     * @private
		     */
		    function baseLodash() {
		      // No operation performed.
		    }

		    /**
		     * The base constructor for creating `lodash` wrapper objects.
		     *
		     * @private
		     * @param {*} value The value to wrap.
		     * @param {boolean} [chainAll] Enable explicit method chain sequences.
		     */
		    function LodashWrapper(value, chainAll) {
		      this.__wrapped__ = value;
		      this.__actions__ = [];
		      this.__chain__ = !!chainAll;
		      this.__index__ = 0;
		      this.__values__ = undefined$1;
		    }

		    /**
		     * By default, the template delimiters used by lodash are like those in
		     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
		     * following template settings to use alternative delimiters.
		     *
		     * @static
		     * @memberOf _
		     * @type {Object}
		     */
		    lodash.templateSettings = {

		      /**
		       * Used to detect `data` property values to be HTML-escaped.
		       *
		       * @memberOf _.templateSettings
		       * @type {RegExp}
		       */
		      'escape': reEscape,

		      /**
		       * Used to detect code to be evaluated.
		       *
		       * @memberOf _.templateSettings
		       * @type {RegExp}
		       */
		      'evaluate': reEvaluate,

		      /**
		       * Used to detect `data` property values to inject.
		       *
		       * @memberOf _.templateSettings
		       * @type {RegExp}
		       */
		      'interpolate': reInterpolate,

		      /**
		       * Used to reference the data object in the template text.
		       *
		       * @memberOf _.templateSettings
		       * @type {string}
		       */
		      'variable': '',

		      /**
		       * Used to import variables into the compiled template.
		       *
		       * @memberOf _.templateSettings
		       * @type {Object}
		       */
		      'imports': {

		        /**
		         * A reference to the `lodash` function.
		         *
		         * @memberOf _.templateSettings.imports
		         * @type {Function}
		         */
		        '_': lodash
		      }
		    };

		    // Ensure wrappers are instances of `baseLodash`.
		    lodash.prototype = baseLodash.prototype;
		    lodash.prototype.constructor = lodash;

		    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
		    LodashWrapper.prototype.constructor = LodashWrapper;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
		     *
		     * @private
		     * @constructor
		     * @param {*} value The value to wrap.
		     */
		    function LazyWrapper(value) {
		      this.__wrapped__ = value;
		      this.__actions__ = [];
		      this.__dir__ = 1;
		      this.__filtered__ = false;
		      this.__iteratees__ = [];
		      this.__takeCount__ = MAX_ARRAY_LENGTH;
		      this.__views__ = [];
		    }

		    /**
		     * Creates a clone of the lazy wrapper object.
		     *
		     * @private
		     * @name clone
		     * @memberOf LazyWrapper
		     * @returns {Object} Returns the cloned `LazyWrapper` object.
		     */
		    function lazyClone() {
		      var result = new LazyWrapper(this.__wrapped__);
		      result.__actions__ = copyArray(this.__actions__);
		      result.__dir__ = this.__dir__;
		      result.__filtered__ = this.__filtered__;
		      result.__iteratees__ = copyArray(this.__iteratees__);
		      result.__takeCount__ = this.__takeCount__;
		      result.__views__ = copyArray(this.__views__);
		      return result;
		    }

		    /**
		     * Reverses the direction of lazy iteration.
		     *
		     * @private
		     * @name reverse
		     * @memberOf LazyWrapper
		     * @returns {Object} Returns the new reversed `LazyWrapper` object.
		     */
		    function lazyReverse() {
		      if (this.__filtered__) {
		        var result = new LazyWrapper(this);
		        result.__dir__ = -1;
		        result.__filtered__ = true;
		      } else {
		        result = this.clone();
		        result.__dir__ *= -1;
		      }
		      return result;
		    }

		    /**
		     * Extracts the unwrapped value from its lazy wrapper.
		     *
		     * @private
		     * @name value
		     * @memberOf LazyWrapper
		     * @returns {*} Returns the unwrapped value.
		     */
		    function lazyValue() {
		      var array = this.__wrapped__.value(),
		          dir = this.__dir__,
		          isArr = isArray(array),
		          isRight = dir < 0,
		          arrLength = isArr ? array.length : 0,
		          view = getView(0, arrLength, this.__views__),
		          start = view.start,
		          end = view.end,
		          length = end - start,
		          index = isRight ? end : (start - 1),
		          iteratees = this.__iteratees__,
		          iterLength = iteratees.length,
		          resIndex = 0,
		          takeCount = nativeMin(length, this.__takeCount__);

		      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
		        return baseWrapperValue(array, this.__actions__);
		      }
		      var result = [];

		      outer:
		      while (length-- && resIndex < takeCount) {
		        index += dir;

		        var iterIndex = -1,
		            value = array[index];

		        while (++iterIndex < iterLength) {
		          var data = iteratees[iterIndex],
		              iteratee = data.iteratee,
		              type = data.type,
		              computed = iteratee(value);

		          if (type == LAZY_MAP_FLAG) {
		            value = computed;
		          } else if (!computed) {
		            if (type == LAZY_FILTER_FLAG) {
		              continue outer;
		            } else {
		              break outer;
		            }
		          }
		        }
		        result[resIndex++] = value;
		      }
		      return result;
		    }

		    // Ensure `LazyWrapper` is an instance of `baseLodash`.
		    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
		    LazyWrapper.prototype.constructor = LazyWrapper;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a hash object.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function Hash(entries) {
		      var index = -1,
		          length = entries == null ? 0 : entries.length;

		      this.clear();
		      while (++index < length) {
		        var entry = entries[index];
		        this.set(entry[0], entry[1]);
		      }
		    }

		    /**
		     * Removes all key-value entries from the hash.
		     *
		     * @private
		     * @name clear
		     * @memberOf Hash
		     */
		    function hashClear() {
		      this.__data__ = nativeCreate ? nativeCreate(null) : {};
		      this.size = 0;
		    }

		    /**
		     * Removes `key` and its value from the hash.
		     *
		     * @private
		     * @name delete
		     * @memberOf Hash
		     * @param {Object} hash The hash to modify.
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function hashDelete(key) {
		      var result = this.has(key) && delete this.__data__[key];
		      this.size -= result ? 1 : 0;
		      return result;
		    }

		    /**
		     * Gets the hash value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf Hash
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function hashGet(key) {
		      var data = this.__data__;
		      if (nativeCreate) {
		        var result = data[key];
		        return result === HASH_UNDEFINED ? undefined$1 : result;
		      }
		      return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
		    }

		    /**
		     * Checks if a hash value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf Hash
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function hashHas(key) {
		      var data = this.__data__;
		      return nativeCreate ? (data[key] !== undefined$1) : hasOwnProperty.call(data, key);
		    }

		    /**
		     * Sets the hash `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf Hash
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the hash instance.
		     */
		    function hashSet(key, value) {
		      var data = this.__data__;
		      this.size += this.has(key) ? 0 : 1;
		      data[key] = (nativeCreate && value === undefined$1) ? HASH_UNDEFINED : value;
		      return this;
		    }

		    // Add methods to `Hash`.
		    Hash.prototype.clear = hashClear;
		    Hash.prototype['delete'] = hashDelete;
		    Hash.prototype.get = hashGet;
		    Hash.prototype.has = hashHas;
		    Hash.prototype.set = hashSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an list cache object.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function ListCache(entries) {
		      var index = -1,
		          length = entries == null ? 0 : entries.length;

		      this.clear();
		      while (++index < length) {
		        var entry = entries[index];
		        this.set(entry[0], entry[1]);
		      }
		    }

		    /**
		     * Removes all key-value entries from the list cache.
		     *
		     * @private
		     * @name clear
		     * @memberOf ListCache
		     */
		    function listCacheClear() {
		      this.__data__ = [];
		      this.size = 0;
		    }

		    /**
		     * Removes `key` and its value from the list cache.
		     *
		     * @private
		     * @name delete
		     * @memberOf ListCache
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function listCacheDelete(key) {
		      var data = this.__data__,
		          index = assocIndexOf(data, key);

		      if (index < 0) {
		        return false;
		      }
		      var lastIndex = data.length - 1;
		      if (index == lastIndex) {
		        data.pop();
		      } else {
		        splice.call(data, index, 1);
		      }
		      --this.size;
		      return true;
		    }

		    /**
		     * Gets the list cache value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf ListCache
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function listCacheGet(key) {
		      var data = this.__data__,
		          index = assocIndexOf(data, key);

		      return index < 0 ? undefined$1 : data[index][1];
		    }

		    /**
		     * Checks if a list cache value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf ListCache
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function listCacheHas(key) {
		      return assocIndexOf(this.__data__, key) > -1;
		    }

		    /**
		     * Sets the list cache `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf ListCache
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the list cache instance.
		     */
		    function listCacheSet(key, value) {
		      var data = this.__data__,
		          index = assocIndexOf(data, key);

		      if (index < 0) {
		        ++this.size;
		        data.push([key, value]);
		      } else {
		        data[index][1] = value;
		      }
		      return this;
		    }

		    // Add methods to `ListCache`.
		    ListCache.prototype.clear = listCacheClear;
		    ListCache.prototype['delete'] = listCacheDelete;
		    ListCache.prototype.get = listCacheGet;
		    ListCache.prototype.has = listCacheHas;
		    ListCache.prototype.set = listCacheSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a map cache object to store key-value pairs.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function MapCache(entries) {
		      var index = -1,
		          length = entries == null ? 0 : entries.length;

		      this.clear();
		      while (++index < length) {
		        var entry = entries[index];
		        this.set(entry[0], entry[1]);
		      }
		    }

		    /**
		     * Removes all key-value entries from the map.
		     *
		     * @private
		     * @name clear
		     * @memberOf MapCache
		     */
		    function mapCacheClear() {
		      this.size = 0;
		      this.__data__ = {
		        'hash': new Hash,
		        'map': new (Map || ListCache),
		        'string': new Hash
		      };
		    }

		    /**
		     * Removes `key` and its value from the map.
		     *
		     * @private
		     * @name delete
		     * @memberOf MapCache
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function mapCacheDelete(key) {
		      var result = getMapData(this, key)['delete'](key);
		      this.size -= result ? 1 : 0;
		      return result;
		    }

		    /**
		     * Gets the map value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf MapCache
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function mapCacheGet(key) {
		      return getMapData(this, key).get(key);
		    }

		    /**
		     * Checks if a map value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf MapCache
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function mapCacheHas(key) {
		      return getMapData(this, key).has(key);
		    }

		    /**
		     * Sets the map `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf MapCache
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the map cache instance.
		     */
		    function mapCacheSet(key, value) {
		      var data = getMapData(this, key),
		          size = data.size;

		      data.set(key, value);
		      this.size += data.size == size ? 0 : 1;
		      return this;
		    }

		    // Add methods to `MapCache`.
		    MapCache.prototype.clear = mapCacheClear;
		    MapCache.prototype['delete'] = mapCacheDelete;
		    MapCache.prototype.get = mapCacheGet;
		    MapCache.prototype.has = mapCacheHas;
		    MapCache.prototype.set = mapCacheSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     *
		     * Creates an array cache object to store unique values.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [values] The values to cache.
		     */
		    function SetCache(values) {
		      var index = -1,
		          length = values == null ? 0 : values.length;

		      this.__data__ = new MapCache;
		      while (++index < length) {
		        this.add(values[index]);
		      }
		    }

		    /**
		     * Adds `value` to the array cache.
		     *
		     * @private
		     * @name add
		     * @memberOf SetCache
		     * @alias push
		     * @param {*} value The value to cache.
		     * @returns {Object} Returns the cache instance.
		     */
		    function setCacheAdd(value) {
		      this.__data__.set(value, HASH_UNDEFINED);
		      return this;
		    }

		    /**
		     * Checks if `value` is in the array cache.
		     *
		     * @private
		     * @name has
		     * @memberOf SetCache
		     * @param {*} value The value to search for.
		     * @returns {number} Returns `true` if `value` is found, else `false`.
		     */
		    function setCacheHas(value) {
		      return this.__data__.has(value);
		    }

		    // Add methods to `SetCache`.
		    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
		    SetCache.prototype.has = setCacheHas;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a stack cache object to store key-value pairs.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function Stack(entries) {
		      var data = this.__data__ = new ListCache(entries);
		      this.size = data.size;
		    }

		    /**
		     * Removes all key-value entries from the stack.
		     *
		     * @private
		     * @name clear
		     * @memberOf Stack
		     */
		    function stackClear() {
		      this.__data__ = new ListCache;
		      this.size = 0;
		    }

		    /**
		     * Removes `key` and its value from the stack.
		     *
		     * @private
		     * @name delete
		     * @memberOf Stack
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function stackDelete(key) {
		      var data = this.__data__,
		          result = data['delete'](key);

		      this.size = data.size;
		      return result;
		    }

		    /**
		     * Gets the stack value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf Stack
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function stackGet(key) {
		      return this.__data__.get(key);
		    }

		    /**
		     * Checks if a stack value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf Stack
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function stackHas(key) {
		      return this.__data__.has(key);
		    }

		    /**
		     * Sets the stack `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf Stack
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the stack cache instance.
		     */
		    function stackSet(key, value) {
		      var data = this.__data__;
		      if (data instanceof ListCache) {
		        var pairs = data.__data__;
		        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
		          pairs.push([key, value]);
		          this.size = ++data.size;
		          return this;
		        }
		        data = this.__data__ = new MapCache(pairs);
		      }
		      data.set(key, value);
		      this.size = data.size;
		      return this;
		    }

		    // Add methods to `Stack`.
		    Stack.prototype.clear = stackClear;
		    Stack.prototype['delete'] = stackDelete;
		    Stack.prototype.get = stackGet;
		    Stack.prototype.has = stackHas;
		    Stack.prototype.set = stackSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an array of the enumerable property names of the array-like `value`.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @param {boolean} inherited Specify returning inherited property names.
		     * @returns {Array} Returns the array of property names.
		     */
		    function arrayLikeKeys(value, inherited) {
		      var isArr = isArray(value),
		          isArg = !isArr && isArguments(value),
		          isBuff = !isArr && !isArg && isBuffer(value),
		          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
		          skipIndexes = isArr || isArg || isBuff || isType,
		          result = skipIndexes ? baseTimes(value.length, String) : [],
		          length = result.length;

		      for (var key in value) {
		        if ((inherited || hasOwnProperty.call(value, key)) &&
		            !(skipIndexes && (
		               // Safari 9 has enumerable `arguments.length` in strict mode.
		               key == 'length' ||
		               // Node.js 0.10 has enumerable non-index properties on buffers.
		               (isBuff && (key == 'offset' || key == 'parent')) ||
		               // PhantomJS 2 has enumerable non-index properties on typed arrays.
		               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
		               // Skip index properties.
		               isIndex(key, length)
		            ))) {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * A specialized version of `_.sample` for arrays.
		     *
		     * @private
		     * @param {Array} array The array to sample.
		     * @returns {*} Returns the random element.
		     */
		    function arraySample(array) {
		      var length = array.length;
		      return length ? array[baseRandom(0, length - 1)] : undefined$1;
		    }

		    /**
		     * A specialized version of `_.sampleSize` for arrays.
		     *
		     * @private
		     * @param {Array} array The array to sample.
		     * @param {number} n The number of elements to sample.
		     * @returns {Array} Returns the random elements.
		     */
		    function arraySampleSize(array, n) {
		      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
		    }

		    /**
		     * A specialized version of `_.shuffle` for arrays.
		     *
		     * @private
		     * @param {Array} array The array to shuffle.
		     * @returns {Array} Returns the new shuffled array.
		     */
		    function arrayShuffle(array) {
		      return shuffleSelf(copyArray(array));
		    }

		    /**
		     * This function is like `assignValue` except that it doesn't assign
		     * `undefined` values.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {string} key The key of the property to assign.
		     * @param {*} value The value to assign.
		     */
		    function assignMergeValue(object, key, value) {
		      if ((value !== undefined$1 && !eq(object[key], value)) ||
		          (value === undefined$1 && !(key in object))) {
		        baseAssignValue(object, key, value);
		      }
		    }

		    /**
		     * Assigns `value` to `key` of `object` if the existing value is not equivalent
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {string} key The key of the property to assign.
		     * @param {*} value The value to assign.
		     */
		    function assignValue(object, key, value) {
		      var objValue = object[key];
		      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
		          (value === undefined$1 && !(key in object))) {
		        baseAssignValue(object, key, value);
		      }
		    }

		    /**
		     * Gets the index at which the `key` is found in `array` of key-value pairs.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {*} key The key to search for.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     */
		    function assocIndexOf(array, key) {
		      var length = array.length;
		      while (length--) {
		        if (eq(array[length][0], key)) {
		          return length;
		        }
		      }
		      return -1;
		    }

		    /**
		     * Aggregates elements of `collection` on `accumulator` with keys transformed
		     * by `iteratee` and values set by `setter`.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} setter The function to set `accumulator` values.
		     * @param {Function} iteratee The iteratee to transform keys.
		     * @param {Object} accumulator The initial aggregated object.
		     * @returns {Function} Returns `accumulator`.
		     */
		    function baseAggregator(collection, setter, iteratee, accumulator) {
		      baseEach(collection, function(value, key, collection) {
		        setter(accumulator, value, iteratee(value), collection);
		      });
		      return accumulator;
		    }

		    /**
		     * The base implementation of `_.assign` without support for multiple sources
		     * or `customizer` functions.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @returns {Object} Returns `object`.
		     */
		    function baseAssign(object, source) {
		      return object && copyObject(source, keys(source), object);
		    }

		    /**
		     * The base implementation of `_.assignIn` without support for multiple sources
		     * or `customizer` functions.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @returns {Object} Returns `object`.
		     */
		    function baseAssignIn(object, source) {
		      return object && copyObject(source, keysIn(source), object);
		    }

		    /**
		     * The base implementation of `assignValue` and `assignMergeValue` without
		     * value checks.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {string} key The key of the property to assign.
		     * @param {*} value The value to assign.
		     */
		    function baseAssignValue(object, key, value) {
		      if (key == '__proto__' && defineProperty) {
		        defineProperty(object, key, {
		          'configurable': true,
		          'enumerable': true,
		          'value': value,
		          'writable': true
		        });
		      } else {
		        object[key] = value;
		      }
		    }

		    /**
		     * The base implementation of `_.at` without support for individual paths.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {string[]} paths The property paths to pick.
		     * @returns {Array} Returns the picked elements.
		     */
		    function baseAt(object, paths) {
		      var index = -1,
		          length = paths.length,
		          result = Array(length),
		          skip = object == null;

		      while (++index < length) {
		        result[index] = skip ? undefined$1 : get(object, paths[index]);
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.clamp` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {number} number The number to clamp.
		     * @param {number} [lower] The lower bound.
		     * @param {number} upper The upper bound.
		     * @returns {number} Returns the clamped number.
		     */
		    function baseClamp(number, lower, upper) {
		      if (number === number) {
		        if (upper !== undefined$1) {
		          number = number <= upper ? number : upper;
		        }
		        if (lower !== undefined$1) {
		          number = number >= lower ? number : lower;
		        }
		      }
		      return number;
		    }

		    /**
		     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
		     * traversed objects.
		     *
		     * @private
		     * @param {*} value The value to clone.
		     * @param {boolean} bitmask The bitmask flags.
		     *  1 - Deep clone
		     *  2 - Flatten inherited properties
		     *  4 - Clone symbols
		     * @param {Function} [customizer] The function to customize cloning.
		     * @param {string} [key] The key of `value`.
		     * @param {Object} [object] The parent object of `value`.
		     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
		     * @returns {*} Returns the cloned value.
		     */
		    function baseClone(value, bitmask, customizer, key, object, stack) {
		      var result,
		          isDeep = bitmask & CLONE_DEEP_FLAG,
		          isFlat = bitmask & CLONE_FLAT_FLAG,
		          isFull = bitmask & CLONE_SYMBOLS_FLAG;

		      if (customizer) {
		        result = object ? customizer(value, key, object, stack) : customizer(value);
		      }
		      if (result !== undefined$1) {
		        return result;
		      }
		      if (!isObject(value)) {
		        return value;
		      }
		      var isArr = isArray(value);
		      if (isArr) {
		        result = initCloneArray(value);
		        if (!isDeep) {
		          return copyArray(value, result);
		        }
		      } else {
		        var tag = getTag(value),
		            isFunc = tag == funcTag || tag == genTag;

		        if (isBuffer(value)) {
		          return cloneBuffer(value, isDeep);
		        }
		        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
		          result = (isFlat || isFunc) ? {} : initCloneObject(value);
		          if (!isDeep) {
		            return isFlat
		              ? copySymbolsIn(value, baseAssignIn(result, value))
		              : copySymbols(value, baseAssign(result, value));
		          }
		        } else {
		          if (!cloneableTags[tag]) {
		            return object ? value : {};
		          }
		          result = initCloneByTag(value, tag, isDeep);
		        }
		      }
		      // Check for circular references and return its corresponding clone.
		      stack || (stack = new Stack);
		      var stacked = stack.get(value);
		      if (stacked) {
		        return stacked;
		      }
		      stack.set(value, result);

		      if (isSet(value)) {
		        value.forEach(function(subValue) {
		          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
		        });
		      } else if (isMap(value)) {
		        value.forEach(function(subValue, key) {
		          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
		        });
		      }

		      var keysFunc = isFull
		        ? (isFlat ? getAllKeysIn : getAllKeys)
		        : (isFlat ? keysIn : keys);

		      var props = isArr ? undefined$1 : keysFunc(value);
		      arrayEach(props || value, function(subValue, key) {
		        if (props) {
		          key = subValue;
		          subValue = value[key];
		        }
		        // Recursively populate clone (susceptible to call stack limits).
		        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
		      });
		      return result;
		    }

		    /**
		     * The base implementation of `_.conforms` which doesn't clone `source`.
		     *
		     * @private
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {Function} Returns the new spec function.
		     */
		    function baseConforms(source) {
		      var props = keys(source);
		      return function(object) {
		        return baseConformsTo(object, source, props);
		      };
		    }

		    /**
		     * The base implementation of `_.conformsTo` which accepts `props` to check.
		     *
		     * @private
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
		     */
		    function baseConformsTo(object, source, props) {
		      var length = props.length;
		      if (object == null) {
		        return !length;
		      }
		      object = Object(object);
		      while (length--) {
		        var key = props[length],
		            predicate = source[key],
		            value = object[key];

		        if ((value === undefined$1 && !(key in object)) || !predicate(value)) {
		          return false;
		        }
		      }
		      return true;
		    }

		    /**
		     * The base implementation of `_.delay` and `_.defer` which accepts `args`
		     * to provide to `func`.
		     *
		     * @private
		     * @param {Function} func The function to delay.
		     * @param {number} wait The number of milliseconds to delay invocation.
		     * @param {Array} args The arguments to provide to `func`.
		     * @returns {number|Object} Returns the timer id or timeout object.
		     */
		    function baseDelay(func, wait, args) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      return setTimeout(function() { func.apply(undefined$1, args); }, wait);
		    }

		    /**
		     * The base implementation of methods like `_.difference` without support
		     * for excluding multiple arrays or iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {Array} values The values to exclude.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     */
		    function baseDifference(array, values, iteratee, comparator) {
		      var index = -1,
		          includes = arrayIncludes,
		          isCommon = true,
		          length = array.length,
		          result = [],
		          valuesLength = values.length;

		      if (!length) {
		        return result;
		      }
		      if (iteratee) {
		        values = arrayMap(values, baseUnary(iteratee));
		      }
		      if (comparator) {
		        includes = arrayIncludesWith;
		        isCommon = false;
		      }
		      else if (values.length >= LARGE_ARRAY_SIZE) {
		        includes = cacheHas;
		        isCommon = false;
		        values = new SetCache(values);
		      }
		      outer:
		      while (++index < length) {
		        var value = array[index],
		            computed = iteratee == null ? value : iteratee(value);

		        value = (comparator || value !== 0) ? value : 0;
		        if (isCommon && computed === computed) {
		          var valuesIndex = valuesLength;
		          while (valuesIndex--) {
		            if (values[valuesIndex] === computed) {
		              continue outer;
		            }
		          }
		          result.push(value);
		        }
		        else if (!includes(values, computed, comparator)) {
		          result.push(value);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.forEach` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     */
		    var baseEach = createBaseEach(baseForOwn);

		    /**
		     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     */
		    var baseEachRight = createBaseEach(baseForOwnRight, true);

		    /**
		     * The base implementation of `_.every` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} predicate The function invoked per iteration.
		     * @returns {boolean} Returns `true` if all elements pass the predicate check,
		     *  else `false`
		     */
		    function baseEvery(collection, predicate) {
		      var result = true;
		      baseEach(collection, function(value, index, collection) {
		        result = !!predicate(value, index, collection);
		        return result;
		      });
		      return result;
		    }

		    /**
		     * The base implementation of methods like `_.max` and `_.min` which accepts a
		     * `comparator` to determine the extremum value.
		     *
		     * @private
		     * @param {Array} array The array to iterate over.
		     * @param {Function} iteratee The iteratee invoked per iteration.
		     * @param {Function} comparator The comparator used to compare values.
		     * @returns {*} Returns the extremum value.
		     */
		    function baseExtremum(array, iteratee, comparator) {
		      var index = -1,
		          length = array.length;

		      while (++index < length) {
		        var value = array[index],
		            current = iteratee(value);

		        if (current != null && (computed === undefined$1
		              ? (current === current && !isSymbol(current))
		              : comparator(current, computed)
		            )) {
		          var computed = current,
		              result = value;
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.fill` without an iteratee call guard.
		     *
		     * @private
		     * @param {Array} array The array to fill.
		     * @param {*} value The value to fill `array` with.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns `array`.
		     */
		    function baseFill(array, value, start, end) {
		      var length = array.length;

		      start = toInteger(start);
		      if (start < 0) {
		        start = -start > length ? 0 : (length + start);
		      }
		      end = (end === undefined$1 || end > length) ? length : toInteger(end);
		      if (end < 0) {
		        end += length;
		      }
		      end = start > end ? 0 : toLength(end);
		      while (start < end) {
		        array[start++] = value;
		      }
		      return array;
		    }

		    /**
		     * The base implementation of `_.filter` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} predicate The function invoked per iteration.
		     * @returns {Array} Returns the new filtered array.
		     */
		    function baseFilter(collection, predicate) {
		      var result = [];
		      baseEach(collection, function(value, index, collection) {
		        if (predicate(value, index, collection)) {
		          result.push(value);
		        }
		      });
		      return result;
		    }

		    /**
		     * The base implementation of `_.flatten` with support for restricting flattening.
		     *
		     * @private
		     * @param {Array} array The array to flatten.
		     * @param {number} depth The maximum recursion depth.
		     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
		     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
		     * @param {Array} [result=[]] The initial result value.
		     * @returns {Array} Returns the new flattened array.
		     */
		    function baseFlatten(array, depth, predicate, isStrict, result) {
		      var index = -1,
		          length = array.length;

		      predicate || (predicate = isFlattenable);
		      result || (result = []);

		      while (++index < length) {
		        var value = array[index];
		        if (depth > 0 && predicate(value)) {
		          if (depth > 1) {
		            // Recursively flatten arrays (susceptible to call stack limits).
		            baseFlatten(value, depth - 1, predicate, isStrict, result);
		          } else {
		            arrayPush(result, value);
		          }
		        } else if (!isStrict) {
		          result[result.length] = value;
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `baseForOwn` which iterates over `object`
		     * properties returned by `keysFunc` and invokes `iteratee` for each property.
		     * Iteratee functions may exit iteration early by explicitly returning `false`.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @param {Function} keysFunc The function to get the keys of `object`.
		     * @returns {Object} Returns `object`.
		     */
		    var baseFor = createBaseFor();

		    /**
		     * This function is like `baseFor` except that it iterates over properties
		     * in the opposite order.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @param {Function} keysFunc The function to get the keys of `object`.
		     * @returns {Object} Returns `object`.
		     */
		    var baseForRight = createBaseFor(true);

		    /**
		     * The base implementation of `_.forOwn` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     */
		    function baseForOwn(object, iteratee) {
		      return object && baseFor(object, iteratee, keys);
		    }

		    /**
		     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     */
		    function baseForOwnRight(object, iteratee) {
		      return object && baseForRight(object, iteratee, keys);
		    }

		    /**
		     * The base implementation of `_.functions` which creates an array of
		     * `object` function property names filtered from `props`.
		     *
		     * @private
		     * @param {Object} object The object to inspect.
		     * @param {Array} props The property names to filter.
		     * @returns {Array} Returns the function names.
		     */
		    function baseFunctions(object, props) {
		      return arrayFilter(props, function(key) {
		        return isFunction(object[key]);
		      });
		    }

		    /**
		     * The base implementation of `_.get` without support for default values.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to get.
		     * @returns {*} Returns the resolved value.
		     */
		    function baseGet(object, path) {
		      path = castPath(path, object);

		      var index = 0,
		          length = path.length;

		      while (object != null && index < length) {
		        object = object[toKey(path[index++])];
		      }
		      return (index && index == length) ? object : undefined$1;
		    }

		    /**
		     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
		     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
		     * symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Function} keysFunc The function to get the keys of `object`.
		     * @param {Function} symbolsFunc The function to get the symbols of `object`.
		     * @returns {Array} Returns the array of property names and symbols.
		     */
		    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
		      var result = keysFunc(object);
		      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
		    }

		    /**
		     * The base implementation of `getTag` without fallbacks for buggy environments.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @returns {string} Returns the `toStringTag`.
		     */
		    function baseGetTag(value) {
		      if (value == null) {
		        return value === undefined$1 ? undefinedTag : nullTag;
		      }
		      return (symToStringTag && symToStringTag in Object(value))
		        ? getRawTag(value)
		        : objectToString(value);
		    }

		    /**
		     * The base implementation of `_.gt` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is greater than `other`,
		     *  else `false`.
		     */
		    function baseGt(value, other) {
		      return value > other;
		    }

		    /**
		     * The base implementation of `_.has` without support for deep paths.
		     *
		     * @private
		     * @param {Object} [object] The object to query.
		     * @param {Array|string} key The key to check.
		     * @returns {boolean} Returns `true` if `key` exists, else `false`.
		     */
		    function baseHas(object, key) {
		      return object != null && hasOwnProperty.call(object, key);
		    }

		    /**
		     * The base implementation of `_.hasIn` without support for deep paths.
		     *
		     * @private
		     * @param {Object} [object] The object to query.
		     * @param {Array|string} key The key to check.
		     * @returns {boolean} Returns `true` if `key` exists, else `false`.
		     */
		    function baseHasIn(object, key) {
		      return object != null && key in Object(object);
		    }

		    /**
		     * The base implementation of `_.inRange` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {number} number The number to check.
		     * @param {number} start The start of the range.
		     * @param {number} end The end of the range.
		     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
		     */
		    function baseInRange(number, start, end) {
		      return number >= nativeMin(start, end) && number < nativeMax(start, end);
		    }

		    /**
		     * The base implementation of methods like `_.intersection`, without support
		     * for iteratee shorthands, that accepts an array of arrays to inspect.
		     *
		     * @private
		     * @param {Array} arrays The arrays to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of shared values.
		     */
		    function baseIntersection(arrays, iteratee, comparator) {
		      var includes = comparator ? arrayIncludesWith : arrayIncludes,
		          length = arrays[0].length,
		          othLength = arrays.length,
		          othIndex = othLength,
		          caches = Array(othLength),
		          maxLength = Infinity,
		          result = [];

		      while (othIndex--) {
		        var array = arrays[othIndex];
		        if (othIndex && iteratee) {
		          array = arrayMap(array, baseUnary(iteratee));
		        }
		        maxLength = nativeMin(array.length, maxLength);
		        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
		          ? new SetCache(othIndex && array)
		          : undefined$1;
		      }
		      array = arrays[0];

		      var index = -1,
		          seen = caches[0];

		      outer:
		      while (++index < length && result.length < maxLength) {
		        var value = array[index],
		            computed = iteratee ? iteratee(value) : value;

		        value = (comparator || value !== 0) ? value : 0;
		        if (!(seen
		              ? cacheHas(seen, computed)
		              : includes(result, computed, comparator)
		            )) {
		          othIndex = othLength;
		          while (--othIndex) {
		            var cache = caches[othIndex];
		            if (!(cache
		                  ? cacheHas(cache, computed)
		                  : includes(arrays[othIndex], computed, comparator))
		                ) {
		              continue outer;
		            }
		          }
		          if (seen) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.invert` and `_.invertBy` which inverts
		     * `object` with values transformed by `iteratee` and set by `setter`.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} setter The function to set `accumulator` values.
		     * @param {Function} iteratee The iteratee to transform values.
		     * @param {Object} accumulator The initial inverted object.
		     * @returns {Function} Returns `accumulator`.
		     */
		    function baseInverter(object, setter, iteratee, accumulator) {
		      baseForOwn(object, function(value, key, object) {
		        setter(accumulator, iteratee(value), key, object);
		      });
		      return accumulator;
		    }

		    /**
		     * The base implementation of `_.invoke` without support for individual
		     * method arguments.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the method to invoke.
		     * @param {Array} args The arguments to invoke the method with.
		     * @returns {*} Returns the result of the invoked method.
		     */
		    function baseInvoke(object, path, args) {
		      path = castPath(path, object);
		      object = parent(object, path);
		      var func = object == null ? object : object[toKey(last(path))];
		      return func == null ? undefined$1 : apply(func, object, args);
		    }

		    /**
		     * The base implementation of `_.isArguments`.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
		     */
		    function baseIsArguments(value) {
		      return isObjectLike(value) && baseGetTag(value) == argsTag;
		    }

		    /**
		     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
		     */
		    function baseIsArrayBuffer(value) {
		      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
		    }

		    /**
		     * The base implementation of `_.isDate` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
		     */
		    function baseIsDate(value) {
		      return isObjectLike(value) && baseGetTag(value) == dateTag;
		    }

		    /**
		     * The base implementation of `_.isEqual` which supports partial comparisons
		     * and tracks traversed objects.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @param {boolean} bitmask The bitmask flags.
		     *  1 - Unordered comparison
		     *  2 - Partial comparison
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     */
		    function baseIsEqual(value, other, bitmask, customizer, stack) {
		      if (value === other) {
		        return true;
		      }
		      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
		        return value !== value && other !== other;
		      }
		      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
		    }

		    /**
		     * A specialized version of `baseIsEqual` for arrays and objects which performs
		     * deep comparisons and tracks traversed objects enabling objects with circular
		     * references to be compared.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
		     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		     */
		    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
		      var objIsArr = isArray(object),
		          othIsArr = isArray(other),
		          objTag = objIsArr ? arrayTag : getTag(object),
		          othTag = othIsArr ? arrayTag : getTag(other);

		      objTag = objTag == argsTag ? objectTag : objTag;
		      othTag = othTag == argsTag ? objectTag : othTag;

		      var objIsObj = objTag == objectTag,
		          othIsObj = othTag == objectTag,
		          isSameTag = objTag == othTag;

		      if (isSameTag && isBuffer(object)) {
		        if (!isBuffer(other)) {
		          return false;
		        }
		        objIsArr = true;
		        objIsObj = false;
		      }
		      if (isSameTag && !objIsObj) {
		        stack || (stack = new Stack);
		        return (objIsArr || isTypedArray(object))
		          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
		          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
		      }
		      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
		        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
		            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

		        if (objIsWrapped || othIsWrapped) {
		          var objUnwrapped = objIsWrapped ? object.value() : object,
		              othUnwrapped = othIsWrapped ? other.value() : other;

		          stack || (stack = new Stack);
		          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
		        }
		      }
		      if (!isSameTag) {
		        return false;
		      }
		      stack || (stack = new Stack);
		      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
		    }

		    /**
		     * The base implementation of `_.isMap` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
		     */
		    function baseIsMap(value) {
		      return isObjectLike(value) && getTag(value) == mapTag;
		    }

		    /**
		     * The base implementation of `_.isMatch` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property values to match.
		     * @param {Array} matchData The property names, values, and compare flags to match.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		     */
		    function baseIsMatch(object, source, matchData, customizer) {
		      var index = matchData.length,
		          length = index,
		          noCustomizer = !customizer;

		      if (object == null) {
		        return !length;
		      }
		      object = Object(object);
		      while (index--) {
		        var data = matchData[index];
		        if ((noCustomizer && data[2])
		              ? data[1] !== object[data[0]]
		              : !(data[0] in object)
		            ) {
		          return false;
		        }
		      }
		      while (++index < length) {
		        data = matchData[index];
		        var key = data[0],
		            objValue = object[key],
		            srcValue = data[1];

		        if (noCustomizer && data[2]) {
		          if (objValue === undefined$1 && !(key in object)) {
		            return false;
		          }
		        } else {
		          var stack = new Stack;
		          if (customizer) {
		            var result = customizer(objValue, srcValue, key, object, source, stack);
		          }
		          if (!(result === undefined$1
		                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
		                : result
		              )) {
		            return false;
		          }
		        }
		      }
		      return true;
		    }

		    /**
		     * The base implementation of `_.isNative` without bad shim checks.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a native function,
		     *  else `false`.
		     */
		    function baseIsNative(value) {
		      if (!isObject(value) || isMasked(value)) {
		        return false;
		      }
		      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
		      return pattern.test(toSource(value));
		    }

		    /**
		     * The base implementation of `_.isRegExp` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
		     */
		    function baseIsRegExp(value) {
		      return isObjectLike(value) && baseGetTag(value) == regexpTag;
		    }

		    /**
		     * The base implementation of `_.isSet` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
		     */
		    function baseIsSet(value) {
		      return isObjectLike(value) && getTag(value) == setTag;
		    }

		    /**
		     * The base implementation of `_.isTypedArray` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
		     */
		    function baseIsTypedArray(value) {
		      return isObjectLike(value) &&
		        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
		    }

		    /**
		     * The base implementation of `_.iteratee`.
		     *
		     * @private
		     * @param {*} [value=_.identity] The value to convert to an iteratee.
		     * @returns {Function} Returns the iteratee.
		     */
		    function baseIteratee(value) {
		      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
		      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
		      if (typeof value == 'function') {
		        return value;
		      }
		      if (value == null) {
		        return identity;
		      }
		      if (typeof value == 'object') {
		        return isArray(value)
		          ? baseMatchesProperty(value[0], value[1])
		          : baseMatches(value);
		      }
		      return property(value);
		    }

		    /**
		     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     */
		    function baseKeys(object) {
		      if (!isPrototype(object)) {
		        return nativeKeys(object);
		      }
		      var result = [];
		      for (var key in Object(object)) {
		        if (hasOwnProperty.call(object, key) && key != 'constructor') {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     */
		    function baseKeysIn(object) {
		      if (!isObject(object)) {
		        return nativeKeysIn(object);
		      }
		      var isProto = isPrototype(object),
		          result = [];

		      for (var key in object) {
		        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.lt` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is less than `other`,
		     *  else `false`.
		     */
		    function baseLt(value, other) {
		      return value < other;
		    }

		    /**
		     * The base implementation of `_.map` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Array} Returns the new mapped array.
		     */
		    function baseMap(collection, iteratee) {
		      var index = -1,
		          result = isArrayLike(collection) ? Array(collection.length) : [];

		      baseEach(collection, function(value, key, collection) {
		        result[++index] = iteratee(value, key, collection);
		      });
		      return result;
		    }

		    /**
		     * The base implementation of `_.matches` which doesn't clone `source`.
		     *
		     * @private
		     * @param {Object} source The object of property values to match.
		     * @returns {Function} Returns the new spec function.
		     */
		    function baseMatches(source) {
		      var matchData = getMatchData(source);
		      if (matchData.length == 1 && matchData[0][2]) {
		        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
		      }
		      return function(object) {
		        return object === source || baseIsMatch(object, source, matchData);
		      };
		    }

		    /**
		     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
		     *
		     * @private
		     * @param {string} path The path of the property to get.
		     * @param {*} srcValue The value to match.
		     * @returns {Function} Returns the new spec function.
		     */
		    function baseMatchesProperty(path, srcValue) {
		      if (isKey(path) && isStrictComparable(srcValue)) {
		        return matchesStrictComparable(toKey(path), srcValue);
		      }
		      return function(object) {
		        var objValue = get(object, path);
		        return (objValue === undefined$1 && objValue === srcValue)
		          ? hasIn(object, path)
		          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
		      };
		    }

		    /**
		     * The base implementation of `_.merge` without support for multiple sources.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @param {number} srcIndex The index of `source`.
		     * @param {Function} [customizer] The function to customize merged values.
		     * @param {Object} [stack] Tracks traversed source values and their merged
		     *  counterparts.
		     */
		    function baseMerge(object, source, srcIndex, customizer, stack) {
		      if (object === source) {
		        return;
		      }
		      baseFor(source, function(srcValue, key) {
		        stack || (stack = new Stack);
		        if (isObject(srcValue)) {
		          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
		        }
		        else {
		          var newValue = customizer
		            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
		            : undefined$1;

		          if (newValue === undefined$1) {
		            newValue = srcValue;
		          }
		          assignMergeValue(object, key, newValue);
		        }
		      }, keysIn);
		    }

		    /**
		     * A specialized version of `baseMerge` for arrays and objects which performs
		     * deep merges and tracks traversed objects enabling objects with circular
		     * references to be merged.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @param {string} key The key of the value to merge.
		     * @param {number} srcIndex The index of `source`.
		     * @param {Function} mergeFunc The function to merge values.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @param {Object} [stack] Tracks traversed source values and their merged
		     *  counterparts.
		     */
		    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
		      var objValue = safeGet(object, key),
		          srcValue = safeGet(source, key),
		          stacked = stack.get(srcValue);

		      if (stacked) {
		        assignMergeValue(object, key, stacked);
		        return;
		      }
		      var newValue = customizer
		        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
		        : undefined$1;

		      var isCommon = newValue === undefined$1;

		      if (isCommon) {
		        var isArr = isArray(srcValue),
		            isBuff = !isArr && isBuffer(srcValue),
		            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

		        newValue = srcValue;
		        if (isArr || isBuff || isTyped) {
		          if (isArray(objValue)) {
		            newValue = objValue;
		          }
		          else if (isArrayLikeObject(objValue)) {
		            newValue = copyArray(objValue);
		          }
		          else if (isBuff) {
		            isCommon = false;
		            newValue = cloneBuffer(srcValue, true);
		          }
		          else if (isTyped) {
		            isCommon = false;
		            newValue = cloneTypedArray(srcValue, true);
		          }
		          else {
		            newValue = [];
		          }
		        }
		        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
		          newValue = objValue;
		          if (isArguments(objValue)) {
		            newValue = toPlainObject(objValue);
		          }
		          else if (!isObject(objValue) || isFunction(objValue)) {
		            newValue = initCloneObject(srcValue);
		          }
		        }
		        else {
		          isCommon = false;
		        }
		      }
		      if (isCommon) {
		        // Recursively merge objects and arrays (susceptible to call stack limits).
		        stack.set(srcValue, newValue);
		        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
		        stack['delete'](srcValue);
		      }
		      assignMergeValue(object, key, newValue);
		    }

		    /**
		     * The base implementation of `_.nth` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {Array} array The array to query.
		     * @param {number} n The index of the element to return.
		     * @returns {*} Returns the nth element of `array`.
		     */
		    function baseNth(array, n) {
		      var length = array.length;
		      if (!length) {
		        return;
		      }
		      n += n < 0 ? length : 0;
		      return isIndex(n, length) ? array[n] : undefined$1;
		    }

		    /**
		     * The base implementation of `_.orderBy` without param guards.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
		     * @param {string[]} orders The sort orders of `iteratees`.
		     * @returns {Array} Returns the new sorted array.
		     */
		    function baseOrderBy(collection, iteratees, orders) {
		      if (iteratees.length) {
		        iteratees = arrayMap(iteratees, function(iteratee) {
		          if (isArray(iteratee)) {
		            return function(value) {
		              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
		            }
		          }
		          return iteratee;
		        });
		      } else {
		        iteratees = [identity];
		      }

		      var index = -1;
		      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

		      var result = baseMap(collection, function(value, key, collection) {
		        var criteria = arrayMap(iteratees, function(iteratee) {
		          return iteratee(value);
		        });
		        return { 'criteria': criteria, 'index': ++index, 'value': value };
		      });

		      return baseSortBy(result, function(object, other) {
		        return compareMultiple(object, other, orders);
		      });
		    }

		    /**
		     * The base implementation of `_.pick` without support for individual
		     * property identifiers.
		     *
		     * @private
		     * @param {Object} object The source object.
		     * @param {string[]} paths The property paths to pick.
		     * @returns {Object} Returns the new object.
		     */
		    function basePick(object, paths) {
		      return basePickBy(object, paths, function(value, path) {
		        return hasIn(object, path);
		      });
		    }

		    /**
		     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The source object.
		     * @param {string[]} paths The property paths to pick.
		     * @param {Function} predicate The function invoked per property.
		     * @returns {Object} Returns the new object.
		     */
		    function basePickBy(object, paths, predicate) {
		      var index = -1,
		          length = paths.length,
		          result = {};

		      while (++index < length) {
		        var path = paths[index],
		            value = baseGet(object, path);

		        if (predicate(value, path)) {
		          baseSet(result, castPath(path, object), value);
		        }
		      }
		      return result;
		    }

		    /**
		     * A specialized version of `baseProperty` which supports deep paths.
		     *
		     * @private
		     * @param {Array|string} path The path of the property to get.
		     * @returns {Function} Returns the new accessor function.
		     */
		    function basePropertyDeep(path) {
		      return function(object) {
		        return baseGet(object, path);
		      };
		    }

		    /**
		     * The base implementation of `_.pullAllBy` without support for iteratee
		     * shorthands.
		     *
		     * @private
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns `array`.
		     */
		    function basePullAll(array, values, iteratee, comparator) {
		      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
		          index = -1,
		          length = values.length,
		          seen = array;

		      if (array === values) {
		        values = copyArray(values);
		      }
		      if (iteratee) {
		        seen = arrayMap(array, baseUnary(iteratee));
		      }
		      while (++index < length) {
		        var fromIndex = 0,
		            value = values[index],
		            computed = iteratee ? iteratee(value) : value;

		        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
		          if (seen !== array) {
		            splice.call(seen, fromIndex, 1);
		          }
		          splice.call(array, fromIndex, 1);
		        }
		      }
		      return array;
		    }

		    /**
		     * The base implementation of `_.pullAt` without support for individual
		     * indexes or capturing the removed elements.
		     *
		     * @private
		     * @param {Array} array The array to modify.
		     * @param {number[]} indexes The indexes of elements to remove.
		     * @returns {Array} Returns `array`.
		     */
		    function basePullAt(array, indexes) {
		      var length = array ? indexes.length : 0,
		          lastIndex = length - 1;

		      while (length--) {
		        var index = indexes[length];
		        if (length == lastIndex || index !== previous) {
		          var previous = index;
		          if (isIndex(index)) {
		            splice.call(array, index, 1);
		          } else {
		            baseUnset(array, index);
		          }
		        }
		      }
		      return array;
		    }

		    /**
		     * The base implementation of `_.random` without support for returning
		     * floating-point numbers.
		     *
		     * @private
		     * @param {number} lower The lower bound.
		     * @param {number} upper The upper bound.
		     * @returns {number} Returns the random number.
		     */
		    function baseRandom(lower, upper) {
		      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
		    }

		    /**
		     * The base implementation of `_.range` and `_.rangeRight` which doesn't
		     * coerce arguments.
		     *
		     * @private
		     * @param {number} start The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} step The value to increment or decrement by.
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Array} Returns the range of numbers.
		     */
		    function baseRange(start, end, step, fromRight) {
		      var index = -1,
		          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
		          result = Array(length);

		      while (length--) {
		        result[fromRight ? length : ++index] = start;
		        start += step;
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.repeat` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {string} string The string to repeat.
		     * @param {number} n The number of times to repeat the string.
		     * @returns {string} Returns the repeated string.
		     */
		    function baseRepeat(string, n) {
		      var result = '';
		      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
		        return result;
		      }
		      // Leverage the exponentiation by squaring algorithm for a faster repeat.
		      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
		      do {
		        if (n % 2) {
		          result += string;
		        }
		        n = nativeFloor(n / 2);
		        if (n) {
		          string += string;
		        }
		      } while (n);

		      return result;
		    }

		    /**
		     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
		     *
		     * @private
		     * @param {Function} func The function to apply a rest parameter to.
		     * @param {number} [start=func.length-1] The start position of the rest parameter.
		     * @returns {Function} Returns the new function.
		     */
		    function baseRest(func, start) {
		      return setToString(overRest(func, start, identity), func + '');
		    }

		    /**
		     * The base implementation of `_.sample`.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to sample.
		     * @returns {*} Returns the random element.
		     */
		    function baseSample(collection) {
		      return arraySample(values(collection));
		    }

		    /**
		     * The base implementation of `_.sampleSize` without param guards.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to sample.
		     * @param {number} n The number of elements to sample.
		     * @returns {Array} Returns the random elements.
		     */
		    function baseSampleSize(collection, n) {
		      var array = values(collection);
		      return shuffleSelf(array, baseClamp(n, 0, array.length));
		    }

		    /**
		     * The base implementation of `_.set`.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {*} value The value to set.
		     * @param {Function} [customizer] The function to customize path creation.
		     * @returns {Object} Returns `object`.
		     */
		    function baseSet(object, path, value, customizer) {
		      if (!isObject(object)) {
		        return object;
		      }
		      path = castPath(path, object);

		      var index = -1,
		          length = path.length,
		          lastIndex = length - 1,
		          nested = object;

		      while (nested != null && ++index < length) {
		        var key = toKey(path[index]),
		            newValue = value;

		        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
		          return object;
		        }

		        if (index != lastIndex) {
		          var objValue = nested[key];
		          newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
		          if (newValue === undefined$1) {
		            newValue = isObject(objValue)
		              ? objValue
		              : (isIndex(path[index + 1]) ? [] : {});
		          }
		        }
		        assignValue(nested, key, newValue);
		        nested = nested[key];
		      }
		      return object;
		    }

		    /**
		     * The base implementation of `setData` without support for hot loop shorting.
		     *
		     * @private
		     * @param {Function} func The function to associate metadata with.
		     * @param {*} data The metadata.
		     * @returns {Function} Returns `func`.
		     */
		    var baseSetData = !metaMap ? identity : function(func, data) {
		      metaMap.set(func, data);
		      return func;
		    };

		    /**
		     * The base implementation of `setToString` without support for hot loop shorting.
		     *
		     * @private
		     * @param {Function} func The function to modify.
		     * @param {Function} string The `toString` result.
		     * @returns {Function} Returns `func`.
		     */
		    var baseSetToString = !defineProperty ? identity : function(func, string) {
		      return defineProperty(func, 'toString', {
		        'configurable': true,
		        'enumerable': false,
		        'value': constant(string),
		        'writable': true
		      });
		    };

		    /**
		     * The base implementation of `_.shuffle`.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to shuffle.
		     * @returns {Array} Returns the new shuffled array.
		     */
		    function baseShuffle(collection) {
		      return shuffleSelf(values(collection));
		    }

		    /**
		     * The base implementation of `_.slice` without an iteratee call guard.
		     *
		     * @private
		     * @param {Array} array The array to slice.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns the slice of `array`.
		     */
		    function baseSlice(array, start, end) {
		      var index = -1,
		          length = array.length;

		      if (start < 0) {
		        start = -start > length ? 0 : (length + start);
		      }
		      end = end > length ? length : end;
		      if (end < 0) {
		        end += length;
		      }
		      length = start > end ? 0 : ((end - start) >>> 0);
		      start >>>= 0;

		      var result = Array(length);
		      while (++index < length) {
		        result[index] = array[index + start];
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.some` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} predicate The function invoked per iteration.
		     * @returns {boolean} Returns `true` if any element passes the predicate check,
		     *  else `false`.
		     */
		    function baseSome(collection, predicate) {
		      var result;

		      baseEach(collection, function(value, index, collection) {
		        result = predicate(value, index, collection);
		        return !result;
		      });
		      return !!result;
		    }

		    /**
		     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
		     * performs a binary search of `array` to determine the index at which `value`
		     * should be inserted into `array` in order to maintain its sort order.
		     *
		     * @private
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {boolean} [retHighest] Specify returning the highest qualified index.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     */
		    function baseSortedIndex(array, value, retHighest) {
		      var low = 0,
		          high = array == null ? low : array.length;

		      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
		        while (low < high) {
		          var mid = (low + high) >>> 1,
		              computed = array[mid];

		          if (computed !== null && !isSymbol(computed) &&
		              (retHighest ? (computed <= value) : (computed < value))) {
		            low = mid + 1;
		          } else {
		            high = mid;
		          }
		        }
		        return high;
		      }
		      return baseSortedIndexBy(array, value, identity, retHighest);
		    }

		    /**
		     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
		     * which invokes `iteratee` for `value` and each element of `array` to compute
		     * their sort ranking. The iteratee is invoked with one argument; (value).
		     *
		     * @private
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Function} iteratee The iteratee invoked per element.
		     * @param {boolean} [retHighest] Specify returning the highest qualified index.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     */
		    function baseSortedIndexBy(array, value, iteratee, retHighest) {
		      var low = 0,
		          high = array == null ? 0 : array.length;
		      if (high === 0) {
		        return 0;
		      }

		      value = iteratee(value);
		      var valIsNaN = value !== value,
		          valIsNull = value === null,
		          valIsSymbol = isSymbol(value),
		          valIsUndefined = value === undefined$1;

		      while (low < high) {
		        var mid = nativeFloor((low + high) / 2),
		            computed = iteratee(array[mid]),
		            othIsDefined = computed !== undefined$1,
		            othIsNull = computed === null,
		            othIsReflexive = computed === computed,
		            othIsSymbol = isSymbol(computed);

		        if (valIsNaN) {
		          var setLow = retHighest || othIsReflexive;
		        } else if (valIsUndefined) {
		          setLow = othIsReflexive && (retHighest || othIsDefined);
		        } else if (valIsNull) {
		          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
		        } else if (valIsSymbol) {
		          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
		        } else if (othIsNull || othIsSymbol) {
		          setLow = false;
		        } else {
		          setLow = retHighest ? (computed <= value) : (computed < value);
		        }
		        if (setLow) {
		          low = mid + 1;
		        } else {
		          high = mid;
		        }
		      }
		      return nativeMin(high, MAX_ARRAY_INDEX);
		    }

		    /**
		     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
		     * support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     */
		    function baseSortedUniq(array, iteratee) {
		      var index = -1,
		          length = array.length,
		          resIndex = 0,
		          result = [];

		      while (++index < length) {
		        var value = array[index],
		            computed = iteratee ? iteratee(value) : value;

		        if (!index || !eq(computed, seen)) {
		          var seen = computed;
		          result[resIndex++] = value === 0 ? 0 : value;
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.toNumber` which doesn't ensure correct
		     * conversions of binary, hexadecimal, or octal string values.
		     *
		     * @private
		     * @param {*} value The value to process.
		     * @returns {number} Returns the number.
		     */
		    function baseToNumber(value) {
		      if (typeof value == 'number') {
		        return value;
		      }
		      if (isSymbol(value)) {
		        return NAN;
		      }
		      return +value;
		    }

		    /**
		     * The base implementation of `_.toString` which doesn't convert nullish
		     * values to empty strings.
		     *
		     * @private
		     * @param {*} value The value to process.
		     * @returns {string} Returns the string.
		     */
		    function baseToString(value) {
		      // Exit early for strings to avoid a performance hit in some environments.
		      if (typeof value == 'string') {
		        return value;
		      }
		      if (isArray(value)) {
		        // Recursively convert values (susceptible to call stack limits).
		        return arrayMap(value, baseToString) + '';
		      }
		      if (isSymbol(value)) {
		        return symbolToString ? symbolToString.call(value) : '';
		      }
		      var result = (value + '');
		      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
		    }

		    /**
		     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     */
		    function baseUniq(array, iteratee, comparator) {
		      var index = -1,
		          includes = arrayIncludes,
		          length = array.length,
		          isCommon = true,
		          result = [],
		          seen = result;

		      if (comparator) {
		        isCommon = false;
		        includes = arrayIncludesWith;
		      }
		      else if (length >= LARGE_ARRAY_SIZE) {
		        var set = iteratee ? null : createSet(array);
		        if (set) {
		          return setToArray(set);
		        }
		        isCommon = false;
		        includes = cacheHas;
		        seen = new SetCache;
		      }
		      else {
		        seen = iteratee ? [] : result;
		      }
		      outer:
		      while (++index < length) {
		        var value = array[index],
		            computed = iteratee ? iteratee(value) : value;

		        value = (comparator || value !== 0) ? value : 0;
		        if (isCommon && computed === computed) {
		          var seenIndex = seen.length;
		          while (seenIndex--) {
		            if (seen[seenIndex] === computed) {
		              continue outer;
		            }
		          }
		          if (iteratee) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		        else if (!includes(seen, computed, comparator)) {
		          if (seen !== result) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.unset`.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The property path to unset.
		     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
		     */
		    function baseUnset(object, path) {
		      path = castPath(path, object);
		      object = parent(object, path);
		      return object == null || delete object[toKey(last(path))];
		    }

		    /**
		     * The base implementation of `_.update`.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to update.
		     * @param {Function} updater The function to produce the updated value.
		     * @param {Function} [customizer] The function to customize path creation.
		     * @returns {Object} Returns `object`.
		     */
		    function baseUpdate(object, path, updater, customizer) {
		      return baseSet(object, path, updater(baseGet(object, path)), customizer);
		    }

		    /**
		     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
		     * without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to query.
		     * @param {Function} predicate The function invoked per iteration.
		     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Array} Returns the slice of `array`.
		     */
		    function baseWhile(array, predicate, isDrop, fromRight) {
		      var length = array.length,
		          index = fromRight ? length : -1;

		      while ((fromRight ? index-- : ++index < length) &&
		        predicate(array[index], index, array)) {}

		      return isDrop
		        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
		        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
		    }

		    /**
		     * The base implementation of `wrapperValue` which returns the result of
		     * performing a sequence of actions on the unwrapped `value`, where each
		     * successive action is supplied the return value of the previous.
		     *
		     * @private
		     * @param {*} value The unwrapped value.
		     * @param {Array} actions Actions to perform to resolve the unwrapped value.
		     * @returns {*} Returns the resolved value.
		     */
		    function baseWrapperValue(value, actions) {
		      var result = value;
		      if (result instanceof LazyWrapper) {
		        result = result.value();
		      }
		      return arrayReduce(actions, function(result, action) {
		        return action.func.apply(action.thisArg, arrayPush([result], action.args));
		      }, result);
		    }

		    /**
		     * The base implementation of methods like `_.xor`, without support for
		     * iteratee shorthands, that accepts an array of arrays to inspect.
		     *
		     * @private
		     * @param {Array} arrays The arrays to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of values.
		     */
		    function baseXor(arrays, iteratee, comparator) {
		      var length = arrays.length;
		      if (length < 2) {
		        return length ? baseUniq(arrays[0]) : [];
		      }
		      var index = -1,
		          result = Array(length);

		      while (++index < length) {
		        var array = arrays[index],
		            othIndex = -1;

		        while (++othIndex < length) {
		          if (othIndex != index) {
		            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
		          }
		        }
		      }
		      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
		    }

		    /**
		     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
		     *
		     * @private
		     * @param {Array} props The property identifiers.
		     * @param {Array} values The property values.
		     * @param {Function} assignFunc The function to assign values.
		     * @returns {Object} Returns the new object.
		     */
		    function baseZipObject(props, values, assignFunc) {
		      var index = -1,
		          length = props.length,
		          valsLength = values.length,
		          result = {};

		      while (++index < length) {
		        var value = index < valsLength ? values[index] : undefined$1;
		        assignFunc(result, props[index], value);
		      }
		      return result;
		    }

		    /**
		     * Casts `value` to an empty array if it's not an array like object.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {Array|Object} Returns the cast array-like object.
		     */
		    function castArrayLikeObject(value) {
		      return isArrayLikeObject(value) ? value : [];
		    }

		    /**
		     * Casts `value` to `identity` if it's not a function.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {Function} Returns cast function.
		     */
		    function castFunction(value) {
		      return typeof value == 'function' ? value : identity;
		    }

		    /**
		     * Casts `value` to a path array if it's not one.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @param {Object} [object] The object to query keys on.
		     * @returns {Array} Returns the cast property path array.
		     */
		    function castPath(value, object) {
		      if (isArray(value)) {
		        return value;
		      }
		      return isKey(value, object) ? [value] : stringToPath(toString(value));
		    }

		    /**
		     * A `baseRest` alias which can be replaced with `identity` by module
		     * replacement plugins.
		     *
		     * @private
		     * @type {Function}
		     * @param {Function} func The function to apply a rest parameter to.
		     * @returns {Function} Returns the new function.
		     */
		    var castRest = baseRest;

		    /**
		     * Casts `array` to a slice if it's needed.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {number} start The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns the cast slice.
		     */
		    function castSlice(array, start, end) {
		      var length = array.length;
		      end = end === undefined$1 ? length : end;
		      return (!start && end >= length) ? array : baseSlice(array, start, end);
		    }

		    /**
		     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
		     *
		     * @private
		     * @param {number|Object} id The timer id or timeout object of the timer to clear.
		     */
		    var clearTimeout = ctxClearTimeout || function(id) {
		      return root.clearTimeout(id);
		    };

		    /**
		     * Creates a clone of  `buffer`.
		     *
		     * @private
		     * @param {Buffer} buffer The buffer to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Buffer} Returns the cloned buffer.
		     */
		    function cloneBuffer(buffer, isDeep) {
		      if (isDeep) {
		        return buffer.slice();
		      }
		      var length = buffer.length,
		          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

		      buffer.copy(result);
		      return result;
		    }

		    /**
		     * Creates a clone of `arrayBuffer`.
		     *
		     * @private
		     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
		     * @returns {ArrayBuffer} Returns the cloned array buffer.
		     */
		    function cloneArrayBuffer(arrayBuffer) {
		      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
		      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
		      return result;
		    }

		    /**
		     * Creates a clone of `dataView`.
		     *
		     * @private
		     * @param {Object} dataView The data view to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the cloned data view.
		     */
		    function cloneDataView(dataView, isDeep) {
		      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
		      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
		    }

		    /**
		     * Creates a clone of `regexp`.
		     *
		     * @private
		     * @param {Object} regexp The regexp to clone.
		     * @returns {Object} Returns the cloned regexp.
		     */
		    function cloneRegExp(regexp) {
		      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
		      result.lastIndex = regexp.lastIndex;
		      return result;
		    }

		    /**
		     * Creates a clone of the `symbol` object.
		     *
		     * @private
		     * @param {Object} symbol The symbol object to clone.
		     * @returns {Object} Returns the cloned symbol object.
		     */
		    function cloneSymbol(symbol) {
		      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
		    }

		    /**
		     * Creates a clone of `typedArray`.
		     *
		     * @private
		     * @param {Object} typedArray The typed array to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the cloned typed array.
		     */
		    function cloneTypedArray(typedArray, isDeep) {
		      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
		      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
		    }

		    /**
		     * Compares values to sort them in ascending order.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {number} Returns the sort order indicator for `value`.
		     */
		    function compareAscending(value, other) {
		      if (value !== other) {
		        var valIsDefined = value !== undefined$1,
		            valIsNull = value === null,
		            valIsReflexive = value === value,
		            valIsSymbol = isSymbol(value);

		        var othIsDefined = other !== undefined$1,
		            othIsNull = other === null,
		            othIsReflexive = other === other,
		            othIsSymbol = isSymbol(other);

		        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
		            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
		            (valIsNull && othIsDefined && othIsReflexive) ||
		            (!valIsDefined && othIsReflexive) ||
		            !valIsReflexive) {
		          return 1;
		        }
		        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
		            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
		            (othIsNull && valIsDefined && valIsReflexive) ||
		            (!othIsDefined && valIsReflexive) ||
		            !othIsReflexive) {
		          return -1;
		        }
		      }
		      return 0;
		    }

		    /**
		     * Used by `_.orderBy` to compare multiple properties of a value to another
		     * and stable sort them.
		     *
		     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
		     * specify an order of "desc" for descending or "asc" for ascending sort order
		     * of corresponding values.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {boolean[]|string[]} orders The order to sort by for each property.
		     * @returns {number} Returns the sort order indicator for `object`.
		     */
		    function compareMultiple(object, other, orders) {
		      var index = -1,
		          objCriteria = object.criteria,
		          othCriteria = other.criteria,
		          length = objCriteria.length,
		          ordersLength = orders.length;

		      while (++index < length) {
		        var result = compareAscending(objCriteria[index], othCriteria[index]);
		        if (result) {
		          if (index >= ordersLength) {
		            return result;
		          }
		          var order = orders[index];
		          return result * (order == 'desc' ? -1 : 1);
		        }
		      }
		      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
		      // that causes it, under certain circumstances, to provide the same value for
		      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
		      // for more details.
		      //
		      // This also ensures a stable sort in V8 and other engines.
		      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
		      return object.index - other.index;
		    }

		    /**
		     * Creates an array that is the composition of partially applied arguments,
		     * placeholders, and provided arguments into a single array of arguments.
		     *
		     * @private
		     * @param {Array} args The provided arguments.
		     * @param {Array} partials The arguments to prepend to those provided.
		     * @param {Array} holders The `partials` placeholder indexes.
		     * @params {boolean} [isCurried] Specify composing for a curried function.
		     * @returns {Array} Returns the new array of composed arguments.
		     */
		    function composeArgs(args, partials, holders, isCurried) {
		      var argsIndex = -1,
		          argsLength = args.length,
		          holdersLength = holders.length,
		          leftIndex = -1,
		          leftLength = partials.length,
		          rangeLength = nativeMax(argsLength - holdersLength, 0),
		          result = Array(leftLength + rangeLength),
		          isUncurried = !isCurried;

		      while (++leftIndex < leftLength) {
		        result[leftIndex] = partials[leftIndex];
		      }
		      while (++argsIndex < holdersLength) {
		        if (isUncurried || argsIndex < argsLength) {
		          result[holders[argsIndex]] = args[argsIndex];
		        }
		      }
		      while (rangeLength--) {
		        result[leftIndex++] = args[argsIndex++];
		      }
		      return result;
		    }

		    /**
		     * This function is like `composeArgs` except that the arguments composition
		     * is tailored for `_.partialRight`.
		     *
		     * @private
		     * @param {Array} args The provided arguments.
		     * @param {Array} partials The arguments to append to those provided.
		     * @param {Array} holders The `partials` placeholder indexes.
		     * @params {boolean} [isCurried] Specify composing for a curried function.
		     * @returns {Array} Returns the new array of composed arguments.
		     */
		    function composeArgsRight(args, partials, holders, isCurried) {
		      var argsIndex = -1,
		          argsLength = args.length,
		          holdersIndex = -1,
		          holdersLength = holders.length,
		          rightIndex = -1,
		          rightLength = partials.length,
		          rangeLength = nativeMax(argsLength - holdersLength, 0),
		          result = Array(rangeLength + rightLength),
		          isUncurried = !isCurried;

		      while (++argsIndex < rangeLength) {
		        result[argsIndex] = args[argsIndex];
		      }
		      var offset = argsIndex;
		      while (++rightIndex < rightLength) {
		        result[offset + rightIndex] = partials[rightIndex];
		      }
		      while (++holdersIndex < holdersLength) {
		        if (isUncurried || argsIndex < argsLength) {
		          result[offset + holders[holdersIndex]] = args[argsIndex++];
		        }
		      }
		      return result;
		    }

		    /**
		     * Copies the values of `source` to `array`.
		     *
		     * @private
		     * @param {Array} source The array to copy values from.
		     * @param {Array} [array=[]] The array to copy values to.
		     * @returns {Array} Returns `array`.
		     */
		    function copyArray(source, array) {
		      var index = -1,
		          length = source.length;

		      array || (array = Array(length));
		      while (++index < length) {
		        array[index] = source[index];
		      }
		      return array;
		    }

		    /**
		     * Copies properties of `source` to `object`.
		     *
		     * @private
		     * @param {Object} source The object to copy properties from.
		     * @param {Array} props The property identifiers to copy.
		     * @param {Object} [object={}] The object to copy properties to.
		     * @param {Function} [customizer] The function to customize copied values.
		     * @returns {Object} Returns `object`.
		     */
		    function copyObject(source, props, object, customizer) {
		      var isNew = !object;
		      object || (object = {});

		      var index = -1,
		          length = props.length;

		      while (++index < length) {
		        var key = props[index];

		        var newValue = customizer
		          ? customizer(object[key], source[key], key, object, source)
		          : undefined$1;

		        if (newValue === undefined$1) {
		          newValue = source[key];
		        }
		        if (isNew) {
		          baseAssignValue(object, key, newValue);
		        } else {
		          assignValue(object, key, newValue);
		        }
		      }
		      return object;
		    }

		    /**
		     * Copies own symbols of `source` to `object`.
		     *
		     * @private
		     * @param {Object} source The object to copy symbols from.
		     * @param {Object} [object={}] The object to copy symbols to.
		     * @returns {Object} Returns `object`.
		     */
		    function copySymbols(source, object) {
		      return copyObject(source, getSymbols(source), object);
		    }

		    /**
		     * Copies own and inherited symbols of `source` to `object`.
		     *
		     * @private
		     * @param {Object} source The object to copy symbols from.
		     * @param {Object} [object={}] The object to copy symbols to.
		     * @returns {Object} Returns `object`.
		     */
		    function copySymbolsIn(source, object) {
		      return copyObject(source, getSymbolsIn(source), object);
		    }

		    /**
		     * Creates a function like `_.groupBy`.
		     *
		     * @private
		     * @param {Function} setter The function to set accumulator values.
		     * @param {Function} [initializer] The accumulator object initializer.
		     * @returns {Function} Returns the new aggregator function.
		     */
		    function createAggregator(setter, initializer) {
		      return function(collection, iteratee) {
		        var func = isArray(collection) ? arrayAggregator : baseAggregator,
		            accumulator = initializer ? initializer() : {};

		        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
		      };
		    }

		    /**
		     * Creates a function like `_.assign`.
		     *
		     * @private
		     * @param {Function} assigner The function to assign values.
		     * @returns {Function} Returns the new assigner function.
		     */
		    function createAssigner(assigner) {
		      return baseRest(function(object, sources) {
		        var index = -1,
		            length = sources.length,
		            customizer = length > 1 ? sources[length - 1] : undefined$1,
		            guard = length > 2 ? sources[2] : undefined$1;

		        customizer = (assigner.length > 3 && typeof customizer == 'function')
		          ? (length--, customizer)
		          : undefined$1;

		        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
		          customizer = length < 3 ? undefined$1 : customizer;
		          length = 1;
		        }
		        object = Object(object);
		        while (++index < length) {
		          var source = sources[index];
		          if (source) {
		            assigner(object, source, index, customizer);
		          }
		        }
		        return object;
		      });
		    }

		    /**
		     * Creates a `baseEach` or `baseEachRight` function.
		     *
		     * @private
		     * @param {Function} eachFunc The function to iterate over a collection.
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new base function.
		     */
		    function createBaseEach(eachFunc, fromRight) {
		      return function(collection, iteratee) {
		        if (collection == null) {
		          return collection;
		        }
		        if (!isArrayLike(collection)) {
		          return eachFunc(collection, iteratee);
		        }
		        var length = collection.length,
		            index = fromRight ? length : -1,
		            iterable = Object(collection);

		        while ((fromRight ? index-- : ++index < length)) {
		          if (iteratee(iterable[index], index, iterable) === false) {
		            break;
		          }
		        }
		        return collection;
		      };
		    }

		    /**
		     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
		     *
		     * @private
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new base function.
		     */
		    function createBaseFor(fromRight) {
		      return function(object, iteratee, keysFunc) {
		        var index = -1,
		            iterable = Object(object),
		            props = keysFunc(object),
		            length = props.length;

		        while (length--) {
		          var key = props[fromRight ? length : ++index];
		          if (iteratee(iterable[key], key, iterable) === false) {
		            break;
		          }
		        }
		        return object;
		      };
		    }

		    /**
		     * Creates a function that wraps `func` to invoke it with the optional `this`
		     * binding of `thisArg`.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createBind(func, bitmask, thisArg) {
		      var isBind = bitmask & WRAP_BIND_FLAG,
		          Ctor = createCtor(func);

		      function wrapper() {
		        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
		        return fn.apply(isBind ? thisArg : this, arguments);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a function like `_.lowerFirst`.
		     *
		     * @private
		     * @param {string} methodName The name of the `String` case method to use.
		     * @returns {Function} Returns the new case function.
		     */
		    function createCaseFirst(methodName) {
		      return function(string) {
		        string = toString(string);

		        var strSymbols = hasUnicode(string)
		          ? stringToArray(string)
		          : undefined$1;

		        var chr = strSymbols
		          ? strSymbols[0]
		          : string.charAt(0);

		        var trailing = strSymbols
		          ? castSlice(strSymbols, 1).join('')
		          : string.slice(1);

		        return chr[methodName]() + trailing;
		      };
		    }

		    /**
		     * Creates a function like `_.camelCase`.
		     *
		     * @private
		     * @param {Function} callback The function to combine each word.
		     * @returns {Function} Returns the new compounder function.
		     */
		    function createCompounder(callback) {
		      return function(string) {
		        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
		      };
		    }

		    /**
		     * Creates a function that produces an instance of `Ctor` regardless of
		     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
		     *
		     * @private
		     * @param {Function} Ctor The constructor to wrap.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createCtor(Ctor) {
		      return function() {
		        // Use a `switch` statement to work with class constructors. See
		        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
		        // for more details.
		        var args = arguments;
		        switch (args.length) {
		          case 0: return new Ctor;
		          case 1: return new Ctor(args[0]);
		          case 2: return new Ctor(args[0], args[1]);
		          case 3: return new Ctor(args[0], args[1], args[2]);
		          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
		          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
		          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
		          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
		        }
		        var thisBinding = baseCreate(Ctor.prototype),
		            result = Ctor.apply(thisBinding, args);

		        // Mimic the constructor's `return` behavior.
		        // See https://es5.github.io/#x13.2.2 for more details.
		        return isObject(result) ? result : thisBinding;
		      };
		    }

		    /**
		     * Creates a function that wraps `func` to enable currying.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {number} arity The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createCurry(func, bitmask, arity) {
		      var Ctor = createCtor(func);

		      function wrapper() {
		        var length = arguments.length,
		            args = Array(length),
		            index = length,
		            placeholder = getHolder(wrapper);

		        while (index--) {
		          args[index] = arguments[index];
		        }
		        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
		          ? []
		          : replaceHolders(args, placeholder);

		        length -= holders.length;
		        if (length < arity) {
		          return createRecurry(
		            func, bitmask, createHybrid, wrapper.placeholder, undefined$1,
		            args, holders, undefined$1, undefined$1, arity - length);
		        }
		        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
		        return apply(fn, this, args);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a `_.find` or `_.findLast` function.
		     *
		     * @private
		     * @param {Function} findIndexFunc The function to find the collection index.
		     * @returns {Function} Returns the new find function.
		     */
		    function createFind(findIndexFunc) {
		      return function(collection, predicate, fromIndex) {
		        var iterable = Object(collection);
		        if (!isArrayLike(collection)) {
		          var iteratee = getIteratee(predicate, 3);
		          collection = keys(collection);
		          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
		        }
		        var index = findIndexFunc(collection, predicate, fromIndex);
		        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined$1;
		      };
		    }

		    /**
		     * Creates a `_.flow` or `_.flowRight` function.
		     *
		     * @private
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new flow function.
		     */
		    function createFlow(fromRight) {
		      return flatRest(function(funcs) {
		        var length = funcs.length,
		            index = length,
		            prereq = LodashWrapper.prototype.thru;

		        if (fromRight) {
		          funcs.reverse();
		        }
		        while (index--) {
		          var func = funcs[index];
		          if (typeof func != 'function') {
		            throw new TypeError(FUNC_ERROR_TEXT);
		          }
		          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
		            var wrapper = new LodashWrapper([], true);
		          }
		        }
		        index = wrapper ? index : length;
		        while (++index < length) {
		          func = funcs[index];

		          var funcName = getFuncName(func),
		              data = funcName == 'wrapper' ? getData(func) : undefined$1;

		          if (data && isLaziable(data[0]) &&
		                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
		                !data[4].length && data[9] == 1
		              ) {
		            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
		          } else {
		            wrapper = (func.length == 1 && isLaziable(func))
		              ? wrapper[funcName]()
		              : wrapper.thru(func);
		          }
		        }
		        return function() {
		          var args = arguments,
		              value = args[0];

		          if (wrapper && args.length == 1 && isArray(value)) {
		            return wrapper.plant(value).value();
		          }
		          var index = 0,
		              result = length ? funcs[index].apply(this, args) : value;

		          while (++index < length) {
		            result = funcs[index].call(this, result);
		          }
		          return result;
		        };
		      });
		    }

		    /**
		     * Creates a function that wraps `func` to invoke it with optional `this`
		     * binding of `thisArg`, partial application, and currying.
		     *
		     * @private
		     * @param {Function|string} func The function or method name to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {Array} [partials] The arguments to prepend to those provided to
		     *  the new function.
		     * @param {Array} [holders] The `partials` placeholder indexes.
		     * @param {Array} [partialsRight] The arguments to append to those provided
		     *  to the new function.
		     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
		     * @param {Array} [argPos] The argument positions of the new function.
		     * @param {number} [ary] The arity cap of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
		      var isAry = bitmask & WRAP_ARY_FLAG,
		          isBind = bitmask & WRAP_BIND_FLAG,
		          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
		          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
		          isFlip = bitmask & WRAP_FLIP_FLAG,
		          Ctor = isBindKey ? undefined$1 : createCtor(func);

		      function wrapper() {
		        var length = arguments.length,
		            args = Array(length),
		            index = length;

		        while (index--) {
		          args[index] = arguments[index];
		        }
		        if (isCurried) {
		          var placeholder = getHolder(wrapper),
		              holdersCount = countHolders(args, placeholder);
		        }
		        if (partials) {
		          args = composeArgs(args, partials, holders, isCurried);
		        }
		        if (partialsRight) {
		          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
		        }
		        length -= holdersCount;
		        if (isCurried && length < arity) {
		          var newHolders = replaceHolders(args, placeholder);
		          return createRecurry(
		            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
		            args, newHolders, argPos, ary, arity - length
		          );
		        }
		        var thisBinding = isBind ? thisArg : this,
		            fn = isBindKey ? thisBinding[func] : func;

		        length = args.length;
		        if (argPos) {
		          args = reorder(args, argPos);
		        } else if (isFlip && length > 1) {
		          args.reverse();
		        }
		        if (isAry && ary < length) {
		          args.length = ary;
		        }
		        if (this && this !== root && this instanceof wrapper) {
		          fn = Ctor || createCtor(fn);
		        }
		        return fn.apply(thisBinding, args);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a function like `_.invertBy`.
		     *
		     * @private
		     * @param {Function} setter The function to set accumulator values.
		     * @param {Function} toIteratee The function to resolve iteratees.
		     * @returns {Function} Returns the new inverter function.
		     */
		    function createInverter(setter, toIteratee) {
		      return function(object, iteratee) {
		        return baseInverter(object, setter, toIteratee(iteratee), {});
		      };
		    }

		    /**
		     * Creates a function that performs a mathematical operation on two values.
		     *
		     * @private
		     * @param {Function} operator The function to perform the operation.
		     * @param {number} [defaultValue] The value used for `undefined` arguments.
		     * @returns {Function} Returns the new mathematical operation function.
		     */
		    function createMathOperation(operator, defaultValue) {
		      return function(value, other) {
		        var result;
		        if (value === undefined$1 && other === undefined$1) {
		          return defaultValue;
		        }
		        if (value !== undefined$1) {
		          result = value;
		        }
		        if (other !== undefined$1) {
		          if (result === undefined$1) {
		            return other;
		          }
		          if (typeof value == 'string' || typeof other == 'string') {
		            value = baseToString(value);
		            other = baseToString(other);
		          } else {
		            value = baseToNumber(value);
		            other = baseToNumber(other);
		          }
		          result = operator(value, other);
		        }
		        return result;
		      };
		    }

		    /**
		     * Creates a function like `_.over`.
		     *
		     * @private
		     * @param {Function} arrayFunc The function to iterate over iteratees.
		     * @returns {Function} Returns the new over function.
		     */
		    function createOver(arrayFunc) {
		      return flatRest(function(iteratees) {
		        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
		        return baseRest(function(args) {
		          var thisArg = this;
		          return arrayFunc(iteratees, function(iteratee) {
		            return apply(iteratee, thisArg, args);
		          });
		        });
		      });
		    }

		    /**
		     * Creates the padding for `string` based on `length`. The `chars` string
		     * is truncated if the number of characters exceeds `length`.
		     *
		     * @private
		     * @param {number} length The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padding for `string`.
		     */
		    function createPadding(length, chars) {
		      chars = chars === undefined$1 ? ' ' : baseToString(chars);

		      var charsLength = chars.length;
		      if (charsLength < 2) {
		        return charsLength ? baseRepeat(chars, length) : chars;
		      }
		      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
		      return hasUnicode(chars)
		        ? castSlice(stringToArray(result), 0, length).join('')
		        : result.slice(0, length);
		    }

		    /**
		     * Creates a function that wraps `func` to invoke it with the `this` binding
		     * of `thisArg` and `partials` prepended to the arguments it receives.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {*} thisArg The `this` binding of `func`.
		     * @param {Array} partials The arguments to prepend to those provided to
		     *  the new function.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createPartial(func, bitmask, thisArg, partials) {
		      var isBind = bitmask & WRAP_BIND_FLAG,
		          Ctor = createCtor(func);

		      function wrapper() {
		        var argsIndex = -1,
		            argsLength = arguments.length,
		            leftIndex = -1,
		            leftLength = partials.length,
		            args = Array(leftLength + argsLength),
		            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

		        while (++leftIndex < leftLength) {
		          args[leftIndex] = partials[leftIndex];
		        }
		        while (argsLength--) {
		          args[leftIndex++] = arguments[++argsIndex];
		        }
		        return apply(fn, isBind ? thisArg : this, args);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a `_.range` or `_.rangeRight` function.
		     *
		     * @private
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new range function.
		     */
		    function createRange(fromRight) {
		      return function(start, end, step) {
		        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
		          end = step = undefined$1;
		        }
		        // Ensure the sign of `-0` is preserved.
		        start = toFinite(start);
		        if (end === undefined$1) {
		          end = start;
		          start = 0;
		        } else {
		          end = toFinite(end);
		        }
		        step = step === undefined$1 ? (start < end ? 1 : -1) : toFinite(step);
		        return baseRange(start, end, step, fromRight);
		      };
		    }

		    /**
		     * Creates a function that performs a relational operation on two values.
		     *
		     * @private
		     * @param {Function} operator The function to perform the operation.
		     * @returns {Function} Returns the new relational operation function.
		     */
		    function createRelationalOperation(operator) {
		      return function(value, other) {
		        if (!(typeof value == 'string' && typeof other == 'string')) {
		          value = toNumber(value);
		          other = toNumber(other);
		        }
		        return operator(value, other);
		      };
		    }

		    /**
		     * Creates a function that wraps `func` to continue currying.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {Function} wrapFunc The function to create the `func` wrapper.
		     * @param {*} placeholder The placeholder value.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {Array} [partials] The arguments to prepend to those provided to
		     *  the new function.
		     * @param {Array} [holders] The `partials` placeholder indexes.
		     * @param {Array} [argPos] The argument positions of the new function.
		     * @param {number} [ary] The arity cap of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
		      var isCurry = bitmask & WRAP_CURRY_FLAG,
		          newHolders = isCurry ? holders : undefined$1,
		          newHoldersRight = isCurry ? undefined$1 : holders,
		          newPartials = isCurry ? partials : undefined$1,
		          newPartialsRight = isCurry ? undefined$1 : partials;

		      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
		      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

		      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
		        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
		      }
		      var newData = [
		        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
		        newHoldersRight, argPos, ary, arity
		      ];

		      var result = wrapFunc.apply(undefined$1, newData);
		      if (isLaziable(func)) {
		        setData(result, newData);
		      }
		      result.placeholder = placeholder;
		      return setWrapToString(result, func, bitmask);
		    }

		    /**
		     * Creates a function like `_.round`.
		     *
		     * @private
		     * @param {string} methodName The name of the `Math` method to use when rounding.
		     * @returns {Function} Returns the new round function.
		     */
		    function createRound(methodName) {
		      var func = Math[methodName];
		      return function(number, precision) {
		        number = toNumber(number);
		        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
		        if (precision && nativeIsFinite(number)) {
		          // Shift with exponential notation to avoid floating-point issues.
		          // See [MDN](https://mdn.io/round#Examples) for more details.
		          var pair = (toString(number) + 'e').split('e'),
		              value = func(pair[0] + 'e' + (+pair[1] + precision));

		          pair = (toString(value) + 'e').split('e');
		          return +(pair[0] + 'e' + (+pair[1] - precision));
		        }
		        return func(number);
		      };
		    }

		    /**
		     * Creates a set object of `values`.
		     *
		     * @private
		     * @param {Array} values The values to add to the set.
		     * @returns {Object} Returns the new set.
		     */
		    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
		      return new Set(values);
		    };

		    /**
		     * Creates a `_.toPairs` or `_.toPairsIn` function.
		     *
		     * @private
		     * @param {Function} keysFunc The function to get the keys of a given object.
		     * @returns {Function} Returns the new pairs function.
		     */
		    function createToPairs(keysFunc) {
		      return function(object) {
		        var tag = getTag(object);
		        if (tag == mapTag) {
		          return mapToArray(object);
		        }
		        if (tag == setTag) {
		          return setToPairs(object);
		        }
		        return baseToPairs(object, keysFunc(object));
		      };
		    }

		    /**
		     * Creates a function that either curries or invokes `func` with optional
		     * `this` binding and partially applied arguments.
		     *
		     * @private
		     * @param {Function|string} func The function or method name to wrap.
		     * @param {number} bitmask The bitmask flags.
		     *    1 - `_.bind`
		     *    2 - `_.bindKey`
		     *    4 - `_.curry` or `_.curryRight` of a bound function
		     *    8 - `_.curry`
		     *   16 - `_.curryRight`
		     *   32 - `_.partial`
		     *   64 - `_.partialRight`
		     *  128 - `_.rearg`
		     *  256 - `_.ary`
		     *  512 - `_.flip`
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {Array} [partials] The arguments to be partially applied.
		     * @param {Array} [holders] The `partials` placeholder indexes.
		     * @param {Array} [argPos] The argument positions of the new function.
		     * @param {number} [ary] The arity cap of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
		      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
		      if (!isBindKey && typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      var length = partials ? partials.length : 0;
		      if (!length) {
		        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
		        partials = holders = undefined$1;
		      }
		      ary = ary === undefined$1 ? ary : nativeMax(toInteger(ary), 0);
		      arity = arity === undefined$1 ? arity : toInteger(arity);
		      length -= holders ? holders.length : 0;

		      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
		        var partialsRight = partials,
		            holdersRight = holders;

		        partials = holders = undefined$1;
		      }
		      var data = isBindKey ? undefined$1 : getData(func);

		      var newData = [
		        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
		        argPos, ary, arity
		      ];

		      if (data) {
		        mergeData(newData, data);
		      }
		      func = newData[0];
		      bitmask = newData[1];
		      thisArg = newData[2];
		      partials = newData[3];
		      holders = newData[4];
		      arity = newData[9] = newData[9] === undefined$1
		        ? (isBindKey ? 0 : func.length)
		        : nativeMax(newData[9] - length, 0);

		      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
		        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
		      }
		      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
		        var result = createBind(func, bitmask, thisArg);
		      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
		        result = createCurry(func, bitmask, arity);
		      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
		        result = createPartial(func, bitmask, thisArg, partials);
		      } else {
		        result = createHybrid.apply(undefined$1, newData);
		      }
		      var setter = data ? baseSetData : setData;
		      return setWrapToString(setter(result, newData), func, bitmask);
		    }

		    /**
		     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
		     * of source objects to the destination object for all destination properties
		     * that resolve to `undefined`.
		     *
		     * @private
		     * @param {*} objValue The destination value.
		     * @param {*} srcValue The source value.
		     * @param {string} key The key of the property to assign.
		     * @param {Object} object The parent object of `objValue`.
		     * @returns {*} Returns the value to assign.
		     */
		    function customDefaultsAssignIn(objValue, srcValue, key, object) {
		      if (objValue === undefined$1 ||
		          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
		        return srcValue;
		      }
		      return objValue;
		    }

		    /**
		     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
		     * objects into destination objects that are passed thru.
		     *
		     * @private
		     * @param {*} objValue The destination value.
		     * @param {*} srcValue The source value.
		     * @param {string} key The key of the property to merge.
		     * @param {Object} object The parent object of `objValue`.
		     * @param {Object} source The parent object of `srcValue`.
		     * @param {Object} [stack] Tracks traversed source values and their merged
		     *  counterparts.
		     * @returns {*} Returns the value to assign.
		     */
		    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
		      if (isObject(objValue) && isObject(srcValue)) {
		        // Recursively merge objects and arrays (susceptible to call stack limits).
		        stack.set(srcValue, objValue);
		        baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
		        stack['delete'](srcValue);
		      }
		      return objValue;
		    }

		    /**
		     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
		     * objects.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @param {string} key The key of the property to inspect.
		     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
		     */
		    function customOmitClone(value) {
		      return isPlainObject(value) ? undefined$1 : value;
		    }

		    /**
		     * A specialized version of `baseIsEqualDeep` for arrays with support for
		     * partial deep comparisons.
		     *
		     * @private
		     * @param {Array} array The array to compare.
		     * @param {Array} other The other array to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} stack Tracks traversed `array` and `other` objects.
		     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
		     */
		    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
		      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
		          arrLength = array.length,
		          othLength = other.length;

		      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
		        return false;
		      }
		      // Check that cyclic values are equal.
		      var arrStacked = stack.get(array);
		      var othStacked = stack.get(other);
		      if (arrStacked && othStacked) {
		        return arrStacked == other && othStacked == array;
		      }
		      var index = -1,
		          result = true,
		          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined$1;

		      stack.set(array, other);
		      stack.set(other, array);

		      // Ignore non-index properties.
		      while (++index < arrLength) {
		        var arrValue = array[index],
		            othValue = other[index];

		        if (customizer) {
		          var compared = isPartial
		            ? customizer(othValue, arrValue, index, other, array, stack)
		            : customizer(arrValue, othValue, index, array, other, stack);
		        }
		        if (compared !== undefined$1) {
		          if (compared) {
		            continue;
		          }
		          result = false;
		          break;
		        }
		        // Recursively compare arrays (susceptible to call stack limits).
		        if (seen) {
		          if (!arraySome(other, function(othValue, othIndex) {
		                if (!cacheHas(seen, othIndex) &&
		                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
		                  return seen.push(othIndex);
		                }
		              })) {
		            result = false;
		            break;
		          }
		        } else if (!(
		              arrValue === othValue ||
		                equalFunc(arrValue, othValue, bitmask, customizer, stack)
		            )) {
		          result = false;
		          break;
		        }
		      }
		      stack['delete'](array);
		      stack['delete'](other);
		      return result;
		    }

		    /**
		     * A specialized version of `baseIsEqualDeep` for comparing objects of
		     * the same `toStringTag`.
		     *
		     * **Note:** This function only supports comparing values with tags of
		     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {string} tag The `toStringTag` of the objects to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} stack Tracks traversed `object` and `other` objects.
		     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		     */
		    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
		      switch (tag) {
		        case dataViewTag:
		          if ((object.byteLength != other.byteLength) ||
		              (object.byteOffset != other.byteOffset)) {
		            return false;
		          }
		          object = object.buffer;
		          other = other.buffer;

		        case arrayBufferTag:
		          if ((object.byteLength != other.byteLength) ||
		              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
		            return false;
		          }
		          return true;

		        case boolTag:
		        case dateTag:
		        case numberTag:
		          // Coerce booleans to `1` or `0` and dates to milliseconds.
		          // Invalid dates are coerced to `NaN`.
		          return eq(+object, +other);

		        case errorTag:
		          return object.name == other.name && object.message == other.message;

		        case regexpTag:
		        case stringTag:
		          // Coerce regexes to strings and treat strings, primitives and objects,
		          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
		          // for more details.
		          return object == (other + '');

		        case mapTag:
		          var convert = mapToArray;

		        case setTag:
		          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
		          convert || (convert = setToArray);

		          if (object.size != other.size && !isPartial) {
		            return false;
		          }
		          // Assume cyclic values are equal.
		          var stacked = stack.get(object);
		          if (stacked) {
		            return stacked == other;
		          }
		          bitmask |= COMPARE_UNORDERED_FLAG;

		          // Recursively compare objects (susceptible to call stack limits).
		          stack.set(object, other);
		          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
		          stack['delete'](object);
		          return result;

		        case symbolTag:
		          if (symbolValueOf) {
		            return symbolValueOf.call(object) == symbolValueOf.call(other);
		          }
		      }
		      return false;
		    }

		    /**
		     * A specialized version of `baseIsEqualDeep` for objects with support for
		     * partial deep comparisons.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} stack Tracks traversed `object` and `other` objects.
		     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		     */
		    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
		      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
		          objProps = getAllKeys(object),
		          objLength = objProps.length,
		          othProps = getAllKeys(other),
		          othLength = othProps.length;

		      if (objLength != othLength && !isPartial) {
		        return false;
		      }
		      var index = objLength;
		      while (index--) {
		        var key = objProps[index];
		        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
		          return false;
		        }
		      }
		      // Check that cyclic values are equal.
		      var objStacked = stack.get(object);
		      var othStacked = stack.get(other);
		      if (objStacked && othStacked) {
		        return objStacked == other && othStacked == object;
		      }
		      var result = true;
		      stack.set(object, other);
		      stack.set(other, object);

		      var skipCtor = isPartial;
		      while (++index < objLength) {
		        key = objProps[index];
		        var objValue = object[key],
		            othValue = other[key];

		        if (customizer) {
		          var compared = isPartial
		            ? customizer(othValue, objValue, key, other, object, stack)
		            : customizer(objValue, othValue, key, object, other, stack);
		        }
		        // Recursively compare objects (susceptible to call stack limits).
		        if (!(compared === undefined$1
		              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
		              : compared
		            )) {
		          result = false;
		          break;
		        }
		        skipCtor || (skipCtor = key == 'constructor');
		      }
		      if (result && !skipCtor) {
		        var objCtor = object.constructor,
		            othCtor = other.constructor;

		        // Non `Object` object instances with different constructors are not equal.
		        if (objCtor != othCtor &&
		            ('constructor' in object && 'constructor' in other) &&
		            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
		              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
		          result = false;
		        }
		      }
		      stack['delete'](object);
		      stack['delete'](other);
		      return result;
		    }

		    /**
		     * A specialized version of `baseRest` which flattens the rest array.
		     *
		     * @private
		     * @param {Function} func The function to apply a rest parameter to.
		     * @returns {Function} Returns the new function.
		     */
		    function flatRest(func) {
		      return setToString(overRest(func, undefined$1, flatten), func + '');
		    }

		    /**
		     * Creates an array of own enumerable property names and symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names and symbols.
		     */
		    function getAllKeys(object) {
		      return baseGetAllKeys(object, keys, getSymbols);
		    }

		    /**
		     * Creates an array of own and inherited enumerable property names and
		     * symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names and symbols.
		     */
		    function getAllKeysIn(object) {
		      return baseGetAllKeys(object, keysIn, getSymbolsIn);
		    }

		    /**
		     * Gets metadata for `func`.
		     *
		     * @private
		     * @param {Function} func The function to query.
		     * @returns {*} Returns the metadata for `func`.
		     */
		    var getData = !metaMap ? noop : function(func) {
		      return metaMap.get(func);
		    };

		    /**
		     * Gets the name of `func`.
		     *
		     * @private
		     * @param {Function} func The function to query.
		     * @returns {string} Returns the function name.
		     */
		    function getFuncName(func) {
		      var result = (func.name + ''),
		          array = realNames[result],
		          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

		      while (length--) {
		        var data = array[length],
		            otherFunc = data.func;
		        if (otherFunc == null || otherFunc == func) {
		          return data.name;
		        }
		      }
		      return result;
		    }

		    /**
		     * Gets the argument placeholder value for `func`.
		     *
		     * @private
		     * @param {Function} func The function to inspect.
		     * @returns {*} Returns the placeholder value.
		     */
		    function getHolder(func) {
		      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
		      return object.placeholder;
		    }

		    /**
		     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
		     * this function returns the custom method, otherwise it returns `baseIteratee`.
		     * If arguments are provided, the chosen function is invoked with them and
		     * its result is returned.
		     *
		     * @private
		     * @param {*} [value] The value to convert to an iteratee.
		     * @param {number} [arity] The arity of the created iteratee.
		     * @returns {Function} Returns the chosen function or its result.
		     */
		    function getIteratee() {
		      var result = lodash.iteratee || iteratee;
		      result = result === iteratee ? baseIteratee : result;
		      return arguments.length ? result(arguments[0], arguments[1]) : result;
		    }

		    /**
		     * Gets the data for `map`.
		     *
		     * @private
		     * @param {Object} map The map to query.
		     * @param {string} key The reference key.
		     * @returns {*} Returns the map data.
		     */
		    function getMapData(map, key) {
		      var data = map.__data__;
		      return isKeyable(key)
		        ? data[typeof key == 'string' ? 'string' : 'hash']
		        : data.map;
		    }

		    /**
		     * Gets the property names, values, and compare flags of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the match data of `object`.
		     */
		    function getMatchData(object) {
		      var result = keys(object),
		          length = result.length;

		      while (length--) {
		        var key = result[length],
		            value = object[key];

		        result[length] = [key, value, isStrictComparable(value)];
		      }
		      return result;
		    }

		    /**
		     * Gets the native function at `key` of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {string} key The key of the method to get.
		     * @returns {*} Returns the function if it's native, else `undefined`.
		     */
		    function getNative(object, key) {
		      var value = getValue(object, key);
		      return baseIsNative(value) ? value : undefined$1;
		    }

		    /**
		     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @returns {string} Returns the raw `toStringTag`.
		     */
		    function getRawTag(value) {
		      var isOwn = hasOwnProperty.call(value, symToStringTag),
		          tag = value[symToStringTag];

		      try {
		        value[symToStringTag] = undefined$1;
		        var unmasked = true;
		      } catch (e) {}

		      var result = nativeObjectToString.call(value);
		      if (unmasked) {
		        if (isOwn) {
		          value[symToStringTag] = tag;
		        } else {
		          delete value[symToStringTag];
		        }
		      }
		      return result;
		    }

		    /**
		     * Creates an array of the own enumerable symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of symbols.
		     */
		    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
		      if (object == null) {
		        return [];
		      }
		      object = Object(object);
		      return arrayFilter(nativeGetSymbols(object), function(symbol) {
		        return propertyIsEnumerable.call(object, symbol);
		      });
		    };

		    /**
		     * Creates an array of the own and inherited enumerable symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of symbols.
		     */
		    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
		      var result = [];
		      while (object) {
		        arrayPush(result, getSymbols(object));
		        object = getPrototype(object);
		      }
		      return result;
		    };

		    /**
		     * Gets the `toStringTag` of `value`.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @returns {string} Returns the `toStringTag`.
		     */
		    var getTag = baseGetTag;

		    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
		    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
		        (Map && getTag(new Map) != mapTag) ||
		        (Promise && getTag(Promise.resolve()) != promiseTag) ||
		        (Set && getTag(new Set) != setTag) ||
		        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
		      getTag = function(value) {
		        var result = baseGetTag(value),
		            Ctor = result == objectTag ? value.constructor : undefined$1,
		            ctorString = Ctor ? toSource(Ctor) : '';

		        if (ctorString) {
		          switch (ctorString) {
		            case dataViewCtorString: return dataViewTag;
		            case mapCtorString: return mapTag;
		            case promiseCtorString: return promiseTag;
		            case setCtorString: return setTag;
		            case weakMapCtorString: return weakMapTag;
		          }
		        }
		        return result;
		      };
		    }

		    /**
		     * Gets the view, applying any `transforms` to the `start` and `end` positions.
		     *
		     * @private
		     * @param {number} start The start of the view.
		     * @param {number} end The end of the view.
		     * @param {Array} transforms The transformations to apply to the view.
		     * @returns {Object} Returns an object containing the `start` and `end`
		     *  positions of the view.
		     */
		    function getView(start, end, transforms) {
		      var index = -1,
		          length = transforms.length;

		      while (++index < length) {
		        var data = transforms[index],
		            size = data.size;

		        switch (data.type) {
		          case 'drop':      start += size; break;
		          case 'dropRight': end -= size; break;
		          case 'take':      end = nativeMin(end, start + size); break;
		          case 'takeRight': start = nativeMax(start, end - size); break;
		        }
		      }
		      return { 'start': start, 'end': end };
		    }

		    /**
		     * Extracts wrapper details from the `source` body comment.
		     *
		     * @private
		     * @param {string} source The source to inspect.
		     * @returns {Array} Returns the wrapper details.
		     */
		    function getWrapDetails(source) {
		      var match = source.match(reWrapDetails);
		      return match ? match[1].split(reSplitDetails) : [];
		    }

		    /**
		     * Checks if `path` exists on `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path to check.
		     * @param {Function} hasFunc The function to check properties.
		     * @returns {boolean} Returns `true` if `path` exists, else `false`.
		     */
		    function hasPath(object, path, hasFunc) {
		      path = castPath(path, object);

		      var index = -1,
		          length = path.length,
		          result = false;

		      while (++index < length) {
		        var key = toKey(path[index]);
		        if (!(result = object != null && hasFunc(object, key))) {
		          break;
		        }
		        object = object[key];
		      }
		      if (result || ++index != length) {
		        return result;
		      }
		      length = object == null ? 0 : object.length;
		      return !!length && isLength(length) && isIndex(key, length) &&
		        (isArray(object) || isArguments(object));
		    }

		    /**
		     * Initializes an array clone.
		     *
		     * @private
		     * @param {Array} array The array to clone.
		     * @returns {Array} Returns the initialized clone.
		     */
		    function initCloneArray(array) {
		      var length = array.length,
		          result = new array.constructor(length);

		      // Add properties assigned by `RegExp#exec`.
		      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
		        result.index = array.index;
		        result.input = array.input;
		      }
		      return result;
		    }

		    /**
		     * Initializes an object clone.
		     *
		     * @private
		     * @param {Object} object The object to clone.
		     * @returns {Object} Returns the initialized clone.
		     */
		    function initCloneObject(object) {
		      return (typeof object.constructor == 'function' && !isPrototype(object))
		        ? baseCreate(getPrototype(object))
		        : {};
		    }

		    /**
		     * Initializes an object clone based on its `toStringTag`.
		     *
		     * **Note:** This function only supports cloning values with tags of
		     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
		     *
		     * @private
		     * @param {Object} object The object to clone.
		     * @param {string} tag The `toStringTag` of the object to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the initialized clone.
		     */
		    function initCloneByTag(object, tag, isDeep) {
		      var Ctor = object.constructor;
		      switch (tag) {
		        case arrayBufferTag:
		          return cloneArrayBuffer(object);

		        case boolTag:
		        case dateTag:
		          return new Ctor(+object);

		        case dataViewTag:
		          return cloneDataView(object, isDeep);

		        case float32Tag: case float64Tag:
		        case int8Tag: case int16Tag: case int32Tag:
		        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
		          return cloneTypedArray(object, isDeep);

		        case mapTag:
		          return new Ctor;

		        case numberTag:
		        case stringTag:
		          return new Ctor(object);

		        case regexpTag:
		          return cloneRegExp(object);

		        case setTag:
		          return new Ctor;

		        case symbolTag:
		          return cloneSymbol(object);
		      }
		    }

		    /**
		     * Inserts wrapper `details` in a comment at the top of the `source` body.
		     *
		     * @private
		     * @param {string} source The source to modify.
		     * @returns {Array} details The details to insert.
		     * @returns {string} Returns the modified source.
		     */
		    function insertWrapDetails(source, details) {
		      var length = details.length;
		      if (!length) {
		        return source;
		      }
		      var lastIndex = length - 1;
		      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
		      details = details.join(length > 2 ? ', ' : ' ');
		      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
		    }

		    /**
		     * Checks if `value` is a flattenable `arguments` object or array.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
		     */
		    function isFlattenable(value) {
		      return isArray(value) || isArguments(value) ||
		        !!(spreadableSymbol && value && value[spreadableSymbol]);
		    }

		    /**
		     * Checks if `value` is a valid array-like index.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
		     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
		     */
		    function isIndex(value, length) {
		      var type = typeof value;
		      length = length == null ? MAX_SAFE_INTEGER : length;

		      return !!length &&
		        (type == 'number' ||
		          (type != 'symbol' && reIsUint.test(value))) &&
		            (value > -1 && value % 1 == 0 && value < length);
		    }

		    /**
		     * Checks if the given arguments are from an iteratee call.
		     *
		     * @private
		     * @param {*} value The potential iteratee value argument.
		     * @param {*} index The potential iteratee index or key argument.
		     * @param {*} object The potential iteratee object argument.
		     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
		     *  else `false`.
		     */
		    function isIterateeCall(value, index, object) {
		      if (!isObject(object)) {
		        return false;
		      }
		      var type = typeof index;
		      if (type == 'number'
		            ? (isArrayLike(object) && isIndex(index, object.length))
		            : (type == 'string' && index in object)
		          ) {
		        return eq(object[index], value);
		      }
		      return false;
		    }

		    /**
		     * Checks if `value` is a property name and not a property path.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @param {Object} [object] The object to query keys on.
		     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
		     */
		    function isKey(value, object) {
		      if (isArray(value)) {
		        return false;
		      }
		      var type = typeof value;
		      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
		          value == null || isSymbol(value)) {
		        return true;
		      }
		      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
		        (object != null && value in Object(object));
		    }

		    /**
		     * Checks if `value` is suitable for use as unique object key.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
		     */
		    function isKeyable(value) {
		      var type = typeof value;
		      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
		        ? (value !== '__proto__')
		        : (value === null);
		    }

		    /**
		     * Checks if `func` has a lazy counterpart.
		     *
		     * @private
		     * @param {Function} func The function to check.
		     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
		     *  else `false`.
		     */
		    function isLaziable(func) {
		      var funcName = getFuncName(func),
		          other = lodash[funcName];

		      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
		        return false;
		      }
		      if (func === other) {
		        return true;
		      }
		      var data = getData(other);
		      return !!data && func === data[0];
		    }

		    /**
		     * Checks if `func` has its source masked.
		     *
		     * @private
		     * @param {Function} func The function to check.
		     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
		     */
		    function isMasked(func) {
		      return !!maskSrcKey && (maskSrcKey in func);
		    }

		    /**
		     * Checks if `func` is capable of being masked.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
		     */
		    var isMaskable = coreJsData ? isFunction : stubFalse;

		    /**
		     * Checks if `value` is likely a prototype object.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
		     */
		    function isPrototype(value) {
		      var Ctor = value && value.constructor,
		          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

		      return value === proto;
		    }

		    /**
		     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` if suitable for strict
		     *  equality comparisons, else `false`.
		     */
		    function isStrictComparable(value) {
		      return value === value && !isObject(value);
		    }

		    /**
		     * A specialized version of `matchesProperty` for source values suitable
		     * for strict equality comparisons, i.e. `===`.
		     *
		     * @private
		     * @param {string} key The key of the property to get.
		     * @param {*} srcValue The value to match.
		     * @returns {Function} Returns the new spec function.
		     */
		    function matchesStrictComparable(key, srcValue) {
		      return function(object) {
		        if (object == null) {
		          return false;
		        }
		        return object[key] === srcValue &&
		          (srcValue !== undefined$1 || (key in Object(object)));
		      };
		    }

		    /**
		     * A specialized version of `_.memoize` which clears the memoized function's
		     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
		     *
		     * @private
		     * @param {Function} func The function to have its output memoized.
		     * @returns {Function} Returns the new memoized function.
		     */
		    function memoizeCapped(func) {
		      var result = memoize(func, function(key) {
		        if (cache.size === MAX_MEMOIZE_SIZE) {
		          cache.clear();
		        }
		        return key;
		      });

		      var cache = result.cache;
		      return result;
		    }

		    /**
		     * Merges the function metadata of `source` into `data`.
		     *
		     * Merging metadata reduces the number of wrappers used to invoke a function.
		     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
		     * may be applied regardless of execution order. Methods like `_.ary` and
		     * `_.rearg` modify function arguments, making the order in which they are
		     * executed important, preventing the merging of metadata. However, we make
		     * an exception for a safe combined case where curried functions have `_.ary`
		     * and or `_.rearg` applied.
		     *
		     * @private
		     * @param {Array} data The destination metadata.
		     * @param {Array} source The source metadata.
		     * @returns {Array} Returns `data`.
		     */
		    function mergeData(data, source) {
		      var bitmask = data[1],
		          srcBitmask = source[1],
		          newBitmask = bitmask | srcBitmask,
		          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

		      var isCombo =
		        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
		        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
		        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

		      // Exit early if metadata can't be merged.
		      if (!(isCommon || isCombo)) {
		        return data;
		      }
		      // Use source `thisArg` if available.
		      if (srcBitmask & WRAP_BIND_FLAG) {
		        data[2] = source[2];
		        // Set when currying a bound function.
		        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
		      }
		      // Compose partial arguments.
		      var value = source[3];
		      if (value) {
		        var partials = data[3];
		        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
		        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
		      }
		      // Compose partial right arguments.
		      value = source[5];
		      if (value) {
		        partials = data[5];
		        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
		        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
		      }
		      // Use source `argPos` if available.
		      value = source[7];
		      if (value) {
		        data[7] = value;
		      }
		      // Use source `ary` if it's smaller.
		      if (srcBitmask & WRAP_ARY_FLAG) {
		        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
		      }
		      // Use source `arity` if one is not provided.
		      if (data[9] == null) {
		        data[9] = source[9];
		      }
		      // Use source `func` and merge bitmasks.
		      data[0] = source[0];
		      data[1] = newBitmask;

		      return data;
		    }

		    /**
		     * This function is like
		     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
		     * except that it includes inherited enumerable properties.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     */
		    function nativeKeysIn(object) {
		      var result = [];
		      if (object != null) {
		        for (var key in Object(object)) {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * Converts `value` to a string using `Object.prototype.toString`.
		     *
		     * @private
		     * @param {*} value The value to convert.
		     * @returns {string} Returns the converted string.
		     */
		    function objectToString(value) {
		      return nativeObjectToString.call(value);
		    }

		    /**
		     * A specialized version of `baseRest` which transforms the rest array.
		     *
		     * @private
		     * @param {Function} func The function to apply a rest parameter to.
		     * @param {number} [start=func.length-1] The start position of the rest parameter.
		     * @param {Function} transform The rest array transform.
		     * @returns {Function} Returns the new function.
		     */
		    function overRest(func, start, transform) {
		      start = nativeMax(start === undefined$1 ? (func.length - 1) : start, 0);
		      return function() {
		        var args = arguments,
		            index = -1,
		            length = nativeMax(args.length - start, 0),
		            array = Array(length);

		        while (++index < length) {
		          array[index] = args[start + index];
		        }
		        index = -1;
		        var otherArgs = Array(start + 1);
		        while (++index < start) {
		          otherArgs[index] = args[index];
		        }
		        otherArgs[start] = transform(array);
		        return apply(func, this, otherArgs);
		      };
		    }

		    /**
		     * Gets the parent value at `path` of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array} path The path to get the parent value of.
		     * @returns {*} Returns the parent value.
		     */
		    function parent(object, path) {
		      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
		    }

		    /**
		     * Reorder `array` according to the specified indexes where the element at
		     * the first index is assigned as the first element, the element at
		     * the second index is assigned as the second element, and so on.
		     *
		     * @private
		     * @param {Array} array The array to reorder.
		     * @param {Array} indexes The arranged array indexes.
		     * @returns {Array} Returns `array`.
		     */
		    function reorder(array, indexes) {
		      var arrLength = array.length,
		          length = nativeMin(indexes.length, arrLength),
		          oldArray = copyArray(array);

		      while (length--) {
		        var index = indexes[length];
		        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
		      }
		      return array;
		    }

		    /**
		     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {string} key The key of the property to get.
		     * @returns {*} Returns the property value.
		     */
		    function safeGet(object, key) {
		      if (key === 'constructor' && typeof object[key] === 'function') {
		        return;
		      }

		      if (key == '__proto__') {
		        return;
		      }

		      return object[key];
		    }

		    /**
		     * Sets metadata for `func`.
		     *
		     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
		     * period of time, it will trip its breaker and transition to an identity
		     * function to avoid garbage collection pauses in V8. See
		     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
		     * for more details.
		     *
		     * @private
		     * @param {Function} func The function to associate metadata with.
		     * @param {*} data The metadata.
		     * @returns {Function} Returns `func`.
		     */
		    var setData = shortOut(baseSetData);

		    /**
		     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
		     *
		     * @private
		     * @param {Function} func The function to delay.
		     * @param {number} wait The number of milliseconds to delay invocation.
		     * @returns {number|Object} Returns the timer id or timeout object.
		     */
		    var setTimeout = ctxSetTimeout || function(func, wait) {
		      return root.setTimeout(func, wait);
		    };

		    /**
		     * Sets the `toString` method of `func` to return `string`.
		     *
		     * @private
		     * @param {Function} func The function to modify.
		     * @param {Function} string The `toString` result.
		     * @returns {Function} Returns `func`.
		     */
		    var setToString = shortOut(baseSetToString);

		    /**
		     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
		     * with wrapper details in a comment at the top of the source body.
		     *
		     * @private
		     * @param {Function} wrapper The function to modify.
		     * @param {Function} reference The reference function.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @returns {Function} Returns `wrapper`.
		     */
		    function setWrapToString(wrapper, reference, bitmask) {
		      var source = (reference + '');
		      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
		    }

		    /**
		     * Creates a function that'll short out and invoke `identity` instead
		     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
		     * milliseconds.
		     *
		     * @private
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new shortable function.
		     */
		    function shortOut(func) {
		      var count = 0,
		          lastCalled = 0;

		      return function() {
		        var stamp = nativeNow(),
		            remaining = HOT_SPAN - (stamp - lastCalled);

		        lastCalled = stamp;
		        if (remaining > 0) {
		          if (++count >= HOT_COUNT) {
		            return arguments[0];
		          }
		        } else {
		          count = 0;
		        }
		        return func.apply(undefined$1, arguments);
		      };
		    }

		    /**
		     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
		     *
		     * @private
		     * @param {Array} array The array to shuffle.
		     * @param {number} [size=array.length] The size of `array`.
		     * @returns {Array} Returns `array`.
		     */
		    function shuffleSelf(array, size) {
		      var index = -1,
		          length = array.length,
		          lastIndex = length - 1;

		      size = size === undefined$1 ? length : size;
		      while (++index < size) {
		        var rand = baseRandom(index, lastIndex),
		            value = array[rand];

		        array[rand] = array[index];
		        array[index] = value;
		      }
		      array.length = size;
		      return array;
		    }

		    /**
		     * Converts `string` to a property path array.
		     *
		     * @private
		     * @param {string} string The string to convert.
		     * @returns {Array} Returns the property path array.
		     */
		    var stringToPath = memoizeCapped(function(string) {
		      var result = [];
		      if (string.charCodeAt(0) === 46 /* . */) {
		        result.push('');
		      }
		      string.replace(rePropName, function(match, number, quote, subString) {
		        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
		      });
		      return result;
		    });

		    /**
		     * Converts `value` to a string key if it's not a string or symbol.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {string|symbol} Returns the key.
		     */
		    function toKey(value) {
		      if (typeof value == 'string' || isSymbol(value)) {
		        return value;
		      }
		      var result = (value + '');
		      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
		    }

		    /**
		     * Converts `func` to its source code.
		     *
		     * @private
		     * @param {Function} func The function to convert.
		     * @returns {string} Returns the source code.
		     */
		    function toSource(func) {
		      if (func != null) {
		        try {
		          return funcToString.call(func);
		        } catch (e) {}
		        try {
		          return (func + '');
		        } catch (e) {}
		      }
		      return '';
		    }

		    /**
		     * Updates wrapper `details` based on `bitmask` flags.
		     *
		     * @private
		     * @returns {Array} details The details to modify.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @returns {Array} Returns `details`.
		     */
		    function updateWrapDetails(details, bitmask) {
		      arrayEach(wrapFlags, function(pair) {
		        var value = '_.' + pair[0];
		        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
		          details.push(value);
		        }
		      });
		      return details.sort();
		    }

		    /**
		     * Creates a clone of `wrapper`.
		     *
		     * @private
		     * @param {Object} wrapper The wrapper to clone.
		     * @returns {Object} Returns the cloned wrapper.
		     */
		    function wrapperClone(wrapper) {
		      if (wrapper instanceof LazyWrapper) {
		        return wrapper.clone();
		      }
		      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
		      result.__actions__ = copyArray(wrapper.__actions__);
		      result.__index__  = wrapper.__index__;
		      result.__values__ = wrapper.__values__;
		      return result;
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an array of elements split into groups the length of `size`.
		     * If `array` can't be split evenly, the final chunk will be the remaining
		     * elements.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to process.
		     * @param {number} [size=1] The length of each chunk
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the new array of chunks.
		     * @example
		     *
		     * _.chunk(['a', 'b', 'c', 'd'], 2);
		     * // => [['a', 'b'], ['c', 'd']]
		     *
		     * _.chunk(['a', 'b', 'c', 'd'], 3);
		     * // => [['a', 'b', 'c'], ['d']]
		     */
		    function chunk(array, size, guard) {
		      if ((guard ? isIterateeCall(array, size, guard) : size === undefined$1)) {
		        size = 1;
		      } else {
		        size = nativeMax(toInteger(size), 0);
		      }
		      var length = array == null ? 0 : array.length;
		      if (!length || size < 1) {
		        return [];
		      }
		      var index = 0,
		          resIndex = 0,
		          result = Array(nativeCeil(length / size));

		      while (index < length) {
		        result[resIndex++] = baseSlice(array, index, (index += size));
		      }
		      return result;
		    }

		    /**
		     * Creates an array with all falsey values removed. The values `false`, `null`,
		     * `0`, `""`, `undefined`, and `NaN` are falsey.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to compact.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.compact([0, 1, false, 2, '', 3]);
		     * // => [1, 2, 3]
		     */
		    function compact(array) {
		      var index = -1,
		          length = array == null ? 0 : array.length,
		          resIndex = 0,
		          result = [];

		      while (++index < length) {
		        var value = array[index];
		        if (value) {
		          result[resIndex++] = value;
		        }
		      }
		      return result;
		    }

		    /**
		     * Creates a new array concatenating `array` with any additional arrays
		     * and/or values.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to concatenate.
		     * @param {...*} [values] The values to concatenate.
		     * @returns {Array} Returns the new concatenated array.
		     * @example
		     *
		     * var array = [1];
		     * var other = _.concat(array, 2, [3], [[4]]);
		     *
		     * console.log(other);
		     * // => [1, 2, 3, [4]]
		     *
		     * console.log(array);
		     * // => [1]
		     */
		    function concat() {
		      var length = arguments.length;
		      if (!length) {
		        return [];
		      }
		      var args = Array(length - 1),
		          array = arguments[0],
		          index = length;

		      while (index--) {
		        args[index - 1] = arguments[index];
		      }
		      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
		    }

		    /**
		     * Creates an array of `array` values not included in the other given arrays
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons. The order and references of result values are
		     * determined by the first array.
		     *
		     * **Note:** Unlike `_.pullAll`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...Array} [values] The values to exclude.
		     * @returns {Array} Returns the new array of filtered values.
		     * @see _.without, _.xor
		     * @example
		     *
		     * _.difference([2, 1], [2, 3]);
		     * // => [1]
		     */
		    var difference = baseRest(function(array, values) {
		      return isArrayLikeObject(array)
		        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
		        : [];
		    });

		    /**
		     * This method is like `_.difference` except that it accepts `iteratee` which
		     * is invoked for each element of `array` and `values` to generate the criterion
		     * by which they're compared. The order and references of result values are
		     * determined by the first array. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...Array} [values] The values to exclude.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
		     * // => [1.2]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
		     * // => [{ 'x': 2 }]
		     */
		    var differenceBy = baseRest(function(array, values) {
		      var iteratee = last(values);
		      if (isArrayLikeObject(iteratee)) {
		        iteratee = undefined$1;
		      }
		      return isArrayLikeObject(array)
		        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
		        : [];
		    });

		    /**
		     * This method is like `_.difference` except that it accepts `comparator`
		     * which is invoked to compare elements of `array` to `values`. The order and
		     * references of result values are determined by the first array. The comparator
		     * is invoked with two arguments: (arrVal, othVal).
		     *
		     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...Array} [values] The values to exclude.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     *
		     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
		     * // => [{ 'x': 2, 'y': 1 }]
		     */
		    var differenceWith = baseRest(function(array, values) {
		      var comparator = last(values);
		      if (isArrayLikeObject(comparator)) {
		        comparator = undefined$1;
		      }
		      return isArrayLikeObject(array)
		        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined$1, comparator)
		        : [];
		    });

		    /**
		     * Creates a slice of `array` with `n` elements dropped from the beginning.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.5.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to drop.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.drop([1, 2, 3]);
		     * // => [2, 3]
		     *
		     * _.drop([1, 2, 3], 2);
		     * // => [3]
		     *
		     * _.drop([1, 2, 3], 5);
		     * // => []
		     *
		     * _.drop([1, 2, 3], 0);
		     * // => [1, 2, 3]
		     */
		    function drop(array, n, guard) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      return baseSlice(array, n < 0 ? 0 : n, length);
		    }

		    /**
		     * Creates a slice of `array` with `n` elements dropped from the end.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to drop.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.dropRight([1, 2, 3]);
		     * // => [1, 2]
		     *
		     * _.dropRight([1, 2, 3], 2);
		     * // => [1]
		     *
		     * _.dropRight([1, 2, 3], 5);
		     * // => []
		     *
		     * _.dropRight([1, 2, 3], 0);
		     * // => [1, 2, 3]
		     */
		    function dropRight(array, n, guard) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      n = length - n;
		      return baseSlice(array, 0, n < 0 ? 0 : n);
		    }

		    /**
		     * Creates a slice of `array` excluding elements dropped from the end.
		     * Elements are dropped until `predicate` returns falsey. The predicate is
		     * invoked with three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': true },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': false }
		     * ];
		     *
		     * _.dropRightWhile(users, function(o) { return !o.active; });
		     * // => objects for ['barney']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
		     * // => objects for ['barney', 'fred']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.dropRightWhile(users, ['active', false]);
		     * // => objects for ['barney']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.dropRightWhile(users, 'active');
		     * // => objects for ['barney', 'fred', 'pebbles']
		     */
		    function dropRightWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3), true, true)
		        : [];
		    }

		    /**
		     * Creates a slice of `array` excluding elements dropped from the beginning.
		     * Elements are dropped until `predicate` returns falsey. The predicate is
		     * invoked with three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': false },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': true }
		     * ];
		     *
		     * _.dropWhile(users, function(o) { return !o.active; });
		     * // => objects for ['pebbles']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.dropWhile(users, { 'user': 'barney', 'active': false });
		     * // => objects for ['fred', 'pebbles']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.dropWhile(users, ['active', false]);
		     * // => objects for ['pebbles']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.dropWhile(users, 'active');
		     * // => objects for ['barney', 'fred', 'pebbles']
		     */
		    function dropWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3), true)
		        : [];
		    }

		    /**
		     * Fills elements of `array` with `value` from `start` up to, but not
		     * including, `end`.
		     *
		     * **Note:** This method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.2.0
		     * @category Array
		     * @param {Array} array The array to fill.
		     * @param {*} value The value to fill `array` with.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [1, 2, 3];
		     *
		     * _.fill(array, 'a');
		     * console.log(array);
		     * // => ['a', 'a', 'a']
		     *
		     * _.fill(Array(3), 2);
		     * // => [2, 2, 2]
		     *
		     * _.fill([4, 6, 8, 10], '*', 1, 3);
		     * // => [4, '*', '*', 10]
		     */
		    function fill(array, value, start, end) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
		        start = 0;
		        end = length;
		      }
		      return baseFill(array, value, start, end);
		    }

		    /**
		     * This method is like `_.find` except that it returns the index of the first
		     * element `predicate` returns truthy for instead of the element itself.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @returns {number} Returns the index of the found element, else `-1`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': false },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': true }
		     * ];
		     *
		     * _.findIndex(users, function(o) { return o.user == 'barney'; });
		     * // => 0
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findIndex(users, { 'user': 'fred', 'active': false });
		     * // => 1
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findIndex(users, ['active', false]);
		     * // => 0
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findIndex(users, 'active');
		     * // => 2
		     */
		    function findIndex(array, predicate, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = fromIndex == null ? 0 : toInteger(fromIndex);
		      if (index < 0) {
		        index = nativeMax(length + index, 0);
		      }
		      return baseFindIndex(array, getIteratee(predicate, 3), index);
		    }

		    /**
		     * This method is like `_.findIndex` except that it iterates over elements
		     * of `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=array.length-1] The index to search from.
		     * @returns {number} Returns the index of the found element, else `-1`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': true },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': false }
		     * ];
		     *
		     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
		     * // => 2
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
		     * // => 0
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findLastIndex(users, ['active', false]);
		     * // => 2
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findLastIndex(users, 'active');
		     * // => 0
		     */
		    function findLastIndex(array, predicate, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = length - 1;
		      if (fromIndex !== undefined$1) {
		        index = toInteger(fromIndex);
		        index = fromIndex < 0
		          ? nativeMax(length + index, 0)
		          : nativeMin(index, length - 1);
		      }
		      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
		    }

		    /**
		     * Flattens `array` a single level deep.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to flatten.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * _.flatten([1, [2, [3, [4]], 5]]);
		     * // => [1, 2, [3, [4]], 5]
		     */
		    function flatten(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseFlatten(array, 1) : [];
		    }

		    /**
		     * Recursively flattens `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to flatten.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * _.flattenDeep([1, [2, [3, [4]], 5]]);
		     * // => [1, 2, 3, 4, 5]
		     */
		    function flattenDeep(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseFlatten(array, INFINITY) : [];
		    }

		    /**
		     * Recursively flatten `array` up to `depth` times.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.4.0
		     * @category Array
		     * @param {Array} array The array to flatten.
		     * @param {number} [depth=1] The maximum recursion depth.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * var array = [1, [2, [3, [4]], 5]];
		     *
		     * _.flattenDepth(array, 1);
		     * // => [1, 2, [3, [4]], 5]
		     *
		     * _.flattenDepth(array, 2);
		     * // => [1, 2, 3, [4], 5]
		     */
		    function flattenDepth(array, depth) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      depth = depth === undefined$1 ? 1 : toInteger(depth);
		      return baseFlatten(array, depth);
		    }

		    /**
		     * The inverse of `_.toPairs`; this method returns an object composed
		     * from key-value `pairs`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} pairs The key-value pairs.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * _.fromPairs([['a', 1], ['b', 2]]);
		     * // => { 'a': 1, 'b': 2 }
		     */
		    function fromPairs(pairs) {
		      var index = -1,
		          length = pairs == null ? 0 : pairs.length,
		          result = {};

		      while (++index < length) {
		        var pair = pairs[index];
		        result[pair[0]] = pair[1];
		      }
		      return result;
		    }

		    /**
		     * Gets the first element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @alias first
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {*} Returns the first element of `array`.
		     * @example
		     *
		     * _.head([1, 2, 3]);
		     * // => 1
		     *
		     * _.head([]);
		     * // => undefined
		     */
		    function head(array) {
		      return (array && array.length) ? array[0] : undefined$1;
		    }

		    /**
		     * Gets the index at which the first occurrence of `value` is found in `array`
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons. If `fromIndex` is negative, it's used as the
		     * offset from the end of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.indexOf([1, 2, 1, 2], 2);
		     * // => 1
		     *
		     * // Search from the `fromIndex`.
		     * _.indexOf([1, 2, 1, 2], 2, 2);
		     * // => 3
		     */
		    function indexOf(array, value, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = fromIndex == null ? 0 : toInteger(fromIndex);
		      if (index < 0) {
		        index = nativeMax(length + index, 0);
		      }
		      return baseIndexOf(array, value, index);
		    }

		    /**
		     * Gets all but the last element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.initial([1, 2, 3]);
		     * // => [1, 2]
		     */
		    function initial(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseSlice(array, 0, -1) : [];
		    }

		    /**
		     * Creates an array of unique values that are included in all given arrays
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons. The order and references of result values are
		     * determined by the first array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @returns {Array} Returns the new array of intersecting values.
		     * @example
		     *
		     * _.intersection([2, 1], [2, 3]);
		     * // => [2]
		     */
		    var intersection = baseRest(function(arrays) {
		      var mapped = arrayMap(arrays, castArrayLikeObject);
		      return (mapped.length && mapped[0] === arrays[0])
		        ? baseIntersection(mapped)
		        : [];
		    });

		    /**
		     * This method is like `_.intersection` except that it accepts `iteratee`
		     * which is invoked for each element of each `arrays` to generate the criterion
		     * by which they're compared. The order and references of result values are
		     * determined by the first array. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of intersecting values.
		     * @example
		     *
		     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
		     * // => [2.1]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }]
		     */
		    var intersectionBy = baseRest(function(arrays) {
		      var iteratee = last(arrays),
		          mapped = arrayMap(arrays, castArrayLikeObject);

		      if (iteratee === last(mapped)) {
		        iteratee = undefined$1;
		      } else {
		        mapped.pop();
		      }
		      return (mapped.length && mapped[0] === arrays[0])
		        ? baseIntersection(mapped, getIteratee(iteratee, 2))
		        : [];
		    });

		    /**
		     * This method is like `_.intersection` except that it accepts `comparator`
		     * which is invoked to compare elements of `arrays`. The order and references
		     * of result values are determined by the first array. The comparator is
		     * invoked with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of intersecting values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.intersectionWith(objects, others, _.isEqual);
		     * // => [{ 'x': 1, 'y': 2 }]
		     */
		    var intersectionWith = baseRest(function(arrays) {
		      var comparator = last(arrays),
		          mapped = arrayMap(arrays, castArrayLikeObject);

		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      if (comparator) {
		        mapped.pop();
		      }
		      return (mapped.length && mapped[0] === arrays[0])
		        ? baseIntersection(mapped, undefined$1, comparator)
		        : [];
		    });

		    /**
		     * Converts all elements in `array` into a string separated by `separator`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to convert.
		     * @param {string} [separator=','] The element separator.
		     * @returns {string} Returns the joined string.
		     * @example
		     *
		     * _.join(['a', 'b', 'c'], '~');
		     * // => 'a~b~c'
		     */
		    function join(array, separator) {
		      return array == null ? '' : nativeJoin.call(array, separator);
		    }

		    /**
		     * Gets the last element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {*} Returns the last element of `array`.
		     * @example
		     *
		     * _.last([1, 2, 3]);
		     * // => 3
		     */
		    function last(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? array[length - 1] : undefined$1;
		    }

		    /**
		     * This method is like `_.indexOf` except that it iterates over elements of
		     * `array` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=array.length-1] The index to search from.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.lastIndexOf([1, 2, 1, 2], 2);
		     * // => 3
		     *
		     * // Search from the `fromIndex`.
		     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
		     * // => 1
		     */
		    function lastIndexOf(array, value, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = length;
		      if (fromIndex !== undefined$1) {
		        index = toInteger(fromIndex);
		        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
		      }
		      return value === value
		        ? strictLastIndexOf(array, value, index)
		        : baseFindIndex(array, baseIsNaN, index, true);
		    }

		    /**
		     * Gets the element at index `n` of `array`. If `n` is negative, the nth
		     * element from the end is returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.11.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=0] The index of the element to return.
		     * @returns {*} Returns the nth element of `array`.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'd'];
		     *
		     * _.nth(array, 1);
		     * // => 'b'
		     *
		     * _.nth(array, -2);
		     * // => 'c';
		     */
		    function nth(array, n) {
		      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined$1;
		    }

		    /**
		     * Removes all given values from `array` using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
		     * to remove elements from an array by predicate.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {...*} [values] The values to remove.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
		     *
		     * _.pull(array, 'a', 'c');
		     * console.log(array);
		     * // => ['b', 'b']
		     */
		    var pull = baseRest(pullAll);

		    /**
		     * This method is like `_.pull` except that it accepts an array of values to remove.
		     *
		     * **Note:** Unlike `_.difference`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
		     *
		     * _.pullAll(array, ['a', 'c']);
		     * console.log(array);
		     * // => ['b', 'b']
		     */
		    function pullAll(array, values) {
		      return (array && array.length && values && values.length)
		        ? basePullAll(array, values)
		        : array;
		    }

		    /**
		     * This method is like `_.pullAll` except that it accepts `iteratee` which is
		     * invoked for each element of `array` and `values` to generate the criterion
		     * by which they're compared. The iteratee is invoked with one argument: (value).
		     *
		     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
		     *
		     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
		     * console.log(array);
		     * // => [{ 'x': 2 }]
		     */
		    function pullAllBy(array, values, iteratee) {
		      return (array && array.length && values && values.length)
		        ? basePullAll(array, values, getIteratee(iteratee, 2))
		        : array;
		    }

		    /**
		     * This method is like `_.pullAll` except that it accepts `comparator` which
		     * is invoked to compare elements of `array` to `values`. The comparator is
		     * invoked with two arguments: (arrVal, othVal).
		     *
		     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.6.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
		     *
		     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
		     * console.log(array);
		     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
		     */
		    function pullAllWith(array, values, comparator) {
		      return (array && array.length && values && values.length)
		        ? basePullAll(array, values, undefined$1, comparator)
		        : array;
		    }

		    /**
		     * Removes elements from `array` corresponding to `indexes` and returns an
		     * array of removed elements.
		     *
		     * **Note:** Unlike `_.at`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
		     * @returns {Array} Returns the new array of removed elements.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'd'];
		     * var pulled = _.pullAt(array, [1, 3]);
		     *
		     * console.log(array);
		     * // => ['a', 'c']
		     *
		     * console.log(pulled);
		     * // => ['b', 'd']
		     */
		    var pullAt = flatRest(function(array, indexes) {
		      var length = array == null ? 0 : array.length,
		          result = baseAt(array, indexes);

		      basePullAt(array, arrayMap(indexes, function(index) {
		        return isIndex(index, length) ? +index : index;
		      }).sort(compareAscending));

		      return result;
		    });

		    /**
		     * Removes all elements from `array` that `predicate` returns truthy for
		     * and returns an array of the removed elements. The predicate is invoked
		     * with three arguments: (value, index, array).
		     *
		     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
		     * to pull elements from an array by value.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new array of removed elements.
		     * @example
		     *
		     * var array = [1, 2, 3, 4];
		     * var evens = _.remove(array, function(n) {
		     *   return n % 2 == 0;
		     * });
		     *
		     * console.log(array);
		     * // => [1, 3]
		     *
		     * console.log(evens);
		     * // => [2, 4]
		     */
		    function remove(array, predicate) {
		      var result = [];
		      if (!(array && array.length)) {
		        return result;
		      }
		      var index = -1,
		          indexes = [],
		          length = array.length;

		      predicate = getIteratee(predicate, 3);
		      while (++index < length) {
		        var value = array[index];
		        if (predicate(value, index, array)) {
		          result.push(value);
		          indexes.push(index);
		        }
		      }
		      basePullAt(array, indexes);
		      return result;
		    }

		    /**
		     * Reverses `array` so that the first element becomes the last, the second
		     * element becomes the second to last, and so on.
		     *
		     * **Note:** This method mutates `array` and is based on
		     * [`Array#reverse`](https://mdn.io/Array/reverse).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [1, 2, 3];
		     *
		     * _.reverse(array);
		     * // => [3, 2, 1]
		     *
		     * console.log(array);
		     * // => [3, 2, 1]
		     */
		    function reverse(array) {
		      return array == null ? array : nativeReverse.call(array);
		    }

		    /**
		     * Creates a slice of `array` from `start` up to, but not including, `end`.
		     *
		     * **Note:** This method is used instead of
		     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
		     * returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to slice.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns the slice of `array`.
		     */
		    function slice(array, start, end) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
		        start = 0;
		        end = length;
		      }
		      else {
		        start = start == null ? 0 : toInteger(start);
		        end = end === undefined$1 ? length : toInteger(end);
		      }
		      return baseSlice(array, start, end);
		    }

		    /**
		     * Uses a binary search to determine the lowest index at which `value`
		     * should be inserted into `array` in order to maintain its sort order.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * _.sortedIndex([30, 50], 40);
		     * // => 1
		     */
		    function sortedIndex(array, value) {
		      return baseSortedIndex(array, value);
		    }

		    /**
		     * This method is like `_.sortedIndex` except that it accepts `iteratee`
		     * which is invoked for `value` and each element of `array` to compute their
		     * sort ranking. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * var objects = [{ 'x': 4 }, { 'x': 5 }];
		     *
		     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
		     * // => 0
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
		     * // => 0
		     */
		    function sortedIndexBy(array, value, iteratee) {
		      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
		    }

		    /**
		     * This method is like `_.indexOf` except that it performs a binary
		     * search on a sorted `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
		     * // => 1
		     */
		    function sortedIndexOf(array, value) {
		      var length = array == null ? 0 : array.length;
		      if (length) {
		        var index = baseSortedIndex(array, value);
		        if (index < length && eq(array[index], value)) {
		          return index;
		        }
		      }
		      return -1;
		    }

		    /**
		     * This method is like `_.sortedIndex` except that it returns the highest
		     * index at which `value` should be inserted into `array` in order to
		     * maintain its sort order.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
		     * // => 4
		     */
		    function sortedLastIndex(array, value) {
		      return baseSortedIndex(array, value, true);
		    }

		    /**
		     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
		     * which is invoked for `value` and each element of `array` to compute their
		     * sort ranking. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * var objects = [{ 'x': 4 }, { 'x': 5 }];
		     *
		     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
		     * // => 1
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
		     * // => 1
		     */
		    function sortedLastIndexBy(array, value, iteratee) {
		      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
		    }

		    /**
		     * This method is like `_.lastIndexOf` except that it performs a binary
		     * search on a sorted `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
		     * // => 3
		     */
		    function sortedLastIndexOf(array, value) {
		      var length = array == null ? 0 : array.length;
		      if (length) {
		        var index = baseSortedIndex(array, value, true) - 1;
		        if (eq(array[index], value)) {
		          return index;
		        }
		      }
		      return -1;
		    }

		    /**
		     * This method is like `_.uniq` except that it's designed and optimized
		     * for sorted arrays.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.sortedUniq([1, 1, 2]);
		     * // => [1, 2]
		     */
		    function sortedUniq(array) {
		      return (array && array.length)
		        ? baseSortedUniq(array)
		        : [];
		    }

		    /**
		     * This method is like `_.uniqBy` except that it's designed and optimized
		     * for sorted arrays.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
		     * // => [1.1, 2.3]
		     */
		    function sortedUniqBy(array, iteratee) {
		      return (array && array.length)
		        ? baseSortedUniq(array, getIteratee(iteratee, 2))
		        : [];
		    }

		    /**
		     * Gets all but the first element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.tail([1, 2, 3]);
		     * // => [2, 3]
		     */
		    function tail(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseSlice(array, 1, length) : [];
		    }

		    /**
		     * Creates a slice of `array` with `n` elements taken from the beginning.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to take.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.take([1, 2, 3]);
		     * // => [1]
		     *
		     * _.take([1, 2, 3], 2);
		     * // => [1, 2]
		     *
		     * _.take([1, 2, 3], 5);
		     * // => [1, 2, 3]
		     *
		     * _.take([1, 2, 3], 0);
		     * // => []
		     */
		    function take(array, n, guard) {
		      if (!(array && array.length)) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      return baseSlice(array, 0, n < 0 ? 0 : n);
		    }

		    /**
		     * Creates a slice of `array` with `n` elements taken from the end.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to take.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.takeRight([1, 2, 3]);
		     * // => [3]
		     *
		     * _.takeRight([1, 2, 3], 2);
		     * // => [2, 3]
		     *
		     * _.takeRight([1, 2, 3], 5);
		     * // => [1, 2, 3]
		     *
		     * _.takeRight([1, 2, 3], 0);
		     * // => []
		     */
		    function takeRight(array, n, guard) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      n = length - n;
		      return baseSlice(array, n < 0 ? 0 : n, length);
		    }

		    /**
		     * Creates a slice of `array` with elements taken from the end. Elements are
		     * taken until `predicate` returns falsey. The predicate is invoked with
		     * three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': true },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': false }
		     * ];
		     *
		     * _.takeRightWhile(users, function(o) { return !o.active; });
		     * // => objects for ['fred', 'pebbles']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
		     * // => objects for ['pebbles']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.takeRightWhile(users, ['active', false]);
		     * // => objects for ['fred', 'pebbles']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.takeRightWhile(users, 'active');
		     * // => []
		     */
		    function takeRightWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3), false, true)
		        : [];
		    }

		    /**
		     * Creates a slice of `array` with elements taken from the beginning. Elements
		     * are taken until `predicate` returns falsey. The predicate is invoked with
		     * three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': false },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': true }
		     * ];
		     *
		     * _.takeWhile(users, function(o) { return !o.active; });
		     * // => objects for ['barney', 'fred']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.takeWhile(users, { 'user': 'barney', 'active': false });
		     * // => objects for ['barney']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.takeWhile(users, ['active', false]);
		     * // => objects for ['barney', 'fred']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.takeWhile(users, 'active');
		     * // => []
		     */
		    function takeWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3))
		        : [];
		    }

		    /**
		     * Creates an array of unique values, in order, from all given arrays using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @returns {Array} Returns the new array of combined values.
		     * @example
		     *
		     * _.union([2], [1, 2]);
		     * // => [2, 1]
		     */
		    var union = baseRest(function(arrays) {
		      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
		    });

		    /**
		     * This method is like `_.union` except that it accepts `iteratee` which is
		     * invoked for each element of each `arrays` to generate the criterion by
		     * which uniqueness is computed. Result values are chosen from the first
		     * array in which the value occurs. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of combined values.
		     * @example
		     *
		     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
		     * // => [2.1, 1.2]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }, { 'x': 2 }]
		     */
		    var unionBy = baseRest(function(arrays) {
		      var iteratee = last(arrays);
		      if (isArrayLikeObject(iteratee)) {
		        iteratee = undefined$1;
		      }
		      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
		    });

		    /**
		     * This method is like `_.union` except that it accepts `comparator` which
		     * is invoked to compare elements of `arrays`. Result values are chosen from
		     * the first array in which the value occurs. The comparator is invoked
		     * with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of combined values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.unionWith(objects, others, _.isEqual);
		     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
		     */
		    var unionWith = baseRest(function(arrays) {
		      var comparator = last(arrays);
		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
		    });

		    /**
		     * Creates a duplicate-free version of an array, using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons, in which only the first occurrence of each element
		     * is kept. The order of result values is determined by the order they occur
		     * in the array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.uniq([2, 1, 2]);
		     * // => [2, 1]
		     */
		    function uniq(array) {
		      return (array && array.length) ? baseUniq(array) : [];
		    }

		    /**
		     * This method is like `_.uniq` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the criterion by which
		     * uniqueness is computed. The order of result values is determined by the
		     * order they occur in the array. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
		     * // => [2.1, 1.2]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }, { 'x': 2 }]
		     */
		    function uniqBy(array, iteratee) {
		      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
		    }

		    /**
		     * This method is like `_.uniq` except that it accepts `comparator` which
		     * is invoked to compare elements of `array`. The order of result values is
		     * determined by the order they occur in the array.The comparator is invoked
		     * with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.uniqWith(objects, _.isEqual);
		     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
		     */
		    function uniqWith(array, comparator) {
		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      return (array && array.length) ? baseUniq(array, undefined$1, comparator) : [];
		    }

		    /**
		     * This method is like `_.zip` except that it accepts an array of grouped
		     * elements and creates an array regrouping the elements to their pre-zip
		     * configuration.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.2.0
		     * @category Array
		     * @param {Array} array The array of grouped elements to process.
		     * @returns {Array} Returns the new array of regrouped elements.
		     * @example
		     *
		     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
		     * // => [['a', 1, true], ['b', 2, false]]
		     *
		     * _.unzip(zipped);
		     * // => [['a', 'b'], [1, 2], [true, false]]
		     */
		    function unzip(array) {
		      if (!(array && array.length)) {
		        return [];
		      }
		      var length = 0;
		      array = arrayFilter(array, function(group) {
		        if (isArrayLikeObject(group)) {
		          length = nativeMax(group.length, length);
		          return true;
		        }
		      });
		      return baseTimes(length, function(index) {
		        return arrayMap(array, baseProperty(index));
		      });
		    }

		    /**
		     * This method is like `_.unzip` except that it accepts `iteratee` to specify
		     * how regrouped values should be combined. The iteratee is invoked with the
		     * elements of each group: (...group).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.8.0
		     * @category Array
		     * @param {Array} array The array of grouped elements to process.
		     * @param {Function} [iteratee=_.identity] The function to combine
		     *  regrouped values.
		     * @returns {Array} Returns the new array of regrouped elements.
		     * @example
		     *
		     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
		     * // => [[1, 10, 100], [2, 20, 200]]
		     *
		     * _.unzipWith(zipped, _.add);
		     * // => [3, 30, 300]
		     */
		    function unzipWith(array, iteratee) {
		      if (!(array && array.length)) {
		        return [];
		      }
		      var result = unzip(array);
		      if (iteratee == null) {
		        return result;
		      }
		      return arrayMap(result, function(group) {
		        return apply(iteratee, undefined$1, group);
		      });
		    }

		    /**
		     * Creates an array excluding all given values using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * **Note:** Unlike `_.pull`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...*} [values] The values to exclude.
		     * @returns {Array} Returns the new array of filtered values.
		     * @see _.difference, _.xor
		     * @example
		     *
		     * _.without([2, 1, 2, 3], 1, 2);
		     * // => [3]
		     */
		    var without = baseRest(function(array, values) {
		      return isArrayLikeObject(array)
		        ? baseDifference(array, values)
		        : [];
		    });

		    /**
		     * Creates an array of unique values that is the
		     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
		     * of the given arrays. The order of result values is determined by the order
		     * they occur in the arrays.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @returns {Array} Returns the new array of filtered values.
		     * @see _.difference, _.without
		     * @example
		     *
		     * _.xor([2, 1], [2, 3]);
		     * // => [1, 3]
		     */
		    var xor = baseRest(function(arrays) {
		      return baseXor(arrayFilter(arrays, isArrayLikeObject));
		    });

		    /**
		     * This method is like `_.xor` except that it accepts `iteratee` which is
		     * invoked for each element of each `arrays` to generate the criterion by
		     * which by which they're compared. The order of result values is determined
		     * by the order they occur in the arrays. The iteratee is invoked with one
		     * argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
		     * // => [1.2, 3.4]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 2 }]
		     */
		    var xorBy = baseRest(function(arrays) {
		      var iteratee = last(arrays);
		      if (isArrayLikeObject(iteratee)) {
		        iteratee = undefined$1;
		      }
		      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
		    });

		    /**
		     * This method is like `_.xor` except that it accepts `comparator` which is
		     * invoked to compare elements of `arrays`. The order of result values is
		     * determined by the order they occur in the arrays. The comparator is invoked
		     * with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.xorWith(objects, others, _.isEqual);
		     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
		     */
		    var xorWith = baseRest(function(arrays) {
		      var comparator = last(arrays);
		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
		    });

		    /**
		     * Creates an array of grouped elements, the first of which contains the
		     * first elements of the given arrays, the second of which contains the
		     * second elements of the given arrays, and so on.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to process.
		     * @returns {Array} Returns the new array of grouped elements.
		     * @example
		     *
		     * _.zip(['a', 'b'], [1, 2], [true, false]);
		     * // => [['a', 1, true], ['b', 2, false]]
		     */
		    var zip = baseRest(unzip);

		    /**
		     * This method is like `_.fromPairs` except that it accepts two arrays,
		     * one of property identifiers and one of corresponding values.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.4.0
		     * @category Array
		     * @param {Array} [props=[]] The property identifiers.
		     * @param {Array} [values=[]] The property values.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * _.zipObject(['a', 'b'], [1, 2]);
		     * // => { 'a': 1, 'b': 2 }
		     */
		    function zipObject(props, values) {
		      return baseZipObject(props || [], values || [], assignValue);
		    }

		    /**
		     * This method is like `_.zipObject` except that it supports property paths.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.1.0
		     * @category Array
		     * @param {Array} [props=[]] The property identifiers.
		     * @param {Array} [values=[]] The property values.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
		     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
		     */
		    function zipObjectDeep(props, values) {
		      return baseZipObject(props || [], values || [], baseSet);
		    }

		    /**
		     * This method is like `_.zip` except that it accepts `iteratee` to specify
		     * how grouped values should be combined. The iteratee is invoked with the
		     * elements of each group: (...group).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.8.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to process.
		     * @param {Function} [iteratee=_.identity] The function to combine
		     *  grouped values.
		     * @returns {Array} Returns the new array of grouped elements.
		     * @example
		     *
		     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
		     *   return a + b + c;
		     * });
		     * // => [111, 222]
		     */
		    var zipWith = baseRest(function(arrays) {
		      var length = arrays.length,
		          iteratee = length > 1 ? arrays[length - 1] : undefined$1;

		      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined$1;
		      return unzipWith(arrays, iteratee);
		    });

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
		     * chain sequences enabled. The result of such sequences must be unwrapped
		     * with `_#value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.3.0
		     * @category Seq
		     * @param {*} value The value to wrap.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'age': 36 },
		     *   { 'user': 'fred',    'age': 40 },
		     *   { 'user': 'pebbles', 'age': 1 }
		     * ];
		     *
		     * var youngest = _
		     *   .chain(users)
		     *   .sortBy('age')
		     *   .map(function(o) {
		     *     return o.user + ' is ' + o.age;
		     *   })
		     *   .head()
		     *   .value();
		     * // => 'pebbles is 1'
		     */
		    function chain(value) {
		      var result = lodash(value);
		      result.__chain__ = true;
		      return result;
		    }

		    /**
		     * This method invokes `interceptor` and returns `value`. The interceptor
		     * is invoked with one argument; (value). The purpose of this method is to
		     * "tap into" a method chain sequence in order to modify intermediate results.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Seq
		     * @param {*} value The value to provide to `interceptor`.
		     * @param {Function} interceptor The function to invoke.
		     * @returns {*} Returns `value`.
		     * @example
		     *
		     * _([1, 2, 3])
		     *  .tap(function(array) {
		     *    // Mutate input array.
		     *    array.pop();
		     *  })
		     *  .reverse()
		     *  .value();
		     * // => [2, 1]
		     */
		    function tap(value, interceptor) {
		      interceptor(value);
		      return value;
		    }

		    /**
		     * This method is like `_.tap` except that it returns the result of `interceptor`.
		     * The purpose of this method is to "pass thru" values replacing intermediate
		     * results in a method chain sequence.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Seq
		     * @param {*} value The value to provide to `interceptor`.
		     * @param {Function} interceptor The function to invoke.
		     * @returns {*} Returns the result of `interceptor`.
		     * @example
		     *
		     * _('  abc  ')
		     *  .chain()
		     *  .trim()
		     *  .thru(function(value) {
		     *    return [value];
		     *  })
		     *  .value();
		     * // => ['abc']
		     */
		    function thru(value, interceptor) {
		      return interceptor(value);
		    }

		    /**
		     * This method is the wrapper version of `_.at`.
		     *
		     * @name at
		     * @memberOf _
		     * @since 1.0.0
		     * @category Seq
		     * @param {...(string|string[])} [paths] The property paths to pick.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
		     *
		     * _(object).at(['a[0].b.c', 'a[1]']).value();
		     * // => [3, 4]
		     */
		    var wrapperAt = flatRest(function(paths) {
		      var length = paths.length,
		          start = length ? paths[0] : 0,
		          value = this.__wrapped__,
		          interceptor = function(object) { return baseAt(object, paths); };

		      if (length > 1 || this.__actions__.length ||
		          !(value instanceof LazyWrapper) || !isIndex(start)) {
		        return this.thru(interceptor);
		      }
		      value = value.slice(start, +start + (length ? 1 : 0));
		      value.__actions__.push({
		        'func': thru,
		        'args': [interceptor],
		        'thisArg': undefined$1
		      });
		      return new LodashWrapper(value, this.__chain__).thru(function(array) {
		        if (length && !array.length) {
		          array.push(undefined$1);
		        }
		        return array;
		      });
		    });

		    /**
		     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
		     *
		     * @name chain
		     * @memberOf _
		     * @since 0.1.0
		     * @category Seq
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36 },
		     *   { 'user': 'fred',   'age': 40 }
		     * ];
		     *
		     * // A sequence without explicit chaining.
		     * _(users).head();
		     * // => { 'user': 'barney', 'age': 36 }
		     *
		     * // A sequence with explicit chaining.
		     * _(users)
		     *   .chain()
		     *   .head()
		     *   .pick('user')
		     *   .value();
		     * // => { 'user': 'barney' }
		     */
		    function wrapperChain() {
		      return chain(this);
		    }

		    /**
		     * Executes the chain sequence and returns the wrapped result.
		     *
		     * @name commit
		     * @memberOf _
		     * @since 3.2.0
		     * @category Seq
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var array = [1, 2];
		     * var wrapped = _(array).push(3);
		     *
		     * console.log(array);
		     * // => [1, 2]
		     *
		     * wrapped = wrapped.commit();
		     * console.log(array);
		     * // => [1, 2, 3]
		     *
		     * wrapped.last();
		     * // => 3
		     *
		     * console.log(array);
		     * // => [1, 2, 3]
		     */
		    function wrapperCommit() {
		      return new LodashWrapper(this.value(), this.__chain__);
		    }

		    /**
		     * Gets the next value on a wrapped object following the
		     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
		     *
		     * @name next
		     * @memberOf _
		     * @since 4.0.0
		     * @category Seq
		     * @returns {Object} Returns the next iterator value.
		     * @example
		     *
		     * var wrapped = _([1, 2]);
		     *
		     * wrapped.next();
		     * // => { 'done': false, 'value': 1 }
		     *
		     * wrapped.next();
		     * // => { 'done': false, 'value': 2 }
		     *
		     * wrapped.next();
		     * // => { 'done': true, 'value': undefined }
		     */
		    function wrapperNext() {
		      if (this.__values__ === undefined$1) {
		        this.__values__ = toArray(this.value());
		      }
		      var done = this.__index__ >= this.__values__.length,
		          value = done ? undefined$1 : this.__values__[this.__index__++];

		      return { 'done': done, 'value': value };
		    }

		    /**
		     * Enables the wrapper to be iterable.
		     *
		     * @name Symbol.iterator
		     * @memberOf _
		     * @since 4.0.0
		     * @category Seq
		     * @returns {Object} Returns the wrapper object.
		     * @example
		     *
		     * var wrapped = _([1, 2]);
		     *
		     * wrapped[Symbol.iterator]() === wrapped;
		     * // => true
		     *
		     * Array.from(wrapped);
		     * // => [1, 2]
		     */
		    function wrapperToIterator() {
		      return this;
		    }

		    /**
		     * Creates a clone of the chain sequence planting `value` as the wrapped value.
		     *
		     * @name plant
		     * @memberOf _
		     * @since 3.2.0
		     * @category Seq
		     * @param {*} value The value to plant.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var wrapped = _([1, 2]).map(square);
		     * var other = wrapped.plant([3, 4]);
		     *
		     * other.value();
		     * // => [9, 16]
		     *
		     * wrapped.value();
		     * // => [1, 4]
		     */
		    function wrapperPlant(value) {
		      var result,
		          parent = this;

		      while (parent instanceof baseLodash) {
		        var clone = wrapperClone(parent);
		        clone.__index__ = 0;
		        clone.__values__ = undefined$1;
		        if (result) {
		          previous.__wrapped__ = clone;
		        } else {
		          result = clone;
		        }
		        var previous = clone;
		        parent = parent.__wrapped__;
		      }
		      previous.__wrapped__ = value;
		      return result;
		    }

		    /**
		     * This method is the wrapper version of `_.reverse`.
		     *
		     * **Note:** This method mutates the wrapped array.
		     *
		     * @name reverse
		     * @memberOf _
		     * @since 0.1.0
		     * @category Seq
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var array = [1, 2, 3];
		     *
		     * _(array).reverse().value()
		     * // => [3, 2, 1]
		     *
		     * console.log(array);
		     * // => [3, 2, 1]
		     */
		    function wrapperReverse() {
		      var value = this.__wrapped__;
		      if (value instanceof LazyWrapper) {
		        var wrapped = value;
		        if (this.__actions__.length) {
		          wrapped = new LazyWrapper(this);
		        }
		        wrapped = wrapped.reverse();
		        wrapped.__actions__.push({
		          'func': thru,
		          'args': [reverse],
		          'thisArg': undefined$1
		        });
		        return new LodashWrapper(wrapped, this.__chain__);
		      }
		      return this.thru(reverse);
		    }

		    /**
		     * Executes the chain sequence to resolve the unwrapped value.
		     *
		     * @name value
		     * @memberOf _
		     * @since 0.1.0
		     * @alias toJSON, valueOf
		     * @category Seq
		     * @returns {*} Returns the resolved unwrapped value.
		     * @example
		     *
		     * _([1, 2, 3]).value();
		     * // => [1, 2, 3]
		     */
		    function wrapperValue() {
		      return baseWrapperValue(this.__wrapped__, this.__actions__);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` thru `iteratee`. The corresponding value of
		     * each key is the number of times the key was returned by `iteratee`. The
		     * iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.5.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * _.countBy([6.1, 4.2, 6.3], Math.floor);
		     * // => { '4': 1, '6': 2 }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.countBy(['one', 'two', 'three'], 'length');
		     * // => { '3': 2, '5': 1 }
		     */
		    var countBy = createAggregator(function(result, value, key) {
		      if (hasOwnProperty.call(result, key)) {
		        ++result[key];
		      } else {
		        baseAssignValue(result, key, 1);
		      }
		    });

		    /**
		     * Checks if `predicate` returns truthy for **all** elements of `collection`.
		     * Iteration is stopped once `predicate` returns falsey. The predicate is
		     * invoked with three arguments: (value, index|key, collection).
		     *
		     * **Note:** This method returns `true` for
		     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
		     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
		     * elements of empty collections.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {boolean} Returns `true` if all elements pass the predicate check,
		     *  else `false`.
		     * @example
		     *
		     * _.every([true, 1, null, 'yes'], Boolean);
		     * // => false
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': false },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.every(users, { 'user': 'barney', 'active': false });
		     * // => false
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.every(users, ['active', false]);
		     * // => true
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.every(users, 'active');
		     * // => false
		     */
		    function every(collection, predicate, guard) {
		      var func = isArray(collection) ? arrayEvery : baseEvery;
		      if (guard && isIterateeCall(collection, predicate, guard)) {
		        predicate = undefined$1;
		      }
		      return func(collection, getIteratee(predicate, 3));
		    }

		    /**
		     * Iterates over elements of `collection`, returning an array of all elements
		     * `predicate` returns truthy for. The predicate is invoked with three
		     * arguments: (value, index|key, collection).
		     *
		     * **Note:** Unlike `_.remove`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new filtered array.
		     * @see _.reject
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': true },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * _.filter(users, function(o) { return !o.active; });
		     * // => objects for ['fred']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.filter(users, { 'age': 36, 'active': true });
		     * // => objects for ['barney']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.filter(users, ['active', false]);
		     * // => objects for ['fred']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.filter(users, 'active');
		     * // => objects for ['barney']
		     *
		     * // Combining several predicates using `_.overEvery` or `_.overSome`.
		     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
		     * // => objects for ['fred', 'barney']
		     */
		    function filter(collection, predicate) {
		      var func = isArray(collection) ? arrayFilter : baseFilter;
		      return func(collection, getIteratee(predicate, 3));
		    }

		    /**
		     * Iterates over elements of `collection`, returning the first element
		     * `predicate` returns truthy for. The predicate is invoked with three
		     * arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @returns {*} Returns the matched element, else `undefined`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'age': 36, 'active': true },
		     *   { 'user': 'fred',    'age': 40, 'active': false },
		     *   { 'user': 'pebbles', 'age': 1,  'active': true }
		     * ];
		     *
		     * _.find(users, function(o) { return o.age < 40; });
		     * // => object for 'barney'
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.find(users, { 'age': 1, 'active': true });
		     * // => object for 'pebbles'
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.find(users, ['active', false]);
		     * // => object for 'fred'
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.find(users, 'active');
		     * // => object for 'barney'
		     */
		    var find = createFind(findIndex);

		    /**
		     * This method is like `_.find` except that it iterates over elements of
		     * `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=collection.length-1] The index to search from.
		     * @returns {*} Returns the matched element, else `undefined`.
		     * @example
		     *
		     * _.findLast([1, 2, 3, 4], function(n) {
		     *   return n % 2 == 1;
		     * });
		     * // => 3
		     */
		    var findLast = createFind(findLastIndex);

		    /**
		     * Creates a flattened array of values by running each element in `collection`
		     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
		     * with three arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * function duplicate(n) {
		     *   return [n, n];
		     * }
		     *
		     * _.flatMap([1, 2], duplicate);
		     * // => [1, 1, 2, 2]
		     */
		    function flatMap(collection, iteratee) {
		      return baseFlatten(map(collection, iteratee), 1);
		    }

		    /**
		     * This method is like `_.flatMap` except that it recursively flattens the
		     * mapped results.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * function duplicate(n) {
		     *   return [[[n, n]]];
		     * }
		     *
		     * _.flatMapDeep([1, 2], duplicate);
		     * // => [1, 1, 2, 2]
		     */
		    function flatMapDeep(collection, iteratee) {
		      return baseFlatten(map(collection, iteratee), INFINITY);
		    }

		    /**
		     * This method is like `_.flatMap` except that it recursively flattens the
		     * mapped results up to `depth` times.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {number} [depth=1] The maximum recursion depth.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * function duplicate(n) {
		     *   return [[[n, n]]];
		     * }
		     *
		     * _.flatMapDepth([1, 2], duplicate, 2);
		     * // => [[1, 1], [2, 2]]
		     */
		    function flatMapDepth(collection, iteratee, depth) {
		      depth = depth === undefined$1 ? 1 : toInteger(depth);
		      return baseFlatten(map(collection, iteratee), depth);
		    }

		    /**
		     * Iterates over elements of `collection` and invokes `iteratee` for each element.
		     * The iteratee is invoked with three arguments: (value, index|key, collection).
		     * Iteratee functions may exit iteration early by explicitly returning `false`.
		     *
		     * **Note:** As with other "Collections" methods, objects with a "length"
		     * property are iterated like arrays. To avoid this behavior use `_.forIn`
		     * or `_.forOwn` for object iteration.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @alias each
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     * @see _.forEachRight
		     * @example
		     *
		     * _.forEach([1, 2], function(value) {
		     *   console.log(value);
		     * });
		     * // => Logs `1` then `2`.
		     *
		     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
		     */
		    function forEach(collection, iteratee) {
		      var func = isArray(collection) ? arrayEach : baseEach;
		      return func(collection, getIteratee(iteratee, 3));
		    }

		    /**
		     * This method is like `_.forEach` except that it iterates over elements of
		     * `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @alias eachRight
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     * @see _.forEach
		     * @example
		     *
		     * _.forEachRight([1, 2], function(value) {
		     *   console.log(value);
		     * });
		     * // => Logs `2` then `1`.
		     */
		    function forEachRight(collection, iteratee) {
		      var func = isArray(collection) ? arrayEachRight : baseEachRight;
		      return func(collection, getIteratee(iteratee, 3));
		    }

		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` thru `iteratee`. The order of grouped values
		     * is determined by the order they occur in `collection`. The corresponding
		     * value of each key is an array of elements responsible for generating the
		     * key. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
		     * // => { '4': [4.2], '6': [6.1, 6.3] }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.groupBy(['one', 'two', 'three'], 'length');
		     * // => { '3': ['one', 'two'], '5': ['three'] }
		     */
		    var groupBy = createAggregator(function(result, value, key) {
		      if (hasOwnProperty.call(result, key)) {
		        result[key].push(value);
		      } else {
		        baseAssignValue(result, key, [value]);
		      }
		    });

		    /**
		     * Checks if `value` is in `collection`. If `collection` is a string, it's
		     * checked for a substring of `value`, otherwise
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * is used for equality comparisons. If `fromIndex` is negative, it's used as
		     * the offset from the end of `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object|string} collection The collection to inspect.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
		     * @returns {boolean} Returns `true` if `value` is found, else `false`.
		     * @example
		     *
		     * _.includes([1, 2, 3], 1);
		     * // => true
		     *
		     * _.includes([1, 2, 3], 1, 2);
		     * // => false
		     *
		     * _.includes({ 'a': 1, 'b': 2 }, 1);
		     * // => true
		     *
		     * _.includes('abcd', 'bc');
		     * // => true
		     */
		    function includes(collection, value, fromIndex, guard) {
		      collection = isArrayLike(collection) ? collection : values(collection);
		      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

		      var length = collection.length;
		      if (fromIndex < 0) {
		        fromIndex = nativeMax(length + fromIndex, 0);
		      }
		      return isString(collection)
		        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
		        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
		    }

		    /**
		     * Invokes the method at `path` of each element in `collection`, returning
		     * an array of the results of each invoked method. Any additional arguments
		     * are provided to each invoked method. If `path` is a function, it's invoked
		     * for, and `this` bound to, each element in `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array|Function|string} path The path of the method to invoke or
		     *  the function invoked per iteration.
		     * @param {...*} [args] The arguments to invoke each method with.
		     * @returns {Array} Returns the array of results.
		     * @example
		     *
		     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
		     * // => [[1, 5, 7], [1, 2, 3]]
		     *
		     * _.invokeMap([123, 456], String.prototype.split, '');
		     * // => [['1', '2', '3'], ['4', '5', '6']]
		     */
		    var invokeMap = baseRest(function(collection, path, args) {
		      var index = -1,
		          isFunc = typeof path == 'function',
		          result = isArrayLike(collection) ? Array(collection.length) : [];

		      baseEach(collection, function(value) {
		        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
		      });
		      return result;
		    });

		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` thru `iteratee`. The corresponding value of
		     * each key is the last element responsible for generating the key. The
		     * iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * var array = [
		     *   { 'dir': 'left', 'code': 97 },
		     *   { 'dir': 'right', 'code': 100 }
		     * ];
		     *
		     * _.keyBy(array, function(o) {
		     *   return String.fromCharCode(o.code);
		     * });
		     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
		     *
		     * _.keyBy(array, 'dir');
		     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
		     */
		    var keyBy = createAggregator(function(result, value, key) {
		      baseAssignValue(result, key, value);
		    });

		    /**
		     * Creates an array of values by running each element in `collection` thru
		     * `iteratee`. The iteratee is invoked with three arguments:
		     * (value, index|key, collection).
		     *
		     * Many lodash methods are guarded to work as iteratees for methods like
		     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
		     *
		     * The guarded methods are:
		     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
		     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
		     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
		     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new mapped array.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * _.map([4, 8], square);
		     * // => [16, 64]
		     *
		     * _.map({ 'a': 4, 'b': 8 }, square);
		     * // => [16, 64] (iteration order is not guaranteed)
		     *
		     * var users = [
		     *   { 'user': 'barney' },
		     *   { 'user': 'fred' }
		     * ];
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.map(users, 'user');
		     * // => ['barney', 'fred']
		     */
		    function map(collection, iteratee) {
		      var func = isArray(collection) ? arrayMap : baseMap;
		      return func(collection, getIteratee(iteratee, 3));
		    }

		    /**
		     * This method is like `_.sortBy` except that it allows specifying the sort
		     * orders of the iteratees to sort by. If `orders` is unspecified, all values
		     * are sorted in ascending order. Otherwise, specify an order of "desc" for
		     * descending or "asc" for ascending sort order of corresponding values.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
		     *  The iteratees to sort by.
		     * @param {string[]} [orders] The sort orders of `iteratees`.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
		     * @returns {Array} Returns the new sorted array.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'fred',   'age': 48 },
		     *   { 'user': 'barney', 'age': 34 },
		     *   { 'user': 'fred',   'age': 40 },
		     *   { 'user': 'barney', 'age': 36 }
		     * ];
		     *
		     * // Sort by `user` in ascending order and by `age` in descending order.
		     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
		     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
		     */
		    function orderBy(collection, iteratees, orders, guard) {
		      if (collection == null) {
		        return [];
		      }
		      if (!isArray(iteratees)) {
		        iteratees = iteratees == null ? [] : [iteratees];
		      }
		      orders = guard ? undefined$1 : orders;
		      if (!isArray(orders)) {
		        orders = orders == null ? [] : [orders];
		      }
		      return baseOrderBy(collection, iteratees, orders);
		    }

		    /**
		     * Creates an array of elements split into two groups, the first of which
		     * contains elements `predicate` returns truthy for, the second of which
		     * contains elements `predicate` returns falsey for. The predicate is
		     * invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the array of grouped elements.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'age': 36, 'active': false },
		     *   { 'user': 'fred',    'age': 40, 'active': true },
		     *   { 'user': 'pebbles', 'age': 1,  'active': false }
		     * ];
		     *
		     * _.partition(users, function(o) { return o.active; });
		     * // => objects for [['fred'], ['barney', 'pebbles']]
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.partition(users, { 'age': 1, 'active': false });
		     * // => objects for [['pebbles'], ['barney', 'fred']]
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.partition(users, ['active', false]);
		     * // => objects for [['barney', 'pebbles'], ['fred']]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.partition(users, 'active');
		     * // => objects for [['fred'], ['barney', 'pebbles']]
		     */
		    var partition = createAggregator(function(result, value, key) {
		      result[key ? 0 : 1].push(value);
		    }, function() { return [[], []]; });

		    /**
		     * Reduces `collection` to a value which is the accumulated result of running
		     * each element in `collection` thru `iteratee`, where each successive
		     * invocation is supplied the return value of the previous. If `accumulator`
		     * is not given, the first element of `collection` is used as the initial
		     * value. The iteratee is invoked with four arguments:
		     * (accumulator, value, index|key, collection).
		     *
		     * Many lodash methods are guarded to work as iteratees for methods like
		     * `_.reduce`, `_.reduceRight`, and `_.transform`.
		     *
		     * The guarded methods are:
		     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
		     * and `sortBy`
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {*} [accumulator] The initial value.
		     * @returns {*} Returns the accumulated value.
		     * @see _.reduceRight
		     * @example
		     *
		     * _.reduce([1, 2], function(sum, n) {
		     *   return sum + n;
		     * }, 0);
		     * // => 3
		     *
		     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
		     *   (result[value] || (result[value] = [])).push(key);
		     *   return result;
		     * }, {});
		     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
		     */
		    function reduce(collection, iteratee, accumulator) {
		      var func = isArray(collection) ? arrayReduce : baseReduce,
		          initAccum = arguments.length < 3;

		      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
		    }

		    /**
		     * This method is like `_.reduce` except that it iterates over elements of
		     * `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {*} [accumulator] The initial value.
		     * @returns {*} Returns the accumulated value.
		     * @see _.reduce
		     * @example
		     *
		     * var array = [[0, 1], [2, 3], [4, 5]];
		     *
		     * _.reduceRight(array, function(flattened, other) {
		     *   return flattened.concat(other);
		     * }, []);
		     * // => [4, 5, 2, 3, 0, 1]
		     */
		    function reduceRight(collection, iteratee, accumulator) {
		      var func = isArray(collection) ? arrayReduceRight : baseReduce,
		          initAccum = arguments.length < 3;

		      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
		    }

		    /**
		     * The opposite of `_.filter`; this method returns the elements of `collection`
		     * that `predicate` does **not** return truthy for.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new filtered array.
		     * @see _.filter
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': false },
		     *   { 'user': 'fred',   'age': 40, 'active': true }
		     * ];
		     *
		     * _.reject(users, function(o) { return !o.active; });
		     * // => objects for ['fred']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.reject(users, { 'age': 40, 'active': true });
		     * // => objects for ['barney']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.reject(users, ['active', false]);
		     * // => objects for ['fred']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.reject(users, 'active');
		     * // => objects for ['barney']
		     */
		    function reject(collection, predicate) {
		      var func = isArray(collection) ? arrayFilter : baseFilter;
		      return func(collection, negate(getIteratee(predicate, 3)));
		    }

		    /**
		     * Gets a random element from `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to sample.
		     * @returns {*} Returns the random element.
		     * @example
		     *
		     * _.sample([1, 2, 3, 4]);
		     * // => 2
		     */
		    function sample(collection) {
		      var func = isArray(collection) ? arraySample : baseSample;
		      return func(collection);
		    }

		    /**
		     * Gets `n` random elements at unique keys from `collection` up to the
		     * size of `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to sample.
		     * @param {number} [n=1] The number of elements to sample.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the random elements.
		     * @example
		     *
		     * _.sampleSize([1, 2, 3], 2);
		     * // => [3, 1]
		     *
		     * _.sampleSize([1, 2, 3], 4);
		     * // => [2, 3, 1]
		     */
		    function sampleSize(collection, n, guard) {
		      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined$1)) {
		        n = 1;
		      } else {
		        n = toInteger(n);
		      }
		      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
		      return func(collection, n);
		    }

		    /**
		     * Creates an array of shuffled values, using a version of the
		     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to shuffle.
		     * @returns {Array} Returns the new shuffled array.
		     * @example
		     *
		     * _.shuffle([1, 2, 3, 4]);
		     * // => [4, 1, 3, 2]
		     */
		    function shuffle(collection) {
		      var func = isArray(collection) ? arrayShuffle : baseShuffle;
		      return func(collection);
		    }

		    /**
		     * Gets the size of `collection` by returning its length for array-like
		     * values or the number of own enumerable string keyed properties for objects.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object|string} collection The collection to inspect.
		     * @returns {number} Returns the collection size.
		     * @example
		     *
		     * _.size([1, 2, 3]);
		     * // => 3
		     *
		     * _.size({ 'a': 1, 'b': 2 });
		     * // => 2
		     *
		     * _.size('pebbles');
		     * // => 7
		     */
		    function size(collection) {
		      if (collection == null) {
		        return 0;
		      }
		      if (isArrayLike(collection)) {
		        return isString(collection) ? stringSize(collection) : collection.length;
		      }
		      var tag = getTag(collection);
		      if (tag == mapTag || tag == setTag) {
		        return collection.size;
		      }
		      return baseKeys(collection).length;
		    }

		    /**
		     * Checks if `predicate` returns truthy for **any** element of `collection`.
		     * Iteration is stopped once `predicate` returns truthy. The predicate is
		     * invoked with three arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {boolean} Returns `true` if any element passes the predicate check,
		     *  else `false`.
		     * @example
		     *
		     * _.some([null, 0, 'yes', false], Boolean);
		     * // => true
		     *
		     * var users = [
		     *   { 'user': 'barney', 'active': true },
		     *   { 'user': 'fred',   'active': false }
		     * ];
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.some(users, { 'user': 'barney', 'active': false });
		     * // => false
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.some(users, ['active', false]);
		     * // => true
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.some(users, 'active');
		     * // => true
		     */
		    function some(collection, predicate, guard) {
		      var func = isArray(collection) ? arraySome : baseSome;
		      if (guard && isIterateeCall(collection, predicate, guard)) {
		        predicate = undefined$1;
		      }
		      return func(collection, getIteratee(predicate, 3));
		    }

		    /**
		     * Creates an array of elements, sorted in ascending order by the results of
		     * running each element in a collection thru each iteratee. This method
		     * performs a stable sort, that is, it preserves the original sort order of
		     * equal elements. The iteratees are invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {...(Function|Function[])} [iteratees=[_.identity]]
		     *  The iteratees to sort by.
		     * @returns {Array} Returns the new sorted array.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'fred',   'age': 48 },
		     *   { 'user': 'barney', 'age': 36 },
		     *   { 'user': 'fred',   'age': 30 },
		     *   { 'user': 'barney', 'age': 34 }
		     * ];
		     *
		     * _.sortBy(users, [function(o) { return o.user; }]);
		     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
		     *
		     * _.sortBy(users, ['user', 'age']);
		     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
		     */
		    var sortBy = baseRest(function(collection, iteratees) {
		      if (collection == null) {
		        return [];
		      }
		      var length = iteratees.length;
		      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
		        iteratees = [];
		      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
		        iteratees = [iteratees[0]];
		      }
		      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
		    });

		    /*------------------------------------------------------------------------*/

		    /**
		     * Gets the timestamp of the number of milliseconds that have elapsed since
		     * the Unix epoch (1 January 1970 00:00:00 UTC).
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Date
		     * @returns {number} Returns the timestamp.
		     * @example
		     *
		     * _.defer(function(stamp) {
		     *   console.log(_.now() - stamp);
		     * }, _.now());
		     * // => Logs the number of milliseconds it took for the deferred invocation.
		     */
		    var now = ctxNow || function() {
		      return root.Date.now();
		    };

		    /*------------------------------------------------------------------------*/

		    /**
		     * The opposite of `_.before`; this method creates a function that invokes
		     * `func` once it's called `n` or more times.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {number} n The number of calls before `func` is invoked.
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * var saves = ['profile', 'settings'];
		     *
		     * var done = _.after(saves.length, function() {
		     *   console.log('done saving!');
		     * });
		     *
		     * _.forEach(saves, function(type) {
		     *   asyncSave({ 'type': type, 'complete': done });
		     * });
		     * // => Logs 'done saving!' after the two async saves have completed.
		     */
		    function after(n, func) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      n = toInteger(n);
		      return function() {
		        if (--n < 1) {
		          return func.apply(this, arguments);
		        }
		      };
		    }

		    /**
		     * Creates a function that invokes `func`, with up to `n` arguments,
		     * ignoring any additional arguments.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} func The function to cap arguments for.
		     * @param {number} [n=func.length] The arity cap.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the new capped function.
		     * @example
		     *
		     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
		     * // => [6, 8, 10]
		     */
		    function ary(func, n, guard) {
		      n = guard ? undefined$1 : n;
		      n = (func && n == null) ? func.length : n;
		      return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
		    }

		    /**
		     * Creates a function that invokes `func`, with the `this` binding and arguments
		     * of the created function, while it's called less than `n` times. Subsequent
		     * calls to the created function return the result of the last `func` invocation.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {number} n The number of calls at which `func` is no longer invoked.
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * jQuery(element).on('click', _.before(5, addContactToList));
		     * // => Allows adding up to 4 contacts to the list.
		     */
		    function before(n, func) {
		      var result;
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      n = toInteger(n);
		      return function() {
		        if (--n > 0) {
		          result = func.apply(this, arguments);
		        }
		        if (n <= 1) {
		          func = undefined$1;
		        }
		        return result;
		      };
		    }

		    /**
		     * Creates a function that invokes `func` with the `this` binding of `thisArg`
		     * and `partials` prepended to the arguments it receives.
		     *
		     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
		     * may be used as a placeholder for partially applied arguments.
		     *
		     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
		     * property of bound functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to bind.
		     * @param {*} thisArg The `this` binding of `func`.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new bound function.
		     * @example
		     *
		     * function greet(greeting, punctuation) {
		     *   return greeting + ' ' + this.user + punctuation;
		     * }
		     *
		     * var object = { 'user': 'fred' };
		     *
		     * var bound = _.bind(greet, object, 'hi');
		     * bound('!');
		     * // => 'hi fred!'
		     *
		     * // Bound with placeholders.
		     * var bound = _.bind(greet, object, _, '!');
		     * bound('hi');
		     * // => 'hi fred!'
		     */
		    var bind = baseRest(function(func, thisArg, partials) {
		      var bitmask = WRAP_BIND_FLAG;
		      if (partials.length) {
		        var holders = replaceHolders(partials, getHolder(bind));
		        bitmask |= WRAP_PARTIAL_FLAG;
		      }
		      return createWrap(func, bitmask, thisArg, partials, holders);
		    });

		    /**
		     * Creates a function that invokes the method at `object[key]` with `partials`
		     * prepended to the arguments it receives.
		     *
		     * This method differs from `_.bind` by allowing bound functions to reference
		     * methods that may be redefined or don't yet exist. See
		     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
		     * for more details.
		     *
		     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for partially applied arguments.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.10.0
		     * @category Function
		     * @param {Object} object The object to invoke the method on.
		     * @param {string} key The key of the method.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new bound function.
		     * @example
		     *
		     * var object = {
		     *   'user': 'fred',
		     *   'greet': function(greeting, punctuation) {
		     *     return greeting + ' ' + this.user + punctuation;
		     *   }
		     * };
		     *
		     * var bound = _.bindKey(object, 'greet', 'hi');
		     * bound('!');
		     * // => 'hi fred!'
		     *
		     * object.greet = function(greeting, punctuation) {
		     *   return greeting + 'ya ' + this.user + punctuation;
		     * };
		     *
		     * bound('!');
		     * // => 'hiya fred!'
		     *
		     * // Bound with placeholders.
		     * var bound = _.bindKey(object, 'greet', _, '!');
		     * bound('hi');
		     * // => 'hiya fred!'
		     */
		    var bindKey = baseRest(function(object, key, partials) {
		      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
		      if (partials.length) {
		        var holders = replaceHolders(partials, getHolder(bindKey));
		        bitmask |= WRAP_PARTIAL_FLAG;
		      }
		      return createWrap(key, bitmask, object, partials, holders);
		    });

		    /**
		     * Creates a function that accepts arguments of `func` and either invokes
		     * `func` returning its result, if at least `arity` number of arguments have
		     * been provided, or returns a function that accepts the remaining `func`
		     * arguments, and so on. The arity of `func` may be specified if `func.length`
		     * is not sufficient.
		     *
		     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
		     * may be used as a placeholder for provided arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of curried functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Function
		     * @param {Function} func The function to curry.
		     * @param {number} [arity=func.length] The arity of `func`.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the new curried function.
		     * @example
		     *
		     * var abc = function(a, b, c) {
		     *   return [a, b, c];
		     * };
		     *
		     * var curried = _.curry(abc);
		     *
		     * curried(1)(2)(3);
		     * // => [1, 2, 3]
		     *
		     * curried(1, 2)(3);
		     * // => [1, 2, 3]
		     *
		     * curried(1, 2, 3);
		     * // => [1, 2, 3]
		     *
		     * // Curried with placeholders.
		     * curried(1)(_, 3)(2);
		     * // => [1, 2, 3]
		     */
		    function curry(func, arity, guard) {
		      arity = guard ? undefined$1 : arity;
		      var result = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
		      result.placeholder = curry.placeholder;
		      return result;
		    }

		    /**
		     * This method is like `_.curry` except that arguments are applied to `func`
		     * in the manner of `_.partialRight` instead of `_.partial`.
		     *
		     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for provided arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of curried functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} func The function to curry.
		     * @param {number} [arity=func.length] The arity of `func`.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the new curried function.
		     * @example
		     *
		     * var abc = function(a, b, c) {
		     *   return [a, b, c];
		     * };
		     *
		     * var curried = _.curryRight(abc);
		     *
		     * curried(3)(2)(1);
		     * // => [1, 2, 3]
		     *
		     * curried(2, 3)(1);
		     * // => [1, 2, 3]
		     *
		     * curried(1, 2, 3);
		     * // => [1, 2, 3]
		     *
		     * // Curried with placeholders.
		     * curried(3)(1, _)(2);
		     * // => [1, 2, 3]
		     */
		    function curryRight(func, arity, guard) {
		      arity = guard ? undefined$1 : arity;
		      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
		      result.placeholder = curryRight.placeholder;
		      return result;
		    }

		    /**
		     * Creates a debounced function that delays invoking `func` until after `wait`
		     * milliseconds have elapsed since the last time the debounced function was
		     * invoked. The debounced function comes with a `cancel` method to cancel
		     * delayed `func` invocations and a `flush` method to immediately invoke them.
		     * Provide `options` to indicate whether `func` should be invoked on the
		     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
		     * with the last arguments provided to the debounced function. Subsequent
		     * calls to the debounced function return the result of the last `func`
		     * invocation.
		     *
		     * **Note:** If `leading` and `trailing` options are `true`, `func` is
		     * invoked on the trailing edge of the timeout only if the debounced function
		     * is invoked more than once during the `wait` timeout.
		     *
		     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
		     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
		     *
		     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
		     * for details over the differences between `_.debounce` and `_.throttle`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to debounce.
		     * @param {number} [wait=0] The number of milliseconds to delay.
		     * @param {Object} [options={}] The options object.
		     * @param {boolean} [options.leading=false]
		     *  Specify invoking on the leading edge of the timeout.
		     * @param {number} [options.maxWait]
		     *  The maximum time `func` is allowed to be delayed before it's invoked.
		     * @param {boolean} [options.trailing=true]
		     *  Specify invoking on the trailing edge of the timeout.
		     * @returns {Function} Returns the new debounced function.
		     * @example
		     *
		     * // Avoid costly calculations while the window size is in flux.
		     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
		     *
		     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
		     * jQuery(element).on('click', _.debounce(sendMail, 300, {
		     *   'leading': true,
		     *   'trailing': false
		     * }));
		     *
		     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
		     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
		     * var source = new EventSource('/stream');
		     * jQuery(source).on('message', debounced);
		     *
		     * // Cancel the trailing debounced invocation.
		     * jQuery(window).on('popstate', debounced.cancel);
		     */
		    function debounce(func, wait, options) {
		      var lastArgs,
		          lastThis,
		          maxWait,
		          result,
		          timerId,
		          lastCallTime,
		          lastInvokeTime = 0,
		          leading = false,
		          maxing = false,
		          trailing = true;

		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      wait = toNumber(wait) || 0;
		      if (isObject(options)) {
		        leading = !!options.leading;
		        maxing = 'maxWait' in options;
		        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
		        trailing = 'trailing' in options ? !!options.trailing : trailing;
		      }

		      function invokeFunc(time) {
		        var args = lastArgs,
		            thisArg = lastThis;

		        lastArgs = lastThis = undefined$1;
		        lastInvokeTime = time;
		        result = func.apply(thisArg, args);
		        return result;
		      }

		      function leadingEdge(time) {
		        // Reset any `maxWait` timer.
		        lastInvokeTime = time;
		        // Start the timer for the trailing edge.
		        timerId = setTimeout(timerExpired, wait);
		        // Invoke the leading edge.
		        return leading ? invokeFunc(time) : result;
		      }

		      function remainingWait(time) {
		        var timeSinceLastCall = time - lastCallTime,
		            timeSinceLastInvoke = time - lastInvokeTime,
		            timeWaiting = wait - timeSinceLastCall;

		        return maxing
		          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
		          : timeWaiting;
		      }

		      function shouldInvoke(time) {
		        var timeSinceLastCall = time - lastCallTime,
		            timeSinceLastInvoke = time - lastInvokeTime;

		        // Either this is the first call, activity has stopped and we're at the
		        // trailing edge, the system time has gone backwards and we're treating
		        // it as the trailing edge, or we've hit the `maxWait` limit.
		        return (lastCallTime === undefined$1 || (timeSinceLastCall >= wait) ||
		          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
		      }

		      function timerExpired() {
		        var time = now();
		        if (shouldInvoke(time)) {
		          return trailingEdge(time);
		        }
		        // Restart the timer.
		        timerId = setTimeout(timerExpired, remainingWait(time));
		      }

		      function trailingEdge(time) {
		        timerId = undefined$1;

		        // Only invoke if we have `lastArgs` which means `func` has been
		        // debounced at least once.
		        if (trailing && lastArgs) {
		          return invokeFunc(time);
		        }
		        lastArgs = lastThis = undefined$1;
		        return result;
		      }

		      function cancel() {
		        if (timerId !== undefined$1) {
		          clearTimeout(timerId);
		        }
		        lastInvokeTime = 0;
		        lastArgs = lastCallTime = lastThis = timerId = undefined$1;
		      }

		      function flush() {
		        return timerId === undefined$1 ? result : trailingEdge(now());
		      }

		      function debounced() {
		        var time = now(),
		            isInvoking = shouldInvoke(time);

		        lastArgs = arguments;
		        lastThis = this;
		        lastCallTime = time;

		        if (isInvoking) {
		          if (timerId === undefined$1) {
		            return leadingEdge(lastCallTime);
		          }
		          if (maxing) {
		            // Handle invocations in a tight loop.
		            clearTimeout(timerId);
		            timerId = setTimeout(timerExpired, wait);
		            return invokeFunc(lastCallTime);
		          }
		        }
		        if (timerId === undefined$1) {
		          timerId = setTimeout(timerExpired, wait);
		        }
		        return result;
		      }
		      debounced.cancel = cancel;
		      debounced.flush = flush;
		      return debounced;
		    }

		    /**
		     * Defers invoking the `func` until the current call stack has cleared. Any
		     * additional arguments are provided to `func` when it's invoked.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to defer.
		     * @param {...*} [args] The arguments to invoke `func` with.
		     * @returns {number} Returns the timer id.
		     * @example
		     *
		     * _.defer(function(text) {
		     *   console.log(text);
		     * }, 'deferred');
		     * // => Logs 'deferred' after one millisecond.
		     */
		    var defer = baseRest(function(func, args) {
		      return baseDelay(func, 1, args);
		    });

		    /**
		     * Invokes `func` after `wait` milliseconds. Any additional arguments are
		     * provided to `func` when it's invoked.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to delay.
		     * @param {number} wait The number of milliseconds to delay invocation.
		     * @param {...*} [args] The arguments to invoke `func` with.
		     * @returns {number} Returns the timer id.
		     * @example
		     *
		     * _.delay(function(text) {
		     *   console.log(text);
		     * }, 1000, 'later');
		     * // => Logs 'later' after one second.
		     */
		    var delay = baseRest(function(func, wait, args) {
		      return baseDelay(func, toNumber(wait) || 0, args);
		    });

		    /**
		     * Creates a function that invokes `func` with arguments reversed.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Function
		     * @param {Function} func The function to flip arguments for.
		     * @returns {Function} Returns the new flipped function.
		     * @example
		     *
		     * var flipped = _.flip(function() {
		     *   return _.toArray(arguments);
		     * });
		     *
		     * flipped('a', 'b', 'c', 'd');
		     * // => ['d', 'c', 'b', 'a']
		     */
		    function flip(func) {
		      return createWrap(func, WRAP_FLIP_FLAG);
		    }

		    /**
		     * Creates a function that memoizes the result of `func`. If `resolver` is
		     * provided, it determines the cache key for storing the result based on the
		     * arguments provided to the memoized function. By default, the first argument
		     * provided to the memoized function is used as the map cache key. The `func`
		     * is invoked with the `this` binding of the memoized function.
		     *
		     * **Note:** The cache is exposed as the `cache` property on the memoized
		     * function. Its creation may be customized by replacing the `_.memoize.Cache`
		     * constructor with one whose instances implement the
		     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
		     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to have its output memoized.
		     * @param {Function} [resolver] The function to resolve the cache key.
		     * @returns {Function} Returns the new memoized function.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2 };
		     * var other = { 'c': 3, 'd': 4 };
		     *
		     * var values = _.memoize(_.values);
		     * values(object);
		     * // => [1, 2]
		     *
		     * values(other);
		     * // => [3, 4]
		     *
		     * object.a = 2;
		     * values(object);
		     * // => [1, 2]
		     *
		     * // Modify the result cache.
		     * values.cache.set(object, ['a', 'b']);
		     * values(object);
		     * // => ['a', 'b']
		     *
		     * // Replace `_.memoize.Cache`.
		     * _.memoize.Cache = WeakMap;
		     */
		    function memoize(func, resolver) {
		      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      var memoized = function() {
		        var args = arguments,
		            key = resolver ? resolver.apply(this, args) : args[0],
		            cache = memoized.cache;

		        if (cache.has(key)) {
		          return cache.get(key);
		        }
		        var result = func.apply(this, args);
		        memoized.cache = cache.set(key, result) || cache;
		        return result;
		      };
		      memoized.cache = new (memoize.Cache || MapCache);
		      return memoized;
		    }

		    // Expose `MapCache`.
		    memoize.Cache = MapCache;

		    /**
		     * Creates a function that negates the result of the predicate `func`. The
		     * `func` predicate is invoked with the `this` binding and arguments of the
		     * created function.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} predicate The predicate to negate.
		     * @returns {Function} Returns the new negated function.
		     * @example
		     *
		     * function isEven(n) {
		     *   return n % 2 == 0;
		     * }
		     *
		     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
		     * // => [1, 3, 5]
		     */
		    function negate(predicate) {
		      if (typeof predicate != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      return function() {
		        var args = arguments;
		        switch (args.length) {
		          case 0: return !predicate.call(this);
		          case 1: return !predicate.call(this, args[0]);
		          case 2: return !predicate.call(this, args[0], args[1]);
		          case 3: return !predicate.call(this, args[0], args[1], args[2]);
		        }
		        return !predicate.apply(this, args);
		      };
		    }

		    /**
		     * Creates a function that is restricted to invoking `func` once. Repeat calls
		     * to the function return the value of the first invocation. The `func` is
		     * invoked with the `this` binding and arguments of the created function.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * var initialize = _.once(createApplication);
		     * initialize();
		     * initialize();
		     * // => `createApplication` is invoked once
		     */
		    function once(func) {
		      return before(2, func);
		    }

		    /**
		     * Creates a function that invokes `func` with its arguments transformed.
		     *
		     * @static
		     * @since 4.0.0
		     * @memberOf _
		     * @category Function
		     * @param {Function} func The function to wrap.
		     * @param {...(Function|Function[])} [transforms=[_.identity]]
		     *  The argument transforms.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * function doubled(n) {
		     *   return n * 2;
		     * }
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var func = _.overArgs(function(x, y) {
		     *   return [x, y];
		     * }, [square, doubled]);
		     *
		     * func(9, 3);
		     * // => [81, 6]
		     *
		     * func(10, 5);
		     * // => [100, 10]
		     */
		    var overArgs = castRest(function(func, transforms) {
		      transforms = (transforms.length == 1 && isArray(transforms[0]))
		        ? arrayMap(transforms[0], baseUnary(getIteratee()))
		        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

		      var funcsLength = transforms.length;
		      return baseRest(function(args) {
		        var index = -1,
		            length = nativeMin(args.length, funcsLength);

		        while (++index < length) {
		          args[index] = transforms[index].call(this, args[index]);
		        }
		        return apply(func, this, args);
		      });
		    });

		    /**
		     * Creates a function that invokes `func` with `partials` prepended to the
		     * arguments it receives. This method is like `_.bind` except it does **not**
		     * alter the `this` binding.
		     *
		     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for partially applied arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of partially
		     * applied functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.2.0
		     * @category Function
		     * @param {Function} func The function to partially apply arguments to.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new partially applied function.
		     * @example
		     *
		     * function greet(greeting, name) {
		     *   return greeting + ' ' + name;
		     * }
		     *
		     * var sayHelloTo = _.partial(greet, 'hello');
		     * sayHelloTo('fred');
		     * // => 'hello fred'
		     *
		     * // Partially applied with placeholders.
		     * var greetFred = _.partial(greet, _, 'fred');
		     * greetFred('hi');
		     * // => 'hi fred'
		     */
		    var partial = baseRest(function(func, partials) {
		      var holders = replaceHolders(partials, getHolder(partial));
		      return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
		    });

		    /**
		     * This method is like `_.partial` except that partially applied arguments
		     * are appended to the arguments it receives.
		     *
		     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for partially applied arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of partially
		     * applied functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.0.0
		     * @category Function
		     * @param {Function} func The function to partially apply arguments to.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new partially applied function.
		     * @example
		     *
		     * function greet(greeting, name) {
		     *   return greeting + ' ' + name;
		     * }
		     *
		     * var greetFred = _.partialRight(greet, 'fred');
		     * greetFred('hi');
		     * // => 'hi fred'
		     *
		     * // Partially applied with placeholders.
		     * var sayHelloTo = _.partialRight(greet, 'hello', _);
		     * sayHelloTo('fred');
		     * // => 'hello fred'
		     */
		    var partialRight = baseRest(function(func, partials) {
		      var holders = replaceHolders(partials, getHolder(partialRight));
		      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
		    });

		    /**
		     * Creates a function that invokes `func` with arguments arranged according
		     * to the specified `indexes` where the argument value at the first index is
		     * provided as the first argument, the argument value at the second index is
		     * provided as the second argument, and so on.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} func The function to rearrange arguments for.
		     * @param {...(number|number[])} indexes The arranged argument indexes.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var rearged = _.rearg(function(a, b, c) {
		     *   return [a, b, c];
		     * }, [2, 0, 1]);
		     *
		     * rearged('b', 'c', 'a')
		     * // => ['a', 'b', 'c']
		     */
		    var rearg = flatRest(function(func, indexes) {
		      return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
		    });

		    /**
		     * Creates a function that invokes `func` with the `this` binding of the
		     * created function and arguments from `start` and beyond provided as
		     * an array.
		     *
		     * **Note:** This method is based on the
		     * [rest parameter](https://mdn.io/rest_parameters).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Function
		     * @param {Function} func The function to apply a rest parameter to.
		     * @param {number} [start=func.length-1] The start position of the rest parameter.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var say = _.rest(function(what, names) {
		     *   return what + ' ' + _.initial(names).join(', ') +
		     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
		     * });
		     *
		     * say('hello', 'fred', 'barney', 'pebbles');
		     * // => 'hello fred, barney, & pebbles'
		     */
		    function rest(func, start) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      start = start === undefined$1 ? start : toInteger(start);
		      return baseRest(func, start);
		    }

		    /**
		     * Creates a function that invokes `func` with the `this` binding of the
		     * create function and an array of arguments much like
		     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
		     *
		     * **Note:** This method is based on the
		     * [spread operator](https://mdn.io/spread_operator).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.2.0
		     * @category Function
		     * @param {Function} func The function to spread arguments over.
		     * @param {number} [start=0] The start position of the spread.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var say = _.spread(function(who, what) {
		     *   return who + ' says ' + what;
		     * });
		     *
		     * say(['fred', 'hello']);
		     * // => 'fred says hello'
		     *
		     * var numbers = Promise.all([
		     *   Promise.resolve(40),
		     *   Promise.resolve(36)
		     * ]);
		     *
		     * numbers.then(_.spread(function(x, y) {
		     *   return x + y;
		     * }));
		     * // => a Promise of 76
		     */
		    function spread(func, start) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      start = start == null ? 0 : nativeMax(toInteger(start), 0);
		      return baseRest(function(args) {
		        var array = args[start],
		            otherArgs = castSlice(args, 0, start);

		        if (array) {
		          arrayPush(otherArgs, array);
		        }
		        return apply(func, this, otherArgs);
		      });
		    }

		    /**
		     * Creates a throttled function that only invokes `func` at most once per
		     * every `wait` milliseconds. The throttled function comes with a `cancel`
		     * method to cancel delayed `func` invocations and a `flush` method to
		     * immediately invoke them. Provide `options` to indicate whether `func`
		     * should be invoked on the leading and/or trailing edge of the `wait`
		     * timeout. The `func` is invoked with the last arguments provided to the
		     * throttled function. Subsequent calls to the throttled function return the
		     * result of the last `func` invocation.
		     *
		     * **Note:** If `leading` and `trailing` options are `true`, `func` is
		     * invoked on the trailing edge of the timeout only if the throttled function
		     * is invoked more than once during the `wait` timeout.
		     *
		     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
		     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
		     *
		     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
		     * for details over the differences between `_.throttle` and `_.debounce`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to throttle.
		     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
		     * @param {Object} [options={}] The options object.
		     * @param {boolean} [options.leading=true]
		     *  Specify invoking on the leading edge of the timeout.
		     * @param {boolean} [options.trailing=true]
		     *  Specify invoking on the trailing edge of the timeout.
		     * @returns {Function} Returns the new throttled function.
		     * @example
		     *
		     * // Avoid excessively updating the position while scrolling.
		     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
		     *
		     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
		     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
		     * jQuery(element).on('click', throttled);
		     *
		     * // Cancel the trailing throttled invocation.
		     * jQuery(window).on('popstate', throttled.cancel);
		     */
		    function throttle(func, wait, options) {
		      var leading = true,
		          trailing = true;

		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      if (isObject(options)) {
		        leading = 'leading' in options ? !!options.leading : leading;
		        trailing = 'trailing' in options ? !!options.trailing : trailing;
		      }
		      return debounce(func, wait, {
		        'leading': leading,
		        'maxWait': wait,
		        'trailing': trailing
		      });
		    }

		    /**
		     * Creates a function that accepts up to one argument, ignoring any
		     * additional arguments.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Function
		     * @param {Function} func The function to cap arguments for.
		     * @returns {Function} Returns the new capped function.
		     * @example
		     *
		     * _.map(['6', '8', '10'], _.unary(parseInt));
		     * // => [6, 8, 10]
		     */
		    function unary(func) {
		      return ary(func, 1);
		    }

		    /**
		     * Creates a function that provides `value` to `wrapper` as its first
		     * argument. Any additional arguments provided to the function are appended
		     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
		     * binding of the created function.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {*} value The value to wrap.
		     * @param {Function} [wrapper=identity] The wrapper function.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var p = _.wrap(_.escape, function(func, text) {
		     *   return '<p>' + func(text) + '</p>';
		     * });
		     *
		     * p('fred, barney, & pebbles');
		     * // => '<p>fred, barney, &amp; pebbles</p>'
		     */
		    function wrap(value, wrapper) {
		      return partial(castFunction(wrapper), value);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Casts `value` as an array if it's not one.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.4.0
		     * @category Lang
		     * @param {*} value The value to inspect.
		     * @returns {Array} Returns the cast array.
		     * @example
		     *
		     * _.castArray(1);
		     * // => [1]
		     *
		     * _.castArray({ 'a': 1 });
		     * // => [{ 'a': 1 }]
		     *
		     * _.castArray('abc');
		     * // => ['abc']
		     *
		     * _.castArray(null);
		     * // => [null]
		     *
		     * _.castArray(undefined);
		     * // => [undefined]
		     *
		     * _.castArray();
		     * // => []
		     *
		     * var array = [1, 2, 3];
		     * console.log(_.castArray(array) === array);
		     * // => true
		     */
		    function castArray() {
		      if (!arguments.length) {
		        return [];
		      }
		      var value = arguments[0];
		      return isArray(value) ? value : [value];
		    }

		    /**
		     * Creates a shallow clone of `value`.
		     *
		     * **Note:** This method is loosely based on the
		     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
		     * and supports cloning arrays, array buffers, booleans, date objects, maps,
		     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
		     * arrays. The own enumerable properties of `arguments` objects are cloned
		     * as plain objects. An empty object is returned for uncloneable values such
		     * as error objects, functions, DOM nodes, and WeakMaps.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to clone.
		     * @returns {*} Returns the cloned value.
		     * @see _.cloneDeep
		     * @example
		     *
		     * var objects = [{ 'a': 1 }, { 'b': 2 }];
		     *
		     * var shallow = _.clone(objects);
		     * console.log(shallow[0] === objects[0]);
		     * // => true
		     */
		    function clone(value) {
		      return baseClone(value, CLONE_SYMBOLS_FLAG);
		    }

		    /**
		     * This method is like `_.clone` except that it accepts `customizer` which
		     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
		     * cloning is handled by the method instead. The `customizer` is invoked with
		     * up to four arguments; (value [, index|key, object, stack]).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to clone.
		     * @param {Function} [customizer] The function to customize cloning.
		     * @returns {*} Returns the cloned value.
		     * @see _.cloneDeepWith
		     * @example
		     *
		     * function customizer(value) {
		     *   if (_.isElement(value)) {
		     *     return value.cloneNode(false);
		     *   }
		     * }
		     *
		     * var el = _.cloneWith(document.body, customizer);
		     *
		     * console.log(el === document.body);
		     * // => false
		     * console.log(el.nodeName);
		     * // => 'BODY'
		     * console.log(el.childNodes.length);
		     * // => 0
		     */
		    function cloneWith(value, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
		    }

		    /**
		     * This method is like `_.clone` except that it recursively clones `value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.0.0
		     * @category Lang
		     * @param {*} value The value to recursively clone.
		     * @returns {*} Returns the deep cloned value.
		     * @see _.clone
		     * @example
		     *
		     * var objects = [{ 'a': 1 }, { 'b': 2 }];
		     *
		     * var deep = _.cloneDeep(objects);
		     * console.log(deep[0] === objects[0]);
		     * // => false
		     */
		    function cloneDeep(value) {
		      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
		    }

		    /**
		     * This method is like `_.cloneWith` except that it recursively clones `value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to recursively clone.
		     * @param {Function} [customizer] The function to customize cloning.
		     * @returns {*} Returns the deep cloned value.
		     * @see _.cloneWith
		     * @example
		     *
		     * function customizer(value) {
		     *   if (_.isElement(value)) {
		     *     return value.cloneNode(true);
		     *   }
		     * }
		     *
		     * var el = _.cloneDeepWith(document.body, customizer);
		     *
		     * console.log(el === document.body);
		     * // => false
		     * console.log(el.nodeName);
		     * // => 'BODY'
		     * console.log(el.childNodes.length);
		     * // => 20
		     */
		    function cloneDeepWith(value, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
		    }

		    /**
		     * Checks if `object` conforms to `source` by invoking the predicate
		     * properties of `source` with the corresponding property values of `object`.
		     *
		     * **Note:** This method is equivalent to `_.conforms` when `source` is
		     * partially applied.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.14.0
		     * @category Lang
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2 };
		     *
		     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
		     * // => true
		     *
		     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
		     * // => false
		     */
		    function conformsTo(object, source) {
		      return source == null || baseConformsTo(object, source, keys(source));
		    }

		    /**
		     * Performs a
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * comparison between two values to determine if they are equivalent.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1 };
		     * var other = { 'a': 1 };
		     *
		     * _.eq(object, object);
		     * // => true
		     *
		     * _.eq(object, other);
		     * // => false
		     *
		     * _.eq('a', 'a');
		     * // => true
		     *
		     * _.eq('a', Object('a'));
		     * // => false
		     *
		     * _.eq(NaN, NaN);
		     * // => true
		     */
		    function eq(value, other) {
		      return value === other || (value !== value && other !== other);
		    }

		    /**
		     * Checks if `value` is greater than `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is greater than `other`,
		     *  else `false`.
		     * @see _.lt
		     * @example
		     *
		     * _.gt(3, 1);
		     * // => true
		     *
		     * _.gt(3, 3);
		     * // => false
		     *
		     * _.gt(1, 3);
		     * // => false
		     */
		    var gt = createRelationalOperation(baseGt);

		    /**
		     * Checks if `value` is greater than or equal to `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is greater than or equal to
		     *  `other`, else `false`.
		     * @see _.lte
		     * @example
		     *
		     * _.gte(3, 1);
		     * // => true
		     *
		     * _.gte(3, 3);
		     * // => true
		     *
		     * _.gte(1, 3);
		     * // => false
		     */
		    var gte = createRelationalOperation(function(value, other) {
		      return value >= other;
		    });

		    /**
		     * Checks if `value` is likely an `arguments` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
		     *  else `false`.
		     * @example
		     *
		     * _.isArguments(function() { return arguments; }());
		     * // => true
		     *
		     * _.isArguments([1, 2, 3]);
		     * // => false
		     */
		    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
		      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
		        !propertyIsEnumerable.call(value, 'callee');
		    };

		    /**
		     * Checks if `value` is classified as an `Array` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
		     * @example
		     *
		     * _.isArray([1, 2, 3]);
		     * // => true
		     *
		     * _.isArray(document.body.children);
		     * // => false
		     *
		     * _.isArray('abc');
		     * // => false
		     *
		     * _.isArray(_.noop);
		     * // => false
		     */
		    var isArray = Array.isArray;

		    /**
		     * Checks if `value` is classified as an `ArrayBuffer` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
		     * @example
		     *
		     * _.isArrayBuffer(new ArrayBuffer(2));
		     * // => true
		     *
		     * _.isArrayBuffer(new Array(2));
		     * // => false
		     */
		    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

		    /**
		     * Checks if `value` is array-like. A value is considered array-like if it's
		     * not a function and has a `value.length` that's an integer greater than or
		     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
		     * @example
		     *
		     * _.isArrayLike([1, 2, 3]);
		     * // => true
		     *
		     * _.isArrayLike(document.body.children);
		     * // => true
		     *
		     * _.isArrayLike('abc');
		     * // => true
		     *
		     * _.isArrayLike(_.noop);
		     * // => false
		     */
		    function isArrayLike(value) {
		      return value != null && isLength(value.length) && !isFunction(value);
		    }

		    /**
		     * This method is like `_.isArrayLike` except that it also checks if `value`
		     * is an object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array-like object,
		     *  else `false`.
		     * @example
		     *
		     * _.isArrayLikeObject([1, 2, 3]);
		     * // => true
		     *
		     * _.isArrayLikeObject(document.body.children);
		     * // => true
		     *
		     * _.isArrayLikeObject('abc');
		     * // => false
		     *
		     * _.isArrayLikeObject(_.noop);
		     * // => false
		     */
		    function isArrayLikeObject(value) {
		      return isObjectLike(value) && isArrayLike(value);
		    }

		    /**
		     * Checks if `value` is classified as a boolean primitive or object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
		     * @example
		     *
		     * _.isBoolean(false);
		     * // => true
		     *
		     * _.isBoolean(null);
		     * // => false
		     */
		    function isBoolean(value) {
		      return value === true || value === false ||
		        (isObjectLike(value) && baseGetTag(value) == boolTag);
		    }

		    /**
		     * Checks if `value` is a buffer.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
		     * @example
		     *
		     * _.isBuffer(new Buffer(2));
		     * // => true
		     *
		     * _.isBuffer(new Uint8Array(2));
		     * // => false
		     */
		    var isBuffer = nativeIsBuffer || stubFalse;

		    /**
		     * Checks if `value` is classified as a `Date` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
		     * @example
		     *
		     * _.isDate(new Date);
		     * // => true
		     *
		     * _.isDate('Mon April 23 2012');
		     * // => false
		     */
		    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

		    /**
		     * Checks if `value` is likely a DOM element.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
		     * @example
		     *
		     * _.isElement(document.body);
		     * // => true
		     *
		     * _.isElement('<body>');
		     * // => false
		     */
		    function isElement(value) {
		      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
		    }

		    /**
		     * Checks if `value` is an empty object, collection, map, or set.
		     *
		     * Objects are considered empty if they have no own enumerable string keyed
		     * properties.
		     *
		     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
		     * jQuery-like collections are considered empty if they have a `length` of `0`.
		     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
		     * @example
		     *
		     * _.isEmpty(null);
		     * // => true
		     *
		     * _.isEmpty(true);
		     * // => true
		     *
		     * _.isEmpty(1);
		     * // => true
		     *
		     * _.isEmpty([1, 2, 3]);
		     * // => false
		     *
		     * _.isEmpty({ 'a': 1 });
		     * // => false
		     */
		    function isEmpty(value) {
		      if (value == null) {
		        return true;
		      }
		      if (isArrayLike(value) &&
		          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
		            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
		        return !value.length;
		      }
		      var tag = getTag(value);
		      if (tag == mapTag || tag == setTag) {
		        return !value.size;
		      }
		      if (isPrototype(value)) {
		        return !baseKeys(value).length;
		      }
		      for (var key in value) {
		        if (hasOwnProperty.call(value, key)) {
		          return false;
		        }
		      }
		      return true;
		    }

		    /**
		     * Performs a deep comparison between two values to determine if they are
		     * equivalent.
		     *
		     * **Note:** This method supports comparing arrays, array buffers, booleans,
		     * date objects, error objects, maps, numbers, `Object` objects, regexes,
		     * sets, strings, symbols, and typed arrays. `Object` objects are compared
		     * by their own, not inherited, enumerable properties. Functions and DOM
		     * nodes are compared by strict equality, i.e. `===`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1 };
		     * var other = { 'a': 1 };
		     *
		     * _.isEqual(object, other);
		     * // => true
		     *
		     * object === other;
		     * // => false
		     */
		    function isEqual(value, other) {
		      return baseIsEqual(value, other);
		    }

		    /**
		     * This method is like `_.isEqual` except that it accepts `customizer` which
		     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
		     * are handled by the method instead. The `customizer` is invoked with up to
		     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     * @example
		     *
		     * function isGreeting(value) {
		     *   return /^h(?:i|ello)$/.test(value);
		     * }
		     *
		     * function customizer(objValue, othValue) {
		     *   if (isGreeting(objValue) && isGreeting(othValue)) {
		     *     return true;
		     *   }
		     * }
		     *
		     * var array = ['hello', 'goodbye'];
		     * var other = ['hi', 'goodbye'];
		     *
		     * _.isEqualWith(array, other, customizer);
		     * // => true
		     */
		    function isEqualWith(value, other, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      var result = customizer ? customizer(value, other) : undefined$1;
		      return result === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result;
		    }

		    /**
		     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
		     * `SyntaxError`, `TypeError`, or `URIError` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
		     * @example
		     *
		     * _.isError(new Error);
		     * // => true
		     *
		     * _.isError(Error);
		     * // => false
		     */
		    function isError(value) {
		      if (!isObjectLike(value)) {
		        return false;
		      }
		      var tag = baseGetTag(value);
		      return tag == errorTag || tag == domExcTag ||
		        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
		    }

		    /**
		     * Checks if `value` is a finite primitive number.
		     *
		     * **Note:** This method is based on
		     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
		     * @example
		     *
		     * _.isFinite(3);
		     * // => true
		     *
		     * _.isFinite(Number.MIN_VALUE);
		     * // => true
		     *
		     * _.isFinite(Infinity);
		     * // => false
		     *
		     * _.isFinite('3');
		     * // => false
		     */
		    function isFinite(value) {
		      return typeof value == 'number' && nativeIsFinite(value);
		    }

		    /**
		     * Checks if `value` is classified as a `Function` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
		     * @example
		     *
		     * _.isFunction(_);
		     * // => true
		     *
		     * _.isFunction(/abc/);
		     * // => false
		     */
		    function isFunction(value) {
		      if (!isObject(value)) {
		        return false;
		      }
		      // The use of `Object#toString` avoids issues with the `typeof` operator
		      // in Safari 9 which returns 'object' for typed arrays and other constructors.
		      var tag = baseGetTag(value);
		      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
		    }

		    /**
		     * Checks if `value` is an integer.
		     *
		     * **Note:** This method is based on
		     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
		     * @example
		     *
		     * _.isInteger(3);
		     * // => true
		     *
		     * _.isInteger(Number.MIN_VALUE);
		     * // => false
		     *
		     * _.isInteger(Infinity);
		     * // => false
		     *
		     * _.isInteger('3');
		     * // => false
		     */
		    function isInteger(value) {
		      return typeof value == 'number' && value == toInteger(value);
		    }

		    /**
		     * Checks if `value` is a valid array-like length.
		     *
		     * **Note:** This method is loosely based on
		     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
		     * @example
		     *
		     * _.isLength(3);
		     * // => true
		     *
		     * _.isLength(Number.MIN_VALUE);
		     * // => false
		     *
		     * _.isLength(Infinity);
		     * // => false
		     *
		     * _.isLength('3');
		     * // => false
		     */
		    function isLength(value) {
		      return typeof value == 'number' &&
		        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
		    }

		    /**
		     * Checks if `value` is the
		     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
		     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
		     * @example
		     *
		     * _.isObject({});
		     * // => true
		     *
		     * _.isObject([1, 2, 3]);
		     * // => true
		     *
		     * _.isObject(_.noop);
		     * // => true
		     *
		     * _.isObject(null);
		     * // => false
		     */
		    function isObject(value) {
		      var type = typeof value;
		      return value != null && (type == 'object' || type == 'function');
		    }

		    /**
		     * Checks if `value` is object-like. A value is object-like if it's not `null`
		     * and has a `typeof` result of "object".
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
		     * @example
		     *
		     * _.isObjectLike({});
		     * // => true
		     *
		     * _.isObjectLike([1, 2, 3]);
		     * // => true
		     *
		     * _.isObjectLike(_.noop);
		     * // => false
		     *
		     * _.isObjectLike(null);
		     * // => false
		     */
		    function isObjectLike(value) {
		      return value != null && typeof value == 'object';
		    }

		    /**
		     * Checks if `value` is classified as a `Map` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
		     * @example
		     *
		     * _.isMap(new Map);
		     * // => true
		     *
		     * _.isMap(new WeakMap);
		     * // => false
		     */
		    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

		    /**
		     * Performs a partial deep comparison between `object` and `source` to
		     * determine if `object` contains equivalent property values.
		     *
		     * **Note:** This method is equivalent to `_.matches` when `source` is
		     * partially applied.
		     *
		     * Partial comparisons will match empty array and empty object `source`
		     * values against any array or object value, respectively. See `_.isEqual`
		     * for a list of supported value comparisons.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property values to match.
		     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2 };
		     *
		     * _.isMatch(object, { 'b': 2 });
		     * // => true
		     *
		     * _.isMatch(object, { 'b': 1 });
		     * // => false
		     */
		    function isMatch(object, source) {
		      return object === source || baseIsMatch(object, source, getMatchData(source));
		    }

		    /**
		     * This method is like `_.isMatch` except that it accepts `customizer` which
		     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
		     * are handled by the method instead. The `customizer` is invoked with five
		     * arguments: (objValue, srcValue, index|key, object, source).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property values to match.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		     * @example
		     *
		     * function isGreeting(value) {
		     *   return /^h(?:i|ello)$/.test(value);
		     * }
		     *
		     * function customizer(objValue, srcValue) {
		     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
		     *     return true;
		     *   }
		     * }
		     *
		     * var object = { 'greeting': 'hello' };
		     * var source = { 'greeting': 'hi' };
		     *
		     * _.isMatchWith(object, source, customizer);
		     * // => true
		     */
		    function isMatchWith(object, source, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return baseIsMatch(object, source, getMatchData(source), customizer);
		    }

		    /**
		     * Checks if `value` is `NaN`.
		     *
		     * **Note:** This method is based on
		     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
		     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
		     * `undefined` and other non-number values.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
		     * @example
		     *
		     * _.isNaN(NaN);
		     * // => true
		     *
		     * _.isNaN(new Number(NaN));
		     * // => true
		     *
		     * isNaN(undefined);
		     * // => true
		     *
		     * _.isNaN(undefined);
		     * // => false
		     */
		    function isNaN(value) {
		      // An `NaN` primitive is the only value that is not equal to itself.
		      // Perform the `toStringTag` check first to avoid errors with some
		      // ActiveX objects in IE.
		      return isNumber(value) && value != +value;
		    }

		    /**
		     * Checks if `value` is a pristine native function.
		     *
		     * **Note:** This method can't reliably detect native functions in the presence
		     * of the core-js package because core-js circumvents this kind of detection.
		     * Despite multiple requests, the core-js maintainer has made it clear: any
		     * attempt to fix the detection will be obstructed. As a result, we're left
		     * with little choice but to throw an error. Unfortunately, this also affects
		     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
		     * which rely on core-js.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a native function,
		     *  else `false`.
		     * @example
		     *
		     * _.isNative(Array.prototype.push);
		     * // => true
		     *
		     * _.isNative(_);
		     * // => false
		     */
		    function isNative(value) {
		      if (isMaskable(value)) {
		        throw new Error(CORE_ERROR_TEXT);
		      }
		      return baseIsNative(value);
		    }

		    /**
		     * Checks if `value` is `null`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
		     * @example
		     *
		     * _.isNull(null);
		     * // => true
		     *
		     * _.isNull(void 0);
		     * // => false
		     */
		    function isNull(value) {
		      return value === null;
		    }

		    /**
		     * Checks if `value` is `null` or `undefined`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
		     * @example
		     *
		     * _.isNil(null);
		     * // => true
		     *
		     * _.isNil(void 0);
		     * // => true
		     *
		     * _.isNil(NaN);
		     * // => false
		     */
		    function isNil(value) {
		      return value == null;
		    }

		    /**
		     * Checks if `value` is classified as a `Number` primitive or object.
		     *
		     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
		     * classified as numbers, use the `_.isFinite` method.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
		     * @example
		     *
		     * _.isNumber(3);
		     * // => true
		     *
		     * _.isNumber(Number.MIN_VALUE);
		     * // => true
		     *
		     * _.isNumber(Infinity);
		     * // => true
		     *
		     * _.isNumber('3');
		     * // => false
		     */
		    function isNumber(value) {
		      return typeof value == 'number' ||
		        (isObjectLike(value) && baseGetTag(value) == numberTag);
		    }

		    /**
		     * Checks if `value` is a plain object, that is, an object created by the
		     * `Object` constructor or one with a `[[Prototype]]` of `null`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.8.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     * }
		     *
		     * _.isPlainObject(new Foo);
		     * // => false
		     *
		     * _.isPlainObject([1, 2, 3]);
		     * // => false
		     *
		     * _.isPlainObject({ 'x': 0, 'y': 0 });
		     * // => true
		     *
		     * _.isPlainObject(Object.create(null));
		     * // => true
		     */
		    function isPlainObject(value) {
		      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
		        return false;
		      }
		      var proto = getPrototype(value);
		      if (proto === null) {
		        return true;
		      }
		      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
		      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
		        funcToString.call(Ctor) == objectCtorString;
		    }

		    /**
		     * Checks if `value` is classified as a `RegExp` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
		     * @example
		     *
		     * _.isRegExp(/abc/);
		     * // => true
		     *
		     * _.isRegExp('/abc/');
		     * // => false
		     */
		    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

		    /**
		     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
		     * double precision number which isn't the result of a rounded unsafe integer.
		     *
		     * **Note:** This method is based on
		     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
		     * @example
		     *
		     * _.isSafeInteger(3);
		     * // => true
		     *
		     * _.isSafeInteger(Number.MIN_VALUE);
		     * // => false
		     *
		     * _.isSafeInteger(Infinity);
		     * // => false
		     *
		     * _.isSafeInteger('3');
		     * // => false
		     */
		    function isSafeInteger(value) {
		      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
		    }

		    /**
		     * Checks if `value` is classified as a `Set` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
		     * @example
		     *
		     * _.isSet(new Set);
		     * // => true
		     *
		     * _.isSet(new WeakSet);
		     * // => false
		     */
		    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

		    /**
		     * Checks if `value` is classified as a `String` primitive or object.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
		     * @example
		     *
		     * _.isString('abc');
		     * // => true
		     *
		     * _.isString(1);
		     * // => false
		     */
		    function isString(value) {
		      return typeof value == 'string' ||
		        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
		    }

		    /**
		     * Checks if `value` is classified as a `Symbol` primitive or object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
		     * @example
		     *
		     * _.isSymbol(Symbol.iterator);
		     * // => true
		     *
		     * _.isSymbol('abc');
		     * // => false
		     */
		    function isSymbol(value) {
		      return typeof value == 'symbol' ||
		        (isObjectLike(value) && baseGetTag(value) == symbolTag);
		    }

		    /**
		     * Checks if `value` is classified as a typed array.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
		     * @example
		     *
		     * _.isTypedArray(new Uint8Array);
		     * // => true
		     *
		     * _.isTypedArray([]);
		     * // => false
		     */
		    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

		    /**
		     * Checks if `value` is `undefined`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
		     * @example
		     *
		     * _.isUndefined(void 0);
		     * // => true
		     *
		     * _.isUndefined(null);
		     * // => false
		     */
		    function isUndefined(value) {
		      return value === undefined$1;
		    }

		    /**
		     * Checks if `value` is classified as a `WeakMap` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
		     * @example
		     *
		     * _.isWeakMap(new WeakMap);
		     * // => true
		     *
		     * _.isWeakMap(new Map);
		     * // => false
		     */
		    function isWeakMap(value) {
		      return isObjectLike(value) && getTag(value) == weakMapTag;
		    }

		    /**
		     * Checks if `value` is classified as a `WeakSet` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
		     * @example
		     *
		     * _.isWeakSet(new WeakSet);
		     * // => true
		     *
		     * _.isWeakSet(new Set);
		     * // => false
		     */
		    function isWeakSet(value) {
		      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
		    }

		    /**
		     * Checks if `value` is less than `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is less than `other`,
		     *  else `false`.
		     * @see _.gt
		     * @example
		     *
		     * _.lt(1, 3);
		     * // => true
		     *
		     * _.lt(3, 3);
		     * // => false
		     *
		     * _.lt(3, 1);
		     * // => false
		     */
		    var lt = createRelationalOperation(baseLt);

		    /**
		     * Checks if `value` is less than or equal to `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is less than or equal to
		     *  `other`, else `false`.
		     * @see _.gte
		     * @example
		     *
		     * _.lte(1, 3);
		     * // => true
		     *
		     * _.lte(3, 3);
		     * // => true
		     *
		     * _.lte(3, 1);
		     * // => false
		     */
		    var lte = createRelationalOperation(function(value, other) {
		      return value <= other;
		    });

		    /**
		     * Converts `value` to an array.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {Array} Returns the converted array.
		     * @example
		     *
		     * _.toArray({ 'a': 1, 'b': 2 });
		     * // => [1, 2]
		     *
		     * _.toArray('abc');
		     * // => ['a', 'b', 'c']
		     *
		     * _.toArray(1);
		     * // => []
		     *
		     * _.toArray(null);
		     * // => []
		     */
		    function toArray(value) {
		      if (!value) {
		        return [];
		      }
		      if (isArrayLike(value)) {
		        return isString(value) ? stringToArray(value) : copyArray(value);
		      }
		      if (symIterator && value[symIterator]) {
		        return iteratorToArray(value[symIterator]());
		      }
		      var tag = getTag(value),
		          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

		      return func(value);
		    }

		    /**
		     * Converts `value` to a finite number.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.12.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted number.
		     * @example
		     *
		     * _.toFinite(3.2);
		     * // => 3.2
		     *
		     * _.toFinite(Number.MIN_VALUE);
		     * // => 5e-324
		     *
		     * _.toFinite(Infinity);
		     * // => 1.7976931348623157e+308
		     *
		     * _.toFinite('3.2');
		     * // => 3.2
		     */
		    function toFinite(value) {
		      if (!value) {
		        return value === 0 ? value : 0;
		      }
		      value = toNumber(value);
		      if (value === INFINITY || value === -INFINITY) {
		        var sign = (value < 0 ? -1 : 1);
		        return sign * MAX_INTEGER;
		      }
		      return value === value ? value : 0;
		    }

		    /**
		     * Converts `value` to an integer.
		     *
		     * **Note:** This method is loosely based on
		     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.toInteger(3.2);
		     * // => 3
		     *
		     * _.toInteger(Number.MIN_VALUE);
		     * // => 0
		     *
		     * _.toInteger(Infinity);
		     * // => 1.7976931348623157e+308
		     *
		     * _.toInteger('3.2');
		     * // => 3
		     */
		    function toInteger(value) {
		      var result = toFinite(value),
		          remainder = result % 1;

		      return result === result ? (remainder ? result - remainder : result) : 0;
		    }

		    /**
		     * Converts `value` to an integer suitable for use as the length of an
		     * array-like object.
		     *
		     * **Note:** This method is based on
		     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.toLength(3.2);
		     * // => 3
		     *
		     * _.toLength(Number.MIN_VALUE);
		     * // => 0
		     *
		     * _.toLength(Infinity);
		     * // => 4294967295
		     *
		     * _.toLength('3.2');
		     * // => 3
		     */
		    function toLength(value) {
		      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
		    }

		    /**
		     * Converts `value` to a number.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to process.
		     * @returns {number} Returns the number.
		     * @example
		     *
		     * _.toNumber(3.2);
		     * // => 3.2
		     *
		     * _.toNumber(Number.MIN_VALUE);
		     * // => 5e-324
		     *
		     * _.toNumber(Infinity);
		     * // => Infinity
		     *
		     * _.toNumber('3.2');
		     * // => 3.2
		     */
		    function toNumber(value) {
		      if (typeof value == 'number') {
		        return value;
		      }
		      if (isSymbol(value)) {
		        return NAN;
		      }
		      if (isObject(value)) {
		        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
		        value = isObject(other) ? (other + '') : other;
		      }
		      if (typeof value != 'string') {
		        return value === 0 ? value : +value;
		      }
		      value = baseTrim(value);
		      var isBinary = reIsBinary.test(value);
		      return (isBinary || reIsOctal.test(value))
		        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
		        : (reIsBadHex.test(value) ? NAN : +value);
		    }

		    /**
		     * Converts `value` to a plain object flattening inherited enumerable string
		     * keyed properties of `value` to own properties of the plain object.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {Object} Returns the converted plain object.
		     * @example
		     *
		     * function Foo() {
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.assign({ 'a': 1 }, new Foo);
		     * // => { 'a': 1, 'b': 2 }
		     *
		     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
		     * // => { 'a': 1, 'b': 2, 'c': 3 }
		     */
		    function toPlainObject(value) {
		      return copyObject(value, keysIn(value));
		    }

		    /**
		     * Converts `value` to a safe integer. A safe integer can be compared and
		     * represented correctly.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.toSafeInteger(3.2);
		     * // => 3
		     *
		     * _.toSafeInteger(Number.MIN_VALUE);
		     * // => 0
		     *
		     * _.toSafeInteger(Infinity);
		     * // => 9007199254740991
		     *
		     * _.toSafeInteger('3.2');
		     * // => 3
		     */
		    function toSafeInteger(value) {
		      return value
		        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
		        : (value === 0 ? value : 0);
		    }

		    /**
		     * Converts `value` to a string. An empty string is returned for `null`
		     * and `undefined` values. The sign of `-0` is preserved.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {string} Returns the converted string.
		     * @example
		     *
		     * _.toString(null);
		     * // => ''
		     *
		     * _.toString(-0);
		     * // => '-0'
		     *
		     * _.toString([1, 2, 3]);
		     * // => '1,2,3'
		     */
		    function toString(value) {
		      return value == null ? '' : baseToString(value);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Assigns own enumerable string keyed properties of source objects to the
		     * destination object. Source objects are applied from left to right.
		     * Subsequent sources overwrite property assignments of previous sources.
		     *
		     * **Note:** This method mutates `object` and is loosely based on
		     * [`Object.assign`](https://mdn.io/Object/assign).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.10.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.assignIn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     * }
		     *
		     * function Bar() {
		     *   this.c = 3;
		     * }
		     *
		     * Foo.prototype.b = 2;
		     * Bar.prototype.d = 4;
		     *
		     * _.assign({ 'a': 0 }, new Foo, new Bar);
		     * // => { 'a': 1, 'c': 3 }
		     */
		    var assign = createAssigner(function(object, source) {
		      if (isPrototype(source) || isArrayLike(source)) {
		        copyObject(source, keys(source), object);
		        return;
		      }
		      for (var key in source) {
		        if (hasOwnProperty.call(source, key)) {
		          assignValue(object, key, source[key]);
		        }
		      }
		    });

		    /**
		     * This method is like `_.assign` except that it iterates over own and
		     * inherited source properties.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias extend
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.assign
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     * }
		     *
		     * function Bar() {
		     *   this.c = 3;
		     * }
		     *
		     * Foo.prototype.b = 2;
		     * Bar.prototype.d = 4;
		     *
		     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
		     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
		     */
		    var assignIn = createAssigner(function(object, source) {
		      copyObject(source, keysIn(source), object);
		    });

		    /**
		     * This method is like `_.assignIn` except that it accepts `customizer`
		     * which is invoked to produce the assigned values. If `customizer` returns
		     * `undefined`, assignment is handled by the method instead. The `customizer`
		     * is invoked with five arguments: (objValue, srcValue, key, object, source).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias extendWith
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} sources The source objects.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @see _.assignWith
		     * @example
		     *
		     * function customizer(objValue, srcValue) {
		     *   return _.isUndefined(objValue) ? srcValue : objValue;
		     * }
		     *
		     * var defaults = _.partialRight(_.assignInWith, customizer);
		     *
		     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		     * // => { 'a': 1, 'b': 2 }
		     */
		    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
		      copyObject(source, keysIn(source), object, customizer);
		    });

		    /**
		     * This method is like `_.assign` except that it accepts `customizer`
		     * which is invoked to produce the assigned values. If `customizer` returns
		     * `undefined`, assignment is handled by the method instead. The `customizer`
		     * is invoked with five arguments: (objValue, srcValue, key, object, source).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} sources The source objects.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @see _.assignInWith
		     * @example
		     *
		     * function customizer(objValue, srcValue) {
		     *   return _.isUndefined(objValue) ? srcValue : objValue;
		     * }
		     *
		     * var defaults = _.partialRight(_.assignWith, customizer);
		     *
		     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		     * // => { 'a': 1, 'b': 2 }
		     */
		    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
		      copyObject(source, keys(source), object, customizer);
		    });

		    /**
		     * Creates an array of values corresponding to `paths` of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.0.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {...(string|string[])} [paths] The property paths to pick.
		     * @returns {Array} Returns the picked values.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
		     *
		     * _.at(object, ['a[0].b.c', 'a[1]']);
		     * // => [3, 4]
		     */
		    var at = flatRest(baseAt);

		    /**
		     * Creates an object that inherits from the `prototype` object. If a
		     * `properties` object is given, its own enumerable string keyed properties
		     * are assigned to the created object.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.3.0
		     * @category Object
		     * @param {Object} prototype The object to inherit from.
		     * @param {Object} [properties] The properties to assign to the object.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * function Shape() {
		     *   this.x = 0;
		     *   this.y = 0;
		     * }
		     *
		     * function Circle() {
		     *   Shape.call(this);
		     * }
		     *
		     * Circle.prototype = _.create(Shape.prototype, {
		     *   'constructor': Circle
		     * });
		     *
		     * var circle = new Circle;
		     * circle instanceof Circle;
		     * // => true
		     *
		     * circle instanceof Shape;
		     * // => true
		     */
		    function create(prototype, properties) {
		      var result = baseCreate(prototype);
		      return properties == null ? result : baseAssign(result, properties);
		    }

		    /**
		     * Assigns own and inherited enumerable string keyed properties of source
		     * objects to the destination object for all destination properties that
		     * resolve to `undefined`. Source objects are applied from left to right.
		     * Once a property is set, additional values of the same property are ignored.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.defaultsDeep
		     * @example
		     *
		     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		     * // => { 'a': 1, 'b': 2 }
		     */
		    var defaults = baseRest(function(object, sources) {
		      object = Object(object);

		      var index = -1;
		      var length = sources.length;
		      var guard = length > 2 ? sources[2] : undefined$1;

		      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
		        length = 1;
		      }

		      while (++index < length) {
		        var source = sources[index];
		        var props = keysIn(source);
		        var propsIndex = -1;
		        var propsLength = props.length;

		        while (++propsIndex < propsLength) {
		          var key = props[propsIndex];
		          var value = object[key];

		          if (value === undefined$1 ||
		              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
		            object[key] = source[key];
		          }
		        }
		      }

		      return object;
		    });

		    /**
		     * This method is like `_.defaults` except that it recursively assigns
		     * default properties.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.defaults
		     * @example
		     *
		     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
		     * // => { 'a': { 'b': 2, 'c': 3 } }
		     */
		    var defaultsDeep = baseRest(function(args) {
		      args.push(undefined$1, customDefaultsMerge);
		      return apply(mergeWith, undefined$1, args);
		    });

		    /**
		     * This method is like `_.find` except that it returns the key of the first
		     * element `predicate` returns truthy for instead of the element itself.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.1.0
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {string|undefined} Returns the key of the matched element,
		     *  else `undefined`.
		     * @example
		     *
		     * var users = {
		     *   'barney':  { 'age': 36, 'active': true },
		     *   'fred':    { 'age': 40, 'active': false },
		     *   'pebbles': { 'age': 1,  'active': true }
		     * };
		     *
		     * _.findKey(users, function(o) { return o.age < 40; });
		     * // => 'barney' (iteration order is not guaranteed)
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findKey(users, { 'age': 1, 'active': true });
		     * // => 'pebbles'
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findKey(users, ['active', false]);
		     * // => 'fred'
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findKey(users, 'active');
		     * // => 'barney'
		     */
		    function findKey(object, predicate) {
		      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
		    }

		    /**
		     * This method is like `_.findKey` except that it iterates over elements of
		     * a collection in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {string|undefined} Returns the key of the matched element,
		     *  else `undefined`.
		     * @example
		     *
		     * var users = {
		     *   'barney':  { 'age': 36, 'active': true },
		     *   'fred':    { 'age': 40, 'active': false },
		     *   'pebbles': { 'age': 1,  'active': true }
		     * };
		     *
		     * _.findLastKey(users, function(o) { return o.age < 40; });
		     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findLastKey(users, { 'age': 36, 'active': true });
		     * // => 'barney'
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findLastKey(users, ['active', false]);
		     * // => 'fred'
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findLastKey(users, 'active');
		     * // => 'pebbles'
		     */
		    function findLastKey(object, predicate) {
		      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
		    }

		    /**
		     * Iterates over own and inherited enumerable string keyed properties of an
		     * object and invokes `iteratee` for each property. The iteratee is invoked
		     * with three arguments: (value, key, object). Iteratee functions may exit
		     * iteration early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.3.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forInRight
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forIn(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
		     */
		    function forIn(object, iteratee) {
		      return object == null
		        ? object
		        : baseFor(object, getIteratee(iteratee, 3), keysIn);
		    }

		    /**
		     * This method is like `_.forIn` except that it iterates over properties of
		     * `object` in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forIn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forInRight(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
		     */
		    function forInRight(object, iteratee) {
		      return object == null
		        ? object
		        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
		    }

		    /**
		     * Iterates over own enumerable string keyed properties of an object and
		     * invokes `iteratee` for each property. The iteratee is invoked with three
		     * arguments: (value, key, object). Iteratee functions may exit iteration
		     * early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.3.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forOwnRight
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forOwn(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
		     */
		    function forOwn(object, iteratee) {
		      return object && baseForOwn(object, getIteratee(iteratee, 3));
		    }

		    /**
		     * This method is like `_.forOwn` except that it iterates over properties of
		     * `object` in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forOwn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forOwnRight(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
		     */
		    function forOwnRight(object, iteratee) {
		      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
		    }

		    /**
		     * Creates an array of function property names from own enumerable properties
		     * of `object`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @returns {Array} Returns the function names.
		     * @see _.functionsIn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = _.constant('a');
		     *   this.b = _.constant('b');
		     * }
		     *
		     * Foo.prototype.c = _.constant('c');
		     *
		     * _.functions(new Foo);
		     * // => ['a', 'b']
		     */
		    function functions(object) {
		      return object == null ? [] : baseFunctions(object, keys(object));
		    }

		    /**
		     * Creates an array of function property names from own and inherited
		     * enumerable properties of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @returns {Array} Returns the function names.
		     * @see _.functions
		     * @example
		     *
		     * function Foo() {
		     *   this.a = _.constant('a');
		     *   this.b = _.constant('b');
		     * }
		     *
		     * Foo.prototype.c = _.constant('c');
		     *
		     * _.functionsIn(new Foo);
		     * // => ['a', 'b', 'c']
		     */
		    function functionsIn(object) {
		      return object == null ? [] : baseFunctions(object, keysIn(object));
		    }

		    /**
		     * Gets the value at `path` of `object`. If the resolved value is
		     * `undefined`, the `defaultValue` is returned in its place.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to get.
		     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
		     * @returns {*} Returns the resolved value.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		     *
		     * _.get(object, 'a[0].b.c');
		     * // => 3
		     *
		     * _.get(object, ['a', '0', 'b', 'c']);
		     * // => 3
		     *
		     * _.get(object, 'a.b.c', 'default');
		     * // => 'default'
		     */
		    function get(object, path, defaultValue) {
		      var result = object == null ? undefined$1 : baseGet(object, path);
		      return result === undefined$1 ? defaultValue : result;
		    }

		    /**
		     * Checks if `path` is a direct property of `object`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path to check.
		     * @returns {boolean} Returns `true` if `path` exists, else `false`.
		     * @example
		     *
		     * var object = { 'a': { 'b': 2 } };
		     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
		     *
		     * _.has(object, 'a');
		     * // => true
		     *
		     * _.has(object, 'a.b');
		     * // => true
		     *
		     * _.has(object, ['a', 'b']);
		     * // => true
		     *
		     * _.has(other, 'a');
		     * // => false
		     */
		    function has(object, path) {
		      return object != null && hasPath(object, path, baseHas);
		    }

		    /**
		     * Checks if `path` is a direct or inherited property of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path to check.
		     * @returns {boolean} Returns `true` if `path` exists, else `false`.
		     * @example
		     *
		     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
		     *
		     * _.hasIn(object, 'a');
		     * // => true
		     *
		     * _.hasIn(object, 'a.b');
		     * // => true
		     *
		     * _.hasIn(object, ['a', 'b']);
		     * // => true
		     *
		     * _.hasIn(object, 'b');
		     * // => false
		     */
		    function hasIn(object, path) {
		      return object != null && hasPath(object, path, baseHasIn);
		    }

		    /**
		     * Creates an object composed of the inverted keys and values of `object`.
		     * If `object` contains duplicate values, subsequent values overwrite
		     * property assignments of previous values.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.7.0
		     * @category Object
		     * @param {Object} object The object to invert.
		     * @returns {Object} Returns the new inverted object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2, 'c': 1 };
		     *
		     * _.invert(object);
		     * // => { '1': 'c', '2': 'b' }
		     */
		    var invert = createInverter(function(result, value, key) {
		      if (value != null &&
		          typeof value.toString != 'function') {
		        value = nativeObjectToString.call(value);
		      }

		      result[value] = key;
		    }, constant(identity));

		    /**
		     * This method is like `_.invert` except that the inverted object is generated
		     * from the results of running each element of `object` thru `iteratee`. The
		     * corresponding inverted value of each inverted key is an array of keys
		     * responsible for generating the inverted value. The iteratee is invoked
		     * with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.1.0
		     * @category Object
		     * @param {Object} object The object to invert.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Object} Returns the new inverted object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2, 'c': 1 };
		     *
		     * _.invertBy(object);
		     * // => { '1': ['a', 'c'], '2': ['b'] }
		     *
		     * _.invertBy(object, function(value) {
		     *   return 'group' + value;
		     * });
		     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
		     */
		    var invertBy = createInverter(function(result, value, key) {
		      if (value != null &&
		          typeof value.toString != 'function') {
		        value = nativeObjectToString.call(value);
		      }

		      if (hasOwnProperty.call(result, value)) {
		        result[value].push(key);
		      } else {
		        result[value] = [key];
		      }
		    }, getIteratee);

		    /**
		     * Invokes the method at `path` of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the method to invoke.
		     * @param {...*} [args] The arguments to invoke the method with.
		     * @returns {*} Returns the result of the invoked method.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
		     *
		     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
		     * // => [2, 3]
		     */
		    var invoke = baseRest(baseInvoke);

		    /**
		     * Creates an array of the own enumerable property names of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects. See the
		     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
		     * for more details.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.keys(new Foo);
		     * // => ['a', 'b'] (iteration order is not guaranteed)
		     *
		     * _.keys('hi');
		     * // => ['0', '1']
		     */
		    function keys(object) {
		      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
		    }

		    /**
		     * Creates an array of the own and inherited enumerable property names of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.keysIn(new Foo);
		     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
		     */
		    function keysIn(object) {
		      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
		    }

		    /**
		     * The opposite of `_.mapValues`; this method creates an object with the
		     * same values as `object` and keys generated by running each own enumerable
		     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
		     * with three arguments: (value, key, object).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.8.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns the new mapped object.
		     * @see _.mapValues
		     * @example
		     *
		     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
		     *   return key + value;
		     * });
		     * // => { 'a1': 1, 'b2': 2 }
		     */
		    function mapKeys(object, iteratee) {
		      var result = {};
		      iteratee = getIteratee(iteratee, 3);

		      baseForOwn(object, function(value, key, object) {
		        baseAssignValue(result, iteratee(value, key, object), value);
		      });
		      return result;
		    }

		    /**
		     * Creates an object with the same keys as `object` and values generated
		     * by running each own enumerable string keyed property of `object` thru
		     * `iteratee`. The iteratee is invoked with three arguments:
		     * (value, key, object).
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns the new mapped object.
		     * @see _.mapKeys
		     * @example
		     *
		     * var users = {
		     *   'fred':    { 'user': 'fred',    'age': 40 },
		     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
		     * };
		     *
		     * _.mapValues(users, function(o) { return o.age; });
		     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.mapValues(users, 'age');
		     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
		     */
		    function mapValues(object, iteratee) {
		      var result = {};
		      iteratee = getIteratee(iteratee, 3);

		      baseForOwn(object, function(value, key, object) {
		        baseAssignValue(result, key, iteratee(value, key, object));
		      });
		      return result;
		    }

		    /**
		     * This method is like `_.assign` except that it recursively merges own and
		     * inherited enumerable string keyed properties of source objects into the
		     * destination object. Source properties that resolve to `undefined` are
		     * skipped if a destination value exists. Array and plain object properties
		     * are merged recursively. Other objects and value types are overridden by
		     * assignment. Source objects are applied from left to right. Subsequent
		     * sources overwrite property assignments of previous sources.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.5.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = {
		     *   'a': [{ 'b': 2 }, { 'd': 4 }]
		     * };
		     *
		     * var other = {
		     *   'a': [{ 'c': 3 }, { 'e': 5 }]
		     * };
		     *
		     * _.merge(object, other);
		     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
		     */
		    var merge = createAssigner(function(object, source, srcIndex) {
		      baseMerge(object, source, srcIndex);
		    });

		    /**
		     * This method is like `_.merge` except that it accepts `customizer` which
		     * is invoked to produce the merged values of the destination and source
		     * properties. If `customizer` returns `undefined`, merging is handled by the
		     * method instead. The `customizer` is invoked with six arguments:
		     * (objValue, srcValue, key, object, source, stack).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} sources The source objects.
		     * @param {Function} customizer The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * function customizer(objValue, srcValue) {
		     *   if (_.isArray(objValue)) {
		     *     return objValue.concat(srcValue);
		     *   }
		     * }
		     *
		     * var object = { 'a': [1], 'b': [2] };
		     * var other = { 'a': [3], 'b': [4] };
		     *
		     * _.mergeWith(object, other, customizer);
		     * // => { 'a': [1, 3], 'b': [2, 4] }
		     */
		    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
		      baseMerge(object, source, srcIndex, customizer);
		    });

		    /**
		     * The opposite of `_.pick`; this method creates an object composed of the
		     * own and inherited enumerable property paths of `object` that are not omitted.
		     *
		     * **Note:** This method is considerably slower than `_.pick`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {...(string|string[])} [paths] The property paths to omit.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.omit(object, ['a', 'c']);
		     * // => { 'b': '2' }
		     */
		    var omit = flatRest(function(object, paths) {
		      var result = {};
		      if (object == null) {
		        return result;
		      }
		      var isDeep = false;
		      paths = arrayMap(paths, function(path) {
		        path = castPath(path, object);
		        isDeep || (isDeep = path.length > 1);
		        return path;
		      });
		      copyObject(object, getAllKeysIn(object), result);
		      if (isDeep) {
		        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
		      }
		      var length = paths.length;
		      while (length--) {
		        baseUnset(result, paths[length]);
		      }
		      return result;
		    });

		    /**
		     * The opposite of `_.pickBy`; this method creates an object composed of
		     * the own and inherited enumerable string keyed properties of `object` that
		     * `predicate` doesn't return truthy for. The predicate is invoked with two
		     * arguments: (value, key).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {Function} [predicate=_.identity] The function invoked per property.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.omitBy(object, _.isNumber);
		     * // => { 'b': '2' }
		     */
		    function omitBy(object, predicate) {
		      return pickBy(object, negate(getIteratee(predicate)));
		    }

		    /**
		     * Creates an object composed of the picked `object` properties.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {...(string|string[])} [paths] The property paths to pick.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.pick(object, ['a', 'c']);
		     * // => { 'a': 1, 'c': 3 }
		     */
		    var pick = flatRest(function(object, paths) {
		      return object == null ? {} : basePick(object, paths);
		    });

		    /**
		     * Creates an object composed of the `object` properties `predicate` returns
		     * truthy for. The predicate is invoked with two arguments: (value, key).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {Function} [predicate=_.identity] The function invoked per property.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.pickBy(object, _.isNumber);
		     * // => { 'a': 1, 'c': 3 }
		     */
		    function pickBy(object, predicate) {
		      if (object == null) {
		        return {};
		      }
		      var props = arrayMap(getAllKeysIn(object), function(prop) {
		        return [prop];
		      });
		      predicate = getIteratee(predicate);
		      return basePickBy(object, props, function(value, path) {
		        return predicate(value, path[0]);
		      });
		    }

		    /**
		     * This method is like `_.get` except that if the resolved value is a
		     * function it's invoked with the `this` binding of its parent object and
		     * its result is returned.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to resolve.
		     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
		     * @returns {*} Returns the resolved value.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
		     *
		     * _.result(object, 'a[0].b.c1');
		     * // => 3
		     *
		     * _.result(object, 'a[0].b.c2');
		     * // => 4
		     *
		     * _.result(object, 'a[0].b.c3', 'default');
		     * // => 'default'
		     *
		     * _.result(object, 'a[0].b.c3', _.constant('default'));
		     * // => 'default'
		     */
		    function result(object, path, defaultValue) {
		      path = castPath(path, object);

		      var index = -1,
		          length = path.length;

		      // Ensure the loop is entered when path is empty.
		      if (!length) {
		        length = 1;
		        object = undefined$1;
		      }
		      while (++index < length) {
		        var value = object == null ? undefined$1 : object[toKey(path[index])];
		        if (value === undefined$1) {
		          index = length;
		          value = defaultValue;
		        }
		        object = isFunction(value) ? value.call(object) : value;
		      }
		      return object;
		    }

		    /**
		     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
		     * it's created. Arrays are created for missing index properties while objects
		     * are created for all other missing properties. Use `_.setWith` to customize
		     * `path` creation.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		     *
		     * _.set(object, 'a[0].b.c', 4);
		     * console.log(object.a[0].b.c);
		     * // => 4
		     *
		     * _.set(object, ['x', '0', 'y', 'z'], 5);
		     * console.log(object.x[0].y.z);
		     * // => 5
		     */
		    function set(object, path, value) {
		      return object == null ? object : baseSet(object, path, value);
		    }

		    /**
		     * This method is like `_.set` except that it accepts `customizer` which is
		     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
		     * path creation is handled by the method instead. The `customizer` is invoked
		     * with three arguments: (nsValue, key, nsObject).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {*} value The value to set.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = {};
		     *
		     * _.setWith(object, '[0][1]', 'a', Object);
		     * // => { '0': { '1': 'a' } }
		     */
		    function setWith(object, path, value, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return object == null ? object : baseSet(object, path, value, customizer);
		    }

		    /**
		     * Creates an array of own enumerable string keyed-value pairs for `object`
		     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
		     * entries are returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias entries
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the key-value pairs.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.toPairs(new Foo);
		     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
		     */
		    var toPairs = createToPairs(keys);

		    /**
		     * Creates an array of own and inherited enumerable string keyed-value pairs
		     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
		     * or set, its entries are returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias entriesIn
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the key-value pairs.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.toPairsIn(new Foo);
		     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
		     */
		    var toPairsIn = createToPairs(keysIn);

		    /**
		     * An alternative to `_.reduce`; this method transforms `object` to a new
		     * `accumulator` object which is the result of running each of its own
		     * enumerable string keyed properties thru `iteratee`, with each invocation
		     * potentially mutating the `accumulator` object. If `accumulator` is not
		     * provided, a new object with the same `[[Prototype]]` will be used. The
		     * iteratee is invoked with four arguments: (accumulator, value, key, object).
		     * Iteratee functions may exit iteration early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.3.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {*} [accumulator] The custom accumulator value.
		     * @returns {*} Returns the accumulated value.
		     * @example
		     *
		     * _.transform([2, 3, 4], function(result, n) {
		     *   result.push(n *= n);
		     *   return n % 2 == 0;
		     * }, []);
		     * // => [4, 9]
		     *
		     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
		     *   (result[value] || (result[value] = [])).push(key);
		     * }, {});
		     * // => { '1': ['a', 'c'], '2': ['b'] }
		     */
		    function transform(object, iteratee, accumulator) {
		      var isArr = isArray(object),
		          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

		      iteratee = getIteratee(iteratee, 4);
		      if (accumulator == null) {
		        var Ctor = object && object.constructor;
		        if (isArrLike) {
		          accumulator = isArr ? new Ctor : [];
		        }
		        else if (isObject(object)) {
		          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
		        }
		        else {
		          accumulator = {};
		        }
		      }
		      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
		        return iteratee(accumulator, value, index, object);
		      });
		      return accumulator;
		    }

		    /**
		     * Removes the property at `path` of `object`.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to unset.
		     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
		     * _.unset(object, 'a[0].b.c');
		     * // => true
		     *
		     * console.log(object);
		     * // => { 'a': [{ 'b': {} }] };
		     *
		     * _.unset(object, ['a', '0', 'b', 'c']);
		     * // => true
		     *
		     * console.log(object);
		     * // => { 'a': [{ 'b': {} }] };
		     */
		    function unset(object, path) {
		      return object == null ? true : baseUnset(object, path);
		    }

		    /**
		     * This method is like `_.set` except that accepts `updater` to produce the
		     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
		     * is invoked with one argument: (value).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.6.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {Function} updater The function to produce the updated value.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		     *
		     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
		     * console.log(object.a[0].b.c);
		     * // => 9
		     *
		     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
		     * console.log(object.x[0].y.z);
		     * // => 0
		     */
		    function update(object, path, updater) {
		      return object == null ? object : baseUpdate(object, path, castFunction(updater));
		    }

		    /**
		     * This method is like `_.update` except that it accepts `customizer` which is
		     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
		     * path creation is handled by the method instead. The `customizer` is invoked
		     * with three arguments: (nsValue, key, nsObject).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.6.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {Function} updater The function to produce the updated value.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = {};
		     *
		     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
		     * // => { '0': { '1': 'a' } }
		     */
		    function updateWith(object, path, updater, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
		    }

		    /**
		     * Creates an array of the own enumerable string keyed property values of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property values.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.values(new Foo);
		     * // => [1, 2] (iteration order is not guaranteed)
		     *
		     * _.values('hi');
		     * // => ['h', 'i']
		     */
		    function values(object) {
		      return object == null ? [] : baseValues(object, keys(object));
		    }

		    /**
		     * Creates an array of the own and inherited enumerable string keyed property
		     * values of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property values.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.valuesIn(new Foo);
		     * // => [1, 2, 3] (iteration order is not guaranteed)
		     */
		    function valuesIn(object) {
		      return object == null ? [] : baseValues(object, keysIn(object));
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Clamps `number` within the inclusive `lower` and `upper` bounds.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Number
		     * @param {number} number The number to clamp.
		     * @param {number} [lower] The lower bound.
		     * @param {number} upper The upper bound.
		     * @returns {number} Returns the clamped number.
		     * @example
		     *
		     * _.clamp(-10, -5, 5);
		     * // => -5
		     *
		     * _.clamp(10, -5, 5);
		     * // => 5
		     */
		    function clamp(number, lower, upper) {
		      if (upper === undefined$1) {
		        upper = lower;
		        lower = undefined$1;
		      }
		      if (upper !== undefined$1) {
		        upper = toNumber(upper);
		        upper = upper === upper ? upper : 0;
		      }
		      if (lower !== undefined$1) {
		        lower = toNumber(lower);
		        lower = lower === lower ? lower : 0;
		      }
		      return baseClamp(toNumber(number), lower, upper);
		    }

		    /**
		     * Checks if `n` is between `start` and up to, but not including, `end`. If
		     * `end` is not specified, it's set to `start` with `start` then set to `0`.
		     * If `start` is greater than `end` the params are swapped to support
		     * negative ranges.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.3.0
		     * @category Number
		     * @param {number} number The number to check.
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
		     * @see _.range, _.rangeRight
		     * @example
		     *
		     * _.inRange(3, 2, 4);
		     * // => true
		     *
		     * _.inRange(4, 8);
		     * // => true
		     *
		     * _.inRange(4, 2);
		     * // => false
		     *
		     * _.inRange(2, 2);
		     * // => false
		     *
		     * _.inRange(1.2, 2);
		     * // => true
		     *
		     * _.inRange(5.2, 4);
		     * // => false
		     *
		     * _.inRange(-3, -2, -6);
		     * // => true
		     */
		    function inRange(number, start, end) {
		      start = toFinite(start);
		      if (end === undefined$1) {
		        end = start;
		        start = 0;
		      } else {
		        end = toFinite(end);
		      }
		      number = toNumber(number);
		      return baseInRange(number, start, end);
		    }

		    /**
		     * Produces a random number between the inclusive `lower` and `upper` bounds.
		     * If only one argument is provided a number between `0` and the given number
		     * is returned. If `floating` is `true`, or either `lower` or `upper` are
		     * floats, a floating-point number is returned instead of an integer.
		     *
		     * **Note:** JavaScript follows the IEEE-754 standard for resolving
		     * floating-point values which can produce unexpected results.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.7.0
		     * @category Number
		     * @param {number} [lower=0] The lower bound.
		     * @param {number} [upper=1] The upper bound.
		     * @param {boolean} [floating] Specify returning a floating-point number.
		     * @returns {number} Returns the random number.
		     * @example
		     *
		     * _.random(0, 5);
		     * // => an integer between 0 and 5
		     *
		     * _.random(5);
		     * // => also an integer between 0 and 5
		     *
		     * _.random(5, true);
		     * // => a floating-point number between 0 and 5
		     *
		     * _.random(1.2, 5.2);
		     * // => a floating-point number between 1.2 and 5.2
		     */
		    function random(lower, upper, floating) {
		      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
		        upper = floating = undefined$1;
		      }
		      if (floating === undefined$1) {
		        if (typeof upper == 'boolean') {
		          floating = upper;
		          upper = undefined$1;
		        }
		        else if (typeof lower == 'boolean') {
		          floating = lower;
		          lower = undefined$1;
		        }
		      }
		      if (lower === undefined$1 && upper === undefined$1) {
		        lower = 0;
		        upper = 1;
		      }
		      else {
		        lower = toFinite(lower);
		        if (upper === undefined$1) {
		          upper = lower;
		          lower = 0;
		        } else {
		          upper = toFinite(upper);
		        }
		      }
		      if (lower > upper) {
		        var temp = lower;
		        lower = upper;
		        upper = temp;
		      }
		      if (floating || lower % 1 || upper % 1) {
		        var rand = nativeRandom();
		        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
		      }
		      return baseRandom(lower, upper);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the camel cased string.
		     * @example
		     *
		     * _.camelCase('Foo Bar');
		     * // => 'fooBar'
		     *
		     * _.camelCase('--foo-bar--');
		     * // => 'fooBar'
		     *
		     * _.camelCase('__FOO_BAR__');
		     * // => 'fooBar'
		     */
		    var camelCase = createCompounder(function(result, word, index) {
		      word = word.toLowerCase();
		      return result + (index ? capitalize(word) : word);
		    });

		    /**
		     * Converts the first character of `string` to upper case and the remaining
		     * to lower case.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to capitalize.
		     * @returns {string} Returns the capitalized string.
		     * @example
		     *
		     * _.capitalize('FRED');
		     * // => 'Fred'
		     */
		    function capitalize(string) {
		      return upperFirst(toString(string).toLowerCase());
		    }

		    /**
		     * Deburrs `string` by converting
		     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
		     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
		     * letters to basic Latin letters and removing
		     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to deburr.
		     * @returns {string} Returns the deburred string.
		     * @example
		     *
		     * _.deburr('dj vu');
		     * // => 'deja vu'
		     */
		    function deburr(string) {
		      string = toString(string);
		      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
		    }

		    /**
		     * Checks if `string` ends with the given target string.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to inspect.
		     * @param {string} [target] The string to search for.
		     * @param {number} [position=string.length] The position to search up to.
		     * @returns {boolean} Returns `true` if `string` ends with `target`,
		     *  else `false`.
		     * @example
		     *
		     * _.endsWith('abc', 'c');
		     * // => true
		     *
		     * _.endsWith('abc', 'b');
		     * // => false
		     *
		     * _.endsWith('abc', 'b', 2);
		     * // => true
		     */
		    function endsWith(string, target, position) {
		      string = toString(string);
		      target = baseToString(target);

		      var length = string.length;
		      position = position === undefined$1
		        ? length
		        : baseClamp(toInteger(position), 0, length);

		      var end = position;
		      position -= target.length;
		      return position >= 0 && string.slice(position, end) == target;
		    }

		    /**
		     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
		     * corresponding HTML entities.
		     *
		     * **Note:** No other characters are escaped. To escape additional
		     * characters use a third-party library like [_he_](https://mths.be/he).
		     *
		     * Though the ">" character is escaped for symmetry, characters like
		     * ">" and "/" don't need escaping in HTML and have no special meaning
		     * unless they're part of a tag or unquoted attribute value. See
		     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
		     * (under "semi-related fun fact") for more details.
		     *
		     * When working with HTML you should always
		     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
		     * XSS vectors.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category String
		     * @param {string} [string=''] The string to escape.
		     * @returns {string} Returns the escaped string.
		     * @example
		     *
		     * _.escape('fred, barney, & pebbles');
		     * // => 'fred, barney, &amp; pebbles'
		     */
		    function escape(string) {
		      string = toString(string);
		      return (string && reHasUnescapedHtml.test(string))
		        ? string.replace(reUnescapedHtml, escapeHtmlChar)
		        : string;
		    }

		    /**
		     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
		     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to escape.
		     * @returns {string} Returns the escaped string.
		     * @example
		     *
		     * _.escapeRegExp('[lodash](https://lodash.com/)');
		     * // => '\[lodash\]\(https://lodash\.com/\)'
		     */
		    function escapeRegExp(string) {
		      string = toString(string);
		      return (string && reHasRegExpChar.test(string))
		        ? string.replace(reRegExpChar, '\\$&')
		        : string;
		    }

		    /**
		     * Converts `string` to
		     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the kebab cased string.
		     * @example
		     *
		     * _.kebabCase('Foo Bar');
		     * // => 'foo-bar'
		     *
		     * _.kebabCase('fooBar');
		     * // => 'foo-bar'
		     *
		     * _.kebabCase('__FOO_BAR__');
		     * // => 'foo-bar'
		     */
		    var kebabCase = createCompounder(function(result, word, index) {
		      return result + (index ? '-' : '') + word.toLowerCase();
		    });

		    /**
		     * Converts `string`, as space separated words, to lower case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the lower cased string.
		     * @example
		     *
		     * _.lowerCase('--Foo-Bar--');
		     * // => 'foo bar'
		     *
		     * _.lowerCase('fooBar');
		     * // => 'foo bar'
		     *
		     * _.lowerCase('__FOO_BAR__');
		     * // => 'foo bar'
		     */
		    var lowerCase = createCompounder(function(result, word, index) {
		      return result + (index ? ' ' : '') + word.toLowerCase();
		    });

		    /**
		     * Converts the first character of `string` to lower case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the converted string.
		     * @example
		     *
		     * _.lowerFirst('Fred');
		     * // => 'fred'
		     *
		     * _.lowerFirst('FRED');
		     * // => 'fRED'
		     */
		    var lowerFirst = createCaseFirst('toLowerCase');

		    /**
		     * Pads `string` on the left and right sides if it's shorter than `length`.
		     * Padding characters are truncated if they can't be evenly divided by `length`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to pad.
		     * @param {number} [length=0] The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padded string.
		     * @example
		     *
		     * _.pad('abc', 8);
		     * // => '  abc   '
		     *
		     * _.pad('abc', 8, '_-');
		     * // => '_-abc_-_'
		     *
		     * _.pad('abc', 3);
		     * // => 'abc'
		     */
		    function pad(string, length, chars) {
		      string = toString(string);
		      length = toInteger(length);

		      var strLength = length ? stringSize(string) : 0;
		      if (!length || strLength >= length) {
		        return string;
		      }
		      var mid = (length - strLength) / 2;
		      return (
		        createPadding(nativeFloor(mid), chars) +
		        string +
		        createPadding(nativeCeil(mid), chars)
		      );
		    }

		    /**
		     * Pads `string` on the right side if it's shorter than `length`. Padding
		     * characters are truncated if they exceed `length`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to pad.
		     * @param {number} [length=0] The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padded string.
		     * @example
		     *
		     * _.padEnd('abc', 6);
		     * // => 'abc   '
		     *
		     * _.padEnd('abc', 6, '_-');
		     * // => 'abc_-_'
		     *
		     * _.padEnd('abc', 3);
		     * // => 'abc'
		     */
		    function padEnd(string, length, chars) {
		      string = toString(string);
		      length = toInteger(length);

		      var strLength = length ? stringSize(string) : 0;
		      return (length && strLength < length)
		        ? (string + createPadding(length - strLength, chars))
		        : string;
		    }

		    /**
		     * Pads `string` on the left side if it's shorter than `length`. Padding
		     * characters are truncated if they exceed `length`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to pad.
		     * @param {number} [length=0] The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padded string.
		     * @example
		     *
		     * _.padStart('abc', 6);
		     * // => '   abc'
		     *
		     * _.padStart('abc', 6, '_-');
		     * // => '_-_abc'
		     *
		     * _.padStart('abc', 3);
		     * // => 'abc'
		     */
		    function padStart(string, length, chars) {
		      string = toString(string);
		      length = toInteger(length);

		      var strLength = length ? stringSize(string) : 0;
		      return (length && strLength < length)
		        ? (createPadding(length - strLength, chars) + string)
		        : string;
		    }

		    /**
		     * Converts `string` to an integer of the specified radix. If `radix` is
		     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
		     * hexadecimal, in which case a `radix` of `16` is used.
		     *
		     * **Note:** This method aligns with the
		     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.1.0
		     * @category String
		     * @param {string} string The string to convert.
		     * @param {number} [radix=10] The radix to interpret `value` by.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.parseInt('08');
		     * // => 8
		     *
		     * _.map(['6', '08', '10'], _.parseInt);
		     * // => [6, 8, 10]
		     */
		    function parseInt(string, radix, guard) {
		      if (guard || radix == null) {
		        radix = 0;
		      } else if (radix) {
		        radix = +radix;
		      }
		      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
		    }

		    /**
		     * Repeats the given string `n` times.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to repeat.
		     * @param {number} [n=1] The number of times to repeat the string.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the repeated string.
		     * @example
		     *
		     * _.repeat('*', 3);
		     * // => '***'
		     *
		     * _.repeat('abc', 2);
		     * // => 'abcabc'
		     *
		     * _.repeat('abc', 0);
		     * // => ''
		     */
		    function repeat(string, n, guard) {
		      if ((guard ? isIterateeCall(string, n, guard) : n === undefined$1)) {
		        n = 1;
		      } else {
		        n = toInteger(n);
		      }
		      return baseRepeat(toString(string), n);
		    }

		    /**
		     * Replaces matches for `pattern` in `string` with `replacement`.
		     *
		     * **Note:** This method is based on
		     * [`String#replace`](https://mdn.io/String/replace).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to modify.
		     * @param {RegExp|string} pattern The pattern to replace.
		     * @param {Function|string} replacement The match replacement.
		     * @returns {string} Returns the modified string.
		     * @example
		     *
		     * _.replace('Hi Fred', 'Fred', 'Barney');
		     * // => 'Hi Barney'
		     */
		    function replace() {
		      var args = arguments,
		          string = toString(args[0]);

		      return args.length < 3 ? string : string.replace(args[1], args[2]);
		    }

		    /**
		     * Converts `string` to
		     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the snake cased string.
		     * @example
		     *
		     * _.snakeCase('Foo Bar');
		     * // => 'foo_bar'
		     *
		     * _.snakeCase('fooBar');
		     * // => 'foo_bar'
		     *
		     * _.snakeCase('--FOO-BAR--');
		     * // => 'foo_bar'
		     */
		    var snakeCase = createCompounder(function(result, word, index) {
		      return result + (index ? '_' : '') + word.toLowerCase();
		    });

		    /**
		     * Splits `string` by `separator`.
		     *
		     * **Note:** This method is based on
		     * [`String#split`](https://mdn.io/String/split).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to split.
		     * @param {RegExp|string} separator The separator pattern to split by.
		     * @param {number} [limit] The length to truncate results to.
		     * @returns {Array} Returns the string segments.
		     * @example
		     *
		     * _.split('a-b-c', '-', 2);
		     * // => ['a', 'b']
		     */
		    function split(string, separator, limit) {
		      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
		        separator = limit = undefined$1;
		      }
		      limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
		      if (!limit) {
		        return [];
		      }
		      string = toString(string);
		      if (string && (
		            typeof separator == 'string' ||
		            (separator != null && !isRegExp(separator))
		          )) {
		        separator = baseToString(separator);
		        if (!separator && hasUnicode(string)) {
		          return castSlice(stringToArray(string), 0, limit);
		        }
		      }
		      return string.split(separator, limit);
		    }

		    /**
		     * Converts `string` to
		     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.1.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the start cased string.
		     * @example
		     *
		     * _.startCase('--foo-bar--');
		     * // => 'Foo Bar'
		     *
		     * _.startCase('fooBar');
		     * // => 'Foo Bar'
		     *
		     * _.startCase('__FOO_BAR__');
		     * // => 'FOO BAR'
		     */
		    var startCase = createCompounder(function(result, word, index) {
		      return result + (index ? ' ' : '') + upperFirst(word);
		    });

		    /**
		     * Checks if `string` starts with the given target string.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to inspect.
		     * @param {string} [target] The string to search for.
		     * @param {number} [position=0] The position to search from.
		     * @returns {boolean} Returns `true` if `string` starts with `target`,
		     *  else `false`.
		     * @example
		     *
		     * _.startsWith('abc', 'a');
		     * // => true
		     *
		     * _.startsWith('abc', 'b');
		     * // => false
		     *
		     * _.startsWith('abc', 'b', 1);
		     * // => true
		     */
		    function startsWith(string, target, position) {
		      string = toString(string);
		      position = position == null
		        ? 0
		        : baseClamp(toInteger(position), 0, string.length);

		      target = baseToString(target);
		      return string.slice(position, position + target.length) == target;
		    }

		    /**
		     * Creates a compiled template function that can interpolate data properties
		     * in "interpolate" delimiters, HTML-escape interpolated data properties in
		     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
		     * properties may be accessed as free variables in the template. If a setting
		     * object is given, it takes precedence over `_.templateSettings` values.
		     *
		     * **Note:** In the development build `_.template` utilizes
		     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
		     * for easier debugging.
		     *
		     * For more information on precompiling templates see
		     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
		     *
		     * For more information on Chrome extension sandboxes see
		     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category String
		     * @param {string} [string=''] The template string.
		     * @param {Object} [options={}] The options object.
		     * @param {RegExp} [options.escape=_.templateSettings.escape]
		     *  The HTML "escape" delimiter.
		     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
		     *  The "evaluate" delimiter.
		     * @param {Object} [options.imports=_.templateSettings.imports]
		     *  An object to import into the template as free variables.
		     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
		     *  The "interpolate" delimiter.
		     * @param {string} [options.sourceURL='lodash.templateSources[n]']
		     *  The sourceURL of the compiled template.
		     * @param {string} [options.variable='obj']
		     *  The data object variable name.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the compiled template function.
		     * @example
		     *
		     * // Use the "interpolate" delimiter to create a compiled template.
		     * var compiled = _.template('hello <%= user %>!');
		     * compiled({ 'user': 'fred' });
		     * // => 'hello fred!'
		     *
		     * // Use the HTML "escape" delimiter to escape data property values.
		     * var compiled = _.template('<b><%- value %></b>');
		     * compiled({ 'value': '<script>' });
		     * // => '<b>&lt;script&gt;</b>'
		     *
		     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
		     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
		     * compiled({ 'users': ['fred', 'barney'] });
		     * // => '<li>fred</li><li>barney</li>'
		     *
		     * // Use the internal `print` function in "evaluate" delimiters.
		     * var compiled = _.template('<% print("hello " + user); %>!');
		     * compiled({ 'user': 'barney' });
		     * // => 'hello barney!'
		     *
		     * // Use the ES template literal delimiter as an "interpolate" delimiter.
		     * // Disable support by replacing the "interpolate" delimiter.
		     * var compiled = _.template('hello ${ user }!');
		     * compiled({ 'user': 'pebbles' });
		     * // => 'hello pebbles!'
		     *
		     * // Use backslashes to treat delimiters as plain text.
		     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
		     * compiled({ 'value': 'ignored' });
		     * // => '<%- value %>'
		     *
		     * // Use the `imports` option to import `jQuery` as `jq`.
		     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
		     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
		     * compiled({ 'users': ['fred', 'barney'] });
		     * // => '<li>fred</li><li>barney</li>'
		     *
		     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
		     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
		     * compiled(data);
		     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
		     *
		     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
		     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
		     * compiled.source;
		     * // => function(data) {
		     * //   var __t, __p = '';
		     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
		     * //   return __p;
		     * // }
		     *
		     * // Use custom template delimiters.
		     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
		     * var compiled = _.template('hello {{ user }}!');
		     * compiled({ 'user': 'mustache' });
		     * // => 'hello mustache!'
		     *
		     * // Use the `source` property to inline compiled templates for meaningful
		     * // line numbers in error messages and stack traces.
		     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
		     *   var JST = {\
		     *     "main": ' + _.template(mainText).source + '\
		     *   };\
		     * ');
		     */
		    function template(string, options, guard) {
		      // Based on John Resig's `tmpl` implementation
		      // (http://ejohn.org/blog/javascript-micro-templating/)
		      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
		      var settings = lodash.templateSettings;

		      if (guard && isIterateeCall(string, options, guard)) {
		        options = undefined$1;
		      }
		      string = toString(string);
		      options = assignInWith({}, options, settings, customDefaultsAssignIn);

		      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
		          importsKeys = keys(imports),
		          importsValues = baseValues(imports, importsKeys);

		      var isEscaping,
		          isEvaluating,
		          index = 0,
		          interpolate = options.interpolate || reNoMatch,
		          source = "__p += '";

		      // Compile the regexp to match each delimiter.
		      var reDelimiters = RegExp(
		        (options.escape || reNoMatch).source + '|' +
		        interpolate.source + '|' +
		        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
		        (options.evaluate || reNoMatch).source + '|$'
		      , 'g');

		      // Use a sourceURL for easier debugging.
		      // The sourceURL gets injected into the source that's eval-ed, so be careful
		      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
		      // and escape the comment, thus injecting code that gets evaled.
		      var sourceURL = '//# sourceURL=' +
		        (hasOwnProperty.call(options, 'sourceURL')
		          ? (options.sourceURL + '').replace(/\s/g, ' ')
		          : ('lodash.templateSources[' + (++templateCounter) + ']')
		        ) + '\n';

		      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
		        interpolateValue || (interpolateValue = esTemplateValue);

		        // Escape characters that can't be included in string literals.
		        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

		        // Replace delimiters with snippets.
		        if (escapeValue) {
		          isEscaping = true;
		          source += "' +\n__e(" + escapeValue + ") +\n'";
		        }
		        if (evaluateValue) {
		          isEvaluating = true;
		          source += "';\n" + evaluateValue + ";\n__p += '";
		        }
		        if (interpolateValue) {
		          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
		        }
		        index = offset + match.length;

		        // The JS engine embedded in Adobe products needs `match` returned in
		        // order to produce the correct `offset` value.
		        return match;
		      });

		      source += "';\n";

		      // If `variable` is not specified wrap a with-statement around the generated
		      // code to add the data object to the top of the scope chain.
		      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
		      if (!variable) {
		        source = 'with (obj) {\n' + source + '\n}\n';
		      }
		      // Throw an error if a forbidden character was found in `variable`, to prevent
		      // potential command injection attacks.
		      else if (reForbiddenIdentifierChars.test(variable)) {
		        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
		      }

		      // Cleanup code by stripping empty strings.
		      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
		        .replace(reEmptyStringMiddle, '$1')
		        .replace(reEmptyStringTrailing, '$1;');

		      // Frame code as the function body.
		      source = 'function(' + (variable || 'obj') + ') {\n' +
		        (variable
		          ? ''
		          : 'obj || (obj = {});\n'
		        ) +
		        "var __t, __p = ''" +
		        (isEscaping
		           ? ', __e = _.escape'
		           : ''
		        ) +
		        (isEvaluating
		          ? ', __j = Array.prototype.join;\n' +
		            "function print() { __p += __j.call(arguments, '') }\n"
		          : ';\n'
		        ) +
		        source +
		        'return __p\n}';

		      var result = attempt(function() {
		        return Function(importsKeys, sourceURL + 'return ' + source)
		          .apply(undefined$1, importsValues);
		      });

		      // Provide the compiled function's source by its `toString` method or
		      // the `source` property as a convenience for inlining compiled templates.
		      result.source = source;
		      if (isError(result)) {
		        throw result;
		      }
		      return result;
		    }

		    /**
		     * Converts `string`, as a whole, to lower case just like
		     * [String#toLowerCase](https://mdn.io/toLowerCase).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the lower cased string.
		     * @example
		     *
		     * _.toLower('--Foo-Bar--');
		     * // => '--foo-bar--'
		     *
		     * _.toLower('fooBar');
		     * // => 'foobar'
		     *
		     * _.toLower('__FOO_BAR__');
		     * // => '__foo_bar__'
		     */
		    function toLower(value) {
		      return toString(value).toLowerCase();
		    }

		    /**
		     * Converts `string`, as a whole, to upper case just like
		     * [String#toUpperCase](https://mdn.io/toUpperCase).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the upper cased string.
		     * @example
		     *
		     * _.toUpper('--foo-bar--');
		     * // => '--FOO-BAR--'
		     *
		     * _.toUpper('fooBar');
		     * // => 'FOOBAR'
		     *
		     * _.toUpper('__foo_bar__');
		     * // => '__FOO_BAR__'
		     */
		    function toUpper(value) {
		      return toString(value).toUpperCase();
		    }

		    /**
		     * Removes leading and trailing whitespace or specified characters from `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to trim.
		     * @param {string} [chars=whitespace] The characters to trim.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the trimmed string.
		     * @example
		     *
		     * _.trim('  abc  ');
		     * // => 'abc'
		     *
		     * _.trim('-_-abc-_-', '_-');
		     * // => 'abc'
		     *
		     * _.map(['  foo  ', '  bar  '], _.trim);
		     * // => ['foo', 'bar']
		     */
		    function trim(string, chars, guard) {
		      string = toString(string);
		      if (string && (guard || chars === undefined$1)) {
		        return baseTrim(string);
		      }
		      if (!string || !(chars = baseToString(chars))) {
		        return string;
		      }
		      var strSymbols = stringToArray(string),
		          chrSymbols = stringToArray(chars),
		          start = charsStartIndex(strSymbols, chrSymbols),
		          end = charsEndIndex(strSymbols, chrSymbols) + 1;

		      return castSlice(strSymbols, start, end).join('');
		    }

		    /**
		     * Removes trailing whitespace or specified characters from `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to trim.
		     * @param {string} [chars=whitespace] The characters to trim.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the trimmed string.
		     * @example
		     *
		     * _.trimEnd('  abc  ');
		     * // => '  abc'
		     *
		     * _.trimEnd('-_-abc-_-', '_-');
		     * // => '-_-abc'
		     */
		    function trimEnd(string, chars, guard) {
		      string = toString(string);
		      if (string && (guard || chars === undefined$1)) {
		        return string.slice(0, trimmedEndIndex(string) + 1);
		      }
		      if (!string || !(chars = baseToString(chars))) {
		        return string;
		      }
		      var strSymbols = stringToArray(string),
		          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

		      return castSlice(strSymbols, 0, end).join('');
		    }

		    /**
		     * Removes leading whitespace or specified characters from `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to trim.
		     * @param {string} [chars=whitespace] The characters to trim.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the trimmed string.
		     * @example
		     *
		     * _.trimStart('  abc  ');
		     * // => 'abc  '
		     *
		     * _.trimStart('-_-abc-_-', '_-');
		     * // => 'abc-_-'
		     */
		    function trimStart(string, chars, guard) {
		      string = toString(string);
		      if (string && (guard || chars === undefined$1)) {
		        return string.replace(reTrimStart, '');
		      }
		      if (!string || !(chars = baseToString(chars))) {
		        return string;
		      }
		      var strSymbols = stringToArray(string),
		          start = charsStartIndex(strSymbols, stringToArray(chars));

		      return castSlice(strSymbols, start).join('');
		    }

		    /**
		     * Truncates `string` if it's longer than the given maximum string length.
		     * The last characters of the truncated string are replaced with the omission
		     * string which defaults to "...".
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to truncate.
		     * @param {Object} [options={}] The options object.
		     * @param {number} [options.length=30] The maximum string length.
		     * @param {string} [options.omission='...'] The string to indicate text is omitted.
		     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
		     * @returns {string} Returns the truncated string.
		     * @example
		     *
		     * _.truncate('hi-diddly-ho there, neighborino');
		     * // => 'hi-diddly-ho there, neighbo...'
		     *
		     * _.truncate('hi-diddly-ho there, neighborino', {
		     *   'length': 24,
		     *   'separator': ' '
		     * });
		     * // => 'hi-diddly-ho there,...'
		     *
		     * _.truncate('hi-diddly-ho there, neighborino', {
		     *   'length': 24,
		     *   'separator': /,? +/
		     * });
		     * // => 'hi-diddly-ho there...'
		     *
		     * _.truncate('hi-diddly-ho there, neighborino', {
		     *   'omission': ' [...]'
		     * });
		     * // => 'hi-diddly-ho there, neig [...]'
		     */
		    function truncate(string, options) {
		      var length = DEFAULT_TRUNC_LENGTH,
		          omission = DEFAULT_TRUNC_OMISSION;

		      if (isObject(options)) {
		        var separator = 'separator' in options ? options.separator : separator;
		        length = 'length' in options ? toInteger(options.length) : length;
		        omission = 'omission' in options ? baseToString(options.omission) : omission;
		      }
		      string = toString(string);

		      var strLength = string.length;
		      if (hasUnicode(string)) {
		        var strSymbols = stringToArray(string);
		        strLength = strSymbols.length;
		      }
		      if (length >= strLength) {
		        return string;
		      }
		      var end = length - stringSize(omission);
		      if (end < 1) {
		        return omission;
		      }
		      var result = strSymbols
		        ? castSlice(strSymbols, 0, end).join('')
		        : string.slice(0, end);

		      if (separator === undefined$1) {
		        return result + omission;
		      }
		      if (strSymbols) {
		        end += (result.length - end);
		      }
		      if (isRegExp(separator)) {
		        if (string.slice(end).search(separator)) {
		          var match,
		              substring = result;

		          if (!separator.global) {
		            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
		          }
		          separator.lastIndex = 0;
		          while ((match = separator.exec(substring))) {
		            var newEnd = match.index;
		          }
		          result = result.slice(0, newEnd === undefined$1 ? end : newEnd);
		        }
		      } else if (string.indexOf(baseToString(separator), end) != end) {
		        var index = result.lastIndexOf(separator);
		        if (index > -1) {
		          result = result.slice(0, index);
		        }
		      }
		      return result + omission;
		    }

		    /**
		     * The inverse of `_.escape`; this method converts the HTML entities
		     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
		     * their corresponding characters.
		     *
		     * **Note:** No other HTML entities are unescaped. To unescape additional
		     * HTML entities use a third-party library like [_he_](https://mths.be/he).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.6.0
		     * @category String
		     * @param {string} [string=''] The string to unescape.
		     * @returns {string} Returns the unescaped string.
		     * @example
		     *
		     * _.unescape('fred, barney, &amp; pebbles');
		     * // => 'fred, barney, & pebbles'
		     */
		    function unescape(string) {
		      string = toString(string);
		      return (string && reHasEscapedHtml.test(string))
		        ? string.replace(reEscapedHtml, unescapeHtmlChar)
		        : string;
		    }

		    /**
		     * Converts `string`, as space separated words, to upper case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the upper cased string.
		     * @example
		     *
		     * _.upperCase('--foo-bar');
		     * // => 'FOO BAR'
		     *
		     * _.upperCase('fooBar');
		     * // => 'FOO BAR'
		     *
		     * _.upperCase('__foo_bar__');
		     * // => 'FOO BAR'
		     */
		    var upperCase = createCompounder(function(result, word, index) {
		      return result + (index ? ' ' : '') + word.toUpperCase();
		    });

		    /**
		     * Converts the first character of `string` to upper case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the converted string.
		     * @example
		     *
		     * _.upperFirst('fred');
		     * // => 'Fred'
		     *
		     * _.upperFirst('FRED');
		     * // => 'FRED'
		     */
		    var upperFirst = createCaseFirst('toUpperCase');

		    /**
		     * Splits `string` into an array of its words.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to inspect.
		     * @param {RegExp|string} [pattern] The pattern to match words.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the words of `string`.
		     * @example
		     *
		     * _.words('fred, barney, & pebbles');
		     * // => ['fred', 'barney', 'pebbles']
		     *
		     * _.words('fred, barney, & pebbles', /[^, ]+/g);
		     * // => ['fred', 'barney', '&', 'pebbles']
		     */
		    function words(string, pattern, guard) {
		      string = toString(string);
		      pattern = guard ? undefined$1 : pattern;

		      if (pattern === undefined$1) {
		        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
		      }
		      return string.match(pattern) || [];
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Attempts to invoke `func`, returning either the result or the caught error
		     * object. Any additional arguments are provided to `func` when it's invoked.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {Function} func The function to attempt.
		     * @param {...*} [args] The arguments to invoke `func` with.
		     * @returns {*} Returns the `func` result or error object.
		     * @example
		     *
		     * // Avoid throwing errors for invalid selectors.
		     * var elements = _.attempt(function(selector) {
		     *   return document.querySelectorAll(selector);
		     * }, '>_>');
		     *
		     * if (_.isError(elements)) {
		     *   elements = [];
		     * }
		     */
		    var attempt = baseRest(function(func, args) {
		      try {
		        return apply(func, undefined$1, args);
		      } catch (e) {
		        return isError(e) ? e : new Error(e);
		      }
		    });

		    /**
		     * Binds methods of an object to the object itself, overwriting the existing
		     * method.
		     *
		     * **Note:** This method doesn't set the "length" property of bound functions.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {Object} object The object to bind and assign the bound methods to.
		     * @param {...(string|string[])} methodNames The object method names to bind.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var view = {
		     *   'label': 'docs',
		     *   'click': function() {
		     *     console.log('clicked ' + this.label);
		     *   }
		     * };
		     *
		     * _.bindAll(view, ['click']);
		     * jQuery(element).on('click', view.click);
		     * // => Logs 'clicked docs' when clicked.
		     */
		    var bindAll = flatRest(function(object, methodNames) {
		      arrayEach(methodNames, function(key) {
		        key = toKey(key);
		        baseAssignValue(object, key, bind(object[key], object));
		      });
		      return object;
		    });

		    /**
		     * Creates a function that iterates over `pairs` and invokes the corresponding
		     * function of the first predicate to return truthy. The predicate-function
		     * pairs are invoked with the `this` binding and arguments of the created
		     * function.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {Array} pairs The predicate-function pairs.
		     * @returns {Function} Returns the new composite function.
		     * @example
		     *
		     * var func = _.cond([
		     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
		     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
		     *   [_.stubTrue,                      _.constant('no match')]
		     * ]);
		     *
		     * func({ 'a': 1, 'b': 2 });
		     * // => 'matches A'
		     *
		     * func({ 'a': 0, 'b': 1 });
		     * // => 'matches B'
		     *
		     * func({ 'a': '1', 'b': '2' });
		     * // => 'no match'
		     */
		    function cond(pairs) {
		      var length = pairs == null ? 0 : pairs.length,
		          toIteratee = getIteratee();

		      pairs = !length ? [] : arrayMap(pairs, function(pair) {
		        if (typeof pair[1] != 'function') {
		          throw new TypeError(FUNC_ERROR_TEXT);
		        }
		        return [toIteratee(pair[0]), pair[1]];
		      });

		      return baseRest(function(args) {
		        var index = -1;
		        while (++index < length) {
		          var pair = pairs[index];
		          if (apply(pair[0], this, args)) {
		            return apply(pair[1], this, args);
		          }
		        }
		      });
		    }

		    /**
		     * Creates a function that invokes the predicate properties of `source` with
		     * the corresponding property values of a given object, returning `true` if
		     * all predicates return truthy, else `false`.
		     *
		     * **Note:** The created function is equivalent to `_.conformsTo` with
		     * `source` partially applied.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {Function} Returns the new spec function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': 2, 'b': 1 },
		     *   { 'a': 1, 'b': 2 }
		     * ];
		     *
		     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
		     * // => [{ 'a': 1, 'b': 2 }]
		     */
		    function conforms(source) {
		      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that returns `value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Util
		     * @param {*} value The value to return from the new function.
		     * @returns {Function} Returns the new constant function.
		     * @example
		     *
		     * var objects = _.times(2, _.constant({ 'a': 1 }));
		     *
		     * console.log(objects);
		     * // => [{ 'a': 1 }, { 'a': 1 }]
		     *
		     * console.log(objects[0] === objects[1]);
		     * // => true
		     */
		    function constant(value) {
		      return function() {
		        return value;
		      };
		    }

		    /**
		     * Checks `value` to determine whether a default value should be returned in
		     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
		     * or `undefined`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.14.0
		     * @category Util
		     * @param {*} value The value to check.
		     * @param {*} defaultValue The default value.
		     * @returns {*} Returns the resolved value.
		     * @example
		     *
		     * _.defaultTo(1, 10);
		     * // => 1
		     *
		     * _.defaultTo(undefined, 10);
		     * // => 10
		     */
		    function defaultTo(value, defaultValue) {
		      return (value == null || value !== value) ? defaultValue : value;
		    }

		    /**
		     * Creates a function that returns the result of invoking the given functions
		     * with the `this` binding of the created function, where each successive
		     * invocation is supplied the return value of the previous.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [funcs] The functions to invoke.
		     * @returns {Function} Returns the new composite function.
		     * @see _.flowRight
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var addSquare = _.flow([_.add, square]);
		     * addSquare(1, 2);
		     * // => 9
		     */
		    var flow = createFlow();

		    /**
		     * This method is like `_.flow` except that it creates a function that
		     * invokes the given functions from right to left.
		     *
		     * @static
		     * @since 3.0.0
		     * @memberOf _
		     * @category Util
		     * @param {...(Function|Function[])} [funcs] The functions to invoke.
		     * @returns {Function} Returns the new composite function.
		     * @see _.flow
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var addSquare = _.flowRight([square, _.add]);
		     * addSquare(1, 2);
		     * // => 9
		     */
		    var flowRight = createFlow(true);

		    /**
		     * This method returns the first argument it receives.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {*} value Any value.
		     * @returns {*} Returns `value`.
		     * @example
		     *
		     * var object = { 'a': 1 };
		     *
		     * console.log(_.identity(object) === object);
		     * // => true
		     */
		    function identity(value) {
		      return value;
		    }

		    /**
		     * Creates a function that invokes `func` with the arguments of the created
		     * function. If `func` is a property name, the created function returns the
		     * property value for a given element. If `func` is an array or object, the
		     * created function returns `true` for elements that contain the equivalent
		     * source properties, otherwise it returns `false`.
		     *
		     * @static
		     * @since 4.0.0
		     * @memberOf _
		     * @category Util
		     * @param {*} [func=_.identity] The value to convert to a callback.
		     * @returns {Function} Returns the callback.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': true },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
		     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.filter(users, _.iteratee(['user', 'fred']));
		     * // => [{ 'user': 'fred', 'age': 40 }]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.map(users, _.iteratee('user'));
		     * // => ['barney', 'fred']
		     *
		     * // Create custom iteratee shorthands.
		     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
		     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
		     *     return func.test(string);
		     *   };
		     * });
		     *
		     * _.filter(['abc', 'def'], /ef/);
		     * // => ['def']
		     */
		    function iteratee(func) {
		      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that performs a partial deep comparison between a given
		     * object and `source`, returning `true` if the given object has equivalent
		     * property values, else `false`.
		     *
		     * **Note:** The created function is equivalent to `_.isMatch` with `source`
		     * partially applied.
		     *
		     * Partial comparisons will match empty array and empty object `source`
		     * values against any array or object value, respectively. See `_.isEqual`
		     * for a list of supported value comparisons.
		     *
		     * **Note:** Multiple values can be checked by combining several matchers
		     * using `_.overSome`
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {Object} source The object of property values to match.
		     * @returns {Function} Returns the new spec function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': 1, 'b': 2, 'c': 3 },
		     *   { 'a': 4, 'b': 5, 'c': 6 }
		     * ];
		     *
		     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
		     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
		     *
		     * // Checking for several possible values
		     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
		     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
		     */
		    function matches(source) {
		      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that performs a partial deep comparison between the
		     * value at `path` of a given object to `srcValue`, returning `true` if the
		     * object value is equivalent, else `false`.
		     *
		     * **Note:** Partial comparisons will match empty array and empty object
		     * `srcValue` values against any array or object value, respectively. See
		     * `_.isEqual` for a list of supported value comparisons.
		     *
		     * **Note:** Multiple values can be checked by combining several matchers
		     * using `_.overSome`
		     *
		     * @static
		     * @memberOf _
		     * @since 3.2.0
		     * @category Util
		     * @param {Array|string} path The path of the property to get.
		     * @param {*} srcValue The value to match.
		     * @returns {Function} Returns the new spec function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': 1, 'b': 2, 'c': 3 },
		     *   { 'a': 4, 'b': 5, 'c': 6 }
		     * ];
		     *
		     * _.find(objects, _.matchesProperty('a', 4));
		     * // => { 'a': 4, 'b': 5, 'c': 6 }
		     *
		     * // Checking for several possible values
		     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
		     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
		     */
		    function matchesProperty(path, srcValue) {
		      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that invokes the method at `path` of a given object.
		     * Any additional arguments are provided to the invoked method.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Util
		     * @param {Array|string} path The path of the method to invoke.
		     * @param {...*} [args] The arguments to invoke the method with.
		     * @returns {Function} Returns the new invoker function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': { 'b': _.constant(2) } },
		     *   { 'a': { 'b': _.constant(1) } }
		     * ];
		     *
		     * _.map(objects, _.method('a.b'));
		     * // => [2, 1]
		     *
		     * _.map(objects, _.method(['a', 'b']));
		     * // => [2, 1]
		     */
		    var method = baseRest(function(path, args) {
		      return function(object) {
		        return baseInvoke(object, path, args);
		      };
		    });

		    /**
		     * The opposite of `_.method`; this method creates a function that invokes
		     * the method at a given path of `object`. Any additional arguments are
		     * provided to the invoked method.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Util
		     * @param {Object} object The object to query.
		     * @param {...*} [args] The arguments to invoke the method with.
		     * @returns {Function} Returns the new invoker function.
		     * @example
		     *
		     * var array = _.times(3, _.constant),
		     *     object = { 'a': array, 'b': array, 'c': array };
		     *
		     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
		     * // => [2, 0]
		     *
		     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
		     * // => [2, 0]
		     */
		    var methodOf = baseRest(function(object, args) {
		      return function(path) {
		        return baseInvoke(object, path, args);
		      };
		    });

		    /**
		     * Adds all own enumerable string keyed function properties of a source
		     * object to the destination object. If `object` is a function, then methods
		     * are added to its prototype as well.
		     *
		     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
		     * avoid conflicts caused by modifying the original.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {Function|Object} [object=lodash] The destination object.
		     * @param {Object} source The object of functions to add.
		     * @param {Object} [options={}] The options object.
		     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
		     * @returns {Function|Object} Returns `object`.
		     * @example
		     *
		     * function vowels(string) {
		     *   return _.filter(string, function(v) {
		     *     return /[aeiou]/i.test(v);
		     *   });
		     * }
		     *
		     * _.mixin({ 'vowels': vowels });
		     * _.vowels('fred');
		     * // => ['e']
		     *
		     * _('fred').vowels().value();
		     * // => ['e']
		     *
		     * _.mixin({ 'vowels': vowels }, { 'chain': false });
		     * _('fred').vowels();
		     * // => ['e']
		     */
		    function mixin(object, source, options) {
		      var props = keys(source),
		          methodNames = baseFunctions(source, props);

		      if (options == null &&
		          !(isObject(source) && (methodNames.length || !props.length))) {
		        options = source;
		        source = object;
		        object = this;
		        methodNames = baseFunctions(source, keys(source));
		      }
		      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
		          isFunc = isFunction(object);

		      arrayEach(methodNames, function(methodName) {
		        var func = source[methodName];
		        object[methodName] = func;
		        if (isFunc) {
		          object.prototype[methodName] = function() {
		            var chainAll = this.__chain__;
		            if (chain || chainAll) {
		              var result = object(this.__wrapped__),
		                  actions = result.__actions__ = copyArray(this.__actions__);

		              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
		              result.__chain__ = chainAll;
		              return result;
		            }
		            return func.apply(object, arrayPush([this.value()], arguments));
		          };
		        }
		      });

		      return object;
		    }

		    /**
		     * Reverts the `_` variable to its previous value and returns a reference to
		     * the `lodash` function.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @returns {Function} Returns the `lodash` function.
		     * @example
		     *
		     * var lodash = _.noConflict();
		     */
		    function noConflict() {
		      if (root._ === this) {
		        root._ = oldDash;
		      }
		      return this;
		    }

		    /**
		     * This method returns `undefined`.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.3.0
		     * @category Util
		     * @example
		     *
		     * _.times(2, _.noop);
		     * // => [undefined, undefined]
		     */
		    function noop() {
		      // No operation performed.
		    }

		    /**
		     * Creates a function that gets the argument at index `n`. If `n` is negative,
		     * the nth argument from the end is returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {number} [n=0] The index of the argument to return.
		     * @returns {Function} Returns the new pass-thru function.
		     * @example
		     *
		     * var func = _.nthArg(1);
		     * func('a', 'b', 'c', 'd');
		     * // => 'b'
		     *
		     * var func = _.nthArg(-2);
		     * func('a', 'b', 'c', 'd');
		     * // => 'c'
		     */
		    function nthArg(n) {
		      n = toInteger(n);
		      return baseRest(function(args) {
		        return baseNth(args, n);
		      });
		    }

		    /**
		     * Creates a function that invokes `iteratees` with the arguments it receives
		     * and returns their results.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [iteratees=[_.identity]]
		     *  The iteratees to invoke.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.over([Math.max, Math.min]);
		     *
		     * func(1, 2, 3, 4);
		     * // => [4, 1]
		     */
		    var over = createOver(arrayMap);

		    /**
		     * Creates a function that checks if **all** of the `predicates` return
		     * truthy when invoked with the arguments it receives.
		     *
		     * Following shorthands are possible for providing predicates.
		     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
		     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [predicates=[_.identity]]
		     *  The predicates to check.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.overEvery([Boolean, isFinite]);
		     *
		     * func('1');
		     * // => true
		     *
		     * func(null);
		     * // => false
		     *
		     * func(NaN);
		     * // => false
		     */
		    var overEvery = createOver(arrayEvery);

		    /**
		     * Creates a function that checks if **any** of the `predicates` return
		     * truthy when invoked with the arguments it receives.
		     *
		     * Following shorthands are possible for providing predicates.
		     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
		     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [predicates=[_.identity]]
		     *  The predicates to check.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.overSome([Boolean, isFinite]);
		     *
		     * func('1');
		     * // => true
		     *
		     * func(null);
		     * // => true
		     *
		     * func(NaN);
		     * // => false
		     *
		     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
		     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
		     */
		    var overSome = createOver(arraySome);

		    /**
		     * Creates a function that returns the value at `path` of a given object.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Util
		     * @param {Array|string} path The path of the property to get.
		     * @returns {Function} Returns the new accessor function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': { 'b': 2 } },
		     *   { 'a': { 'b': 1 } }
		     * ];
		     *
		     * _.map(objects, _.property('a.b'));
		     * // => [2, 1]
		     *
		     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
		     * // => [1, 2]
		     */
		    function property(path) {
		      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
		    }

		    /**
		     * The opposite of `_.property`; this method creates a function that returns
		     * the value at a given path of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {Object} object The object to query.
		     * @returns {Function} Returns the new accessor function.
		     * @example
		     *
		     * var array = [0, 1, 2],
		     *     object = { 'a': array, 'b': array, 'c': array };
		     *
		     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
		     * // => [2, 0]
		     *
		     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
		     * // => [2, 0]
		     */
		    function propertyOf(object) {
		      return function(path) {
		        return object == null ? undefined$1 : baseGet(object, path);
		      };
		    }

		    /**
		     * Creates an array of numbers (positive and/or negative) progressing from
		     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
		     * `start` is specified without an `end` or `step`. If `end` is not specified,
		     * it's set to `start` with `start` then set to `0`.
		     *
		     * **Note:** JavaScript follows the IEEE-754 standard for resolving
		     * floating-point values which can produce unexpected results.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} [step=1] The value to increment or decrement by.
		     * @returns {Array} Returns the range of numbers.
		     * @see _.inRange, _.rangeRight
		     * @example
		     *
		     * _.range(4);
		     * // => [0, 1, 2, 3]
		     *
		     * _.range(-4);
		     * // => [0, -1, -2, -3]
		     *
		     * _.range(1, 5);
		     * // => [1, 2, 3, 4]
		     *
		     * _.range(0, 20, 5);
		     * // => [0, 5, 10, 15]
		     *
		     * _.range(0, -4, -1);
		     * // => [0, -1, -2, -3]
		     *
		     * _.range(1, 4, 0);
		     * // => [1, 1, 1]
		     *
		     * _.range(0);
		     * // => []
		     */
		    var range = createRange();

		    /**
		     * This method is like `_.range` except that it populates values in
		     * descending order.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} [step=1] The value to increment or decrement by.
		     * @returns {Array} Returns the range of numbers.
		     * @see _.inRange, _.range
		     * @example
		     *
		     * _.rangeRight(4);
		     * // => [3, 2, 1, 0]
		     *
		     * _.rangeRight(-4);
		     * // => [-3, -2, -1, 0]
		     *
		     * _.rangeRight(1, 5);
		     * // => [4, 3, 2, 1]
		     *
		     * _.rangeRight(0, 20, 5);
		     * // => [15, 10, 5, 0]
		     *
		     * _.rangeRight(0, -4, -1);
		     * // => [-3, -2, -1, 0]
		     *
		     * _.rangeRight(1, 4, 0);
		     * // => [1, 1, 1]
		     *
		     * _.rangeRight(0);
		     * // => []
		     */
		    var rangeRight = createRange(true);

		    /**
		     * This method returns a new empty array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {Array} Returns the new empty array.
		     * @example
		     *
		     * var arrays = _.times(2, _.stubArray);
		     *
		     * console.log(arrays);
		     * // => [[], []]
		     *
		     * console.log(arrays[0] === arrays[1]);
		     * // => false
		     */
		    function stubArray() {
		      return [];
		    }

		    /**
		     * This method returns `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {boolean} Returns `false`.
		     * @example
		     *
		     * _.times(2, _.stubFalse);
		     * // => [false, false]
		     */
		    function stubFalse() {
		      return false;
		    }

		    /**
		     * This method returns a new empty object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {Object} Returns the new empty object.
		     * @example
		     *
		     * var objects = _.times(2, _.stubObject);
		     *
		     * console.log(objects);
		     * // => [{}, {}]
		     *
		     * console.log(objects[0] === objects[1]);
		     * // => false
		     */
		    function stubObject() {
		      return {};
		    }

		    /**
		     * This method returns an empty string.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {string} Returns the empty string.
		     * @example
		     *
		     * _.times(2, _.stubString);
		     * // => ['', '']
		     */
		    function stubString() {
		      return '';
		    }

		    /**
		     * This method returns `true`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {boolean} Returns `true`.
		     * @example
		     *
		     * _.times(2, _.stubTrue);
		     * // => [true, true]
		     */
		    function stubTrue() {
		      return true;
		    }

		    /**
		     * Invokes the iteratee `n` times, returning an array of the results of
		     * each invocation. The iteratee is invoked with one argument; (index).
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {number} n The number of times to invoke `iteratee`.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the array of results.
		     * @example
		     *
		     * _.times(3, String);
		     * // => ['0', '1', '2']
		     *
		     *  _.times(4, _.constant(0));
		     * // => [0, 0, 0, 0]
		     */
		    function times(n, iteratee) {
		      n = toInteger(n);
		      if (n < 1 || n > MAX_SAFE_INTEGER) {
		        return [];
		      }
		      var index = MAX_ARRAY_LENGTH,
		          length = nativeMin(n, MAX_ARRAY_LENGTH);

		      iteratee = getIteratee(iteratee);
		      n -= MAX_ARRAY_LENGTH;

		      var result = baseTimes(length, iteratee);
		      while (++index < n) {
		        iteratee(index);
		      }
		      return result;
		    }

		    /**
		     * Converts `value` to a property path array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {*} value The value to convert.
		     * @returns {Array} Returns the new property path array.
		     * @example
		     *
		     * _.toPath('a.b.c');
		     * // => ['a', 'b', 'c']
		     *
		     * _.toPath('a[0].b.c');
		     * // => ['a', '0', 'b', 'c']
		     */
		    function toPath(value) {
		      if (isArray(value)) {
		        return arrayMap(value, toKey);
		      }
		      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
		    }

		    /**
		     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {string} [prefix=''] The value to prefix the ID with.
		     * @returns {string} Returns the unique ID.
		     * @example
		     *
		     * _.uniqueId('contact_');
		     * // => 'contact_104'
		     *
		     * _.uniqueId();
		     * // => '105'
		     */
		    function uniqueId(prefix) {
		      var id = ++idCounter;
		      return toString(prefix) + id;
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Adds two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.4.0
		     * @category Math
		     * @param {number} augend The first number in an addition.
		     * @param {number} addend The second number in an addition.
		     * @returns {number} Returns the total.
		     * @example
		     *
		     * _.add(6, 4);
		     * // => 10
		     */
		    var add = createMathOperation(function(augend, addend) {
		      return augend + addend;
		    }, 0);

		    /**
		     * Computes `number` rounded up to `precision`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Math
		     * @param {number} number The number to round up.
		     * @param {number} [precision=0] The precision to round up to.
		     * @returns {number} Returns the rounded up number.
		     * @example
		     *
		     * _.ceil(4.006);
		     * // => 5
		     *
		     * _.ceil(6.004, 2);
		     * // => 6.01
		     *
		     * _.ceil(6040, -2);
		     * // => 6100
		     */
		    var ceil = createRound('ceil');

		    /**
		     * Divide two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Math
		     * @param {number} dividend The first number in a division.
		     * @param {number} divisor The second number in a division.
		     * @returns {number} Returns the quotient.
		     * @example
		     *
		     * _.divide(6, 4);
		     * // => 1.5
		     */
		    var divide = createMathOperation(function(dividend, divisor) {
		      return dividend / divisor;
		    }, 1);

		    /**
		     * Computes `number` rounded down to `precision`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Math
		     * @param {number} number The number to round down.
		     * @param {number} [precision=0] The precision to round down to.
		     * @returns {number} Returns the rounded down number.
		     * @example
		     *
		     * _.floor(4.006);
		     * // => 4
		     *
		     * _.floor(0.046, 2);
		     * // => 0.04
		     *
		     * _.floor(4060, -2);
		     * // => 4000
		     */
		    var floor = createRound('floor');

		    /**
		     * Computes the maximum value of `array`. If `array` is empty or falsey,
		     * `undefined` is returned.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {*} Returns the maximum value.
		     * @example
		     *
		     * _.max([4, 2, 8, 6]);
		     * // => 8
		     *
		     * _.max([]);
		     * // => undefined
		     */
		    function max(array) {
		      return (array && array.length)
		        ? baseExtremum(array, identity, baseGt)
		        : undefined$1;
		    }

		    /**
		     * This method is like `_.max` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the criterion by which
		     * the value is ranked. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {*} Returns the maximum value.
		     * @example
		     *
		     * var objects = [{ 'n': 1 }, { 'n': 2 }];
		     *
		     * _.maxBy(objects, function(o) { return o.n; });
		     * // => { 'n': 2 }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.maxBy(objects, 'n');
		     * // => { 'n': 2 }
		     */
		    function maxBy(array, iteratee) {
		      return (array && array.length)
		        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
		        : undefined$1;
		    }

		    /**
		     * Computes the mean of the values in `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {number} Returns the mean.
		     * @example
		     *
		     * _.mean([4, 2, 8, 6]);
		     * // => 5
		     */
		    function mean(array) {
		      return baseMean(array, identity);
		    }

		    /**
		     * This method is like `_.mean` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the value to be averaged.
		     * The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the mean.
		     * @example
		     *
		     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
		     *
		     * _.meanBy(objects, function(o) { return o.n; });
		     * // => 5
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.meanBy(objects, 'n');
		     * // => 5
		     */
		    function meanBy(array, iteratee) {
		      return baseMean(array, getIteratee(iteratee, 2));
		    }

		    /**
		     * Computes the minimum value of `array`. If `array` is empty or falsey,
		     * `undefined` is returned.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {*} Returns the minimum value.
		     * @example
		     *
		     * _.min([4, 2, 8, 6]);
		     * // => 2
		     *
		     * _.min([]);
		     * // => undefined
		     */
		    function min(array) {
		      return (array && array.length)
		        ? baseExtremum(array, identity, baseLt)
		        : undefined$1;
		    }

		    /**
		     * This method is like `_.min` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the criterion by which
		     * the value is ranked. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {*} Returns the minimum value.
		     * @example
		     *
		     * var objects = [{ 'n': 1 }, { 'n': 2 }];
		     *
		     * _.minBy(objects, function(o) { return o.n; });
		     * // => { 'n': 1 }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.minBy(objects, 'n');
		     * // => { 'n': 1 }
		     */
		    function minBy(array, iteratee) {
		      return (array && array.length)
		        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
		        : undefined$1;
		    }

		    /**
		     * Multiply two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Math
		     * @param {number} multiplier The first number in a multiplication.
		     * @param {number} multiplicand The second number in a multiplication.
		     * @returns {number} Returns the product.
		     * @example
		     *
		     * _.multiply(6, 4);
		     * // => 24
		     */
		    var multiply = createMathOperation(function(multiplier, multiplicand) {
		      return multiplier * multiplicand;
		    }, 1);

		    /**
		     * Computes `number` rounded to `precision`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Math
		     * @param {number} number The number to round.
		     * @param {number} [precision=0] The precision to round to.
		     * @returns {number} Returns the rounded number.
		     * @example
		     *
		     * _.round(4.006);
		     * // => 4
		     *
		     * _.round(4.006, 2);
		     * // => 4.01
		     *
		     * _.round(4060, -2);
		     * // => 4100
		     */
		    var round = createRound('round');

		    /**
		     * Subtract two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {number} minuend The first number in a subtraction.
		     * @param {number} subtrahend The second number in a subtraction.
		     * @returns {number} Returns the difference.
		     * @example
		     *
		     * _.subtract(6, 4);
		     * // => 2
		     */
		    var subtract = createMathOperation(function(minuend, subtrahend) {
		      return minuend - subtrahend;
		    }, 0);

		    /**
		     * Computes the sum of the values in `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.4.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {number} Returns the sum.
		     * @example
		     *
		     * _.sum([4, 2, 8, 6]);
		     * // => 20
		     */
		    function sum(array) {
		      return (array && array.length)
		        ? baseSum(array, identity)
		        : 0;
		    }

		    /**
		     * This method is like `_.sum` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the value to be summed.
		     * The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the sum.
		     * @example
		     *
		     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
		     *
		     * _.sumBy(objects, function(o) { return o.n; });
		     * // => 20
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.sumBy(objects, 'n');
		     * // => 20
		     */
		    function sumBy(array, iteratee) {
		      return (array && array.length)
		        ? baseSum(array, getIteratee(iteratee, 2))
		        : 0;
		    }

		    /*------------------------------------------------------------------------*/

		    // Add methods that return wrapped values in chain sequences.
		    lodash.after = after;
		    lodash.ary = ary;
		    lodash.assign = assign;
		    lodash.assignIn = assignIn;
		    lodash.assignInWith = assignInWith;
		    lodash.assignWith = assignWith;
		    lodash.at = at;
		    lodash.before = before;
		    lodash.bind = bind;
		    lodash.bindAll = bindAll;
		    lodash.bindKey = bindKey;
		    lodash.castArray = castArray;
		    lodash.chain = chain;
		    lodash.chunk = chunk;
		    lodash.compact = compact;
		    lodash.concat = concat;
		    lodash.cond = cond;
		    lodash.conforms = conforms;
		    lodash.constant = constant;
		    lodash.countBy = countBy;
		    lodash.create = create;
		    lodash.curry = curry;
		    lodash.curryRight = curryRight;
		    lodash.debounce = debounce;
		    lodash.defaults = defaults;
		    lodash.defaultsDeep = defaultsDeep;
		    lodash.defer = defer;
		    lodash.delay = delay;
		    lodash.difference = difference;
		    lodash.differenceBy = differenceBy;
		    lodash.differenceWith = differenceWith;
		    lodash.drop = drop;
		    lodash.dropRight = dropRight;
		    lodash.dropRightWhile = dropRightWhile;
		    lodash.dropWhile = dropWhile;
		    lodash.fill = fill;
		    lodash.filter = filter;
		    lodash.flatMap = flatMap;
		    lodash.flatMapDeep = flatMapDeep;
		    lodash.flatMapDepth = flatMapDepth;
		    lodash.flatten = flatten;
		    lodash.flattenDeep = flattenDeep;
		    lodash.flattenDepth = flattenDepth;
		    lodash.flip = flip;
		    lodash.flow = flow;
		    lodash.flowRight = flowRight;
		    lodash.fromPairs = fromPairs;
		    lodash.functions = functions;
		    lodash.functionsIn = functionsIn;
		    lodash.groupBy = groupBy;
		    lodash.initial = initial;
		    lodash.intersection = intersection;
		    lodash.intersectionBy = intersectionBy;
		    lodash.intersectionWith = intersectionWith;
		    lodash.invert = invert;
		    lodash.invertBy = invertBy;
		    lodash.invokeMap = invokeMap;
		    lodash.iteratee = iteratee;
		    lodash.keyBy = keyBy;
		    lodash.keys = keys;
		    lodash.keysIn = keysIn;
		    lodash.map = map;
		    lodash.mapKeys = mapKeys;
		    lodash.mapValues = mapValues;
		    lodash.matches = matches;
		    lodash.matchesProperty = matchesProperty;
		    lodash.memoize = memoize;
		    lodash.merge = merge;
		    lodash.mergeWith = mergeWith;
		    lodash.method = method;
		    lodash.methodOf = methodOf;
		    lodash.mixin = mixin;
		    lodash.negate = negate;
		    lodash.nthArg = nthArg;
		    lodash.omit = omit;
		    lodash.omitBy = omitBy;
		    lodash.once = once;
		    lodash.orderBy = orderBy;
		    lodash.over = over;
		    lodash.overArgs = overArgs;
		    lodash.overEvery = overEvery;
		    lodash.overSome = overSome;
		    lodash.partial = partial;
		    lodash.partialRight = partialRight;
		    lodash.partition = partition;
		    lodash.pick = pick;
		    lodash.pickBy = pickBy;
		    lodash.property = property;
		    lodash.propertyOf = propertyOf;
		    lodash.pull = pull;
		    lodash.pullAll = pullAll;
		    lodash.pullAllBy = pullAllBy;
		    lodash.pullAllWith = pullAllWith;
		    lodash.pullAt = pullAt;
		    lodash.range = range;
		    lodash.rangeRight = rangeRight;
		    lodash.rearg = rearg;
		    lodash.reject = reject;
		    lodash.remove = remove;
		    lodash.rest = rest;
		    lodash.reverse = reverse;
		    lodash.sampleSize = sampleSize;
		    lodash.set = set;
		    lodash.setWith = setWith;
		    lodash.shuffle = shuffle;
		    lodash.slice = slice;
		    lodash.sortBy = sortBy;
		    lodash.sortedUniq = sortedUniq;
		    lodash.sortedUniqBy = sortedUniqBy;
		    lodash.split = split;
		    lodash.spread = spread;
		    lodash.tail = tail;
		    lodash.take = take;
		    lodash.takeRight = takeRight;
		    lodash.takeRightWhile = takeRightWhile;
		    lodash.takeWhile = takeWhile;
		    lodash.tap = tap;
		    lodash.throttle = throttle;
		    lodash.thru = thru;
		    lodash.toArray = toArray;
		    lodash.toPairs = toPairs;
		    lodash.toPairsIn = toPairsIn;
		    lodash.toPath = toPath;
		    lodash.toPlainObject = toPlainObject;
		    lodash.transform = transform;
		    lodash.unary = unary;
		    lodash.union = union;
		    lodash.unionBy = unionBy;
		    lodash.unionWith = unionWith;
		    lodash.uniq = uniq;
		    lodash.uniqBy = uniqBy;
		    lodash.uniqWith = uniqWith;
		    lodash.unset = unset;
		    lodash.unzip = unzip;
		    lodash.unzipWith = unzipWith;
		    lodash.update = update;
		    lodash.updateWith = updateWith;
		    lodash.values = values;
		    lodash.valuesIn = valuesIn;
		    lodash.without = without;
		    lodash.words = words;
		    lodash.wrap = wrap;
		    lodash.xor = xor;
		    lodash.xorBy = xorBy;
		    lodash.xorWith = xorWith;
		    lodash.zip = zip;
		    lodash.zipObject = zipObject;
		    lodash.zipObjectDeep = zipObjectDeep;
		    lodash.zipWith = zipWith;

		    // Add aliases.
		    lodash.entries = toPairs;
		    lodash.entriesIn = toPairsIn;
		    lodash.extend = assignIn;
		    lodash.extendWith = assignInWith;

		    // Add methods to `lodash.prototype`.
		    mixin(lodash, lodash);

		    /*------------------------------------------------------------------------*/

		    // Add methods that return unwrapped values in chain sequences.
		    lodash.add = add;
		    lodash.attempt = attempt;
		    lodash.camelCase = camelCase;
		    lodash.capitalize = capitalize;
		    lodash.ceil = ceil;
		    lodash.clamp = clamp;
		    lodash.clone = clone;
		    lodash.cloneDeep = cloneDeep;
		    lodash.cloneDeepWith = cloneDeepWith;
		    lodash.cloneWith = cloneWith;
		    lodash.conformsTo = conformsTo;
		    lodash.deburr = deburr;
		    lodash.defaultTo = defaultTo;
		    lodash.divide = divide;
		    lodash.endsWith = endsWith;
		    lodash.eq = eq;
		    lodash.escape = escape;
		    lodash.escapeRegExp = escapeRegExp;
		    lodash.every = every;
		    lodash.find = find;
		    lodash.findIndex = findIndex;
		    lodash.findKey = findKey;
		    lodash.findLast = findLast;
		    lodash.findLastIndex = findLastIndex;
		    lodash.findLastKey = findLastKey;
		    lodash.floor = floor;
		    lodash.forEach = forEach;
		    lodash.forEachRight = forEachRight;
		    lodash.forIn = forIn;
		    lodash.forInRight = forInRight;
		    lodash.forOwn = forOwn;
		    lodash.forOwnRight = forOwnRight;
		    lodash.get = get;
		    lodash.gt = gt;
		    lodash.gte = gte;
		    lodash.has = has;
		    lodash.hasIn = hasIn;
		    lodash.head = head;
		    lodash.identity = identity;
		    lodash.includes = includes;
		    lodash.indexOf = indexOf;
		    lodash.inRange = inRange;
		    lodash.invoke = invoke;
		    lodash.isArguments = isArguments;
		    lodash.isArray = isArray;
		    lodash.isArrayBuffer = isArrayBuffer;
		    lodash.isArrayLike = isArrayLike;
		    lodash.isArrayLikeObject = isArrayLikeObject;
		    lodash.isBoolean = isBoolean;
		    lodash.isBuffer = isBuffer;
		    lodash.isDate = isDate;
		    lodash.isElement = isElement;
		    lodash.isEmpty = isEmpty;
		    lodash.isEqual = isEqual;
		    lodash.isEqualWith = isEqualWith;
		    lodash.isError = isError;
		    lodash.isFinite = isFinite;
		    lodash.isFunction = isFunction;
		    lodash.isInteger = isInteger;
		    lodash.isLength = isLength;
		    lodash.isMap = isMap;
		    lodash.isMatch = isMatch;
		    lodash.isMatchWith = isMatchWith;
		    lodash.isNaN = isNaN;
		    lodash.isNative = isNative;
		    lodash.isNil = isNil;
		    lodash.isNull = isNull;
		    lodash.isNumber = isNumber;
		    lodash.isObject = isObject;
		    lodash.isObjectLike = isObjectLike;
		    lodash.isPlainObject = isPlainObject;
		    lodash.isRegExp = isRegExp;
		    lodash.isSafeInteger = isSafeInteger;
		    lodash.isSet = isSet;
		    lodash.isString = isString;
		    lodash.isSymbol = isSymbol;
		    lodash.isTypedArray = isTypedArray;
		    lodash.isUndefined = isUndefined;
		    lodash.isWeakMap = isWeakMap;
		    lodash.isWeakSet = isWeakSet;
		    lodash.join = join;
		    lodash.kebabCase = kebabCase;
		    lodash.last = last;
		    lodash.lastIndexOf = lastIndexOf;
		    lodash.lowerCase = lowerCase;
		    lodash.lowerFirst = lowerFirst;
		    lodash.lt = lt;
		    lodash.lte = lte;
		    lodash.max = max;
		    lodash.maxBy = maxBy;
		    lodash.mean = mean;
		    lodash.meanBy = meanBy;
		    lodash.min = min;
		    lodash.minBy = minBy;
		    lodash.stubArray = stubArray;
		    lodash.stubFalse = stubFalse;
		    lodash.stubObject = stubObject;
		    lodash.stubString = stubString;
		    lodash.stubTrue = stubTrue;
		    lodash.multiply = multiply;
		    lodash.nth = nth;
		    lodash.noConflict = noConflict;
		    lodash.noop = noop;
		    lodash.now = now;
		    lodash.pad = pad;
		    lodash.padEnd = padEnd;
		    lodash.padStart = padStart;
		    lodash.parseInt = parseInt;
		    lodash.random = random;
		    lodash.reduce = reduce;
		    lodash.reduceRight = reduceRight;
		    lodash.repeat = repeat;
		    lodash.replace = replace;
		    lodash.result = result;
		    lodash.round = round;
		    lodash.runInContext = runInContext;
		    lodash.sample = sample;
		    lodash.size = size;
		    lodash.snakeCase = snakeCase;
		    lodash.some = some;
		    lodash.sortedIndex = sortedIndex;
		    lodash.sortedIndexBy = sortedIndexBy;
		    lodash.sortedIndexOf = sortedIndexOf;
		    lodash.sortedLastIndex = sortedLastIndex;
		    lodash.sortedLastIndexBy = sortedLastIndexBy;
		    lodash.sortedLastIndexOf = sortedLastIndexOf;
		    lodash.startCase = startCase;
		    lodash.startsWith = startsWith;
		    lodash.subtract = subtract;
		    lodash.sum = sum;
		    lodash.sumBy = sumBy;
		    lodash.template = template;
		    lodash.times = times;
		    lodash.toFinite = toFinite;
		    lodash.toInteger = toInteger;
		    lodash.toLength = toLength;
		    lodash.toLower = toLower;
		    lodash.toNumber = toNumber;
		    lodash.toSafeInteger = toSafeInteger;
		    lodash.toString = toString;
		    lodash.toUpper = toUpper;
		    lodash.trim = trim;
		    lodash.trimEnd = trimEnd;
		    lodash.trimStart = trimStart;
		    lodash.truncate = truncate;
		    lodash.unescape = unescape;
		    lodash.uniqueId = uniqueId;
		    lodash.upperCase = upperCase;
		    lodash.upperFirst = upperFirst;

		    // Add aliases.
		    lodash.each = forEach;
		    lodash.eachRight = forEachRight;
		    lodash.first = head;

		    mixin(lodash, (function() {
		      var source = {};
		      baseForOwn(lodash, function(func, methodName) {
		        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
		          source[methodName] = func;
		        }
		      });
		      return source;
		    }()), { 'chain': false });

		    /*------------------------------------------------------------------------*/

		    /**
		     * The semantic version number.
		     *
		     * @static
		     * @memberOf _
		     * @type {string}
		     */
		    lodash.VERSION = VERSION;

		    // Assign default placeholders.
		    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
		      lodash[methodName].placeholder = lodash;
		    });

		    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
		    arrayEach(['drop', 'take'], function(methodName, index) {
		      LazyWrapper.prototype[methodName] = function(n) {
		        n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);

		        var result = (this.__filtered__ && !index)
		          ? new LazyWrapper(this)
		          : this.clone();

		        if (result.__filtered__) {
		          result.__takeCount__ = nativeMin(n, result.__takeCount__);
		        } else {
		          result.__views__.push({
		            'size': nativeMin(n, MAX_ARRAY_LENGTH),
		            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
		          });
		        }
		        return result;
		      };

		      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
		        return this.reverse()[methodName](n).reverse();
		      };
		    });

		    // Add `LazyWrapper` methods that accept an `iteratee` value.
		    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
		      var type = index + 1,
		          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

		      LazyWrapper.prototype[methodName] = function(iteratee) {
		        var result = this.clone();
		        result.__iteratees__.push({
		          'iteratee': getIteratee(iteratee, 3),
		          'type': type
		        });
		        result.__filtered__ = result.__filtered__ || isFilter;
		        return result;
		      };
		    });

		    // Add `LazyWrapper` methods for `_.head` and `_.last`.
		    arrayEach(['head', 'last'], function(methodName, index) {
		      var takeName = 'take' + (index ? 'Right' : '');

		      LazyWrapper.prototype[methodName] = function() {
		        return this[takeName](1).value()[0];
		      };
		    });

		    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
		    arrayEach(['initial', 'tail'], function(methodName, index) {
		      var dropName = 'drop' + (index ? '' : 'Right');

		      LazyWrapper.prototype[methodName] = function() {
		        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
		      };
		    });

		    LazyWrapper.prototype.compact = function() {
		      return this.filter(identity);
		    };

		    LazyWrapper.prototype.find = function(predicate) {
		      return this.filter(predicate).head();
		    };

		    LazyWrapper.prototype.findLast = function(predicate) {
		      return this.reverse().find(predicate);
		    };

		    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
		      if (typeof path == 'function') {
		        return new LazyWrapper(this);
		      }
		      return this.map(function(value) {
		        return baseInvoke(value, path, args);
		      });
		    });

		    LazyWrapper.prototype.reject = function(predicate) {
		      return this.filter(negate(getIteratee(predicate)));
		    };

		    LazyWrapper.prototype.slice = function(start, end) {
		      start = toInteger(start);

		      var result = this;
		      if (result.__filtered__ && (start > 0 || end < 0)) {
		        return new LazyWrapper(result);
		      }
		      if (start < 0) {
		        result = result.takeRight(-start);
		      } else if (start) {
		        result = result.drop(start);
		      }
		      if (end !== undefined$1) {
		        end = toInteger(end);
		        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
		      }
		      return result;
		    };

		    LazyWrapper.prototype.takeRightWhile = function(predicate) {
		      return this.reverse().takeWhile(predicate).reverse();
		    };

		    LazyWrapper.prototype.toArray = function() {
		      return this.take(MAX_ARRAY_LENGTH);
		    };

		    // Add `LazyWrapper` methods to `lodash.prototype`.
		    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
		      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
		          isTaker = /^(?:head|last)$/.test(methodName),
		          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
		          retUnwrapped = isTaker || /^find/.test(methodName);

		      if (!lodashFunc) {
		        return;
		      }
		      lodash.prototype[methodName] = function() {
		        var value = this.__wrapped__,
		            args = isTaker ? [1] : arguments,
		            isLazy = value instanceof LazyWrapper,
		            iteratee = args[0],
		            useLazy = isLazy || isArray(value);

		        var interceptor = function(value) {
		          var result = lodashFunc.apply(lodash, arrayPush([value], args));
		          return (isTaker && chainAll) ? result[0] : result;
		        };

		        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
		          // Avoid lazy use if the iteratee has a "length" value other than `1`.
		          isLazy = useLazy = false;
		        }
		        var chainAll = this.__chain__,
		            isHybrid = !!this.__actions__.length,
		            isUnwrapped = retUnwrapped && !chainAll,
		            onlyLazy = isLazy && !isHybrid;

		        if (!retUnwrapped && useLazy) {
		          value = onlyLazy ? value : new LazyWrapper(this);
		          var result = func.apply(value, args);
		          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined$1 });
		          return new LodashWrapper(result, chainAll);
		        }
		        if (isUnwrapped && onlyLazy) {
		          return func.apply(this, args);
		        }
		        result = this.thru(interceptor);
		        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
		      };
		    });

		    // Add `Array` methods to `lodash.prototype`.
		    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
		      var func = arrayProto[methodName],
		          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
		          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

		      lodash.prototype[methodName] = function() {
		        var args = arguments;
		        if (retUnwrapped && !this.__chain__) {
		          var value = this.value();
		          return func.apply(isArray(value) ? value : [], args);
		        }
		        return this[chainName](function(value) {
		          return func.apply(isArray(value) ? value : [], args);
		        });
		      };
		    });

		    // Map minified method names to their real names.
		    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
		      var lodashFunc = lodash[methodName];
		      if (lodashFunc) {
		        var key = lodashFunc.name + '';
		        if (!hasOwnProperty.call(realNames, key)) {
		          realNames[key] = [];
		        }
		        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
		      }
		    });

		    realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
		      'name': 'wrapper',
		      'func': undefined$1
		    }];

		    // Add methods to `LazyWrapper`.
		    LazyWrapper.prototype.clone = lazyClone;
		    LazyWrapper.prototype.reverse = lazyReverse;
		    LazyWrapper.prototype.value = lazyValue;

		    // Add chain sequence methods to the `lodash` wrapper.
		    lodash.prototype.at = wrapperAt;
		    lodash.prototype.chain = wrapperChain;
		    lodash.prototype.commit = wrapperCommit;
		    lodash.prototype.next = wrapperNext;
		    lodash.prototype.plant = wrapperPlant;
		    lodash.prototype.reverse = wrapperReverse;
		    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

		    // Add lazy aliases.
		    lodash.prototype.first = lodash.prototype.head;

		    if (symIterator) {
		      lodash.prototype[symIterator] = wrapperToIterator;
		    }
		    return lodash;
		  });

		  /*--------------------------------------------------------------------------*/

		  // Export lodash.
		  var _ = runInContext();

		  // Some AMD build optimizers, like r.js, check for condition patterns like:
		  if (freeModule) {
		    // Export for Node.js.
		    (freeModule.exports = _)._ = _;
		    // Export for CommonJS support.
		    freeExports._ = _;
		  }
		  else {
		    // Export to the global object.
		    root._ = _;
		  }
		}.call(lodash)); 
	} (lodash$1, lodash$1.exports));
	return lodash$1.exports;
}

var lodashExports = requireLodash();

// src/jsonDiff.ts
function diff(oldObj, newObj, options = {}) {
  let { embeddedObjKeys, keysToSkip, treatTypeChangeAsReplace } = options;
  if (embeddedObjKeys instanceof Map) {
    embeddedObjKeys = new Map(
      Array.from(embeddedObjKeys.entries()).map(([key, value]) => [
        key instanceof RegExp ? key : key.replace(/^\./, ""),
        value
      ])
    );
  } else if (embeddedObjKeys) {
    embeddedObjKeys = Object.fromEntries(
      Object.entries(embeddedObjKeys).map(([key, value]) => [key.replace(/^\./, ""), value])
    );
  }
  return compare(oldObj, newObj, [], [], {
    embeddedObjKeys,
    keysToSkip: keysToSkip ?? [],
    treatTypeChangeAsReplace: treatTypeChangeAsReplace ?? true
  });
}
var atomizeChangeset = (obj, path = "$", embeddedKey) => {
  if (Array.isArray(obj)) {
    return handleArray(obj, path, embeddedKey);
  } else if (obj.changes || embeddedKey) {
    if (embeddedKey) {
      const [updatedPath, atomicChange] = handleEmbeddedKey(embeddedKey, obj, path);
      path = updatedPath;
      if (atomicChange) {
        return atomicChange;
      }
    } else {
      path = append(path, obj.key);
    }
    return atomizeChangeset(obj.changes || obj, path, obj.embeddedKey);
  } else {
    const valueType = getTypeOfObj(obj.value);
    return [
      {
        ...obj,
        path: valueType === "Object" || path.endsWith(`[${obj.key}]`) ? path : append(path, obj.key),
        valueType
      }
    ];
  }
};
function handleEmbeddedKey(embeddedKey, obj, path) {
  if (embeddedKey === "$index") {
    path = `${path}[${obj.key}]`;
    return [path];
  } else if (embeddedKey === "$value") {
    path = `${path}[?(@=='${obj.key}')]`;
    const valueType = getTypeOfObj(obj.value);
    return [
      path,
      [
        {
          ...obj,
          path,
          valueType
        }
      ]
    ];
  } else if (obj.type === "ADD" /* ADD */) {
    return [path];
  } else {
    path = filterExpression(path, embeddedKey, obj.key);
    return [path];
  }
}
var handleArray = (obj, path, embeddedKey) => {
  return obj.reduce((memo, change) => [...memo, ...atomizeChangeset(change, path, embeddedKey)], []);
};
var getTypeOfObj = (obj) => {
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return null;
  }
  return Object.prototype.toString.call(obj).match(/^\[object\s(.*)\]$/)[1];
};
var getKey = (path) => {
  const left = path[path.length - 1];
  return left != null ? left : "$root";
};
var compare = (oldObj, newObj, path, keyPath, options) => {
  let changes = [];
  const typeOfOldObj = getTypeOfObj(oldObj);
  const typeOfNewObj = getTypeOfObj(newObj);
  if (options.treatTypeChangeAsReplace && typeOfOldObj !== typeOfNewObj) {
    changes.push({ type: "REMOVE" /* REMOVE */, key: getKey(path), value: oldObj });
    if (typeOfNewObj !== "undefined") {
      changes.push({ type: "ADD" /* ADD */, key: getKey(path), value: newObj });
    }
    return changes;
  }
  if (typeOfNewObj === "undefined" && typeOfOldObj !== "undefined") {
    changes.push({ type: "REMOVE" /* REMOVE */, key: getKey(path), value: oldObj });
    return changes;
  }
  if (typeOfNewObj === "Object" && typeOfOldObj === "Array") {
    changes.push({ type: "UPDATE" /* UPDATE */, key: getKey(path), value: newObj, oldValue: oldObj });
    return changes;
  }
  switch (typeOfOldObj) {
    case "Date":
      changes = changes.concat(
        comparePrimitives(oldObj.getTime(), newObj.getTime(), path).map((x) => ({
          ...x,
          value: new Date(x.value),
          oldValue: new Date(x.oldValue)
        }))
      );
      break;
    case "Object": {
      const diffs = compareObject(oldObj, newObj, path, keyPath, false, options);
      if (diffs.length) {
        if (path.length) {
          changes.push({
            type: "UPDATE" /* UPDATE */,
            key: getKey(path),
            changes: diffs
          });
        } else {
          changes = changes.concat(diffs);
        }
      }
      break;
    }
    case "Array":
      changes = changes.concat(compareArray(oldObj, newObj, path, keyPath, options));
      break;
    case "Function":
      break;
    default:
      changes = changes.concat(comparePrimitives(oldObj, newObj, path));
  }
  return changes;
};
var compareObject = (oldObj, newObj, path, keyPath, skipPath = false, options = {}) => {
  let k;
  let newKeyPath;
  let newPath;
  if (skipPath == null) {
    skipPath = false;
  }
  let changes = [];
  const oldObjKeys = Object.keys(oldObj).filter((key) => options.keysToSkip.indexOf(key) === -1);
  const newObjKeys = Object.keys(newObj).filter((key) => options.keysToSkip.indexOf(key) === -1);
  const intersectionKeys = lodashExports.intersection(oldObjKeys, newObjKeys);
  for (k of intersectionKeys) {
    newPath = path.concat([k]);
    newKeyPath = skipPath ? keyPath : keyPath.concat([k]);
    const diffs = compare(oldObj[k], newObj[k], newPath, newKeyPath, options);
    if (diffs.length) {
      changes = changes.concat(diffs);
    }
  }
  const addedKeys = lodashExports.difference(newObjKeys, oldObjKeys);
  for (k of addedKeys) {
    newPath = path.concat([k]);
    newKeyPath = skipPath ? keyPath : keyPath.concat([k]);
    changes.push({
      type: "ADD" /* ADD */,
      key: getKey(newPath),
      value: newObj[k]
    });
  }
  const deletedKeys = lodashExports.difference(oldObjKeys, newObjKeys);
  for (k of deletedKeys) {
    newPath = path.concat([k]);
    newKeyPath = skipPath ? keyPath : keyPath.concat([k]);
    changes.push({
      type: "REMOVE" /* REMOVE */,
      key: getKey(newPath),
      value: oldObj[k]
    });
  }
  return changes;
};
var compareArray = (oldObj, newObj, path, keyPath, options) => {
  if (getTypeOfObj(newObj) !== "Array") {
    return [{ type: "UPDATE" /* UPDATE */, key: getKey(path), value: newObj, oldValue: oldObj }];
  }
  const left = getObjectKey(options.embeddedObjKeys, keyPath);
  const uniqKey = left != null ? left : "$index";
  const indexedOldObj = convertArrayToObj(oldObj, uniqKey);
  const indexedNewObj = convertArrayToObj(newObj, uniqKey);
  const diffs = compareObject(indexedOldObj, indexedNewObj, path, keyPath, true, options);
  if (diffs.length) {
    return [
      {
        type: "UPDATE" /* UPDATE */,
        key: getKey(path),
        embeddedKey: typeof uniqKey === "function" && uniqKey.length === 2 ? uniqKey(newObj[0], true) : uniqKey,
        changes: diffs
      }
    ];
  } else {
    return [];
  }
};
var getObjectKey = (embeddedObjKeys, keyPath) => {
  if (embeddedObjKeys != null) {
    const path = keyPath.join(".");
    if (embeddedObjKeys instanceof Map) {
      for (const [key2, value] of embeddedObjKeys.entries()) {
        if (key2 instanceof RegExp) {
          if (path.match(key2)) {
            return value;
          }
        } else if (path === key2) {
          return value;
        }
      }
    }
    const key = embeddedObjKeys[path];
    if (key != null) {
      return key;
    }
  }
  return void 0;
};
var convertArrayToObj = (arr, uniqKey) => {
  let obj = {};
  if (uniqKey === "$value") {
    arr.forEach((value) => {
      obj[value] = value;
    });
  } else if (uniqKey !== "$index") {
    obj = lodashExports.keyBy(arr, uniqKey);
  } else {
    for (let i = 0; i < arr.length; i++) {
      const value = arr[i];
      obj[i] = value;
    }
  }
  return obj;
};
var comparePrimitives = (oldObj, newObj, path) => {
  const changes = [];
  if (oldObj !== newObj) {
    changes.push({
      type: "UPDATE" /* UPDATE */,
      key: getKey(path),
      value: newObj,
      oldValue: oldObj
    });
  }
  return changes;
};
function append(basePath, nextSegment) {
  return nextSegment.includes(".") ? `${basePath}[${nextSegment}]` : `${basePath}.${nextSegment}`;
}
function filterExpression(basePath, filterKey, filterValue) {
  const value = typeof filterValue === "number" ? filterValue : `'${filterValue}'`;
  return typeof filterKey === "string" && filterKey.includes(".") ? `${basePath}[?(@[${filterKey}]==${value})]` : `${basePath}[?(@.${filterKey}==${value})]`;
}

/**
 * Byte sizes are taken from ECMAScript Language Specification
 * http://www.ecma-international.org/ecma-262/5.1/
 * http://bclary.com/2004/11/07/#a-4.3.16
 */

var byte_size;
var hasRequiredByte_size;

function requireByte_size () {
	if (hasRequiredByte_size) return byte_size;
	hasRequiredByte_size = 1;
	byte_size = {
	  STRING: 2,
	  BOOLEAN: 4,
	  BYTES: 4,
	  NUMBER: 8,
	  Int8Array: 1,
	  Uint8Array: 1,
	  Uint8ClampedArray: 1,
	  Int16Array: 2,
	  Uint16Array: 2,
	  Int32Array: 4,
	  Uint32Array: 4,
	  Float32Array: 4,
	  Float64Array: 8
	};
	return byte_size;
}

var buffer = {};

var base64Js = {};

var hasRequiredBase64Js;

function requireBase64Js () {
	if (hasRequiredBase64Js) return base64Js;
	hasRequiredBase64Js = 1;

	base64Js.byteLength = byteLength;
	base64Js.toByteArray = toByteArray;
	base64Js.fromByteArray = fromByteArray;

	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i];
	  revLookup[code.charCodeAt(i)] = i;
	}

	// Support decoding URL-safe base64 strings, as Node.js does.
	// See: https://en.wikipedia.org/wiki/Base64#URL_applications
	revLookup['-'.charCodeAt(0)] = 62;
	revLookup['_'.charCodeAt(0)] = 63;

	function getLens (b64) {
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // Trim off extra bytes after placeholder bytes are found
	  // See: https://github.com/beatgammit/base64-js/issues/42
	  var validLen = b64.indexOf('=');
	  if (validLen === -1) validLen = len;

	  var placeHoldersLen = validLen === len
	    ? 0
	    : 4 - (validLen % 4);

	  return [validLen, placeHoldersLen]
	}

	// base64 is 4/3 + up to two characters of the original data
	function byteLength (b64) {
	  var lens = getLens(b64);
	  var validLen = lens[0];
	  var placeHoldersLen = lens[1];
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}

	function _byteLength (b64, validLen, placeHoldersLen) {
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}

	function toByteArray (b64) {
	  var tmp;
	  var lens = getLens(b64);
	  var validLen = lens[0];
	  var placeHoldersLen = lens[1];

	  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

	  var curByte = 0;

	  // if there are placeholders, only get up to the last complete 4 chars
	  var len = placeHoldersLen > 0
	    ? validLen - 4
	    : validLen;

	  var i;
	  for (i = 0; i < len; i += 4) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 18) |
	      (revLookup[b64.charCodeAt(i + 1)] << 12) |
	      (revLookup[b64.charCodeAt(i + 2)] << 6) |
	      revLookup[b64.charCodeAt(i + 3)];
	    arr[curByte++] = (tmp >> 16) & 0xFF;
	    arr[curByte++] = (tmp >> 8) & 0xFF;
	    arr[curByte++] = tmp & 0xFF;
	  }

	  if (placeHoldersLen === 2) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 2) |
	      (revLookup[b64.charCodeAt(i + 1)] >> 4);
	    arr[curByte++] = tmp & 0xFF;
	  }

	  if (placeHoldersLen === 1) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 10) |
	      (revLookup[b64.charCodeAt(i + 1)] << 4) |
	      (revLookup[b64.charCodeAt(i + 2)] >> 2);
	    arr[curByte++] = (tmp >> 8) & 0xFF;
	    arr[curByte++] = tmp & 0xFF;
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] +
	    lookup[num >> 12 & 0x3F] +
	    lookup[num >> 6 & 0x3F] +
	    lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp =
	      ((uint8[i] << 16) & 0xFF0000) +
	      ((uint8[i + 1] << 8) & 0xFF00) +
	      (uint8[i + 2] & 0xFF);
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    parts.push(
	      lookup[tmp >> 2] +
	      lookup[(tmp << 4) & 0x3F] +
	      '=='
	    );
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
	    parts.push(
	      lookup[tmp >> 10] +
	      lookup[(tmp >> 4) & 0x3F] +
	      lookup[(tmp << 2) & 0x3F] +
	      '='
	    );
	  }

	  return parts.join('')
	}
	return base64Js;
}

var ieee754 = {};

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredIeee754;

function requireIeee754 () {
	if (hasRequiredIeee754) return ieee754;
	hasRequiredIeee754 = 1;
	ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = (nBytes * 8) - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	};

	ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = (nBytes * 8) - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = ((value * c) - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	};
	return ieee754;
}

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

var hasRequiredBuffer;

function requireBuffer () {
	if (hasRequiredBuffer) return buffer;
	hasRequiredBuffer = 1;
	(function (exports) {

		const base64 = requireBase64Js();
		const ieee754 = requireIeee754();
		const customInspectSymbol =
		  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
		    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
		    : null;

		exports.Buffer = Buffer;
		exports.SlowBuffer = SlowBuffer;
		exports.INSPECT_MAX_BYTES = 50;

		const K_MAX_LENGTH = 0x7fffffff;
		exports.kMaxLength = K_MAX_LENGTH;

		/**
		 * If `Buffer.TYPED_ARRAY_SUPPORT`:
		 *   === true    Use Uint8Array implementation (fastest)
		 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
		 *               implementation (most compatible, even IE6)
		 *
		 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
		 * Opera 11.6+, iOS 4.2+.
		 *
		 * We report that the browser does not support typed arrays if the are not subclassable
		 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
		 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
		 * for __proto__ and has a buggy typed array implementation.
		 */
		Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

		if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
		    typeof console.error === 'function') {
		  console.error(
		    'This browser lacks typed array (Uint8Array) support which is required by ' +
		    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
		  );
		}

		function typedArraySupport () {
		  // Can typed array instances can be augmented?
		  try {
		    const arr = new Uint8Array(1);
		    const proto = { foo: function () { return 42 } };
		    Object.setPrototypeOf(proto, Uint8Array.prototype);
		    Object.setPrototypeOf(arr, proto);
		    return arr.foo() === 42
		  } catch (e) {
		    return false
		  }
		}

		Object.defineProperty(Buffer.prototype, 'parent', {
		  enumerable: true,
		  get: function () {
		    if (!Buffer.isBuffer(this)) return undefined
		    return this.buffer
		  }
		});

		Object.defineProperty(Buffer.prototype, 'offset', {
		  enumerable: true,
		  get: function () {
		    if (!Buffer.isBuffer(this)) return undefined
		    return this.byteOffset
		  }
		});

		function createBuffer (length) {
		  if (length > K_MAX_LENGTH) {
		    throw new RangeError('The value "' + length + '" is invalid for option "size"')
		  }
		  // Return an augmented `Uint8Array` instance
		  const buf = new Uint8Array(length);
		  Object.setPrototypeOf(buf, Buffer.prototype);
		  return buf
		}

		/**
		 * The Buffer constructor returns instances of `Uint8Array` that have their
		 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
		 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
		 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
		 * returns a single octet.
		 *
		 * The `Uint8Array` prototype remains unmodified.
		 */

		function Buffer (arg, encodingOrOffset, length) {
		  // Common case.
		  if (typeof arg === 'number') {
		    if (typeof encodingOrOffset === 'string') {
		      throw new TypeError(
		        'The "string" argument must be of type string. Received type number'
		      )
		    }
		    return allocUnsafe(arg)
		  }
		  return from(arg, encodingOrOffset, length)
		}

		Buffer.poolSize = 8192; // not used by this implementation

		function from (value, encodingOrOffset, length) {
		  if (typeof value === 'string') {
		    return fromString(value, encodingOrOffset)
		  }

		  if (ArrayBuffer.isView(value)) {
		    return fromArrayView(value)
		  }

		  if (value == null) {
		    throw new TypeError(
		      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
		      'or Array-like Object. Received type ' + (typeof value)
		    )
		  }

		  if (isInstance(value, ArrayBuffer) ||
		      (value && isInstance(value.buffer, ArrayBuffer))) {
		    return fromArrayBuffer(value, encodingOrOffset, length)
		  }

		  if (typeof SharedArrayBuffer !== 'undefined' &&
		      (isInstance(value, SharedArrayBuffer) ||
		      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
		    return fromArrayBuffer(value, encodingOrOffset, length)
		  }

		  if (typeof value === 'number') {
		    throw new TypeError(
		      'The "value" argument must not be of type number. Received type number'
		    )
		  }

		  const valueOf = value.valueOf && value.valueOf();
		  if (valueOf != null && valueOf !== value) {
		    return Buffer.from(valueOf, encodingOrOffset, length)
		  }

		  const b = fromObject(value);
		  if (b) return b

		  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
		      typeof value[Symbol.toPrimitive] === 'function') {
		    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
		  }

		  throw new TypeError(
		    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
		    'or Array-like Object. Received type ' + (typeof value)
		  )
		}

		/**
		 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
		 * if value is a number.
		 * Buffer.from(str[, encoding])
		 * Buffer.from(array)
		 * Buffer.from(buffer)
		 * Buffer.from(arrayBuffer[, byteOffset[, length]])
		 **/
		Buffer.from = function (value, encodingOrOffset, length) {
		  return from(value, encodingOrOffset, length)
		};

		// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
		// https://github.com/feross/buffer/pull/148
		Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
		Object.setPrototypeOf(Buffer, Uint8Array);

		function assertSize (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('"size" argument must be of type number')
		  } else if (size < 0) {
		    throw new RangeError('The value "' + size + '" is invalid for option "size"')
		  }
		}

		function alloc (size, fill, encoding) {
		  assertSize(size);
		  if (size <= 0) {
		    return createBuffer(size)
		  }
		  if (fill !== undefined) {
		    // Only pay attention to encoding if it's a string. This
		    // prevents accidentally sending in a number that would
		    // be interpreted as a start offset.
		    return typeof encoding === 'string'
		      ? createBuffer(size).fill(fill, encoding)
		      : createBuffer(size).fill(fill)
		  }
		  return createBuffer(size)
		}

		/**
		 * Creates a new filled Buffer instance.
		 * alloc(size[, fill[, encoding]])
		 **/
		Buffer.alloc = function (size, fill, encoding) {
		  return alloc(size, fill, encoding)
		};

		function allocUnsafe (size) {
		  assertSize(size);
		  return createBuffer(size < 0 ? 0 : checked(size) | 0)
		}

		/**
		 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
		 * */
		Buffer.allocUnsafe = function (size) {
		  return allocUnsafe(size)
		};
		/**
		 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
		 */
		Buffer.allocUnsafeSlow = function (size) {
		  return allocUnsafe(size)
		};

		function fromString (string, encoding) {
		  if (typeof encoding !== 'string' || encoding === '') {
		    encoding = 'utf8';
		  }

		  if (!Buffer.isEncoding(encoding)) {
		    throw new TypeError('Unknown encoding: ' + encoding)
		  }

		  const length = byteLength(string, encoding) | 0;
		  let buf = createBuffer(length);

		  const actual = buf.write(string, encoding);

		  if (actual !== length) {
		    // Writing a hex string, for example, that contains invalid characters will
		    // cause everything after the first invalid character to be ignored. (e.g.
		    // 'abxxcd' will be treated as 'ab')
		    buf = buf.slice(0, actual);
		  }

		  return buf
		}

		function fromArrayLike (array) {
		  const length = array.length < 0 ? 0 : checked(array.length) | 0;
		  const buf = createBuffer(length);
		  for (let i = 0; i < length; i += 1) {
		    buf[i] = array[i] & 255;
		  }
		  return buf
		}

		function fromArrayView (arrayView) {
		  if (isInstance(arrayView, Uint8Array)) {
		    const copy = new Uint8Array(arrayView);
		    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
		  }
		  return fromArrayLike(arrayView)
		}

		function fromArrayBuffer (array, byteOffset, length) {
		  if (byteOffset < 0 || array.byteLength < byteOffset) {
		    throw new RangeError('"offset" is outside of buffer bounds')
		  }

		  if (array.byteLength < byteOffset + (length || 0)) {
		    throw new RangeError('"length" is outside of buffer bounds')
		  }

		  let buf;
		  if (byteOffset === undefined && length === undefined) {
		    buf = new Uint8Array(array);
		  } else if (length === undefined) {
		    buf = new Uint8Array(array, byteOffset);
		  } else {
		    buf = new Uint8Array(array, byteOffset, length);
		  }

		  // Return an augmented `Uint8Array` instance
		  Object.setPrototypeOf(buf, Buffer.prototype);

		  return buf
		}

		function fromObject (obj) {
		  if (Buffer.isBuffer(obj)) {
		    const len = checked(obj.length) | 0;
		    const buf = createBuffer(len);

		    if (buf.length === 0) {
		      return buf
		    }

		    obj.copy(buf, 0, 0, len);
		    return buf
		  }

		  if (obj.length !== undefined) {
		    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
		      return createBuffer(0)
		    }
		    return fromArrayLike(obj)
		  }

		  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
		    return fromArrayLike(obj.data)
		  }
		}

		function checked (length) {
		  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
		  // length is NaN (which is otherwise coerced to zero.)
		  if (length >= K_MAX_LENGTH) {
		    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
		                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
		  }
		  return length | 0
		}

		function SlowBuffer (length) {
		  if (+length != length) { // eslint-disable-line eqeqeq
		    length = 0;
		  }
		  return Buffer.alloc(+length)
		}

		Buffer.isBuffer = function isBuffer (b) {
		  return b != null && b._isBuffer === true &&
		    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
		};

		Buffer.compare = function compare (a, b) {
		  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
		  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
		  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
		    throw new TypeError(
		      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
		    )
		  }

		  if (a === b) return 0

		  let x = a.length;
		  let y = b.length;

		  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
		    if (a[i] !== b[i]) {
		      x = a[i];
		      y = b[i];
		      break
		    }
		  }

		  if (x < y) return -1
		  if (y < x) return 1
		  return 0
		};

		Buffer.isEncoding = function isEncoding (encoding) {
		  switch (String(encoding).toLowerCase()) {
		    case 'hex':
		    case 'utf8':
		    case 'utf-8':
		    case 'ascii':
		    case 'latin1':
		    case 'binary':
		    case 'base64':
		    case 'ucs2':
		    case 'ucs-2':
		    case 'utf16le':
		    case 'utf-16le':
		      return true
		    default:
		      return false
		  }
		};

		Buffer.concat = function concat (list, length) {
		  if (!Array.isArray(list)) {
		    throw new TypeError('"list" argument must be an Array of Buffers')
		  }

		  if (list.length === 0) {
		    return Buffer.alloc(0)
		  }

		  let i;
		  if (length === undefined) {
		    length = 0;
		    for (i = 0; i < list.length; ++i) {
		      length += list[i].length;
		    }
		  }

		  const buffer = Buffer.allocUnsafe(length);
		  let pos = 0;
		  for (i = 0; i < list.length; ++i) {
		    let buf = list[i];
		    if (isInstance(buf, Uint8Array)) {
		      if (pos + buf.length > buffer.length) {
		        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
		        buf.copy(buffer, pos);
		      } else {
		        Uint8Array.prototype.set.call(
		          buffer,
		          buf,
		          pos
		        );
		      }
		    } else if (!Buffer.isBuffer(buf)) {
		      throw new TypeError('"list" argument must be an Array of Buffers')
		    } else {
		      buf.copy(buffer, pos);
		    }
		    pos += buf.length;
		  }
		  return buffer
		};

		function byteLength (string, encoding) {
		  if (Buffer.isBuffer(string)) {
		    return string.length
		  }
		  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
		    return string.byteLength
		  }
		  if (typeof string !== 'string') {
		    throw new TypeError(
		      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
		      'Received type ' + typeof string
		    )
		  }

		  const len = string.length;
		  const mustMatch = (arguments.length > 2 && arguments[2] === true);
		  if (!mustMatch && len === 0) return 0

		  // Use a for loop to avoid recursion
		  let loweredCase = false;
		  for (;;) {
		    switch (encoding) {
		      case 'ascii':
		      case 'latin1':
		      case 'binary':
		        return len
		      case 'utf8':
		      case 'utf-8':
		        return utf8ToBytes(string).length
		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return len * 2
		      case 'hex':
		        return len >>> 1
		      case 'base64':
		        return base64ToBytes(string).length
		      default:
		        if (loweredCase) {
		          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
		        }
		        encoding = ('' + encoding).toLowerCase();
		        loweredCase = true;
		    }
		  }
		}
		Buffer.byteLength = byteLength;

		function slowToString (encoding, start, end) {
		  let loweredCase = false;

		  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
		  // property of a typed array.

		  // This behaves neither like String nor Uint8Array in that we set start/end
		  // to their upper/lower bounds if the value passed is out of range.
		  // undefined is handled specially as per ECMA-262 6th Edition,
		  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
		  if (start === undefined || start < 0) {
		    start = 0;
		  }
		  // Return early if start > this.length. Done here to prevent potential uint32
		  // coercion fail below.
		  if (start > this.length) {
		    return ''
		  }

		  if (end === undefined || end > this.length) {
		    end = this.length;
		  }

		  if (end <= 0) {
		    return ''
		  }

		  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
		  end >>>= 0;
		  start >>>= 0;

		  if (end <= start) {
		    return ''
		  }

		  if (!encoding) encoding = 'utf8';

		  while (true) {
		    switch (encoding) {
		      case 'hex':
		        return hexSlice(this, start, end)

		      case 'utf8':
		      case 'utf-8':
		        return utf8Slice(this, start, end)

		      case 'ascii':
		        return asciiSlice(this, start, end)

		      case 'latin1':
		      case 'binary':
		        return latin1Slice(this, start, end)

		      case 'base64':
		        return base64Slice(this, start, end)

		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return utf16leSlice(this, start, end)

		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = (encoding + '').toLowerCase();
		        loweredCase = true;
		    }
		  }
		}

		// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
		// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
		// reliably in a browserify context because there could be multiple different
		// copies of the 'buffer' package in use. This method works even for Buffer
		// instances that were created from another copy of the `buffer` package.
		// See: https://github.com/feross/buffer/issues/154
		Buffer.prototype._isBuffer = true;

		function swap (b, n, m) {
		  const i = b[n];
		  b[n] = b[m];
		  b[m] = i;
		}

		Buffer.prototype.swap16 = function swap16 () {
		  const len = this.length;
		  if (len % 2 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 16-bits')
		  }
		  for (let i = 0; i < len; i += 2) {
		    swap(this, i, i + 1);
		  }
		  return this
		};

		Buffer.prototype.swap32 = function swap32 () {
		  const len = this.length;
		  if (len % 4 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 32-bits')
		  }
		  for (let i = 0; i < len; i += 4) {
		    swap(this, i, i + 3);
		    swap(this, i + 1, i + 2);
		  }
		  return this
		};

		Buffer.prototype.swap64 = function swap64 () {
		  const len = this.length;
		  if (len % 8 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 64-bits')
		  }
		  for (let i = 0; i < len; i += 8) {
		    swap(this, i, i + 7);
		    swap(this, i + 1, i + 6);
		    swap(this, i + 2, i + 5);
		    swap(this, i + 3, i + 4);
		  }
		  return this
		};

		Buffer.prototype.toString = function toString () {
		  const length = this.length;
		  if (length === 0) return ''
		  if (arguments.length === 0) return utf8Slice(this, 0, length)
		  return slowToString.apply(this, arguments)
		};

		Buffer.prototype.toLocaleString = Buffer.prototype.toString;

		Buffer.prototype.equals = function equals (b) {
		  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
		  if (this === b) return true
		  return Buffer.compare(this, b) === 0
		};

		Buffer.prototype.inspect = function inspect () {
		  let str = '';
		  const max = exports.INSPECT_MAX_BYTES;
		  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
		  if (this.length > max) str += ' ... ';
		  return '<Buffer ' + str + '>'
		};
		if (customInspectSymbol) {
		  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
		}

		Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
		  if (isInstance(target, Uint8Array)) {
		    target = Buffer.from(target, target.offset, target.byteLength);
		  }
		  if (!Buffer.isBuffer(target)) {
		    throw new TypeError(
		      'The "target" argument must be one of type Buffer or Uint8Array. ' +
		      'Received type ' + (typeof target)
		    )
		  }

		  if (start === undefined) {
		    start = 0;
		  }
		  if (end === undefined) {
		    end = target ? target.length : 0;
		  }
		  if (thisStart === undefined) {
		    thisStart = 0;
		  }
		  if (thisEnd === undefined) {
		    thisEnd = this.length;
		  }

		  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
		    throw new RangeError('out of range index')
		  }

		  if (thisStart >= thisEnd && start >= end) {
		    return 0
		  }
		  if (thisStart >= thisEnd) {
		    return -1
		  }
		  if (start >= end) {
		    return 1
		  }

		  start >>>= 0;
		  end >>>= 0;
		  thisStart >>>= 0;
		  thisEnd >>>= 0;

		  if (this === target) return 0

		  let x = thisEnd - thisStart;
		  let y = end - start;
		  const len = Math.min(x, y);

		  const thisCopy = this.slice(thisStart, thisEnd);
		  const targetCopy = target.slice(start, end);

		  for (let i = 0; i < len; ++i) {
		    if (thisCopy[i] !== targetCopy[i]) {
		      x = thisCopy[i];
		      y = targetCopy[i];
		      break
		    }
		  }

		  if (x < y) return -1
		  if (y < x) return 1
		  return 0
		};

		// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
		// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
		//
		// Arguments:
		// - buffer - a Buffer to search
		// - val - a string, Buffer, or number
		// - byteOffset - an index into `buffer`; will be clamped to an int32
		// - encoding - an optional encoding, relevant is val is a string
		// - dir - true for indexOf, false for lastIndexOf
		function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
		  // Empty buffer means no match
		  if (buffer.length === 0) return -1

		  // Normalize byteOffset
		  if (typeof byteOffset === 'string') {
		    encoding = byteOffset;
		    byteOffset = 0;
		  } else if (byteOffset > 0x7fffffff) {
		    byteOffset = 0x7fffffff;
		  } else if (byteOffset < -0x80000000) {
		    byteOffset = -0x80000000;
		  }
		  byteOffset = +byteOffset; // Coerce to Number.
		  if (numberIsNaN(byteOffset)) {
		    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
		    byteOffset = dir ? 0 : (buffer.length - 1);
		  }

		  // Normalize byteOffset: negative offsets start from the end of the buffer
		  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
		  if (byteOffset >= buffer.length) {
		    if (dir) return -1
		    else byteOffset = buffer.length - 1;
		  } else if (byteOffset < 0) {
		    if (dir) byteOffset = 0;
		    else return -1
		  }

		  // Normalize val
		  if (typeof val === 'string') {
		    val = Buffer.from(val, encoding);
		  }

		  // Finally, search either indexOf (if dir is true) or lastIndexOf
		  if (Buffer.isBuffer(val)) {
		    // Special case: looking for empty string/buffer always fails
		    if (val.length === 0) {
		      return -1
		    }
		    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
		  } else if (typeof val === 'number') {
		    val = val & 0xFF; // Search for a byte value [0-255]
		    if (typeof Uint8Array.prototype.indexOf === 'function') {
		      if (dir) {
		        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
		      } else {
		        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
		      }
		    }
		    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
		  }

		  throw new TypeError('val must be string, number or Buffer')
		}

		function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
		  let indexSize = 1;
		  let arrLength = arr.length;
		  let valLength = val.length;

		  if (encoding !== undefined) {
		    encoding = String(encoding).toLowerCase();
		    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
		        encoding === 'utf16le' || encoding === 'utf-16le') {
		      if (arr.length < 2 || val.length < 2) {
		        return -1
		      }
		      indexSize = 2;
		      arrLength /= 2;
		      valLength /= 2;
		      byteOffset /= 2;
		    }
		  }

		  function read (buf, i) {
		    if (indexSize === 1) {
		      return buf[i]
		    } else {
		      return buf.readUInt16BE(i * indexSize)
		    }
		  }

		  let i;
		  if (dir) {
		    let foundIndex = -1;
		    for (i = byteOffset; i < arrLength; i++) {
		      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
		        if (foundIndex === -1) foundIndex = i;
		        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
		      } else {
		        if (foundIndex !== -1) i -= i - foundIndex;
		        foundIndex = -1;
		      }
		    }
		  } else {
		    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
		    for (i = byteOffset; i >= 0; i--) {
		      let found = true;
		      for (let j = 0; j < valLength; j++) {
		        if (read(arr, i + j) !== read(val, j)) {
		          found = false;
		          break
		        }
		      }
		      if (found) return i
		    }
		  }

		  return -1
		}

		Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
		  return this.indexOf(val, byteOffset, encoding) !== -1
		};

		Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
		  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
		};

		Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
		  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
		};

		function hexWrite (buf, string, offset, length) {
		  offset = Number(offset) || 0;
		  const remaining = buf.length - offset;
		  if (!length) {
		    length = remaining;
		  } else {
		    length = Number(length);
		    if (length > remaining) {
		      length = remaining;
		    }
		  }

		  const strLen = string.length;

		  if (length > strLen / 2) {
		    length = strLen / 2;
		  }
		  let i;
		  for (i = 0; i < length; ++i) {
		    const parsed = parseInt(string.substr(i * 2, 2), 16);
		    if (numberIsNaN(parsed)) return i
		    buf[offset + i] = parsed;
		  }
		  return i
		}

		function utf8Write (buf, string, offset, length) {
		  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
		}

		function asciiWrite (buf, string, offset, length) {
		  return blitBuffer(asciiToBytes(string), buf, offset, length)
		}

		function base64Write (buf, string, offset, length) {
		  return blitBuffer(base64ToBytes(string), buf, offset, length)
		}

		function ucs2Write (buf, string, offset, length) {
		  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
		}

		Buffer.prototype.write = function write (string, offset, length, encoding) {
		  // Buffer#write(string)
		  if (offset === undefined) {
		    encoding = 'utf8';
		    length = this.length;
		    offset = 0;
		  // Buffer#write(string, encoding)
		  } else if (length === undefined && typeof offset === 'string') {
		    encoding = offset;
		    length = this.length;
		    offset = 0;
		  // Buffer#write(string, offset[, length][, encoding])
		  } else if (isFinite(offset)) {
		    offset = offset >>> 0;
		    if (isFinite(length)) {
		      length = length >>> 0;
		      if (encoding === undefined) encoding = 'utf8';
		    } else {
		      encoding = length;
		      length = undefined;
		    }
		  } else {
		    throw new Error(
		      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
		    )
		  }

		  const remaining = this.length - offset;
		  if (length === undefined || length > remaining) length = remaining;

		  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
		    throw new RangeError('Attempt to write outside buffer bounds')
		  }

		  if (!encoding) encoding = 'utf8';

		  let loweredCase = false;
		  for (;;) {
		    switch (encoding) {
		      case 'hex':
		        return hexWrite(this, string, offset, length)

		      case 'utf8':
		      case 'utf-8':
		        return utf8Write(this, string, offset, length)

		      case 'ascii':
		      case 'latin1':
		      case 'binary':
		        return asciiWrite(this, string, offset, length)

		      case 'base64':
		        // Warning: maxLength not taken into account in base64Write
		        return base64Write(this, string, offset, length)

		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return ucs2Write(this, string, offset, length)

		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = ('' + encoding).toLowerCase();
		        loweredCase = true;
		    }
		  }
		};

		Buffer.prototype.toJSON = function toJSON () {
		  return {
		    type: 'Buffer',
		    data: Array.prototype.slice.call(this._arr || this, 0)
		  }
		};

		function base64Slice (buf, start, end) {
		  if (start === 0 && end === buf.length) {
		    return base64.fromByteArray(buf)
		  } else {
		    return base64.fromByteArray(buf.slice(start, end))
		  }
		}

		function utf8Slice (buf, start, end) {
		  end = Math.min(buf.length, end);
		  const res = [];

		  let i = start;
		  while (i < end) {
		    const firstByte = buf[i];
		    let codePoint = null;
		    let bytesPerSequence = (firstByte > 0xEF)
		      ? 4
		      : (firstByte > 0xDF)
		          ? 3
		          : (firstByte > 0xBF)
		              ? 2
		              : 1;

		    if (i + bytesPerSequence <= end) {
		      let secondByte, thirdByte, fourthByte, tempCodePoint;

		      switch (bytesPerSequence) {
		        case 1:
		          if (firstByte < 0x80) {
		            codePoint = firstByte;
		          }
		          break
		        case 2:
		          secondByte = buf[i + 1];
		          if ((secondByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
		            if (tempCodePoint > 0x7F) {
		              codePoint = tempCodePoint;
		            }
		          }
		          break
		        case 3:
		          secondByte = buf[i + 1];
		          thirdByte = buf[i + 2];
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
		            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
		              codePoint = tempCodePoint;
		            }
		          }
		          break
		        case 4:
		          secondByte = buf[i + 1];
		          thirdByte = buf[i + 2];
		          fourthByte = buf[i + 3];
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
		            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
		              codePoint = tempCodePoint;
		            }
		          }
		      }
		    }

		    if (codePoint === null) {
		      // we did not generate a valid codePoint so insert a
		      // replacement char (U+FFFD) and advance only 1 byte
		      codePoint = 0xFFFD;
		      bytesPerSequence = 1;
		    } else if (codePoint > 0xFFFF) {
		      // encode to utf16 (surrogate pair dance)
		      codePoint -= 0x10000;
		      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
		      codePoint = 0xDC00 | codePoint & 0x3FF;
		    }

		    res.push(codePoint);
		    i += bytesPerSequence;
		  }

		  return decodeCodePointsArray(res)
		}

		// Based on http://stackoverflow.com/a/22747272/680742, the browser with
		// the lowest limit is Chrome, with 0x10000 args.
		// We go 1 magnitude less, for safety
		const MAX_ARGUMENTS_LENGTH = 0x1000;

		function decodeCodePointsArray (codePoints) {
		  const len = codePoints.length;
		  if (len <= MAX_ARGUMENTS_LENGTH) {
		    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
		  }

		  // Decode in chunks to avoid "call stack size exceeded".
		  let res = '';
		  let i = 0;
		  while (i < len) {
		    res += String.fromCharCode.apply(
		      String,
		      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
		    );
		  }
		  return res
		}

		function asciiSlice (buf, start, end) {
		  let ret = '';
		  end = Math.min(buf.length, end);

		  for (let i = start; i < end; ++i) {
		    ret += String.fromCharCode(buf[i] & 0x7F);
		  }
		  return ret
		}

		function latin1Slice (buf, start, end) {
		  let ret = '';
		  end = Math.min(buf.length, end);

		  for (let i = start; i < end; ++i) {
		    ret += String.fromCharCode(buf[i]);
		  }
		  return ret
		}

		function hexSlice (buf, start, end) {
		  const len = buf.length;

		  if (!start || start < 0) start = 0;
		  if (!end || end < 0 || end > len) end = len;

		  let out = '';
		  for (let i = start; i < end; ++i) {
		    out += hexSliceLookupTable[buf[i]];
		  }
		  return out
		}

		function utf16leSlice (buf, start, end) {
		  const bytes = buf.slice(start, end);
		  let res = '';
		  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
		  for (let i = 0; i < bytes.length - 1; i += 2) {
		    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
		  }
		  return res
		}

		Buffer.prototype.slice = function slice (start, end) {
		  const len = this.length;
		  start = ~~start;
		  end = end === undefined ? len : ~~end;

		  if (start < 0) {
		    start += len;
		    if (start < 0) start = 0;
		  } else if (start > len) {
		    start = len;
		  }

		  if (end < 0) {
		    end += len;
		    if (end < 0) end = 0;
		  } else if (end > len) {
		    end = len;
		  }

		  if (end < start) end = start;

		  const newBuf = this.subarray(start, end);
		  // Return an augmented `Uint8Array` instance
		  Object.setPrototypeOf(newBuf, Buffer.prototype);

		  return newBuf
		};

		/*
		 * Need to make sure that buffer isn't trying to write out of bounds.
		 */
		function checkOffset (offset, ext, length) {
		  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
		  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
		}

		Buffer.prototype.readUintLE =
		Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) checkOffset(offset, byteLength, this.length);

		  let val = this[offset];
		  let mul = 1;
		  let i = 0;
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul;
		  }

		  return val
		};

		Buffer.prototype.readUintBE =
		Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) {
		    checkOffset(offset, byteLength, this.length);
		  }

		  let val = this[offset + --byteLength];
		  let mul = 1;
		  while (byteLength > 0 && (mul *= 0x100)) {
		    val += this[offset + --byteLength] * mul;
		  }

		  return val
		};

		Buffer.prototype.readUint8 =
		Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 1, this.length);
		  return this[offset]
		};

		Buffer.prototype.readUint16LE =
		Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  return this[offset] | (this[offset + 1] << 8)
		};

		Buffer.prototype.readUint16BE =
		Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  return (this[offset] << 8) | this[offset + 1]
		};

		Buffer.prototype.readUint32LE =
		Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return ((this[offset]) |
		      (this[offset + 1] << 8) |
		      (this[offset + 2] << 16)) +
		      (this[offset + 3] * 0x1000000)
		};

		Buffer.prototype.readUint32BE =
		Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return (this[offset] * 0x1000000) +
		    ((this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    this[offset + 3])
		};

		Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
		  offset = offset >>> 0;
		  validateNumber(offset, 'offset');
		  const first = this[offset];
		  const last = this[offset + 7];
		  if (first === undefined || last === undefined) {
		    boundsError(offset, this.length - 8);
		  }

		  const lo = first +
		    this[++offset] * 2 ** 8 +
		    this[++offset] * 2 ** 16 +
		    this[++offset] * 2 ** 24;

		  const hi = this[++offset] +
		    this[++offset] * 2 ** 8 +
		    this[++offset] * 2 ** 16 +
		    last * 2 ** 24;

		  return BigInt(lo) + (BigInt(hi) << BigInt(32))
		});

		Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
		  offset = offset >>> 0;
		  validateNumber(offset, 'offset');
		  const first = this[offset];
		  const last = this[offset + 7];
		  if (first === undefined || last === undefined) {
		    boundsError(offset, this.length - 8);
		  }

		  const hi = first * 2 ** 24 +
		    this[++offset] * 2 ** 16 +
		    this[++offset] * 2 ** 8 +
		    this[++offset];

		  const lo = this[++offset] * 2 ** 24 +
		    this[++offset] * 2 ** 16 +
		    this[++offset] * 2 ** 8 +
		    last;

		  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
		});

		Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) checkOffset(offset, byteLength, this.length);

		  let val = this[offset];
		  let mul = 1;
		  let i = 0;
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul;
		  }
		  mul *= 0x80;

		  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

		  return val
		};

		Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) checkOffset(offset, byteLength, this.length);

		  let i = byteLength;
		  let mul = 1;
		  let val = this[offset + --i];
		  while (i > 0 && (mul *= 0x100)) {
		    val += this[offset + --i] * mul;
		  }
		  mul *= 0x80;

		  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

		  return val
		};

		Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 1, this.length);
		  if (!(this[offset] & 0x80)) return (this[offset])
		  return ((0xff - this[offset] + 1) * -1)
		};

		Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  const val = this[offset] | (this[offset + 1] << 8);
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		};

		Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  const val = this[offset + 1] | (this[offset] << 8);
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		};

		Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return (this[offset]) |
		    (this[offset + 1] << 8) |
		    (this[offset + 2] << 16) |
		    (this[offset + 3] << 24)
		};

		Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return (this[offset] << 24) |
		    (this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    (this[offset + 3])
		};

		Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
		  offset = offset >>> 0;
		  validateNumber(offset, 'offset');
		  const first = this[offset];
		  const last = this[offset + 7];
		  if (first === undefined || last === undefined) {
		    boundsError(offset, this.length - 8);
		  }

		  const val = this[offset + 4] +
		    this[offset + 5] * 2 ** 8 +
		    this[offset + 6] * 2 ** 16 +
		    (last << 24); // Overflow

		  return (BigInt(val) << BigInt(32)) +
		    BigInt(first +
		    this[++offset] * 2 ** 8 +
		    this[++offset] * 2 ** 16 +
		    this[++offset] * 2 ** 24)
		});

		Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
		  offset = offset >>> 0;
		  validateNumber(offset, 'offset');
		  const first = this[offset];
		  const last = this[offset + 7];
		  if (first === undefined || last === undefined) {
		    boundsError(offset, this.length - 8);
		  }

		  const val = (first << 24) + // Overflow
		    this[++offset] * 2 ** 16 +
		    this[++offset] * 2 ** 8 +
		    this[++offset];

		  return (BigInt(val) << BigInt(32)) +
		    BigInt(this[++offset] * 2 ** 24 +
		    this[++offset] * 2 ** 16 +
		    this[++offset] * 2 ** 8 +
		    last)
		});

		Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);
		  return ieee754.read(this, offset, true, 23, 4)
		};

		Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);
		  return ieee754.read(this, offset, false, 23, 4)
		};

		Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 8, this.length);
		  return ieee754.read(this, offset, true, 52, 8)
		};

		Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 8, this.length);
		  return ieee754.read(this, offset, false, 52, 8)
		};

		function checkInt (buf, value, offset, ext, max, min) {
		  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
		  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
		  if (offset + ext > buf.length) throw new RangeError('Index out of range')
		}

		Buffer.prototype.writeUintLE =
		Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) {
		    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
		    checkInt(this, value, offset, byteLength, maxBytes, 0);
		  }

		  let mul = 1;
		  let i = 0;
		  this[offset] = value & 0xFF;
		  while (++i < byteLength && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeUintBE =
		Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) {
		    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
		    checkInt(this, value, offset, byteLength, maxBytes, 0);
		  }

		  let i = byteLength - 1;
		  let mul = 1;
		  this[offset + i] = value & 0xFF;
		  while (--i >= 0 && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeUint8 =
		Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
		  this[offset] = (value & 0xff);
		  return offset + 1
		};

		Buffer.prototype.writeUint16LE =
		Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
		  this[offset] = (value & 0xff);
		  this[offset + 1] = (value >>> 8);
		  return offset + 2
		};

		Buffer.prototype.writeUint16BE =
		Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
		  this[offset] = (value >>> 8);
		  this[offset + 1] = (value & 0xff);
		  return offset + 2
		};

		Buffer.prototype.writeUint32LE =
		Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
		  this[offset + 3] = (value >>> 24);
		  this[offset + 2] = (value >>> 16);
		  this[offset + 1] = (value >>> 8);
		  this[offset] = (value & 0xff);
		  return offset + 4
		};

		Buffer.prototype.writeUint32BE =
		Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
		  this[offset] = (value >>> 24);
		  this[offset + 1] = (value >>> 16);
		  this[offset + 2] = (value >>> 8);
		  this[offset + 3] = (value & 0xff);
		  return offset + 4
		};

		function wrtBigUInt64LE (buf, value, offset, min, max) {
		  checkIntBI(value, min, max, buf, offset, 7);

		  let lo = Number(value & BigInt(0xffffffff));
		  buf[offset++] = lo;
		  lo = lo >> 8;
		  buf[offset++] = lo;
		  lo = lo >> 8;
		  buf[offset++] = lo;
		  lo = lo >> 8;
		  buf[offset++] = lo;
		  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
		  buf[offset++] = hi;
		  hi = hi >> 8;
		  buf[offset++] = hi;
		  hi = hi >> 8;
		  buf[offset++] = hi;
		  hi = hi >> 8;
		  buf[offset++] = hi;
		  return offset
		}

		function wrtBigUInt64BE (buf, value, offset, min, max) {
		  checkIntBI(value, min, max, buf, offset, 7);

		  let lo = Number(value & BigInt(0xffffffff));
		  buf[offset + 7] = lo;
		  lo = lo >> 8;
		  buf[offset + 6] = lo;
		  lo = lo >> 8;
		  buf[offset + 5] = lo;
		  lo = lo >> 8;
		  buf[offset + 4] = lo;
		  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
		  buf[offset + 3] = hi;
		  hi = hi >> 8;
		  buf[offset + 2] = hi;
		  hi = hi >> 8;
		  buf[offset + 1] = hi;
		  hi = hi >> 8;
		  buf[offset] = hi;
		  return offset + 8
		}

		Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
		  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
		});

		Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
		  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
		});

		Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    const limit = Math.pow(2, (8 * byteLength) - 1);

		    checkInt(this, value, offset, byteLength, limit - 1, -limit);
		  }

		  let i = 0;
		  let mul = 1;
		  let sub = 0;
		  this[offset] = value & 0xFF;
		  while (++i < byteLength && (mul *= 0x100)) {
		    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
		      sub = 1;
		    }
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    const limit = Math.pow(2, (8 * byteLength) - 1);

		    checkInt(this, value, offset, byteLength, limit - 1, -limit);
		  }

		  let i = byteLength - 1;
		  let mul = 1;
		  let sub = 0;
		  this[offset + i] = value & 0xFF;
		  while (--i >= 0 && (mul *= 0x100)) {
		    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
		      sub = 1;
		    }
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
		  if (value < 0) value = 0xff + value + 1;
		  this[offset] = (value & 0xff);
		  return offset + 1
		};

		Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
		  this[offset] = (value & 0xff);
		  this[offset + 1] = (value >>> 8);
		  return offset + 2
		};

		Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
		  this[offset] = (value >>> 8);
		  this[offset + 1] = (value & 0xff);
		  return offset + 2
		};

		Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
		  this[offset] = (value & 0xff);
		  this[offset + 1] = (value >>> 8);
		  this[offset + 2] = (value >>> 16);
		  this[offset + 3] = (value >>> 24);
		  return offset + 4
		};

		Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
		  if (value < 0) value = 0xffffffff + value + 1;
		  this[offset] = (value >>> 24);
		  this[offset + 1] = (value >>> 16);
		  this[offset + 2] = (value >>> 8);
		  this[offset + 3] = (value & 0xff);
		  return offset + 4
		};

		Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
		  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
		});

		Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
		  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
		});

		function checkIEEE754 (buf, value, offset, ext, max, min) {
		  if (offset + ext > buf.length) throw new RangeError('Index out of range')
		  if (offset < 0) throw new RangeError('Index out of range')
		}

		function writeFloat (buf, value, offset, littleEndian, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 4);
		  }
		  ieee754.write(buf, value, offset, littleEndian, 23, 4);
		  return offset + 4
		}

		Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, true, noAssert)
		};

		Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, false, noAssert)
		};

		function writeDouble (buf, value, offset, littleEndian, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 8);
		  }
		  ieee754.write(buf, value, offset, littleEndian, 52, 8);
		  return offset + 8
		}

		Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, true, noAssert)
		};

		Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, false, noAssert)
		};

		// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
		Buffer.prototype.copy = function copy (target, targetStart, start, end) {
		  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
		  if (!start) start = 0;
		  if (!end && end !== 0) end = this.length;
		  if (targetStart >= target.length) targetStart = target.length;
		  if (!targetStart) targetStart = 0;
		  if (end > 0 && end < start) end = start;

		  // Copy 0 bytes; we're done
		  if (end === start) return 0
		  if (target.length === 0 || this.length === 0) return 0

		  // Fatal error conditions
		  if (targetStart < 0) {
		    throw new RangeError('targetStart out of bounds')
		  }
		  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
		  if (end < 0) throw new RangeError('sourceEnd out of bounds')

		  // Are we oob?
		  if (end > this.length) end = this.length;
		  if (target.length - targetStart < end - start) {
		    end = target.length - targetStart + start;
		  }

		  const len = end - start;

		  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
		    // Use built-in when available, missing from IE11
		    this.copyWithin(targetStart, start, end);
		  } else {
		    Uint8Array.prototype.set.call(
		      target,
		      this.subarray(start, end),
		      targetStart
		    );
		  }

		  return len
		};

		// Usage:
		//    buffer.fill(number[, offset[, end]])
		//    buffer.fill(buffer[, offset[, end]])
		//    buffer.fill(string[, offset[, end]][, encoding])
		Buffer.prototype.fill = function fill (val, start, end, encoding) {
		  // Handle string cases:
		  if (typeof val === 'string') {
		    if (typeof start === 'string') {
		      encoding = start;
		      start = 0;
		      end = this.length;
		    } else if (typeof end === 'string') {
		      encoding = end;
		      end = this.length;
		    }
		    if (encoding !== undefined && typeof encoding !== 'string') {
		      throw new TypeError('encoding must be a string')
		    }
		    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
		      throw new TypeError('Unknown encoding: ' + encoding)
		    }
		    if (val.length === 1) {
		      const code = val.charCodeAt(0);
		      if ((encoding === 'utf8' && code < 128) ||
		          encoding === 'latin1') {
		        // Fast path: If `val` fits into a single byte, use that numeric value.
		        val = code;
		      }
		    }
		  } else if (typeof val === 'number') {
		    val = val & 255;
		  } else if (typeof val === 'boolean') {
		    val = Number(val);
		  }

		  // Invalid ranges are not set to a default, so can range check early.
		  if (start < 0 || this.length < start || this.length < end) {
		    throw new RangeError('Out of range index')
		  }

		  if (end <= start) {
		    return this
		  }

		  start = start >>> 0;
		  end = end === undefined ? this.length : end >>> 0;

		  if (!val) val = 0;

		  let i;
		  if (typeof val === 'number') {
		    for (i = start; i < end; ++i) {
		      this[i] = val;
		    }
		  } else {
		    const bytes = Buffer.isBuffer(val)
		      ? val
		      : Buffer.from(val, encoding);
		    const len = bytes.length;
		    if (len === 0) {
		      throw new TypeError('The value "' + val +
		        '" is invalid for argument "value"')
		    }
		    for (i = 0; i < end - start; ++i) {
		      this[i + start] = bytes[i % len];
		    }
		  }

		  return this
		};

		// CUSTOM ERRORS
		// =============

		// Simplified versions from Node, changed for Buffer-only usage
		const errors = {};
		function E (sym, getMessage, Base) {
		  errors[sym] = class NodeError extends Base {
		    constructor () {
		      super();

		      Object.defineProperty(this, 'message', {
		        value: getMessage.apply(this, arguments),
		        writable: true,
		        configurable: true
		      });

		      // Add the error code to the name to include it in the stack trace.
		      this.name = `${this.name} [${sym}]`;
		      // Access the stack to generate the error message including the error code
		      // from the name.
		      this.stack; // eslint-disable-line no-unused-expressions
		      // Reset the name to the actual name.
		      delete this.name;
		    }

		    get code () {
		      return sym
		    }

		    set code (value) {
		      Object.defineProperty(this, 'code', {
		        configurable: true,
		        enumerable: true,
		        value,
		        writable: true
		      });
		    }

		    toString () {
		      return `${this.name} [${sym}]: ${this.message}`
		    }
		  };
		}

		E('ERR_BUFFER_OUT_OF_BOUNDS',
		  function (name) {
		    if (name) {
		      return `${name} is outside of buffer bounds`
		    }

		    return 'Attempt to access memory outside buffer bounds'
		  }, RangeError);
		E('ERR_INVALID_ARG_TYPE',
		  function (name, actual) {
		    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
		  }, TypeError);
		E('ERR_OUT_OF_RANGE',
		  function (str, range, input) {
		    let msg = `The value of "${str}" is out of range.`;
		    let received = input;
		    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
		      received = addNumericalSeparator(String(input));
		    } else if (typeof input === 'bigint') {
		      received = String(input);
		      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
		        received = addNumericalSeparator(received);
		      }
		      received += 'n';
		    }
		    msg += ` It must be ${range}. Received ${received}`;
		    return msg
		  }, RangeError);

		function addNumericalSeparator (val) {
		  let res = '';
		  let i = val.length;
		  const start = val[0] === '-' ? 1 : 0;
		  for (; i >= start + 4; i -= 3) {
		    res = `_${val.slice(i - 3, i)}${res}`;
		  }
		  return `${val.slice(0, i)}${res}`
		}

		// CHECK FUNCTIONS
		// ===============

		function checkBounds (buf, offset, byteLength) {
		  validateNumber(offset, 'offset');
		  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
		    boundsError(offset, buf.length - (byteLength + 1));
		  }
		}

		function checkIntBI (value, min, max, buf, offset, byteLength) {
		  if (value > max || value < min) {
		    const n = typeof min === 'bigint' ? 'n' : '';
		    let range;
		    {
		      if (min === 0 || min === BigInt(0)) {
		        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
		      } else {
		        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
		                `${(byteLength + 1) * 8 - 1}${n}`;
		      }
		    }
		    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
		  }
		  checkBounds(buf, offset, byteLength);
		}

		function validateNumber (value, name) {
		  if (typeof value !== 'number') {
		    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
		  }
		}

		function boundsError (value, length, type) {
		  if (Math.floor(value) !== value) {
		    validateNumber(value, type);
		    throw new errors.ERR_OUT_OF_RANGE('offset', 'an integer', value)
		  }

		  if (length < 0) {
		    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
		  }

		  throw new errors.ERR_OUT_OF_RANGE('offset',
		                                    `>= ${0} and <= ${length}`,
		                                    value)
		}

		// HELPER FUNCTIONS
		// ================

		const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

		function base64clean (str) {
		  // Node takes equal signs as end of the Base64 encoding
		  str = str.split('=')[0];
		  // Node strips out invalid characters like \n and \t from the string, base64-js does not
		  str = str.trim().replace(INVALID_BASE64_RE, '');
		  // Node converts strings with length < 2 to ''
		  if (str.length < 2) return ''
		  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
		  while (str.length % 4 !== 0) {
		    str = str + '=';
		  }
		  return str
		}

		function utf8ToBytes (string, units) {
		  units = units || Infinity;
		  let codePoint;
		  const length = string.length;
		  let leadSurrogate = null;
		  const bytes = [];

		  for (let i = 0; i < length; ++i) {
		    codePoint = string.charCodeAt(i);

		    // is surrogate component
		    if (codePoint > 0xD7FF && codePoint < 0xE000) {
		      // last char was a lead
		      if (!leadSurrogate) {
		        // no lead yet
		        if (codePoint > 0xDBFF) {
		          // unexpected trail
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		          continue
		        } else if (i + 1 === length) {
		          // unpaired lead
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		          continue
		        }

		        // valid lead
		        leadSurrogate = codePoint;

		        continue
		      }

		      // 2 leads in a row
		      if (codePoint < 0xDC00) {
		        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		        leadSurrogate = codePoint;
		        continue
		      }

		      // valid surrogate pair
		      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
		    } else if (leadSurrogate) {
		      // valid bmp char, but last char was a lead
		      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		    }

		    leadSurrogate = null;

		    // encode utf8
		    if (codePoint < 0x80) {
		      if ((units -= 1) < 0) break
		      bytes.push(codePoint);
		    } else if (codePoint < 0x800) {
		      if ((units -= 2) < 0) break
		      bytes.push(
		        codePoint >> 0x6 | 0xC0,
		        codePoint & 0x3F | 0x80
		      );
		    } else if (codePoint < 0x10000) {
		      if ((units -= 3) < 0) break
		      bytes.push(
		        codePoint >> 0xC | 0xE0,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      );
		    } else if (codePoint < 0x110000) {
		      if ((units -= 4) < 0) break
		      bytes.push(
		        codePoint >> 0x12 | 0xF0,
		        codePoint >> 0xC & 0x3F | 0x80,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      );
		    } else {
		      throw new Error('Invalid code point')
		    }
		  }

		  return bytes
		}

		function asciiToBytes (str) {
		  const byteArray = [];
		  for (let i = 0; i < str.length; ++i) {
		    // Node's code seems to be doing this and not & 0x7F..
		    byteArray.push(str.charCodeAt(i) & 0xFF);
		  }
		  return byteArray
		}

		function utf16leToBytes (str, units) {
		  let c, hi, lo;
		  const byteArray = [];
		  for (let i = 0; i < str.length; ++i) {
		    if ((units -= 2) < 0) break

		    c = str.charCodeAt(i);
		    hi = c >> 8;
		    lo = c % 256;
		    byteArray.push(lo);
		    byteArray.push(hi);
		  }

		  return byteArray
		}

		function base64ToBytes (str) {
		  return base64.toByteArray(base64clean(str))
		}

		function blitBuffer (src, dst, offset, length) {
		  let i;
		  for (i = 0; i < length; ++i) {
		    if ((i + offset >= dst.length) || (i >= src.length)) break
		    dst[i + offset] = src[i];
		  }
		  return i
		}

		// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
		// the `instanceof` check but they should be treated as of that type.
		// See: https://github.com/feross/buffer/issues/166
		function isInstance (obj, type) {
		  return obj instanceof type ||
		    (obj != null && obj.constructor != null && obj.constructor.name != null &&
		      obj.constructor.name === type.name)
		}
		function numberIsNaN (obj) {
		  // For IE11 support
		  return obj !== obj // eslint-disable-line no-self-compare
		}

		// Create lookup table for `toString('hex')`
		// See: https://github.com/feross/buffer/issues/219
		const hexSliceLookupTable = (function () {
		  const alphabet = '0123456789abcdef';
		  const table = new Array(256);
		  for (let i = 0; i < 16; ++i) {
		    const i16 = i * 16;
		    for (let j = 0; j < 16; ++j) {
		      table[i16 + j] = alphabet[i] + alphabet[j];
		    }
		  }
		  return table
		})();

		// Return not function with Error if BigInt not supported
		function defineBigIntMethod (fn) {
		  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
		}

		function BufferBigIntNotDefined () {
		  throw new Error('BigInt not supported')
		} 
	} (buffer));
	return buffer;
}

var indexv2;
var hasRequiredIndexv2;

function requireIndexv2 () {
	if (hasRequiredIndexv2) return indexv2;
	hasRequiredIndexv2 = 1;
	const ECMA_SIZES = requireByte_size();
	const Buffer =
	  typeof window !== 'undefined' ? requireBuffer().Buffer : commonjsGlobal.Buffer;

	/**
	 * Precisely calculate size of string in node
	 * Based on https://stackoverflow.com/questions/68789144/how-much-memory-do-v8-take-to-store-a-string/68791382#68791382
	 * @param {} str
	 */
	function preciseStringSizeNode (str) {
	  return 12 + 4 * Math.ceil(str.length / 4)
	}

	/**
	 * In the browser environment, window and document are defined as global objects
	 * @returns true if its a Node.js env, false if it is a browser
	 */
	function isNodeEnvironment () {
	  if (typeof window !== 'undefined' && typeof document !== 'undefined') {
	    return false
	  }
	  return true
	}

	function getSizeOfTypedArray (typedArray) {
	  if (typedArray.BYTES_PER_ELEMENT) {
	    return typedArray.length * typedArray.BYTES_PER_ELEMENT
	  }
	  return -1 // error indication
	}

	/**
	 * Size in bytes for complex objects
	 * @param {*} obj
	 * @returns size in bytes, or -1 if JSON.stringify threw an exception
	 */
	function objectSizeComplex (obj) {
	  let totalSize = 0;
	  const errorIndication = -1;

	  try {
	    // convert Map and Set to an object representation
	    let convertedObj = obj;
	    if (obj instanceof Map) {
	      convertedObj = Object.fromEntries(obj);
	    } else if (obj instanceof Set) {
	      convertedObj = Array.from(obj);
	    }

	    // handle typed arrays
	    if (ArrayBuffer.isView(obj)) {
	      return getSizeOfTypedArray(obj)
	    }

	    const serializedObj = JSON.stringify(convertedObj, (key, value) => {
	      if (typeof value === 'bigint') {
	        return value.toString()
	      } else if (typeof value === 'function') {
	        return value.toString()
	      } else if (typeof value === 'undefined') {
	        return 'undefined'
	      } else if (typeof value === 'symbol') {
	        return value.toString()
	      } else if (value instanceof RegExp) {
	        return value.toString()
	      } else {
	        return value
	      }
	    });

	    totalSize = Buffer.byteLength(serializedObj, 'utf8');
	  } catch (ex) {
	    // do not log anyting to console.error
	    return new Error(errorIndication)
	  }

	  return totalSize
	}

	/**
	 * Size in bytes for primitive types
	 * @param {*} obj
	 * @returns size in bytes
	 */
	function objectSizeSimple (obj) {
	  const objectList = [];
	  const stack = [obj];
	  let bytes = 0;

	  while (stack.length) {
	    const value = stack.pop();

	    if (typeof value === 'boolean') {
	      bytes += ECMA_SIZES.BYTES;
	    } else if (typeof value === 'string') {
	      if (isNodeEnvironment()) {
	        bytes += preciseStringSizeNode(value);
	      } else {
	        bytes += value.length * ECMA_SIZES.STRING;
	      }
	    } else if (typeof value === 'number') {
	      bytes += ECMA_SIZES.NUMBER;
	    } else if (typeof value === 'symbol') {
	      const isGlobalSymbol = Symbol.keyFor && Symbol.keyFor(obj);
	      if (isGlobalSymbol) {
	        bytes += Symbol.keyFor(obj).length * ECMA_SIZES.STRING;
	      } else {
	        bytes += (obj.toString().length - 8) * ECMA_SIZES.STRING;
	      }
	    } else if (typeof value === 'bigint') {
	      bytes += Buffer.from(value.toString()).byteLength;
	    } else if (typeof value === 'function') {
	      bytes += value.toString().length;
	    } else if (typeof value === 'object' && objectList.indexOf(value) === -1) {
	      objectList.push(value);

	      for (const i in value) {
	        stack.push(value[i]);
	      }
	    }
	  }
	  return bytes
	}

	indexv2 = function (obj) {
	  let totalSize = 0;

	  if (obj !== null && typeof obj === 'object') {
	    totalSize = objectSizeComplex(obj);
	  } else {
	    totalSize = objectSizeSimple(obj);
	  }

	  return totalSize
	};
	return indexv2;
}

var indexv2Exports = requireIndexv2();
var objectSizeOf = /*@__PURE__*/getDefaultExportFromCjs(indexv2Exports);

const myObjectSizeOf = (obj) => {
    if (isObjectJson(obj)) {
        return JSON.stringify(obj).length * 2;
    }
    return objectSizeOf(obj);
};
class MongoDbClient {
    constructor() {
        this.mongoDatabaseClient = null;
        this.reconnectionCbs = [];
    }
    async connect() {
        if (!this.mongoDatabaseClient) {
            log(LogLevel.INFO)(`mongo client connecting...`);
            const mongoClient = await libExports.MongoClient.connect(MONGO_DATABASE_URI);
            await mongoClient.connect();
            this.mongoDatabaseClient = mongoClient.db(MONGO_DATABASE_NAME);
            log(LogLevel.INFO)(`mongo client connected`);
            for (const cb of this.reconnectionCbs) {
                cb?.();
            }
        }
        else {
            log(LogLevel.INFO)(`mongo client already connected`);
        }
    }
    get __UNSAFE__mongoDatabaseClient() {
        return this.mongoDatabaseClient;
    }
    crud(collection) {
        let mongoCollection = this.mongoDatabaseClient?.collection(collection);
        const connect = () => {
            mongoCollection = this.mongoDatabaseClient?.collection(collection);
            log(LogLevel.INFO)(`collection "${collection}"connected`);
        };
        this.reconnectionCbs.push(connect);
        const updateOne = async (documentId, document, customer, withoutLog) => {
            const now = new Date();
            let documentToUpdate = { ...document };
            Object.keys(documentToUpdate).forEach(key => documentToUpdate[key] === undefined && delete documentToUpdate[key]);
            if (Object.keys(documentToUpdate).length === 0) {
                return;
            }
            let updatedDocument;
            if (withoutLog) {
                documentToUpdate = { ...documentToUpdate, updatedAt: now };
                updatedDocument = await mongoCollection
                    .updateOne({ _id: new libExports.ObjectId(documentId) }, { $set: documentToUpdate });
            }
            else {
                const oldDocument = await mongoCollection.findOne({ _id: new libExports.ObjectId(documentId) });
                documentToUpdate = { ...documentToUpdate, updatedAt: now };
                updatedDocument = await mongoCollection
                    .updateOne({ _id: new libExports.ObjectId(documentId) }, { $set: documentToUpdate });
                const newDocument = await mongoCollection.findOne({ _id: new libExports.ObjectId(documentId) });
                const atomicChanges = atomizeChangeset(diff(oldDocument, newDocument)).filter(({ path }) => path !== '$._id.buffer');
                const documentWithoutLogs = { ...newDocument, logs: [] };
                const bytes = myObjectSizeOf(documentWithoutLogs);
                const maxBytes = 1024 * 50; // 50 KB
                const newLog = {
                    changes: atomicChanges,
                    timestamp: now.getTime(),
                    customerUserId: '', // customer._id.toString(),
                };
                let logs = [];
                if (bytes < maxBytes) {
                    logs = [
                        newLog,
                        ...(newDocument?.logs ?? []),
                    ];
                    while (bytes + myObjectSizeOf(logs) > maxBytes && !!logs.length) {
                        logs.pop();
                    }
                }
                if (!logs.length) {
                    logs = [newLog];
                }
                const documentToUpdateWithLogs = {
                    updatedAt: now,
                    logs,
                };
                await mongoCollection.updateOne({ _id: new libExports.ObjectId(documentId) }, { $set: documentToUpdateWithLogs });
            }
            if (!updatedDocument) {
                throw new JkError(ErrorCode.ERR0303);
            }
            return updatedDocument;
        };
        return {
            insertOne: async (customer, document) => {
                const now = new Date();
                const documentToInsert = {
                    ...document,
                    createdAt: now,
                    updatedAt: now,
                    // companyId: '',
                    ownerUserId: '', // !!(customer?._id?.toString?.()) ? customer._id.toString() : company.systemAdminUserId,
                    state: EntityState.RELEASED,
                    logs: [],
                };
                const newDocument = await mongoCollection.insertOne(documentToInsert);
                if (!newDocument) {
                    log(LogLevel.INFO)(JSON.stringify({
                        collection, /*company, */
                        customer,
                        document,
                    }), 'error on insertOne');
                    throw new JkError(ErrorCode.ERR0810, { message: 'not created' });
                }
                return newDocument;
            },
            findOne: async (documentId, options) => {
                const { projection } = options || {};
                const document = await mongoCollection.findOne({ _id: new libExports.ObjectId(documentId) }, { projection });
                if (!document) {
                    log(LogLevel.INFO)(JSON.stringify({ collection, documentId }), 'error on findOne');
                    throw new JkError(ErrorCode.ERR0211, { message: 'not found' });
                }
                return document;
            },
            findOneByFilter: async (filter, options) => {
                const { projection, sort } = options || {};
                const document = await mongoCollection.findOne(filter, { projection, sort });
                if (!document) {
                    log(LogLevel.INFO)(JSON.stringify({ collection, filter }), 'error on findOneByFilter');
                    throw new JkError(ErrorCode.ERR0211, { message: 'not found' });
                }
                return document;
            },
            findByFilter: async (filter, options) => {
                const { projection, sort } = options || {};
                const document = await mongoCollection.find(filter, { projection, sort }).toArray();
                if (!document) {
                    log(LogLevel.INFO)(JSON.stringify({ collection, filter, options }), 'error on findByFilter');
                    throw new JkError(ErrorCode.ERR0211, { message: 'not found' });
                }
                return document;
            },
            findPaginated: async (page, size, sort = {}, filter, projection) => {
                const totalElements = await mongoCollection.countDocuments(filter);
                const pages = Math.ceil(totalElements / size);
                const startFrom = (page - 1) * size;
                const result = await mongoCollection
                    .find(filter, { projection })
                    .sort(sort)
                    .skip(startFrom)
                    .limit(size)
                    .toArray();
                return { result, totalElements, page, size, sort, pages };
            },
            updateOne,
            countDocuments: async (filter) => {
                return await mongoCollection.countDocuments(filter);
            },
            deleteOne: (documentId, customer) => (updateOne(documentId, { state: EntityState.ARCHIVED })),
            __UNSAFE__mongoCollection: () => mongoCollection,
            __UNSAFE__deleteOne: (documentId) => {
                return mongoCollection.deleteOne({ _id: new libExports.ObjectId(documentId) });
            },
        };
    }
}

const dbClient = new MongoDbClient();

const { findByFilter, insertOne, findOne, updateOne, deleteOne } = dbClient.crud('group');
const getGroups = async (companyId, filter, sort) => findByFilter({ ...filter, companyId }, { sort });
const createGroup = async (contest) => {
    return await insertOne(null, contest);
};
const getGroup = async (companyId, id) => {
    const group = await findOne(id);
    if (group.companyId !== companyId) {
        log(LogLevel.INFO)(JSON.stringify({ groupId: id, companyId }), 'error on getGroupData');
        throw new JkError(ErrorCode.ERR0211, { message: 'not found' });
    }
    return group;
};
const updateGroup = async (id, doc) => updateOne(id, doc, null);
const deleteGroup = async (id) => deleteOne(id, null);

function shuffle(array) {
    let currentIndex = array.length;
    // While there remain elements to shuffle...
    while (currentIndex != 0) {
        // Pick a remaining element...
        const randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        // And swap it with the current element.
        [array[currentIndex], array[randomIndex]] = [
            array[randomIndex],
            array[currentIndex],
        ];
    }
}
const postCreateGroup = async (req, res, next) => {
    const { name, amount, crypto, totalMembers, period, startsOnTimestamp, customerPublicKey, } = req.body;
    const collateralAmount = amount * totalMembers;
    const memberPositions = [];
    for (let i = 1; i <= totalMembers; i++) {
        memberPositions.push(i);
    }
    shuffle(memberPositions);
    const position = memberPositions.pop();
    const companyId = req.company.id;
    const newGroup = {
        companyId,
        crypto,
        name,
        amount,
        collateralAmount,
        totalMembers,
        period,
        startsOnTimestamp,
        memberPositions: [...memberPositions],
        members: {
            [customerPublicKey]: {
                position,
                publicKey: customerPublicKey,
                isOwner: true,
                deposits: {
                // [0]: {
                //   amount: collateral,
                //   round: 0,
                //   timestamp: now.getTime(),
                //   transactionSignature,
                // },
                },
                withdrawals: {},
            },
        },
    };
    const result = await createGroup(newGroup);
    res.sendContent(toGroupResponseDTO(await getGroup(companyId, result.insertedId.toString()), customerPublicKey));
};
const getAllGroups = async (req, res, next) => {
    const status = req.query.status;
    const myGroups = req.query.myGroups;
    const period = req.query.period;
    const crypto = req.query.crypto;
    const amount = +(req.query.amount || 0);
    const customerPublicKey = req.query.customerPublicKey;
    const orderBy = req.query.orderBy;
    const filter = { state: EntityState.RELEASED };
    if (period) {
        filter.period = period;
    }
    if (crypto) {
        filter.crypto = crypto;
    }
    if (amount) {
        filter.amount = amount;
    }
    if (customerPublicKey) {
        if (myGroups) {
            filter[`members.${customerPublicKey}`] = { $exists: true };
        }
        else {
            filter[`members.${customerPublicKey}`] = { $exists: false };
        }
    }
    const sort = {};
    switch (orderBy) {
        case '+amount':
            sort.amount = 1;
            break;
        case '-amount':
            sort.amount = -1;
            break;
        case '+date':
            sort.startsOnTimestamp = 1;
            break;
        case '-date':
            sort.startsOnTimestamp = -1;
            break;
        // case '+slots':
        //   sort.slots = 1;
        //   break;
        // case '-slots':
        //   sort.slots = -1;
        //   break;
        case '+totalMembers':
            sort.totalMembers = 1;
            break;
        case '-totalMembers':
            sort.totalMembers = -1;
            break;
    }
    const groups = await getGroups(req.company.id, filter, sort);
    const contents = groups
        .map((group) => toGroupResponseDTO(group, customerPublicKey))
        .filter((group) => (status ? status === group.status : true)
        && group.totalMembers !== group.slots &&
        (!myGroups ? group.slots > 0 : true) && // only with free slots
        true).sort((a, b) => (b.slots - a.slots) / Math.abs(b.slots - a.slots));
    res.sendContents(contents, { page: 0, size: 0, sort: [], totalElements: contents.length });
};
const getGroupData = async (req, res, next) => {
    const groupId = req.params.id;
    const customerPublicKey = req.query.customerPublicKey;
    const group = await getGroup(req.company.id, groupId);
    const content = toGroupResponseDTO(group, customerPublicKey);
    res.sendContent(content);
};
const postDepositGroup = async (req, res, next) => {
    const now = new Date();
    const groupId = req.params.id;
    const { customerPublicKey, transactionSignature, round /*amount*/ } = req.body;
    console.log(req.body);
    // TODO: validate amount
    const group = await getGroup(req.company.id, groupId);
    const collateral = group.amount * group.totalMembers;
    let newMembers;
    const memberPositions = [...group.memberPositions];
    if (round === 0) {
        if (group.members[customerPublicKey]) {
            newMembers = {
                ...group.members,
                [customerPublicKey]: {
                    ...group.members[customerPublicKey],
                    deposits: {
                        [round]: {
                            amount: collateral,
                            round,
                            timestamp: now.getTime(),
                            transactionSignature,
                        },
                    },
                    withdrawals: {},
                },
            };
        }
        else {
            const position = memberPositions.pop();
            newMembers = {
                ...group.members,
                [customerPublicKey]: {
                    publicKey: customerPublicKey,
                    isOwner: false,
                    position,
                    deposits: {
                        [round]: {
                            amount: collateral,
                            round,
                            timestamp: now.getTime(),
                            transactionSignature,
                        },
                    },
                    withdrawals: {},
                },
            };
        }
    }
    else {
        newMembers = {
            ...group.members,
            [customerPublicKey]: {
                ...group.members[customerPublicKey],
                deposits: {
                    ...group.members[customerPublicKey]?.deposits,
                    [round]: {
                        amount: group.amount,
                        round,
                        timestamp: now.getTime(),
                        transactionSignature,
                    },
                },
            },
        };
    }
    const slots = getGroupSlots({
        members: newMembers,
        totalMembers: group.totalMembers,
        collateralAmount: group.collateralAmount,
    });
    const doc = {
        members: newMembers,
        memberPositions: [...memberPositions],
    };
    if (slots === 0) { // TODO: only for testing purposes
        doc.startsOnTimestamp = Date.now();
    }
    await updateGroup(groupId, doc);
    res.sendContent('ok');
};
const postDisjoinGroup = async (req, res, next) => {
    const groupId = req.params.id;
    const { customerPublicKey } = req.body;
    // TODO: validate amount
    const group = await getGroup(req.company.id, groupId);
    if (group.members[customerPublicKey]) {
        const newMembers = { ...group.members };
        const memberPositions = [newMembers[customerPublicKey].position, ...group.memberPositions].filter((position) => !!position);
        delete newMembers[customerPublicKey];
        await updateGroup(groupId, {
            members: newMembers,
            memberPositions: [...memberPositions],
        });
    }
    const groupUpdated = await getGroup(req.company.id, groupId);
    const content = toGroupResponseDTO(groupUpdated, customerPublicKey);
    res.sendContent(content);
};
const postJoinGroup = async (req, res, next) => {
    const groupId = req.params.id;
    const { customerPublicKey } = req.body;
    // TODO: validate amount
    const group = await getGroup(req.company.id, groupId);
    const memberPositions = [...group.memberPositions];
    if (!memberPositions.length) {
        throw new Error('there are no free slots in the group');
    }
    const position = memberPositions.pop();
    const newMembers = {
        ...group.members,
        [customerPublicKey]: {
            publicKey: customerPublicKey,
            isOwner: false,
            position,
            deposits: {},
            withdrawals: {},
        },
    };
    await updateGroup(groupId, {
        members: newMembers,
        memberPositions: [...memberPositions],
    });
    const groupUpdated = await getGroup(req.company.id, groupId);
    const content = toGroupResponseDTO(groupUpdated, customerPublicKey);
    res.sendContent(content);
};
const postWithdrawal = async (req, res, next) => {
    const now = new Date();
    const groupId = req.params.id;
    const { customerPublicKey, transactionSignature, type /*amount*/ } = req.body;
    // TODO: validate amount
    const group = await getGroup(req.company.id, groupId);
    let newMembers = { ...group.members };
    if (type === GroupWithdrawalType.COLLATERAL) {
        newMembers = {
            ...group.members,
            [customerPublicKey]: {
                ...group.members[customerPublicKey],
                withdrawals: {
                    ...group.members[customerPublicKey].withdrawals,
                    [GroupWithdrawalType.COLLATERAL]: {
                        amount: group.collateralAmount,
                        type: GroupWithdrawalType.COLLATERAL,
                        timestamp: now.getTime(),
                        transactionSignature,
                    },
                },
            },
        };
    }
    if (type === GroupWithdrawalType.ROUND) {
        newMembers = {
            ...group.members,
            [customerPublicKey]: {
                ...group.members[customerPublicKey],
                withdrawals: {
                    ...group.members[customerPublicKey].withdrawals,
                    [GroupWithdrawalType.ROUND]: {
                        amount: group.amount,
                        type: GroupWithdrawalType.ROUND,
                        timestamp: now.getTime(),
                        transactionSignature,
                    },
                },
            },
        };
    }
    if (type === GroupWithdrawalType.INTEREST) {
        newMembers = {
            ...group.members,
            [customerPublicKey]: {
                ...group.members[customerPublicKey],
                withdrawals: {
                    ...group.members[customerPublicKey].withdrawals,
                    [GroupWithdrawalType.INTEREST]: {
                        amount: 0,
                        type: GroupWithdrawalType.INTEREST,
                        timestamp: now.getTime(),
                        transactionSignature,
                    },
                },
            },
        };
    }
    await updateGroup(groupId, { members: newMembers });
    res.sendContent('ok');
};
const archiveGroup = async (req, res, next) => {
    const groupId = req.params.id;
    await deleteGroup(groupId);
    res.sendContent('ok');
};
const __setTimestampGroup = async (req, res, next) => {
    const groupId = req.params.id;
    await updateGroup(groupId, { startsOnTimestamp: req.body.startsOnTimestamp });
    res.sendContent('ok');
};

const router$1 = express.Router();
router$1.get('/', safeResponse(getAllGroups));
router$1.post('/create', safeResponse(postCreateGroup));
router$1.get('/:id', safeResponse(getGroupData));
router$1.delete('/:id', safeResponse(archiveGroup));
router$1.post('/:id/deposit', safeResponse(postDepositGroup));
router$1.post('/:id/disjoin', safeResponse(postDisjoinGroup));
router$1.post('/:id/join', safeResponse(postJoinGroup));
router$1.post('/:id/withdrawal', safeResponse(postWithdrawal));
router$1.post('/:id/set-timestamp', safeResponse(__setTimestampGroup));

const router = express.Router();
router.get('/ping', routerGetPing);
router.get('/version', routerGetVersion);
router.get('/node-env', routerGetNodeEnv);
router.get('/status', routerGetStatus);
router.get('/envs', routerGetEnvs);

var src$2 = {};

var src$1 = {};

var src = {};

/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/

var binaryCase_1;
var hasRequiredBinaryCase;

function requireBinaryCase () {
	if (hasRequiredBinaryCase) return binaryCase_1;
	hasRequiredBinaryCase = 1;

	/**
	 * Toggle the case of a string based on the number value passed in.
	 * @param {string} string
	 * @param {number} number
	 * @param {object} [options={allowOverflow: true}]
	 * @returns {string|boolean}
	 */
	binaryCase_1 = binaryCase;

	function binaryCase(string, number, options) {
	    if (!options || typeof options !== 'object') options = {};
	    if (!options.hasOwnProperty('allowOverflow')) options.allowOverflow = true;

	    if (number > binaryCase.maxNumber(string) && !options.allowOverflow) return false;

	    return getBinaryCase(string, number);
	}

	binaryCase.iterator = function(string, options) {
	    const max = binaryCase.maxNumber(string);

	    if (!options || typeof options !== 'object') options = {};
	    if (!options.hasOwnProperty('startIndex')) options.startIndex = 0;
	    if (typeof options.startIndex !== 'number' || !Number.isInteger(options.startIndex) || options.startIndex < 0) throw Error('Option startIndex must be a non-negative integer.');

	    let index = options.startIndex;
	    return {
	        next: function() {
	            return index > max
	                ? { done: true }
	                : { done: false, value: getBinaryCase(string, index++) };
	        }
	    };
	};

	/**
	 * Get the maximum number that can be used before causing overflow.
	 * @param {string} string
	 * @returns {number}
	 */
	binaryCase.maxNumber = function(string) {
	    const pow = string.match(/[a-z]/ig).length;
	    return Math.pow(2, pow) - 1;
	};

	/**
	 * Get an array of all possible variations.
	 * @param {string} string
	 * @returns {string[]}
	 */
	binaryCase.variations = function(string) {
	    const results = [];
	    const max = binaryCase.maxNumber(string);
	    for (let i = 0; i <= max; i++) {
	        results.push(binaryCase(string, i));
	    }
	    return results;
	};

	/**
	 * A performance improved method for acquiring the binary case, provided by Blake Embrey with very minor modification by James Speirs.
	 * @author Blake Embrey | https://github.com/blakeembrey
	 * @author James Speirs | https://github.com/gi60s
	 * @param {string} str
	 * @param {number} val
	 * @returns {string}
	 */
	function getBinaryCase (str, val) {
	    let res = '';

	    for (let i = 0; i < str.length; i++) {
	        const code = str.charCodeAt(i);

	        if (code >= 65 && code <= 90) {
	            res += val & 1 ? String.fromCharCode(code + 32) : String.fromCharCode(code);
	            val >>>= 1;
	        } else if (code >= 97 && code <= 122) {
	            res += val & 1 ? String.fromCharCode(code - 32) : String.fromCharCode(code);
	            val >>>= 1;
	        } else {
	            res += String.fromCharCode(code);
	        }

	        if (val === 0) {
	            return res + str.substr(i + 1);
	        }
	    }

	    return res;
	}
	return binaryCase_1;
}

var hasRequiredSrc$2;

function requireSrc$2 () {
	if (hasRequiredSrc$2) return src;
	hasRequiredSrc$2 = 1;
	const http = require$$0$b;
	const url = require$$4$1;
	const binarycase = requireBinaryCase();
	const isType = requireTypeIs();

	function getPathWithQueryStringParams (event) {
	  return url.format({ pathname: event.path, query: event.queryStringParameters })
	}
	function getEventBody (event) {
	  return Buffer.from(event.body, event.isBase64Encoded ? 'base64' : 'utf8')
	}

	function clone (json) {
	  return JSON.parse(JSON.stringify(json))
	}

	function getContentType (params) {
	  // only compare mime type; ignore encoding part
	  return params.contentTypeHeader ? params.contentTypeHeader.split(';')[0] : ''
	}

	function isContentTypeBinaryMimeType (params) {
	  return params.binaryMimeTypes.length > 0 && !!isType.is(params.contentType, params.binaryMimeTypes)
	}

	function mapApiGatewayEventToHttpRequest (event, context, socketPath) {
	  const headers = Object.assign({}, event.headers);

	  // NOTE: API Gateway is not setting Content-Length header on requests even when they have a body
	  if (event.body && !headers['Content-Length']) {
	    const body = getEventBody(event);
	    headers['Content-Length'] = Buffer.byteLength(body);
	  }

	  const clonedEventWithoutBody = clone(event);
	  delete clonedEventWithoutBody.body;

	  headers['x-apigateway-event'] = encodeURIComponent(JSON.stringify(clonedEventWithoutBody));
	  headers['x-apigateway-context'] = encodeURIComponent(JSON.stringify(context));

	  return {
	    method: event.httpMethod,
	    path: getPathWithQueryStringParams(event),
	    headers,
	    socketPath
	    // protocol: `${headers['X-Forwarded-Proto']}:`,
	    // host: headers.Host,
	    // hostname: headers.Host, // Alias for host
	    // port: headers['X-Forwarded-Port']
	  }
	}

	function forwardResponseToApiGateway (server, response, resolver) {
	  const buf = [];

	  response
	    .on('data', (chunk) => buf.push(chunk))
	    .on('end', () => {
	      const bodyBuffer = Buffer.concat(buf);
	      const statusCode = response.statusCode;
	      const headers = response.headers;

	      // chunked transfer not currently supported by API Gateway
	      /* istanbul ignore else */
	      if (headers['transfer-encoding'] === 'chunked') {
	        delete headers['transfer-encoding'];
	      }

	      // HACK: modifies header casing to get around API Gateway's limitation of not allowing multiple
	      // headers with the same name, as discussed on the AWS Forum https://forums.aws.amazon.com/message.jspa?messageID=725953#725953
	      Object.keys(headers)
	        .forEach(h => {
	          if (Array.isArray(headers[h])) {
	            if (h.toLowerCase() === 'set-cookie') {
	              headers[h].forEach((value, i) => {
	                headers[binarycase(h, i + 1)] = value;
	              });
	              delete headers[h];
	            } else {
	              headers[h] = headers[h].join(',');
	            }
	          }
	        });

	      const contentType = getContentType({ contentTypeHeader: headers['content-type'] });
	      const isBase64Encoded = isContentTypeBinaryMimeType({ contentType, binaryMimeTypes: server._binaryTypes });
	      const body = bodyBuffer.toString(isBase64Encoded ? 'base64' : 'utf8');
	      const successResponse = { statusCode, body, headers, isBase64Encoded };

	      resolver.succeed({ response: successResponse });
	    });
	}

	function forwardConnectionErrorResponseToApiGateway (error, resolver) {
	  console.log('ERROR: @vendia/serverless-express connection error');
	  console.error(error);
	  const errorResponse = {
	    statusCode: 502, // "DNS resolution, TCP level errors, or actual HTTP parse errors" - https://nodejs.org/api/http.html#http_http_request_options_callback
	    body: '',
	    headers: {}
	  };

	  resolver.succeed({ response: errorResponse });
	}

	function forwardLibraryErrorResponseToApiGateway (error, resolver) {
	  console.log('ERROR: @vendia/serverless-express error');
	  console.error(error);
	  const errorResponse = {
	    statusCode: 500,
	    body: '',
	    headers: {}
	  };

	  resolver.succeed({ response: errorResponse });
	}

	function forwardRequestToNodeServer (server, event, context, resolver) {
	  try {
	    const requestOptions = mapApiGatewayEventToHttpRequest(event, context, getSocketPath(server._socketPathSuffix));
	    const req = http.request(requestOptions, (response) => forwardResponseToApiGateway(server, response, resolver));
	    if (event.body) {
	      const body = getEventBody(event);

	      req.write(body);
	    }

	    req.on('error', (error) => forwardConnectionErrorResponseToApiGateway(error, resolver))
	      .end();
	  } catch (error) {
	    forwardLibraryErrorResponseToApiGateway(error, resolver);
	    return server
	  }
	}

	function startServer (server) {
	  return server.listen(getSocketPath(server._socketPathSuffix))
	}

	function getSocketPath (socketPathSuffix) {
	  /* istanbul ignore if */ /* only running tests on Linux; Window support is for local dev only */
	  if (/^win/.test(process.platform)) {
	    const path = require$$0$4;
	    return path.join('\\\\?\\pipe', process.cwd(), `server-${socketPathSuffix}`)
	  } else {
	    return `/tmp/server-${socketPathSuffix}.sock`
	  }
	}

	function getRandomString () {
	  return Math.random().toString(36).substring(2, 15)
	}

	function createServer (requestListener, serverListenCallback, binaryTypes) {
	  const server = http.createServer(requestListener);

	  server._socketPathSuffix = getRandomString();
	  server._binaryTypes = binaryTypes ? binaryTypes.slice() : [];
	  server.on('listening', () => {
	    server._isListening = true;

	    if (serverListenCallback) serverListenCallback();
	  });
	  server.on('close', () => {
	    server._isListening = false;
	  })
	    .on('error', (error) => {
	      /* istanbul ignore else */
	      if (error.code === 'EADDRINUSE') {
	        console.warn(`WARNING: Attempting to listen on socket ${getSocketPath(server._socketPathSuffix)}, but it is already in use. This is likely as a result of a previous invocation error or timeout. Check the logs for the invocation(s) immediately prior to this for root cause, and consider increasing the timeout and/or cpu/memory allocation if this is purely as a result of a timeout. @vendia/serverless-express will restart the Node.js server listening on a new port and continue with this request.`);
	        server._socketPathSuffix = getRandomString();
	        return server.close(() => startServer(server))
	      } else {
	        console.log('ERROR: server error');
	        console.error(error);
	      }
	    });

	  return server
	}

	function proxy (server, event, context, resolutionMode, callback) {
	  // DEPRECATED: Legacy support
	  if (!resolutionMode) {
	    const resolver = makeResolver({ context, resolutionMode: 'CONTEXT_SUCCEED' });
	    if (server._isListening) {
	      forwardRequestToNodeServer(server, event, context, resolver);
	      return server
	    } else {
	      return startServer(server)
	        .on('listening', () => proxy(server, event, context))
	    }
	  }

	  return {
	    promise: new Promise((resolve, reject) => {
	      const promise = {
	        resolve,
	        reject
	      };
	      const resolver = makeResolver({
	        context,
	        callback,
	        promise,
	        resolutionMode
	      });

	      if (server._isListening) {
	        forwardRequestToNodeServer(server, event, context, resolver);
	      } else {
	        startServer(server)
	          .on('listening', () => forwardRequestToNodeServer(server, event, context, resolver));
	      }
	    })
	  }
	}

	function makeResolver (params/* {
	  context,
	  callback,
	  promise,
	  resolutionMode
	} */) {
	  return {
	    succeed: (params2/* {
	      response
	    } */) => {
	      if (params.resolutionMode === 'CONTEXT_SUCCEED') return params.context.succeed(params2.response)
	      if (params.resolutionMode === 'CALLBACK') return params.callback(null, params2.response)
	      if (params.resolutionMode === 'PROMISE') return params.promise.resolve(params2.response)
	    }
	  }
	}

	src.createServer = createServer;
	src.proxy = proxy;

	/* istanbul ignore else */
	if (process.env.NODE_ENV === 'test') {
	  src.getPathWithQueryStringParams = getPathWithQueryStringParams;
	  src.mapApiGatewayEventToHttpRequest = mapApiGatewayEventToHttpRequest;
	  src.forwardResponseToApiGateway = forwardResponseToApiGateway;
	  src.forwardConnectionErrorResponseToApiGateway = forwardConnectionErrorResponseToApiGateway;
	  src.forwardLibraryErrorResponseToApiGateway = forwardLibraryErrorResponseToApiGateway;
	  src.forwardRequestToNodeServer = forwardRequestToNodeServer;
	  src.startServer = startServer;
	  src.getSocketPath = getSocketPath;
	  src.makeResolver = makeResolver;
	}
	return src;
}

var serverlessExpress$1;
var hasRequiredServerlessExpress$1;

function requireServerlessExpress$1 () {
	if (hasRequiredServerlessExpress$1) return serverlessExpress$1;
	hasRequiredServerlessExpress$1 = 1;

	serverlessExpress$1 = requireSrc$2();
	return serverlessExpress$1;
}

var hasRequiredSrc$1;

function requireSrc$1 () {
	if (hasRequiredSrc$1) return src$1;
	hasRequiredSrc$1 = 1;
	const codeGenieServerlessExpress = requireServerlessExpress$1();

	src$1.createServer = codeGenieServerlessExpress.createServer;
	src$1.proxy = codeGenieServerlessExpress.proxy;

	/* istanbul ignore else */
	if (process.env.NODE_ENV === 'test') {
	  src$1.getPathWithQueryStringParams = codeGenieServerlessExpress.getPathWithQueryStringParams;
	  src$1.mapApiGatewayEventToHttpRequest = codeGenieServerlessExpress.mapApiGatewayEventToHttpRequest;
	  src$1.forwardResponseToApiGateway = codeGenieServerlessExpress.forwardResponseToApiGateway;
	  src$1.forwardConnectionErrorResponseToApiGateway = codeGenieServerlessExpress.forwardConnectionErrorResponseToApiGateway;
	  src$1.forwardLibraryErrorResponseToApiGateway = codeGenieServerlessExpress.forwardLibraryErrorResponseToApiGateway;
	  src$1.forwardRequestToNodeServer = codeGenieServerlessExpress.forwardRequestToNodeServer;
	  src$1.startServer = codeGenieServerlessExpress.startServer;
	  src$1.getSocketPath = codeGenieServerlessExpress.getSocketPath;
	  src$1.makeResolver = codeGenieServerlessExpress.makeResolver;
	}
	return src$1;
}

var serverlessExpress;
var hasRequiredServerlessExpress;

function requireServerlessExpress () {
	if (hasRequiredServerlessExpress) return serverlessExpress;
	hasRequiredServerlessExpress = 1;

	serverlessExpress = requireSrc$1();
	return serverlessExpress;
}

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src$2;
	hasRequiredSrc = 1;
	const serverlessExpress = requireServerlessExpress();

	src$2.createServer = serverlessExpress.createServer;
	src$2.proxy = serverlessExpress.proxy;

	/* istanbul ignore else */
	if (process.env.NODE_ENV === 'test') {
	  src$2.getPathWithQueryStringParams = serverlessExpress.getPathWithQueryStringParams;
	  src$2.mapApiGatewayEventToHttpRequest = serverlessExpress.mapApiGatewayEventToHttpRequest;
	  src$2.forwardResponseToApiGateway = serverlessExpress.forwardResponseToApiGateway;
	  src$2.forwardConnectionErrorResponseToApiGateway = serverlessExpress.forwardConnectionErrorResponseToApiGateway;
	  src$2.forwardLibraryErrorResponseToApiGateway = serverlessExpress.forwardLibraryErrorResponseToApiGateway;
	  src$2.forwardRequestToNodeServer = serverlessExpress.forwardRequestToNodeServer;
	  src$2.startServer = serverlessExpress.startServer;
	  src$2.getSocketPath = serverlessExpress.getSocketPath;
	  src$2.makeResolver = serverlessExpress.makeResolver;
	}
	return src$2;
}

var awsServerlessExpress$1;
var hasRequiredAwsServerlessExpress;

function requireAwsServerlessExpress () {
	if (hasRequiredAwsServerlessExpress) return awsServerlessExpress$1;
	hasRequiredAwsServerlessExpress = 1;

	awsServerlessExpress$1 = requireSrc();
	return awsServerlessExpress$1;
}

var awsServerlessExpressExports = requireAwsServerlessExpress();
var awsServerlessExpress = /*@__PURE__*/getDefaultExportFromCjs(awsServerlessExpressExports);

var bodyParserExports = requireBodyParser();
var bodyParser = /*@__PURE__*/getDefaultExportFromCjs(bodyParserExports);

function setCompany() {
    return async (_req, res, next) => {
        const req = _req;
        let referer, host = ''; //, domain, subdomain;
        try {
            referer = req.header('Referer');
            host = referer?.split?.('/')?.[2] || '';
            // domain = host.split('.').splice(-2).join('.');
            // subdomain = host.split('.').slice(0, -2).join('.');
            let companyId = -1;
            COMPANY_HOSTS.forEach((hosts, index) => {
                if (hosts.includes(host)) {
                    companyId = index + 1;
                }
            });
            if (companyId > 0) {
                req.company = { id: `company-${companyId}` };
            }
            else {
                req.company = { id: '' };
            }
        }
        catch (error) {
            log(LogLevel.ERROR)('Error on setCompany', { error });
        }
        next();
    };
}

// lambda.js
const handler = async (event, context) => {
    const app = initialSetupApp();
    try {
        await dbClient.connect();
        finishSetupApp(app);
        app.use(express.json());
        app.use(express.urlencoded({ extended: false }));
        app.use(bodyParser.urlencoded({
            extended: true,
        }));
        app.use(errorLoggerHandler);
        app.use(errorResponderHandler);
        app.use(failSafeHandler);
        app.use('/vaquita/api/v1', router);
        // @ts-ignore
        app.use('/vaquita/api/v1/group', setCompany(), router$1);
        app.use(notFoundResponse);
    }
    catch (error) {
    }
    const server = awsServerlessExpress.createServer(app);
    awsServerlessExpress.proxy(server, event, context);
};

exports.AwsSdkSigV4Signer = AwsSdkSigV4Signer;
exports.CONFIG_PREFIX_SEPARATOR = CONFIG_PREFIX_SEPARATOR;
exports.Client = Client;
exports.Command = Command;
exports.CredentialsProviderError = CredentialsProviderError;
exports.DEFAULT_RETRY_MODE = DEFAULT_RETRY_MODE;
exports.DefaultIdentityProviderConfig = DefaultIdentityProviderConfig;
exports.ENV_ACCOUNT_ID = ENV_ACCOUNT_ID;
exports.ENV_CREDENTIAL_SCOPE = ENV_CREDENTIAL_SCOPE;
exports.ENV_EXPIRATION = ENV_EXPIRATION;
exports.ENV_KEY = ENV_KEY;
exports.ENV_SECRET = ENV_SECRET;
exports.ENV_SESSION = ENV_SESSION;
exports.EndpointCache = EndpointCache;
exports.Hash = Hash;
exports.HttpRequest = HttpRequest;
exports.NODE_APP_ID_CONFIG_OPTIONS = NODE_APP_ID_CONFIG_OPTIONS;
exports.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = NODE_MAX_ATTEMPT_CONFIG_OPTIONS;
exports.NODE_REGION_CONFIG_FILE_OPTIONS = NODE_REGION_CONFIG_FILE_OPTIONS;
exports.NODE_REGION_CONFIG_OPTIONS = NODE_REGION_CONFIG_OPTIONS;
exports.NODE_RETRY_MODE_CONFIG_OPTIONS = NODE_RETRY_MODE_CONFIG_OPTIONS;
exports.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS;
exports.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS;
exports.NoOpLogger = NoOpLogger;
exports.NodeHttpHandler = NodeHttpHandler;
exports.ProviderError = ProviderError;
exports.SENSITIVE_STRING = SENSITIVE_STRING;
exports.ServiceException = ServiceException;
exports.awsEndpointFunctions = awsEndpointFunctions;
exports.calculateBodyLength = calculateBodyLength;
exports.chain = chain;
exports.collectBodyString = collectBodyString;
exports.createDefaultUserAgentProvider = createDefaultUserAgentProvider;
exports.customEndpointFunctions = customEndpointFunctions;
exports.decorateServiceException = decorateServiceException;
exports.defaultProvider = defaultProvider;
exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion;
exports.emitWarningIfUnsupportedVersion$1 = emitWarningIfUnsupportedVersion$1;
exports.expectInt32 = expectInt32;
exports.expectNonNull = expectNonNull;
exports.expectObject = expectObject;
exports.expectString = expectString;
exports.extendedEncodeURIComponent = extendedEncodeURIComponent;
exports.fromBase64 = fromBase64;
exports.fromEnv = fromEnv;
exports.fromUtf8 = fromUtf8$1;
exports.getAwsRegionExtensionConfiguration = getAwsRegionExtensionConfiguration;
exports.getConfigFilepath = getConfigFilepath;
exports.getContentLengthPlugin = getContentLengthPlugin;
exports.getDefaultExtensionConfiguration = getDefaultExtensionConfiguration;
exports.getEndpointPlugin = getEndpointPlugin;
exports.getHomeDir = getHomeDir;
exports.getHostHeaderPlugin = getHostHeaderPlugin;
exports.getHttpAuthSchemeEndpointRuleSetPlugin = getHttpAuthSchemeEndpointRuleSetPlugin;
exports.getHttpHandlerExtensionConfiguration = getHttpHandlerExtensionConfiguration;
exports.getHttpSigningPlugin = getHttpSigningPlugin;
exports.getLoggerPlugin = getLoggerPlugin;
exports.getProfileName = getProfileName;
exports.getRecursionDetectionPlugin = getRecursionDetectionPlugin;
exports.getRetryPlugin = getRetryPlugin;
exports.getSerdePlugin = getSerdePlugin;
exports.getSmithyContext = getSmithyContext;
exports.getUserAgentPlugin = getUserAgentPlugin;
exports.handler = handler;
exports.isSerializableHeaderValue = isSerializableHeaderValue;
exports.loadConfig = loadConfig;
exports.loadConfigsForDefaultMode = loadConfigsForDefaultMode;
exports.loadSharedConfigFiles = loadSharedConfigFiles;
exports.map = map$1;
exports.normalizeProvider = normalizeProvider$1;
exports.parseIni = parseIni;
exports.parseRfc3339DateTime = parseRfc3339DateTime;
exports.parseRfc3339DateTimeWithOffset = parseRfc3339DateTimeWithOffset;
exports.parseUrl = parseUrl;
exports.parseXmlBody = parseXmlBody;
exports.parseXmlErrorBody = parseXmlErrorBody;
exports.requestBuilder = requestBuilder;
exports.resolveAwsRegionExtensionConfiguration = resolveAwsRegionExtensionConfiguration;
exports.resolveAwsSdkSigV4Config = resolveAwsSdkSigV4Config;
exports.resolveDefaultRuntimeConfig = resolveDefaultRuntimeConfig;
exports.resolveDefaultsModeConfig = resolveDefaultsModeConfig;
exports.resolveEndpoint = resolveEndpoint;
exports.resolveEndpointConfig = resolveEndpointConfig;
exports.resolveHostHeaderConfig = resolveHostHeaderConfig;
exports.resolveHttpHandlerRuntimeConfig = resolveHttpHandlerRuntimeConfig;
exports.resolveRegionConfig = resolveRegionConfig;
exports.resolveRetryConfig = resolveRetryConfig;
exports.resolveUserAgentConfig = resolveUserAgentConfig;
exports.sdkStreamMixin = sdkStreamMixin;
exports.setCredentialFeature = setCredentialFeature;
exports.slurpFile = slurpFile;
exports.streamCollector = streamCollector$1;
exports.strictParseInt32 = strictParseInt32;
exports.take = take;
exports.toBase64 = toBase64;
exports.toUtf8 = toUtf8;
exports.withBaseException = withBaseException;
