{"code":"import { GroupPeriod, GroupStatus, GroupWithdrawalType, } from 'app/group/types';\nimport { addMonths, addWeeks } from 'date-fns';\nexport const getGroupStatus = (group, myWithdrawals, customerPublicKey) => {\n    let depositedCollaterals = 0;\n    let joinedUsers = 0;\n    for (const member of Object.values(group.members || {})) {\n        if (member.deposits?.[0]?.round === 0 &&\n            member.deposits?.[0]?.amount === group.collateralAmount) {\n            depositedCollaterals++;\n        }\n        joinedUsers++;\n    }\n    if (depositedCollaterals < group.totalMembers) {\n        // pending, abandoned\n        if (group.startsOnTimestamp >= Date.now()) {\n            return GroupStatus.PENDING;\n        }\n        return GroupStatus.ABANDONED;\n    }\n    else if (depositedCollaterals === group.totalMembers) {\n        // active, concluded\n        const endDate = group.period === GroupPeriod.MONTHLY\n            ? addMonths(new Date(group.startsOnTimestamp), group.totalMembers)\n            : addWeeks(new Date(group.startsOnTimestamp), group.totalMembers);\n        const allWithdrawals = myWithdrawals.round.successfullyWithdrawn\n            && myWithdrawals.collateral.successfullyWithdrawn\n            && myWithdrawals.interest.successfullyWithdrawn;\n        if (group.startsOnTimestamp > Date.now() && !allWithdrawals) {\n            return GroupStatus.PENDING;\n        }\n        if (endDate.getTime() > Date.now() && !allWithdrawals) {\n            return GroupStatus.ACTIVE;\n        }\n        return GroupStatus.CONCLUDED;\n    }\n    return GroupStatus.ABANDONED;\n};\nexport const getGroupSlots = (group) => {\n    let depositedCollaterals = 0;\n    for (const member of Object.values(group.members || {})) {\n        if (member.deposits?.[0]?.round === 0 &&\n            member.deposits?.[0]?.amount === group.collateralAmount) {\n            depositedCollaterals++;\n        }\n    }\n    return group.totalMembers - depositedCollaterals;\n};\nexport const isSuccessTransaction = (deposit, amount) => {\n    return (typeof amount === 'number' ? !!deposit?.amount && +deposit?.amount === +amount : true) && !!deposit?.timestamp && !!deposit?.transactionSignature;\n};\nexport const toGroupResponseDTO = (group, customerPublicKey) => {\n    const me = group.members?.[customerPublicKey];\n    const countSuccessDeposits = {};\n    let countSuccessRounds = 0;\n    for (const member of Object.values(group.members || {})) {\n        for (const deposit of Object.values(member.deposits || {})) {\n            if (isSuccessTransaction(deposit, +deposit.round === 0 ? group.amount * group.totalMembers : group.amount)) {\n                countSuccessDeposits[deposit.round] = (countSuccessDeposits[deposit.round] ?? 0) + 1;\n            }\n        }\n    }\n    for (let i = 0; i <= group.totalMembers; i++) {\n        countSuccessRounds += +(countSuccessDeposits[i] === group.totalMembers - (i === 0 ? 0 : 1));\n    }\n    const myDeposits = {};\n    for (const deposit of Object.values(me?.deposits || {})) {\n        myDeposits[deposit.round] = {\n            round: deposit.round,\n            successfullyDeposited: deposit.round === 0\n                ? deposit.amount === group.collateralAmount\n                : deposit.amount === group.amount,\n            amount: deposit.amount,\n            timestamp: deposit.timestamp,\n        };\n    }\n    // TODO: valid with dates\n    const myWithdrawals = {\n        [GroupWithdrawalType.COLLATERAL]: {\n            amount: me?.withdrawals?.collateral?.amount ?? 0,\n            type: GroupWithdrawalType.COLLATERAL,\n            timestamp: me?.withdrawals?.collateral?.timestamp ?? 0,\n            successfullyWithdrawn: isSuccessTransaction(me?.withdrawals?.collateral, group.collateralAmount),\n            enabled: countSuccessRounds === group.totalMembers + 1,\n        },\n        [GroupWithdrawalType.ROUND]: {\n            amount: me?.withdrawals?.round?.amount ?? 0,\n            type: GroupWithdrawalType.ROUND,\n            timestamp: me?.withdrawals?.round?.timestamp ?? 0,\n            successfullyWithdrawn: isSuccessTransaction(me?.withdrawals?.round, group.amount),\n            enabled: // group.myPosition <= group.currentPosition &&\n            countSuccessDeposits[me?.position || 0] === group.totalMembers - 1,\n        },\n        [GroupWithdrawalType.INTEREST]: {\n            amount: me?.withdrawals?.interest?.amount ?? 0,\n            type: GroupWithdrawalType.INTEREST,\n            timestamp: me?.withdrawals?.interest?.timestamp ?? 0,\n            successfullyWithdrawn: isSuccessTransaction(me?.withdrawals?.interest, undefined),\n            enabled: countSuccessRounds === group.totalMembers + 1,\n        },\n    };\n    myWithdrawals.collateral.enabled = myWithdrawals.collateral.enabled && !myWithdrawals.collateral.successfullyWithdrawn;\n    myWithdrawals.round.enabled = myWithdrawals.round.enabled && !myWithdrawals.round.successfullyWithdrawn;\n    myWithdrawals.interest.enabled = myWithdrawals.interest.enabled && !myWithdrawals.interest.successfullyWithdrawn;\n    const response = {\n        amount: group.amount,\n        myDeposits,\n        totalMembers: group.totalMembers,\n        period: group.period,\n        startsOnTimestamp: group.startsOnTimestamp,\n        myPosition: me?.position || 0,\n    };\n    const { currentPosition } = getPaymentsTable(response);\n    return {\n        id: group._id.toString(),\n        crypto: group.crypto,\n        name: group.name,\n        amount: group.amount,\n        collateralAmount: group.collateralAmount,\n        myDeposits,\n        myWithdrawals,\n        totalMembers: group.totalMembers,\n        slots: getGroupSlots(group),\n        joinedUsers: Object.values(group.members || {}).length,\n        period: group.period,\n        startsOnTimestamp: group.startsOnTimestamp,\n        status: getGroupStatus(group, myWithdrawals, customerPublicKey),\n        isOwner: !!group.members?.[customerPublicKey]?.isOwner,\n        myPosition: me?.position || 0,\n        currentPosition,\n    };\n};\nexport const getPaymentsTable = (group) => {\n    const items = [];\n    let startDate = new Date(group.startsOnTimestamp || 0);\n    let endDate = startDate;\n    let firstUnpaidItemIndex = -1;\n    let currentPosition = -1;\n    for (let i = 0; i < (group.totalMembers || 0); i++) {\n        if (group.period === GroupPeriod.MONTHLY) {\n            endDate = addMonths(startDate, 1);\n        }\n        else {\n            endDate = addWeeks(startDate, 1);\n        }\n        if (startDate.getTime() <= Date.now() && Date.now() < endDate.getTime()) {\n            currentPosition = i + 1;\n        }\n        const round = i + 1;\n        items.push({\n            round,\n            amount: group.amount || 0,\n            paymentDeadlineTimestamp: endDate.getTime(),\n            status: group.myDeposits[round]?.successfullyDeposited\n                ? 'Paid'\n                : firstUnpaidItemIndex === -1\n                    ? 'Pay'\n                    : 'Pending',\n        });\n        if (firstUnpaidItemIndex === -1 &&\n            round !== group.myPosition &&\n            !group.myDeposits[round]?.successfullyDeposited) {\n            firstUnpaidItemIndex = i;\n        }\n        startDate = endDate;\n    }\n    return { items, firstUnpaidItemIndex, currentPosition };\n};\n","references":["/Users/oscargauss/Documents/projects/Vaquinha/vaquina-back/tmp-folder-build-api-express/src/app/group/types.ts","/Users/oscargauss/Documents/projects/Vaquinha/vaquina-back/node_modules/date-fns/index.d.cts"]}
