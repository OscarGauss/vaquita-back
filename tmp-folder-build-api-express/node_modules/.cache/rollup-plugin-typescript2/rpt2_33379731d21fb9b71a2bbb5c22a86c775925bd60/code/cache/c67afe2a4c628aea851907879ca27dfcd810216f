{"code":"import { EntityState } from 'types';\nimport { getGroupSlots, toGroupResponseDTO } from './helpers';\nimport { createGroup, deleteGroup, getGroup, getGroups, updateGroup } from './services';\nimport { GroupWithdrawalType, } from './types';\nexport function shuffle(array) {\n    let currentIndex = array.length;\n    // While there remain elements to shuffle...\n    while (currentIndex != 0) {\n        // Pick a remaining element...\n        const randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex--;\n        // And swap it with the current element.\n        [array[currentIndex], array[randomIndex]] = [\n            array[randomIndex],\n            array[currentIndex],\n        ];\n    }\n}\nexport const postCreateGroup = async (req, res, next) => {\n    const { name, amount, crypto, totalMembers, period, startsOnTimestamp, customerPublicKey, } = req.body;\n    const collateralAmount = amount * totalMembers;\n    const memberPositions = [];\n    for (let i = 1; i <= totalMembers; i++) {\n        memberPositions.push(i);\n    }\n    shuffle(memberPositions);\n    const position = memberPositions.pop();\n    const companyId = req.company.id;\n    const newGroup = {\n        companyId,\n        crypto,\n        name,\n        amount,\n        collateralAmount,\n        totalMembers,\n        period,\n        startsOnTimestamp,\n        memberPositions: [...memberPositions],\n        members: {\n            [customerPublicKey]: {\n                position,\n                publicKey: customerPublicKey,\n                isOwner: true,\n                deposits: {\n                // [0]: {\n                //   amount: collateral,\n                //   round: 0,\n                //   timestamp: now.getTime(),\n                //   transactionSignature,\n                // },\n                },\n                withdrawals: {},\n            },\n        },\n    };\n    const result = await createGroup(newGroup);\n    res.sendContent(toGroupResponseDTO(await getGroup(companyId, result.insertedId.toString()), customerPublicKey));\n};\nexport const getAllGroups = async (req, res, next) => {\n    const status = req.query.status;\n    const myGroups = req.query.myGroups;\n    const period = req.query.period;\n    const crypto = req.query.crypto;\n    const amount = +(req.query.amount || 0);\n    const customerPublicKey = req.query.customerPublicKey;\n    const orderBy = req.query.orderBy;\n    const filter = { state: EntityState.RELEASED };\n    if (period) {\n        filter.period = period;\n    }\n    if (crypto) {\n        filter.crypto = crypto;\n    }\n    if (amount) {\n        filter.amount = amount;\n    }\n    if (customerPublicKey) {\n        if (myGroups) {\n            filter[`members.${customerPublicKey}`] = { $exists: true };\n        }\n        else {\n            filter[`members.${customerPublicKey}`] = { $exists: false };\n        }\n    }\n    const sort = {};\n    switch (orderBy) {\n        case '+amount':\n            sort.amount = 1;\n            break;\n        case '-amount':\n            sort.amount = -1;\n            break;\n        case '+date':\n            sort.startsOnTimestamp = 1;\n            break;\n        case '-date':\n            sort.startsOnTimestamp = -1;\n            break;\n        // case '+slots':\n        //   sort.slots = 1;\n        //   break;\n        // case '-slots':\n        //   sort.slots = -1;\n        //   break;\n        case '+totalMembers':\n            sort.totalMembers = 1;\n            break;\n        case '-totalMembers':\n            sort.totalMembers = -1;\n            break;\n        default:\n    }\n    const groups = await getGroups(req.company.id, filter, sort);\n    const contents = groups\n        .map((group) => toGroupResponseDTO(group, customerPublicKey))\n        .filter((group) => (status ? status === group.status : true)\n        && group.totalMembers !== group.slots &&\n        (!myGroups ? group.slots > 0 : true) && // only with free slots\n        true).sort((a, b) => (b.slots - a.slots) / Math.abs(b.slots - a.slots));\n    res.sendContents(contents, { page: 0, size: 0, sort: [], totalElements: contents.length });\n};\nexport const getGroupData = async (req, res, next) => {\n    const groupId = req.params.id;\n    const customerPublicKey = req.query.customerPublicKey;\n    const group = await getGroup(req.company.id, groupId);\n    const content = toGroupResponseDTO(group, customerPublicKey);\n    res.sendContent(content);\n};\nexport const postDepositGroup = async (req, res, next) => {\n    const now = new Date();\n    const groupId = req.params.id;\n    const { customerPublicKey, transactionSignature, round /*amount*/ } = req.body;\n    console.log(req.body);\n    // TODO: validate amount\n    const group = await getGroup(req.company.id, groupId);\n    const collateral = group.amount * group.totalMembers;\n    let newMembers;\n    const memberPositions = [...group.memberPositions];\n    if (round === 0) {\n        if (group.members[customerPublicKey]) {\n            newMembers = {\n                ...group.members,\n                [customerPublicKey]: {\n                    ...group.members[customerPublicKey],\n                    deposits: {\n                        [round]: {\n                            amount: collateral,\n                            round,\n                            timestamp: now.getTime(),\n                            transactionSignature,\n                        },\n                    },\n                    withdrawals: {},\n                },\n            };\n        }\n        else {\n            const position = memberPositions.pop();\n            newMembers = {\n                ...group.members,\n                [customerPublicKey]: {\n                    publicKey: customerPublicKey,\n                    isOwner: false,\n                    position,\n                    deposits: {\n                        [round]: {\n                            amount: collateral,\n                            round,\n                            timestamp: now.getTime(),\n                            transactionSignature,\n                        },\n                    },\n                    withdrawals: {},\n                },\n            };\n        }\n    }\n    else {\n        newMembers = {\n            ...group.members,\n            [customerPublicKey]: {\n                ...group.members[customerPublicKey],\n                deposits: {\n                    ...group.members[customerPublicKey]?.deposits,\n                    [round]: {\n                        amount: group.amount,\n                        round,\n                        timestamp: now.getTime(),\n                        transactionSignature,\n                    },\n                },\n            },\n        };\n    }\n    const slots = getGroupSlots({\n        members: newMembers,\n        totalMembers: group.totalMembers,\n        collateralAmount: group.collateralAmount,\n    });\n    const doc = {\n        members: newMembers,\n        memberPositions: [...memberPositions],\n    };\n    if (slots === 0) { // TODO: only for testing purposes\n        doc.startsOnTimestamp = Date.now();\n    }\n    await updateGroup(groupId, doc);\n    res.sendContent('ok');\n};\nexport const postDisjoinGroup = async (req, res, next) => {\n    const groupId = req.params.id;\n    const { customerPublicKey } = req.body;\n    // TODO: validate amount\n    const group = await getGroup(req.company.id, groupId);\n    if (group.members[customerPublicKey]) {\n        const newMembers = { ...group.members };\n        const memberPositions = [newMembers[customerPublicKey].position, ...group.memberPositions].filter((position) => !!position);\n        delete newMembers[customerPublicKey];\n        await updateGroup(groupId, {\n            members: newMembers,\n            memberPositions: [...memberPositions],\n        });\n    }\n    const groupUpdated = await getGroup(req.company.id, groupId);\n    const content = toGroupResponseDTO(groupUpdated, customerPublicKey);\n    res.sendContent(content);\n};\nexport const postJoinGroup = async (req, res, next) => {\n    const groupId = req.params.id;\n    const { customerPublicKey } = req.body;\n    // TODO: validate amount\n    const group = await getGroup(req.company.id, groupId);\n    const memberPositions = [...group.memberPositions];\n    if (!memberPositions.length) {\n        throw new Error('there are no free slots in the group');\n    }\n    const position = memberPositions.pop();\n    const newMembers = {\n        ...group.members,\n        [customerPublicKey]: {\n            publicKey: customerPublicKey,\n            isOwner: false,\n            position,\n            deposits: {},\n            withdrawals: {},\n        },\n    };\n    await updateGroup(groupId, {\n        members: newMembers,\n        memberPositions: [...memberPositions],\n    });\n    const groupUpdated = await getGroup(req.company.id, groupId);\n    const content = toGroupResponseDTO(groupUpdated, customerPublicKey);\n    res.sendContent(content);\n};\nexport const postWithdrawal = async (req, res, next) => {\n    const now = new Date();\n    const groupId = req.params.id;\n    const { customerPublicKey, transactionSignature, type /*amount*/ } = req.body;\n    // TODO: validate amount\n    const group = await getGroup(req.company.id, groupId);\n    let newMembers = { ...group.members };\n    if (type === GroupWithdrawalType.COLLATERAL) {\n        newMembers = {\n            ...group.members,\n            [customerPublicKey]: {\n                ...group.members[customerPublicKey],\n                withdrawals: {\n                    ...group.members[customerPublicKey].withdrawals,\n                    [GroupWithdrawalType.COLLATERAL]: {\n                        amount: group.collateralAmount,\n                        type: GroupWithdrawalType.COLLATERAL,\n                        timestamp: now.getTime(),\n                        transactionSignature,\n                    },\n                },\n            },\n        };\n    }\n    if (type === GroupWithdrawalType.ROUND) {\n        newMembers = {\n            ...group.members,\n            [customerPublicKey]: {\n                ...group.members[customerPublicKey],\n                withdrawals: {\n                    ...group.members[customerPublicKey].withdrawals,\n                    [GroupWithdrawalType.ROUND]: {\n                        amount: group.amount,\n                        type: GroupWithdrawalType.ROUND,\n                        timestamp: now.getTime(),\n                        transactionSignature,\n                    },\n                },\n            },\n        };\n    }\n    if (type === GroupWithdrawalType.INTEREST) {\n        newMembers = {\n            ...group.members,\n            [customerPublicKey]: {\n                ...group.members[customerPublicKey],\n                withdrawals: {\n                    ...group.members[customerPublicKey].withdrawals,\n                    [GroupWithdrawalType.INTEREST]: {\n                        amount: 0,\n                        type: GroupWithdrawalType.INTEREST,\n                        timestamp: now.getTime(),\n                        transactionSignature,\n                    },\n                },\n            },\n        };\n    }\n    await updateGroup(groupId, { members: newMembers });\n    res.sendContent('ok');\n};\nexport const archiveGroup = async (req, res, next) => {\n    const groupId = req.params.id;\n    await deleteGroup(groupId);\n    res.sendContent('ok');\n};\nexport const __setTimestampGroup = async (req, res, next) => {\n    const groupId = req.params.id;\n    await updateGroup(groupId, { startsOnTimestamp: req.body.startsOnTimestamp });\n    res.sendContent('ok');\n};\n","references":["/Users/oscargauss/Documents/projects/Vaquinha/vaquina-back/node_modules/@juki-team/commons/dist/types/index.d.ts","/Users/oscargauss/Documents/projects/Vaquinha/vaquina-back/node_modules/mongodb/mongodb.d.ts","/Users/oscargauss/Documents/projects/Vaquinha/vaquina-back/tmp-folder-build-api-express/src/types/index.ts","/Users/oscargauss/Documents/projects/Vaquinha/vaquina-back/tmp-folder-build-api-express/src/app/group/helpers.ts","/Users/oscargauss/Documents/projects/Vaquinha/vaquina-back/tmp-folder-build-api-express/src/app/group/services.ts","/Users/oscargauss/Documents/projects/Vaquinha/vaquina-back/tmp-folder-build-api-express/src/app/group/types.ts"]}
