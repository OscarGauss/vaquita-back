{"code":"import { isObjectJson } from '@juki-team/commons';\nimport { MONGO_DATABASE_NAME, MONGO_DATABASE_URI } from 'config/settings';\nimport { log } from 'helpers';\nimport { atomizeChangeset, diff } from 'json-diff-ts';\nimport { MongoClient, ObjectId } from 'mongodb';\nimport objectSizeOf from 'object-sizeof';\nimport { EntityState, ErrorCode, JkError, LogLevel, } from 'types';\nconst myObjectSizeOf = (obj) => {\n    if (isObjectJson(obj)) {\n        return JSON.stringify(obj).length * 2;\n    }\n    return objectSizeOf(obj);\n};\nexport class MongoDbClient {\n    constructor() {\n        this.mongoDatabaseClient = null;\n        this.reconnectionCbs = [];\n    }\n    async connect() {\n        if (!this.mongoDatabaseClient) {\n            log(LogLevel.INFO)(`mongo client connecting...`);\n            const mongoClient = await MongoClient.connect(MONGO_DATABASE_URI);\n            await mongoClient.connect();\n            this.mongoDatabaseClient = mongoClient.db(MONGO_DATABASE_NAME);\n            log(LogLevel.INFO)(`mongo client connected`);\n            for (const cb of this.reconnectionCbs) {\n                cb?.();\n            }\n        }\n        else {\n            log(LogLevel.INFO)(`mongo client already connected`);\n        }\n    }\n    get __UNSAFE__mongoDatabaseClient() {\n        return this.mongoDatabaseClient;\n    }\n    crud(collection) {\n        let mongoCollection = this.mongoDatabaseClient?.collection(collection);\n        const connect = () => {\n            mongoCollection = this.mongoDatabaseClient?.collection(collection);\n            log(LogLevel.INFO)(`collection \"${collection}\"connected`);\n        };\n        this.reconnectionCbs.push(connect);\n        const updateOne = async (documentId, document, customer, withoutLog) => {\n            const now = new Date();\n            let documentToUpdate = { ...document };\n            Object.keys(documentToUpdate).forEach(key => documentToUpdate[key] === undefined && delete documentToUpdate[key]);\n            if (Object.keys(documentToUpdate).length === 0) {\n                return;\n            }\n            let updatedDocument;\n            if (withoutLog) {\n                documentToUpdate = { ...documentToUpdate, updatedAt: now };\n                updatedDocument = await mongoCollection\n                    .updateOne({ _id: new ObjectId(documentId) }, { $set: documentToUpdate });\n            }\n            else {\n                const oldDocument = await mongoCollection.findOne({ _id: new ObjectId(documentId) });\n                documentToUpdate = { ...documentToUpdate, updatedAt: now };\n                updatedDocument = await mongoCollection\n                    .updateOne({ _id: new ObjectId(documentId) }, { $set: documentToUpdate });\n                const newDocument = await mongoCollection.findOne({ _id: new ObjectId(documentId) });\n                const atomicChanges = atomizeChangeset(diff(oldDocument, newDocument)).filter(({ path }) => path !== '$._id.buffer');\n                const documentWithoutLogs = { ...newDocument, logs: [] };\n                const bytes = myObjectSizeOf(documentWithoutLogs);\n                const maxBytes = 1024 * 50; // 50 KB\n                const newLog = {\n                    changes: atomicChanges,\n                    timestamp: now.getTime(),\n                    customerUserId: '', // customer._id.toString(),\n                };\n                let logs = [];\n                if (bytes < maxBytes) {\n                    logs = [\n                        newLog,\n                        ...(newDocument?.logs ?? []),\n                    ];\n                    while (bytes + myObjectSizeOf(logs) > maxBytes && !!logs.length) {\n                        logs.pop();\n                    }\n                }\n                if (!logs.length) {\n                    logs = [newLog];\n                }\n                const documentToUpdateWithLogs = {\n                    updatedAt: now,\n                    logs,\n                };\n                await mongoCollection.updateOne({ _id: new ObjectId(documentId) }, { $set: documentToUpdateWithLogs });\n            }\n            if (!updatedDocument) {\n                throw new JkError(ErrorCode.ERR0303);\n            }\n            return updatedDocument;\n        };\n        return {\n            insertOne: async (customer, document) => {\n                const now = new Date();\n                const documentToInsert = {\n                    ...document,\n                    createdAt: now,\n                    updatedAt: now,\n                    // companyId: '',\n                    ownerUserId: '', // !!(customer?._id?.toString?.()) ? customer._id.toString() : company.systemAdminUserId,\n                    state: EntityState.RELEASED,\n                    logs: [],\n                };\n                const newDocument = await mongoCollection.insertOne(documentToInsert);\n                if (!newDocument) {\n                    log(LogLevel.INFO)(JSON.stringify({\n                        collection, /*company, */\n                        customer,\n                        document,\n                    }), 'error on insertOne');\n                    throw new JkError(ErrorCode.ERR0810, { message: 'not created' });\n                }\n                return newDocument;\n            },\n            findOne: async (documentId, options) => {\n                const { projection } = options || {};\n                const document = await mongoCollection.findOne({ _id: new ObjectId(documentId) }, { projection });\n                if (!document) {\n                    log(LogLevel.INFO)(JSON.stringify({ collection, documentId }), 'error on findOne');\n                    throw new JkError(ErrorCode.ERR0211, { message: 'not found' });\n                }\n                return document;\n            },\n            findOneByFilter: async (filter, options) => {\n                const { projection, sort } = options || {};\n                const document = await mongoCollection.findOne(filter, { projection, sort });\n                if (!document) {\n                    log(LogLevel.INFO)(JSON.stringify({ collection, filter }), 'error on findOneByFilter');\n                    throw new JkError(ErrorCode.ERR0211, { message: 'not found' });\n                }\n                return document;\n            },\n            findByFilter: async (filter, options) => {\n                const { projection, sort } = options || {};\n                const document = await mongoCollection.find(filter, { projection, sort }).toArray();\n                if (!document) {\n                    log(LogLevel.INFO)(JSON.stringify({ collection, filter, options }), 'error on findByFilter');\n                    throw new JkError(ErrorCode.ERR0211, { message: 'not found' });\n                }\n                return document;\n            },\n            findPaginated: async (page, size, sort = {}, filter, projection) => {\n                const totalElements = await mongoCollection.countDocuments(filter);\n                const pages = Math.ceil(totalElements / size);\n                const startFrom = (page - 1) * size;\n                const result = await mongoCollection\n                    .find(filter, { projection })\n                    .sort(sort)\n                    .skip(startFrom)\n                    .limit(size)\n                    .toArray();\n                return { result, totalElements, page, size, sort, pages };\n            },\n            updateOne,\n            countDocuments: async (filter) => {\n                return await mongoCollection.countDocuments(filter);\n            },\n            deleteOne: (documentId, customer) => (updateOne(documentId, { state: EntityState.ARCHIVED }, customer)),\n            __UNSAFE__mongoCollection: () => mongoCollection,\n            __UNSAFE__deleteOne: (documentId) => {\n                return mongoCollection.deleteOne({ _id: new ObjectId(documentId) });\n            },\n        };\n    }\n}\n","references":["/Users/oscargauss/Documents/projects/Vaquinha/vaquina-back/node_modules/@juki-team/commons/dist/types/index.d.ts","/Users/oscargauss/Documents/projects/Vaquinha/vaquina-back/node_modules/@juki-team/commons/dist/types/types/entity.d.ts","/Users/oscargauss/Documents/projects/Vaquinha/vaquina-back/tmp-folder-build-api-express/src/config/settings.ts","/Users/oscargauss/Documents/projects/Vaquinha/vaquina-back/tmp-folder-build-api-express/src/helpers/index.ts","/Users/oscargauss/Documents/projects/Vaquinha/vaquina-back/node_modules/json-diff-ts/dist/index.d.ts","/Users/oscargauss/Documents/projects/Vaquinha/vaquina-back/node_modules/mongodb/mongodb.d.ts","/Users/oscargauss/Documents/projects/Vaquinha/vaquina-back/node_modules/object-sizeof/indexv2.d.ts","/Users/oscargauss/Documents/projects/Vaquinha/vaquina-back/tmp-folder-build-api-express/src/types/index.ts"]}
